(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["tmeditor"] = factory();
	else
		root["tmeditor"] = factory();
})((typeof self !== 'undefined' ? self : this), function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "fb15");
/******/ })
/************************************************************************/
/******/ ({

/***/ "00ee":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var test = {};

test[TO_STRING_TAG] = 'z';

module.exports = String(test) === '[object z]';


/***/ }),

/***/ "0122":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _typeof; });
/* harmony import */ var core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("a4d3");
/* harmony import */ var core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("e01a");
/* harmony import */ var core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_description__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_symbol_iterator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("d28b");
/* harmony import */ var core_js_modules_es_symbol_iterator__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_symbol_iterator__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__("e260");
/* harmony import */ var core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_array_iterator__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__("d3b7");
/* harmony import */ var core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__("3ca3");
/* harmony import */ var core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_string_iterator__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var core_js_modules_web_dom_collections_iterator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__("ddb0");
/* harmony import */ var core_js_modules_web_dom_collections_iterator__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_web_dom_collections_iterator__WEBPACK_IMPORTED_MODULE_6__);







function _typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function _typeof(obj) {
      return typeof obj;
    };
  } else {
    _typeof = function _typeof(obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

/***/ }),

/***/ "0366":
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__("1c0b");

// optional / simple context binding
module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;
  switch (length) {
    case 0: return function () {
      return fn.call(that);
    };
    case 1: return function (a) {
      return fn.call(that, a);
    };
    case 2: return function (a, b) {
      return fn.call(that, a, b);
    };
    case 3: return function (a, b, c) {
      return fn.call(that, a, b, c);
    };
  }
  return function (/* ...args */) {
    return fn.apply(that, arguments);
  };
};


/***/ }),

/***/ "0481":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var flattenIntoArray = __webpack_require__("a2bf");
var toObject = __webpack_require__("7b0b");
var toLength = __webpack_require__("50c4");
var toInteger = __webpack_require__("a691");
var arraySpeciesCreate = __webpack_require__("65f0");

// `Array.prototype.flat` method
// https://github.com/tc39/proposal-flatMap
$({ target: 'Array', proto: true }, {
  flat: function flat(/* depthArg = 1 */) {
    var depthArg = arguments.length ? arguments[0] : undefined;
    var O = toObject(this);
    var sourceLen = toLength(O.length);
    var A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, depthArg === undefined ? 1 : toInteger(depthArg));
    return A;
  }
});


/***/ }),

/***/ "0524":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2 4.5V3h16v1.5zm4.5 3V12h7V7.5h-7zM5.758 6h8.484c.419 0 .758.407.758.91v5.681c0 .502-.34.909-.758.909H5.758c-.419 0-.758-.407-.758-.91V6.91c0-.503.34-.91.758-.91zM2 16.5V15h16v1.5z\"/></svg>"

/***/ }),

/***/ "0538":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__("1c0b");
var isObject = __webpack_require__("861d");

var slice = [].slice;
var factories = {};

var construct = function (C, argsLength, args) {
  if (!(argsLength in factories)) {
    for (var list = [], i = 0; i < argsLength; i++) list[i] = 'a[' + i + ']';
    // eslint-disable-next-line no-new-func
    factories[argsLength] = Function('C,a', 'return new C(' + list.join(',') + ')');
  } return factories[argsLength](C, args);
};

// `Function.prototype.bind` method implementation
// https://tc39.github.io/ecma262/#sec-function.prototype.bind
module.exports = Function.bind || function bind(that /* , ...args */) {
  var fn = aFunction(this);
  var partArgs = slice.call(arguments, 1);
  var boundFunction = function bound(/* args... */) {
    var args = partArgs.concat(slice.call(arguments));
    return this instanceof boundFunction ? construct(fn, args.length, args) : fn.apply(that, args);
  };
  if (isObject(fn.prototype)) boundFunction.prototype = fn.prototype;
  return boundFunction;
};


/***/ }),

/***/ "057f":
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__("fc6a");
var nativeGetOwnPropertyNames = __webpack_require__("241c").f;

var toString = {}.toString;

var windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames
  ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function (it) {
  try {
    return nativeGetOwnPropertyNames(it);
  } catch (error) {
    return windowNames.slice();
  }
};

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]'
    ? getWindowNames(it)
    : nativeGetOwnPropertyNames(toIndexedObject(it));
};


/***/ }),

/***/ "06cf":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var propertyIsEnumerableModule = __webpack_require__("d1e7");
var createPropertyDescriptor = __webpack_require__("5c6c");
var toIndexedObject = __webpack_require__("fc6a");
var toPrimitive = __webpack_require__("c04e");
var has = __webpack_require__("5135");
var IE8_DOM_DEFINE = __webpack_require__("0cfb");

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
exports.f = DESCRIPTORS ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
  O = toIndexedObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return nativeGetOwnPropertyDescriptor(O, P);
  } catch (error) { /* empty */ }
  if (has(O, P)) return createPropertyDescriptor(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};


/***/ }),

/***/ "0a06":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "0b25":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("a691");
var toLength = __webpack_require__("50c4");

// `ToIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-toindex
module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length or index');
  return length;
};


/***/ }),

/***/ "0cfb":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var fails = __webpack_require__("d039");
var createElement = __webpack_require__("cc12");

// Thank's IE8 for his funny defineProperty
module.exports = !DESCRIPTORS && !fails(function () {
  return Object.defineProperty(createElement('div'), 'a', {
    get: function () { return 7; }
  }).a != 7;
});


/***/ }),

/***/ "0db1":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2 4.5V3h16v1.5zm0 3V6h5.674v1.5zm0 3V9h5.674v1.5zm0 3V12h5.674v1.5zm8.5-6V12h6V7.5h-6zM9.682 6h7.636c.377 0 .682.407.682.91v5.68c0 .503-.305.91-.682.91H9.682c-.377 0-.682-.407-.682-.91V6.91c0-.503.305-.91.682-.91zM2 16.5V15h16v1.5z\"/></svg>"

/***/ }),

/***/ "0de3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _setPrototypeOf; });
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

/***/ }),

/***/ "1033":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.586 14.633l.021.004c-.036.335.095.655.393.962.082.083.173.15.274.201h1.474a.6.6 0 1 1 0 1.2H5.304a.6.6 0 0 1 0-1.2h1.15c.474-.07.809-.182 1.005-.334.157-.122.291-.32.404-.597l2.416-9.55a1.053 1.053 0 0 0-.281-.823 1.12 1.12 0 0 0-.442-.296H8.15a.6.6 0 0 1 0-1.2h6.443a.6.6 0 1 1 0 1.2h-1.195c-.376.056-.65.155-.823.296-.215.175-.423.439-.623.79l-2.366 9.347z\"/></svg>"

/***/ }),

/***/ "10d1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("da84");
var redefineAll = __webpack_require__("e2cc");
var InternalMetadataModule = __webpack_require__("f183");
var collection = __webpack_require__("6d61");
var collectionWeak = __webpack_require__("acac");
var isObject = __webpack_require__("861d");
var enforceIternalState = __webpack_require__("69f3").enforce;
var NATIVE_WEAK_MAP = __webpack_require__("7f9a");

var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var isExtensible = Object.isExtensible;
var InternalWeakMap;

var wrapper = function (init) {
  return function WeakMap() {
    return init(this, arguments.length ? arguments[0] : undefined);
  };
};

// `WeakMap` constructor
// https://tc39.github.io/ecma262/#sec-weakmap-constructor
var $WeakMap = module.exports = collection('WeakMap', wrapper, collectionWeak);

// IE11 WeakMap frozen keys fix
// We can't use feature detection because it crash some old IE builds
// https://github.com/zloirock/core-js/issues/485
if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalWeakMap = collectionWeak.getConstructor(wrapper, 'WeakMap', true);
  InternalMetadataModule.REQUIRED = true;
  var WeakMapPrototype = $WeakMap.prototype;
  var nativeDelete = WeakMapPrototype['delete'];
  var nativeHas = WeakMapPrototype.has;
  var nativeGet = WeakMapPrototype.get;
  var nativeSet = WeakMapPrototype.set;
  redefineAll(WeakMapPrototype, {
    'delete': function (key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeDelete.call(this, key) || state.frozen['delete'](key);
      } return nativeDelete.call(this, key);
    },
    has: function has(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas.call(this, key) || state.frozen.has(key);
      } return nativeHas.call(this, key);
    },
    get: function get(key) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        return nativeHas.call(this, key) ? nativeGet.call(this, key) : state.frozen.get(key);
      } return nativeGet.call(this, key);
    },
    set: function set(key, value) {
      if (isObject(key) && !isExtensible(key)) {
        var state = enforceIternalState(this);
        if (!state.frozen) state.frozen = new InternalWeakMap();
        nativeHas.call(this, key) ? nativeSet.call(this, key, value) : state.frozen.set(key, value);
      } else nativeSet.call(this, key, value);
      return this;
    }
  });
}


/***/ }),

/***/ "1148":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toInteger = __webpack_require__("a691");
var requireObjectCoercible = __webpack_require__("1d80");

// `String.prototype.repeat` method implementation
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
module.exports = ''.repeat || function repeat(count) {
  var str = String(requireObjectCoercible(this));
  var result = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError('Wrong number of repetitions');
  for (;n > 0; (n >>>= 1) && (str += str)) if (n & 1) result += str;
  return result;
};


/***/ }),

/***/ "1276":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
var isRegExp = __webpack_require__("44e7");
var anObject = __webpack_require__("825a");
var requireObjectCoercible = __webpack_require__("1d80");
var speciesConstructor = __webpack_require__("4840");
var advanceStringIndex = __webpack_require__("8aa5");
var toLength = __webpack_require__("50c4");
var callRegExpExec = __webpack_require__("14c3");
var regexpExec = __webpack_require__("9263");
var fails = __webpack_require__("d039");

var arrayPush = [].push;
var min = Math.min;
var MAX_UINT32 = 0xFFFFFFFF;

// babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError
var SUPPORTS_Y = !fails(function () { return !RegExp(MAX_UINT32, 'y'); });

// @@split logic
fixRegExpWellKnownSymbolLogic('split', 2, function (SPLIT, nativeSplit, maybeCallNative) {
  var internalSplit;
  if (
    'abbc'.split(/(b)*/)[1] == 'c' ||
    'test'.split(/(?:)/, -1).length != 4 ||
    'ab'.split(/(?:ab)*/).length != 2 ||
    '.'.split(/(.?)(.?)/).length != 4 ||
    '.'.split(/()()/).length > 1 ||
    ''.split(/.?/).length
  ) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function (separator, limit) {
      var string = String(requireObjectCoercible(this));
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (separator === undefined) return [string];
      // If `separator` is not a regex, use native split
      if (!isRegExp(separator)) {
        return nativeSplit.call(string, separator, lim);
      }
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') +
                  (separator.multiline ? 'm' : '') +
                  (separator.unicode ? 'u' : '') +
                  (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      // Make `global` and avoid `lastIndex` issues by working with a copy
      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;
      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy.lastIndex;
        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match.length > 1 && match.index < string.length) arrayPush.apply(output, match.slice(1));
          lastLength = match[0].length;
          lastLastIndex = lastIndex;
          if (output.length >= lim) break;
        }
        if (separatorCopy.lastIndex === match.index) separatorCopy.lastIndex++; // Avoid an infinite loop
      }
      if (lastLastIndex === string.length) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));
      return output.length > lim ? output.slice(0, lim) : output;
    };
  // Chakra, V8
  } else if ('0'.split(undefined, 0).length) {
    internalSplit = function (separator, limit) {
      return separator === undefined && limit === 0 ? [] : nativeSplit.call(this, separator, limit);
    };
  } else internalSplit = nativeSplit;

  return [
    // `String.prototype.split` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.split
    function split(separator, limit) {
      var O = requireObjectCoercible(this);
      var splitter = separator == undefined ? undefined : separator[SPLIT];
      return splitter !== undefined
        ? splitter.call(separator, O, limit)
        : internalSplit.call(String(O), separator, limit);
    },
    // `RegExp.prototype[@@split]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
    //
    // NOTE: This cannot be properly polyfilled in engines that don't support
    // the 'y' flag.
    function (regexp, limit) {
      var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== nativeSplit);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);
      var C = speciesConstructor(rx, RegExp);

      var unicodeMatching = rx.unicode;
      var flags = (rx.ignoreCase ? 'i' : '') +
                  (rx.multiline ? 'm' : '') +
                  (rx.unicode ? 'u' : '') +
                  (SUPPORTS_Y ? 'y' : 'g');

      // ^(? + rx + ) is needed, in combination with some S slicing, to
      // simulate the 'y' flag.
      var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
      var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
      if (lim === 0) return [];
      if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
      var p = 0;
      var q = 0;
      var A = [];
      while (q < S.length) {
        splitter.lastIndex = SUPPORTS_Y ? q : 0;
        var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
        var e;
        if (
          z === null ||
          (e = min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p
        ) {
          q = advanceStringIndex(S, q, unicodeMatching);
        } else {
          A.push(S.slice(p, q));
          if (A.length === lim) return A;
          for (var i = 1; i <= z.length - 1; i++) {
            A.push(z[i]);
            if (A.length === lim) return A;
          }
          q = p = e;
        }
      }
      A.push(S.slice(p));
      return A;
    }
  ];
}, !SUPPORTS_Y);


/***/ }),

/***/ "129f":
/***/ (function(module, exports) {

// `SameValue` abstract operation
// https://tc39.github.io/ecma262/#sec-samevalue
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};


/***/ }),

/***/ "13d5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $reduce = __webpack_require__("d58f").left;
var arrayMethodIsStrict = __webpack_require__("a640");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var STRICT_METHOD = arrayMethodIsStrict('reduce');
var USES_TO_LENGTH = arrayMethodUsesToLength('reduce', { 1: 0 });

// `Array.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-array.prototype.reduce
$({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
  reduce: function reduce(callbackfn /* , initialValue */) {
    return $reduce(this, callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "1414":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6.91 10.54c.26-.23.64-.21.88.03l3.36 3.14 2.23-2.06a.64.64 0 0 1 .87 0l2.52 2.97V4.5H3.2v10.12l3.71-4.08zm10.27-7.51c.6 0 1.09.47 1.09 1.05v11.84c0 .59-.49 1.06-1.09 1.06H2.79c-.6 0-1.09-.47-1.09-1.06V4.08c0-.58.49-1.05 1.1-1.05h14.38zm-5.22 5.56a1.96 1.96 0 1 1 3.4-1.96 1.96 1.96 0 0 1-3.4 1.96z\"/></svg>"

/***/ }),

/***/ "145e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__("7b0b");
var toAbsoluteIndex = __webpack_require__("23cb");
var toLength = __webpack_require__("50c4");

var min = Math.min;

// `Array.prototype.copyWithin` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.copywithin
module.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;
  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }
  while (count-- > 0) {
    if (from in O) O[to] = O[from];
    else delete O[to];
    to += inc;
    from += inc;
  } return O;
};


/***/ }),

/***/ "14c3":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("c6b6");
var regexpExec = __webpack_require__("9263");

// `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec
module.exports = function (R, S) {
  var exec = R.exec;
  if (typeof exec === 'function') {
    var result = exec.call(R, S);
    if (typeof result !== 'object') {
      throw TypeError('RegExp exec method returned something other than an Object or null');
    }
    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw TypeError('RegExp#exec called on incompatible receiver');
  }

  return regexpExec.call(R, S);
};



/***/ }),

/***/ "159b":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var DOMIterables = __webpack_require__("fdbc");
var forEach = __webpack_require__("17c2");
var createNonEnumerableProperty = __webpack_require__("9112");

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  // some Chrome versions have non-configurable methods on DOMTokenList
  if (CollectionPrototype && CollectionPrototype.forEach !== forEach) try {
    createNonEnumerableProperty(CollectionPrototype, 'forEach', forEach);
  } catch (error) {
    CollectionPrototype.forEach = forEach;
  }
}


/***/ }),

/***/ "170b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var toLength = __webpack_require__("50c4");
var toAbsoluteIndex = __webpack_require__("23cb");
var speciesConstructor = __webpack_require__("4840");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.subarray` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.subarray
exportTypedArrayMethod('subarray', function subarray(begin, end) {
  var O = aTypedArray(this);
  var length = O.length;
  var beginIndex = toAbsoluteIndex(begin, length);
  return new (speciesConstructor(O, O.constructor))(
    O.buffer,
    O.byteOffset + beginIndex * O.BYTES_PER_ELEMENT,
    toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - beginIndex)
  );
});


/***/ }),

/***/ "17c2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $forEach = __webpack_require__("b727").forEach;
var arrayMethodIsStrict = __webpack_require__("a640");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var STRICT_METHOD = arrayMethodIsStrict('forEach');
var USES_TO_LENGTH = arrayMethodUsesToLength('forEach');

// `Array.prototype.forEach` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
module.exports = (!STRICT_METHOD || !USES_TO_LENGTH) ? function forEach(callbackfn /* , thisArg */) {
  return $forEach(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
} : [].forEach;


/***/ }),

/***/ "1805":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11.077 15l.991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184zm4.919 10.562l-1.414 1.414a.75.75 0 1 1-1.06-1.06l1.414-1.415-1.415-1.414a.75.75 0 0 1 1.061-1.06l1.414 1.414 1.414-1.415a.75.75 0 0 1 1.061 1.061l-1.414 1.414 1.414 1.415a.75.75 0 0 1-1.06 1.06l-1.415-1.414z\"/></svg>"

/***/ }),

/***/ "182d":
/***/ (function(module, exports, __webpack_require__) {

var toPositiveInteger = __webpack_require__("f8cd");

module.exports = function (it, BYTES) {
  var offset = toPositiveInteger(it);
  if (offset % BYTES) throw RangeError('Wrong offset');
  return offset;
};


/***/ }),

/***/ "18a5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var createHTML = __webpack_require__("857a");
var forcedStringHTMLMethod = __webpack_require__("af03");

// `String.prototype.anchor` method
// https://tc39.github.io/ecma262/#sec-string.prototype.anchor
$({ target: 'String', proto: true, forced: forcedStringHTMLMethod('anchor') }, {
  anchor: function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  }
});


/***/ }),

/***/ "18ce":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M6.972 16.615a.997.997 0 0 1-.744-.292l-4.596-4.596a1 1 0 1 1 1.414-1.414l3.926 3.926 9.937-9.937a1 1 0 0 1 1.414 1.415L7.717 16.323a.997.997 0 0 1-.745.292z\"/></svg>"

/***/ }),

/***/ "18ea":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "19aa":
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name) {
  if (!(it instanceof Constructor)) {
    throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
  } return it;
};


/***/ }),

/***/ "1a1b":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\" clip-rule=\"evenodd\" stroke-linejoin=\"round\" stroke-miterlimit=\"1.414\"><path d=\"M18 4.5V3H2v1.5h16zm0 3V6h-5.674v1.5H18zm0 3V9h-5.674v1.5H18zm0 3V12h-5.674v1.5H18zm-8.5-6V12h-6V7.5h6zm.818-1.5H2.682C2.305 6 2 6.407 2 6.91v5.68c0 .503.305.91.682.91h7.636c.377 0 .682-.407.682-.91V6.91c0-.503-.305-.91-.682-.91zM18 16.5V15H2v1.5h16z\"/></svg>"

/***/ }),

/***/ "1af3":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "1be4":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");

module.exports = getBuiltIn('document', 'documentElement');


/***/ }),

/***/ "1c0b":
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') {
    throw TypeError(String(it) + ' is not a function');
  } return it;
};


/***/ }),

/***/ "1c7e":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

var ITERATOR = wellKnownSymbol('iterator');
var SAFE_CLOSING = false;

try {
  var called = 0;
  var iteratorWithReturn = {
    next: function () {
      return { done: !!called++ };
    },
    'return': function () {
      SAFE_CLOSING = true;
    }
  };
  iteratorWithReturn[ITERATOR] = function () {
    return this;
  };
  // eslint-disable-next-line no-throw-literal
  Array.from(iteratorWithReturn, function () { throw 2; });
} catch (error) { /* empty */ }

module.exports = function (exec, SKIP_CLOSING) {
  if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
  var ITERATION_SUPPORT = false;
  try {
    var object = {};
    object[ITERATOR] = function () {
      return {
        next: function () {
          return { done: ITERATION_SUPPORT = true };
        }
      };
    };
    exec(object);
  } catch (error) { /* empty */ }
  return ITERATION_SUPPORT;
};


/***/ }),

/***/ "1cb8":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"9.5\" cy=\"4.5\" r=\"1.5\"/><circle cx=\"9.5\" cy=\"10.5\" r=\"1.5\"/><circle cx=\"9.5\" cy=\"16.5\" r=\"1.5\"/></svg>"

/***/ }),

/***/ "1cdc":
/***/ (function(module, exports, __webpack_require__) {

var userAgent = __webpack_require__("342f");

module.exports = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent);


/***/ }),

/***/ "1d80":
/***/ (function(module, exports) {

// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on " + it);
  return it;
};


/***/ }),

/***/ "1dde":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var wellKnownSymbol = __webpack_require__("b622");
var V8_VERSION = __webpack_require__("2d00");

var SPECIES = wellKnownSymbol('species');

module.exports = function (METHOD_NAME) {
  // We can't use this feature detection in V8 since it causes
  // deoptimization and serious performance degradation
  // https://github.com/zloirock/core-js/issues/677
  return V8_VERSION >= 51 || !fails(function () {
    var array = [];
    var constructor = array.constructor = {};
    constructor[SPECIES] = function () {
      return { foo: 1 };
    };
    return array[METHOD_NAME](Boolean).foo !== 1;
  });
};


/***/ }),

/***/ "1efe":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z\"/></svg>"

/***/ }),

/***/ "1fe2":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var collection = __webpack_require__("6d61");
var collectionWeak = __webpack_require__("acac");

// `WeakSet` constructor
// https://tc39.github.io/ecma262/#sec-weakset-constructor
collection('WeakSet', function (init) {
  return function WeakSet() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionWeak);


/***/ }),

/***/ "2074":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11.627 16.5zm5.873-.196zm0-7.001V8h-13v8.5h4.341c.191.54.457 1.044.785 1.5H2a1.5 1.5 0 0 1-1.5-1.5v-13A1.5 1.5 0 0 1 2 2h4.5a1.5 1.5 0 0 1 1.06.44L9.122 4H16a1.5 1.5 0 0 1 1.5 1.5v1A1.5 1.5 0 0 1 19 8v2.531a6.027 6.027 0 0 0-1.5-1.228zM16 6.5v-1H8.5l-2-2H2v13h1V8a1.5 1.5 0 0 1 1.5-1.5H16z\"/><path d=\"M14.5 19.5a5 5 0 1 1 0-10 5 5 0 0 1 0 10zM15 14v-2h-1v2h-2v1h2v2h1v-2h2v-1h-2z\"/></svg>"

/***/ }),

/***/ "219c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $sort = [].sort;

// `%TypedArray%.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort
exportTypedArrayMethod('sort', function sort(comparefn) {
  return $sort.call(aTypedArray(this), comparefn);
});


/***/ }),

/***/ "2260":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "2266":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var isArrayIteratorMethod = __webpack_require__("e95a");
var toLength = __webpack_require__("50c4");
var bind = __webpack_require__("0366");
var getIteratorMethod = __webpack_require__("35a1");
var callWithSafeIterationClosing = __webpack_require__("9bdd");

var Result = function (stopped, result) {
  this.stopped = stopped;
  this.result = result;
};

var iterate = module.exports = function (iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
  var boundFunction = bind(fn, that, AS_ENTRIES ? 2 : 1);
  var iterator, iterFn, index, length, result, next, step;

  if (IS_ITERATOR) {
    iterator = iterable;
  } else {
    iterFn = getIteratorMethod(iterable);
    if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
    // optimisation for array iterators
    if (isArrayIteratorMethod(iterFn)) {
      for (index = 0, length = toLength(iterable.length); length > index; index++) {
        result = AS_ENTRIES
          ? boundFunction(anObject(step = iterable[index])[0], step[1])
          : boundFunction(iterable[index]);
        if (result && result instanceof Result) return result;
      } return new Result(false);
    }
    iterator = iterFn.call(iterable);
  }

  next = iterator.next;
  while (!(step = next.call(iterator)).done) {
    result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
    if (typeof result == 'object' && result && result instanceof Result) return result;
  } return new Result(false);
};

iterate.stop = function (result) {
  return new Result(true, result);
};


/***/ }),

/***/ "23cb":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("a691");

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
module.exports = function (index, length) {
  var integer = toInteger(index);
  return integer < 0 ? max(integer + length, 0) : min(integer, length);
};


/***/ }),

/***/ "23e7":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var createNonEnumerableProperty = __webpack_require__("9112");
var redefine = __webpack_require__("6eeb");
var setGlobal = __webpack_require__("ce4e");
var copyConstructorProperties = __webpack_require__("e893");
var isForced = __webpack_require__("94ca");

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
module.exports = function (options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global;
  } else if (STATIC) {
    target = global[TARGET] || setGlobal(TARGET, {});
  } else {
    target = (global[TARGET] || {}).prototype;
  }
  if (target) for (key in source) {
    sourceProperty = source[key];
    if (options.noTargetGet) {
      descriptor = getOwnPropertyDescriptor(target, key);
      targetProperty = descriptor && descriptor.value;
    } else targetProperty = target[key];
    FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
    // contained in target
    if (!FORCED && targetProperty !== undefined) {
      if (typeof sourceProperty === typeof targetProperty) continue;
      copyConstructorProperties(sourceProperty, targetProperty);
    }
    // add a flag to not completely full polyfills
    if (options.sham || (targetProperty && targetProperty.sham)) {
      createNonEnumerableProperty(sourceProperty, 'sham', true);
    }
    // extend global
    redefine(target, key, sourceProperty, options);
  }
};


/***/ }),

/***/ "241c":
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__("ca84");
var enumBugKeys = __webpack_require__("7839");

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys(O, hiddenKeys);
};


/***/ }),

/***/ "2532":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var notARegExp = __webpack_require__("5a34");
var requireObjectCoercible = __webpack_require__("1d80");
var correctIsRegExpLogic = __webpack_require__("ab13");

// `String.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-string.prototype.includes
$({ target: 'String', proto: true, forced: !correctIsRegExpLogic('includes') }, {
  includes: function includes(searchString /* , position = 0 */) {
    return !!~String(requireObjectCoercible(this))
      .indexOf(notARegExp(searchString), arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "25a1":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $reduceRight = __webpack_require__("d58f").right;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduceRicht` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduceright
exportTypedArrayMethod('reduceRight', function reduceRight(callbackfn /* , initialValue */) {
  return $reduceRight(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "25eb":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var parseInt = __webpack_require__("c20d");

// `Number.parseInt` method
// https://tc39.github.io/ecma262/#sec-number.parseint
$({ target: 'Number', stat: true, forced: Number.parseInt != parseInt }, {
  parseInt: parseInt
});


/***/ }),

/***/ "25f0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefine = __webpack_require__("6eeb");
var anObject = __webpack_require__("825a");
var fails = __webpack_require__("d039");
var flags = __webpack_require__("ad6d");

var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];

var NOT_GENERIC = fails(function () { return nativeToString.call({ source: 'a', flags: 'b' }) != '/a/b'; });
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = nativeToString.name != TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
  redefine(RegExp.prototype, TO_STRING, function toString() {
    var R = anObject(this);
    var p = String(R.source);
    var rf = R.flags;
    var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);
    return '/' + p + '/' + f;
  }, { unsafe: true });
}


/***/ }),

/***/ "2609":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M7.3 17.37l-.061.088a1.518 1.518 0 0 1-.934.535l-4.178.663-.806-4.153a1.495 1.495 0 0 1 .187-1.058l.056-.086L8.77 2.639c.958-1.351 2.803-1.076 4.296-.03 1.497 1.047 2.387 2.693 1.433 4.055L7.3 17.37zM9.14 4.728l-5.545 8.346 3.277 2.294 5.544-8.346L9.14 4.728zM6.07 16.512l-3.276-2.295.53 2.73 2.746-.435zM9.994 3.506L13.271 5.8c.316-.452-.16-1.333-1.065-1.966-.905-.634-1.895-.78-2.212-.328zM8 18.5L9.375 17H19v1.5H8z\"/></svg>"

/***/ }),

/***/ "2626":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getBuiltIn = __webpack_require__("d066");
var definePropertyModule = __webpack_require__("9bf2");
var wellKnownSymbol = __webpack_require__("b622");
var DESCRIPTORS = __webpack_require__("83ab");

var SPECIES = wellKnownSymbol('species');

module.exports = function (CONSTRUCTOR_NAME) {
  var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
  var defineProperty = definePropertyModule.f;

  if (DESCRIPTORS && Constructor && !Constructor[SPECIES]) {
    defineProperty(Constructor, SPECIES, {
      configurable: true,
      get: function () { return this; }
    });
  }
};


/***/ }),

/***/ "26ee":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony import */ var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5ea3");


/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"] || freeSelf || Function('return this')();

/* harmony default export */ __webpack_exports__["a"] = (root);


/***/ }),

/***/ "276c":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _classCallCheck; });
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

/***/ }),

/***/ "2787":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z\" opacity=\".6\"/><path d=\"M18 7v1H2V7h16zm0 5v1H2v-1h16z\" opacity=\".6\"/><path d=\"M14 1v18a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V1a1 1 0 0 1 1-1h6a1 1 0 0 1 1 1zm-2 1H8v4h4V2zm0 6H8v4h4V8zm0 6H8v4h4v-4z\"/></svg>"

/***/ }),

/***/ "2954":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var speciesConstructor = __webpack_require__("4840");
var fails = __webpack_require__("d039");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $slice = [].slice;

var FORCED = fails(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).slice();
});

// `%TypedArray%.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.slice
exportTypedArrayMethod('slice', function slice(start, end) {
  var list = $slice.call(aTypedArray(this), start, end);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
}, FORCED);


/***/ }),

/***/ "2a21":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "2b8c":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm2.286 4c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h9.928a.75.75 0 1 0 0-1.5H5.036a.75.75 0 0 0-.75.75z\"/></svg>"

/***/ }),

/***/ "2c4a":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "2c4c":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _assertThisInitialized; });
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

/***/ }),

/***/ "2ca0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var toLength = __webpack_require__("50c4");
var notARegExp = __webpack_require__("5a34");
var requireObjectCoercible = __webpack_require__("1d80");
var correctIsRegExpLogic = __webpack_require__("ab13");
var IS_PURE = __webpack_require__("c430");

var nativeStartsWith = ''.startsWith;
var min = Math.min;

var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('startsWith');
// https://github.com/zloirock/core-js/pull/702
var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {
  var descriptor = getOwnPropertyDescriptor(String.prototype, 'startsWith');
  return descriptor && !descriptor.writable;
}();

// `String.prototype.startsWith` method
// https://tc39.github.io/ecma262/#sec-string.prototype.startswith
$({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
  startsWith: function startsWith(searchString /* , position = 0 */) {
    var that = String(requireObjectCoercible(this));
    notARegExp(searchString);
    var index = toLength(min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return nativeStartsWith
      ? nativeStartsWith.call(that, search, index)
      : that.slice(index, index + search.length) === search;
  }
});


/***/ }),

/***/ "2cf4":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var fails = __webpack_require__("d039");
var classof = __webpack_require__("c6b6");
var bind = __webpack_require__("0366");
var html = __webpack_require__("1be4");
var createElement = __webpack_require__("cc12");
var IS_IOS = __webpack_require__("1cdc");

var location = global.location;
var set = global.setImmediate;
var clear = global.clearImmediate;
var process = global.process;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function (id) {
  // eslint-disable-next-line no-prototype-builtins
  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var runner = function (id) {
  return function () {
    run(id);
  };
};

var listener = function (event) {
  run(event.data);
};

var post = function (id) {
  // old engines have not location.origin
  global.postMessage(id + '', location.protocol + '//' + location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
  set = function setImmediate(fn) {
    var args = [];
    var i = 1;
    while (arguments.length > i) args.push(arguments[i++]);
    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
    };
    defer(counter);
    return counter;
  };
  clear = function clearImmediate(id) {
    delete queue[id];
  };
  // Node.js 0.8-
  if (classof(process) == 'process') {
    defer = function (id) {
      process.nextTick(runner(id));
    };
  // Sphere (JS game engine) Dispatch API
  } else if (Dispatch && Dispatch.now) {
    defer = function (id) {
      Dispatch.now(runner(id));
    };
  // Browsers with MessageChannel, includes WebWorkers
  // except iOS - https://github.com/zloirock/core-js/issues/624
  } else if (MessageChannel && !IS_IOS) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = bind(port.postMessage, port, 1);
  // Browsers with postMessage, skip WebWorkers
  // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (
    global.addEventListener &&
    typeof postMessage == 'function' &&
    !global.importScripts &&
    !fails(post) &&
    location.protocol !== 'file:'
  ) {
    defer = post;
    global.addEventListener('message', listener, false);
  // IE8-
  } else if (ONREADYSTATECHANGE in createElement('script')) {
    defer = function (id) {
      html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run(id);
      };
    };
  // Rest old browsers
  } else {
    defer = function (id) {
      setTimeout(runner(id), 0);
    };
  }
}

module.exports = {
  set: set,
  clear: clear
};


/***/ }),

/***/ "2d00":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var userAgent = __webpack_require__("342f");

var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
  match = v8.split('.');
  version = match[0] + match[1];
} else if (userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match) version = match[1];
  }
}

module.exports = version && +version;


/***/ }),

/***/ "2f74":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

/* harmony default export */ __webpack_exports__["a"] = (stubFalse);


/***/ }),

/***/ "3280":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $lastIndexOf = __webpack_require__("e58c");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.lastIndexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.lastindexof
// eslint-disable-next-line no-unused-vars
exportTypedArrayMethod('lastIndexOf', function lastIndexOf(searchElement /* , fromIndex */) {
  return $lastIndexOf.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ "332d":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M14.958 9.367l-2.189 1.837a.75.75 0 0 0 .965 1.149l3.788-3.18a.747.747 0 0 0 .21-.284.75.75 0 0 0-.17-.945L13.77 4.762a.75.75 0 1 0-.964 1.15l2.331 1.955H6.22A.75.75 0 0 0 6 7.9a4 4 0 1 0 1.477 7.718l-.344-1.489A2.5 2.5 0 1 1 6.039 9.4l-.008-.032h8.927z\"/></svg>"

/***/ }),

/***/ "3410":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var fails = __webpack_require__("d039");
var toObject = __webpack_require__("7b0b");
var nativeGetPrototypeOf = __webpack_require__("e163");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__("e177");

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetPrototypeOf(1); });

// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES, sham: !CORRECT_PROTOTYPE_GETTER }, {
  getPrototypeOf: function getPrototypeOf(it) {
    return nativeGetPrototypeOf(toObject(it));
  }
});



/***/ }),

/***/ "342f":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");

module.exports = getBuiltIn('navigator', 'userAgent') || '';


/***/ }),

/***/ "356b":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "35a1":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("f5df");
var Iterators = __webpack_require__("3f8c");
var wellKnownSymbol = __webpack_require__("b622");

var ITERATOR = wellKnownSymbol('iterator');

module.exports = function (it) {
  if (it != undefined) return it[ITERATOR]
    || it['@@iterator']
    || Iterators[classof(it)];
};


/***/ }),

/***/ "37e8":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var definePropertyModule = __webpack_require__("9bf2");
var anObject = __webpack_require__("825a");
var objectKeys = __webpack_require__("df75");

// `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties
module.exports = DESCRIPTORS ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = objectKeys(Properties);
  var length = keys.length;
  var index = 0;
  var key;
  while (length > index) definePropertyModule.f(O, key = keys[index++], Properties[key]);
  return O;
};


/***/ }),

/***/ "3879":
/***/ (function(module, exports) {

module.exports = "<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 700 250\"><rect rx=\"4\"/></svg>"

/***/ }),

/***/ "38cf":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var repeat = __webpack_require__("1148");

// `String.prototype.repeat` method
// https://tc39.github.io/ecma262/#sec-string.prototype.repeat
$({ target: 'String', proto: true }, {
  repeat: repeat
});


/***/ }),

/***/ "3a7b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $findIndex = __webpack_require__("b727").findIndex;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.findindex
exportTypedArrayMethod('findIndex', function findIndex(predicate /* , thisArg */) {
  return $findIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "3a7f":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "3bbe":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");

module.exports = function (it) {
  if (!isObject(it) && it !== null) {
    throw TypeError("Can't set " + String(it) + ' as a prototype');
  } return it;
};


/***/ }),

/***/ "3c5d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var toLength = __webpack_require__("50c4");
var toOffset = __webpack_require__("182d");
var toObject = __webpack_require__("7b0b");
var fails = __webpack_require__("d039");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

var FORCED = fails(function () {
  // eslint-disable-next-line no-undef
  new Int8Array(1).set({});
});

// `%TypedArray%.prototype.set` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set
exportTypedArrayMethod('set', function set(arrayLike /* , offset */) {
  aTypedArray(this);
  var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
  var length = this.length;
  var src = toObject(arrayLike);
  var len = toLength(src.length);
  var index = 0;
  if (len + offset > length) throw RangeError('Wrong length');
  while (index < len) this[offset + index] = src[index++];
}, FORCED);


/***/ }),

/***/ "3ca3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__("6547").charAt;
var InternalStateModule = __webpack_require__("69f3");
var defineIterator = __webpack_require__("7dd0");

var STRING_ITERATOR = 'String Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(STRING_ITERATOR);

// `String.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-string.prototype-@@iterator
defineIterator(String, 'String', function (iterated) {
  setInternalState(this, {
    type: STRING_ITERATOR,
    string: String(iterated),
    index: 0
  });
// `%StringIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%stringiteratorprototype%.next
}, function next() {
  var state = getInternalState(this);
  var string = state.string;
  var index = state.index;
  var point;
  if (index >= string.length) return { value: undefined, done: true };
  point = charAt(string, index);
  state.index += point.length;
  return { value: point, done: false };
});


/***/ }),

/***/ "3d1d":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "3f8c":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "3fcc":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $map = __webpack_require__("b727").map;
var speciesConstructor = __webpack_require__("4840");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.map` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.map
exportTypedArrayMethod('map', function map(mapfn /* , thisArg */) {
  return $map(aTypedArray(this), mapfn, arguments.length > 1 ? arguments[1] : undefined, function (O, length) {
    return new (aTypedArrayConstructor(speciesConstructor(O, O.constructor)))(length);
  });
});


/***/ }),

/***/ "4069":
/***/ (function(module, exports, __webpack_require__) {

// this method was added to unscopables after implementation
// in popular engines, so it's moved to a separate module
var addToUnscopables = __webpack_require__("44d2");

addToUnscopables('flat');


/***/ }),

/***/ "4160":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var forEach = __webpack_require__("17c2");

// `Array.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-array.prototype.foreach
$({ target: 'Array', proto: true, forced: [].forEach != forEach }, {
  forEach: forEach
});


/***/ }),

/***/ "4230":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "428f":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

module.exports = global;


/***/ }),

/***/ "43ae":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "44ad":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var classof = __webpack_require__("c6b6");

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
module.exports = fails(function () {
  // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
  // eslint-disable-next-line no-prototype-builtins
  return !Object('z').propertyIsEnumerable(0);
}) ? function (it) {
  return classof(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;


/***/ }),

/***/ "44d2":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");
var create = __webpack_require__("7c73");
var definePropertyModule = __webpack_require__("9bf2");

var UNSCOPABLES = wellKnownSymbol('unscopables');
var ArrayPrototype = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype[UNSCOPABLES] == undefined) {
  definePropertyModule.f(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}

// add a key to Array.prototype[@@unscopables]
module.exports = function (key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};


/***/ }),

/***/ "44de":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

module.exports = function (a, b) {
  var console = global.console;
  if (console && console.error) {
    arguments.length === 1 ? console.error(a) : console.error(a, b);
  }
};


/***/ }),

/***/ "44e7":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");
var classof = __webpack_require__("c6b6");
var wellKnownSymbol = __webpack_require__("b622");

var MATCH = wellKnownSymbol('match');

// `IsRegExp` abstract operation
// https://tc39.github.io/ecma262/#sec-isregexp
module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : classof(it) == 'RegExp');
};


/***/ }),

/***/ "45fc":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $some = __webpack_require__("b727").some;
var arrayMethodIsStrict = __webpack_require__("a640");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var STRICT_METHOD = arrayMethodIsStrict('some');
var USES_TO_LENGTH = arrayMethodUsesToLength('some');

// `Array.prototype.some` method
// https://tc39.github.io/ecma262/#sec-array.prototype.some
$({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
  some: function some(callbackfn /* , thisArg */) {
    return $some(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "466d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
var anObject = __webpack_require__("825a");
var toLength = __webpack_require__("50c4");
var requireObjectCoercible = __webpack_require__("1d80");
var advanceStringIndex = __webpack_require__("8aa5");
var regExpExec = __webpack_require__("14c3");

// @@match logic
fixRegExpWellKnownSymbolLogic('match', 1, function (MATCH, nativeMatch, maybeCallNative) {
  return [
    // `String.prototype.match` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.match
    function match(regexp) {
      var O = requireObjectCoercible(this);
      var matcher = regexp == undefined ? undefined : regexp[MATCH];
      return matcher !== undefined ? matcher.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
    },
    // `RegExp.prototype[@@match]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
    function (regexp) {
      var res = maybeCallNative(nativeMatch, regexp, this);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);

      if (!rx.global) return regExpExec(rx, S);

      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
      var A = [];
      var n = 0;
      var result;
      while ((result = regExpExec(rx, S)) !== null) {
        var matchStr = String(result[0]);
        A[n] = matchStr;
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
        n++;
      }
      return n === 0 ? null : A;
    }
  ];
});


/***/ }),

/***/ "4840":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var aFunction = __webpack_require__("1c0b");
var wellKnownSymbol = __webpack_require__("b622");

var SPECIES = wellKnownSymbol('species');

// `SpeciesConstructor` abstract operation
// https://tc39.github.io/ecma262/#sec-speciesconstructor
module.exports = function (O, defaultConstructor) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? defaultConstructor : aFunction(S);
};


/***/ }),

/***/ "4928":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M3 6v3h4V6H3zm0 4v3h4v-3H3zm0 4v3h4v-3H3zm5 3h4v-3H8v3zm5 0h4v-3h-4v3zm4-4v-3h-4v3h4zm0-4V6h-4v3h4zm1.5 8a1.5 1.5 0 0 1-1.5 1.5H3A1.5 1.5 0 0 1 1.5 17V4c.222-.863 1.068-1.5 2-1.5h13c.932 0 1.778.637 2 1.5v13zM12 13v-3H8v3h4zm0-4V6H8v3h4z\"/></svg>"

/***/ }),

/***/ "4930":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

module.exports = !!Object.getOwnPropertySymbols && !fails(function () {
  // Chrome 38 Symbol has incorrect toString conversion
  // eslint-disable-next-line no-undef
  return !String(Symbol());
});


/***/ }),

/***/ "498a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $trim = __webpack_require__("58a8").trim;
var forcedStringTrimMethod = __webpack_require__("c8d2");

// `String.prototype.trim` method
// https://tc39.github.io/ecma262/#sec-string.prototype.trim
$({ target: 'String', proto: true, forced: forcedStringTrimMethod('trim') }, {
  trim: function trim() {
    return $trim(this);
  }
});


/***/ }),

/***/ "4ae1":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var getBuiltIn = __webpack_require__("d066");
var aFunction = __webpack_require__("1c0b");
var anObject = __webpack_require__("825a");
var isObject = __webpack_require__("861d");
var create = __webpack_require__("7c73");
var bind = __webpack_require__("0538");
var fails = __webpack_require__("d039");

var nativeConstruct = getBuiltIn('Reflect', 'construct');

// `Reflect.construct` method
// https://tc39.github.io/ecma262/#sec-reflect.construct
// MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it
var NEW_TARGET_BUG = fails(function () {
  function F() { /* empty */ }
  return !(nativeConstruct(function () { /* empty */ }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  nativeConstruct(function () { /* empty */ });
});
var FORCED = NEW_TARGET_BUG || ARGS_BUG;

$({ target: 'Reflect', stat: true, forced: FORCED, sham: FORCED }, {
  construct: function construct(Target, args /* , newTarget */) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return nativeConstruct(Target, args, newTarget);
    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0: return new Target();
        case 1: return new Target(args[0]);
        case 2: return new Target(args[0], args[1]);
        case 3: return new Target(args[0], args[1], args[2]);
        case 4: return new Target(args[0], args[1], args[2], args[3]);
      }
      // w/o altered newTarget, lot of arguments case
      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    }
    // with altered newTarget, not support built-in constructors
    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});


/***/ }),

/***/ "4ca4":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 10 10\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M.941 4.523a.75.75 0 1 1 1.06-1.06l3.006 3.005 3.005-3.005a.75.75 0 1 1 1.06 1.06l-3.549 3.55a.75.75 0 0 1-1.168-.136L.941 4.523z\"/></svg>"

/***/ }),

/***/ "4d63":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var global = __webpack_require__("da84");
var isForced = __webpack_require__("94ca");
var inheritIfRequired = __webpack_require__("7156");
var defineProperty = __webpack_require__("9bf2").f;
var getOwnPropertyNames = __webpack_require__("241c").f;
var isRegExp = __webpack_require__("44e7");
var getFlags = __webpack_require__("ad6d");
var stickyHelpers = __webpack_require__("9f7f");
var redefine = __webpack_require__("6eeb");
var fails = __webpack_require__("d039");
var setInternalState = __webpack_require__("69f3").set;
var setSpecies = __webpack_require__("2626");
var wellKnownSymbol = __webpack_require__("b622");

var MATCH = wellKnownSymbol('match');
var NativeRegExp = global.RegExp;
var RegExpPrototype = NativeRegExp.prototype;
var re1 = /a/g;
var re2 = /a/g;

// "new" should create a new object, old webkit bug
var CORRECT_NEW = new NativeRegExp(re1) !== re1;

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y;

var FORCED = DESCRIPTORS && isForced('RegExp', (!CORRECT_NEW || UNSUPPORTED_Y || fails(function () {
  re2[MATCH] = false;
  // RegExp constructor can alter flags and IsRegExp works correct with @@match
  return NativeRegExp(re1) != re1 || NativeRegExp(re2) == re2 || NativeRegExp(re1, 'i') != '/a/i';
})));

// `RegExp` constructor
// https://tc39.github.io/ecma262/#sec-regexp-constructor
if (FORCED) {
  var RegExpWrapper = function RegExp(pattern, flags) {
    var thisIsRegExp = this instanceof RegExpWrapper;
    var patternIsRegExp = isRegExp(pattern);
    var flagsAreUndefined = flags === undefined;
    var sticky;

    if (!thisIsRegExp && patternIsRegExp && pattern.constructor === RegExpWrapper && flagsAreUndefined) {
      return pattern;
    }

    if (CORRECT_NEW) {
      if (patternIsRegExp && !flagsAreUndefined) pattern = pattern.source;
    } else if (pattern instanceof RegExpWrapper) {
      if (flagsAreUndefined) flags = getFlags.call(pattern);
      pattern = pattern.source;
    }

    if (UNSUPPORTED_Y) {
      sticky = !!flags && flags.indexOf('y') > -1;
      if (sticky) flags = flags.replace(/y/g, '');
    }

    var result = inheritIfRequired(
      CORRECT_NEW ? new NativeRegExp(pattern, flags) : NativeRegExp(pattern, flags),
      thisIsRegExp ? this : RegExpPrototype,
      RegExpWrapper
    );

    if (UNSUPPORTED_Y && sticky) setInternalState(result, { sticky: sticky });

    return result;
  };
  var proxy = function (key) {
    key in RegExpWrapper || defineProperty(RegExpWrapper, key, {
      configurable: true,
      get: function () { return NativeRegExp[key]; },
      set: function (it) { NativeRegExp[key] = it; }
    });
  };
  var keys = getOwnPropertyNames(NativeRegExp);
  var index = 0;
  while (keys.length > index) proxy(keys[index++]);
  RegExpPrototype.constructor = RegExpWrapper;
  RegExpWrapper.prototype = RegExpPrototype;
  redefine(global, 'RegExp', RegExpWrapper);
}

// https://tc39.github.io/ecma262/#sec-get-regexp-@@species
setSpecies('RegExp');


/***/ }),

/***/ "4d64":
/***/ (function(module, exports, __webpack_require__) {

var toIndexedObject = __webpack_require__("fc6a");
var toLength = __webpack_require__("50c4");
var toAbsoluteIndex = __webpack_require__("23cb");

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIndexedObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare
    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++];
      // eslint-disable-next-line no-self-compare
      if (value != value) return true;
    // Array#indexOf ignores holes, Array#includes - not
    } else for (;length > index; index++) {
      if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
    } return !IS_INCLUDES && -1;
  };
};

module.exports = {
  // `Array.prototype.includes` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.includes
  includes: createMethod(true),
  // `Array.prototype.indexOf` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
  indexOf: createMethod(false)
};


/***/ }),

/***/ "4de4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $filter = __webpack_require__("b727").filter;
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('filter');
// Edge 14- issue
var USES_TO_LENGTH = arrayMethodUsesToLength('filter');

// `Array.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-array.prototype.filter
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  filter: function filter(callbackfn /* , thisArg */) {
    return $filter(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "4df4":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var bind = __webpack_require__("0366");
var toObject = __webpack_require__("7b0b");
var callWithSafeIterationClosing = __webpack_require__("9bdd");
var isArrayIteratorMethod = __webpack_require__("e95a");
var toLength = __webpack_require__("50c4");
var createProperty = __webpack_require__("8418");
var getIteratorMethod = __webpack_require__("35a1");

// `Array.from` method implementation
// https://tc39.github.io/ecma262/#sec-array.from
module.exports = function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {
  var O = toObject(arrayLike);
  var C = typeof this == 'function' ? this : Array;
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var index = 0;
  var length, result, step, iterator, next, value;
  if (mapping) mapfn = bind(mapfn, argumentsLength > 2 ? arguments[2] : undefined, 2);
  // if the target is not iterable or it's an array with the default iterator - use a simple case
  if (iteratorMethod != undefined && !(C == Array && isArrayIteratorMethod(iteratorMethod))) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    result = new C();
    for (;!(step = next.call(iterator)).done; index++) {
      value = mapping ? callWithSafeIterationClosing(iterator, mapfn, [step.value, index], true) : step.value;
      createProperty(result, index, value);
    }
  } else {
    length = toLength(O.length);
    result = new C(length);
    for (;length > index; index++) {
      value = mapping ? mapfn(O[index], index) : O[index];
      createProperty(result, index, value);
    }
  }
  result.length = index;
  return result;
};


/***/ }),

/***/ "4ec9":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var collection = __webpack_require__("6d61");
var collectionStrong = __webpack_require__("6566");

// `Map` constructor
// https://tc39.github.io/ecma262/#sec-map-objects
module.exports = collection('Map', function (init) {
  return function Map() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);


/***/ }),

/***/ "4fad":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var $entries = __webpack_require__("6f53").entries;

// `Object.entries` method
// https://tc39.github.io/ecma262/#sec-object.entries
$({ target: 'Object', stat: true }, {
  entries: function entries(O) {
    return $entries(O);
  }
});


/***/ }),

/***/ "507e":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "50c4":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("a691");

var min = Math.min;

// `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength
module.exports = function (argument) {
  return argument > 0 ? min(toInteger(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};


/***/ }),

/***/ "5135":
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};


/***/ }),

/***/ "51a6":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "5319":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
var anObject = __webpack_require__("825a");
var toObject = __webpack_require__("7b0b");
var toLength = __webpack_require__("50c4");
var toInteger = __webpack_require__("a691");
var requireObjectCoercible = __webpack_require__("1d80");
var advanceStringIndex = __webpack_require__("8aa5");
var regExpExec = __webpack_require__("14c3");

var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&'`]|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&'`]|\d\d?)/g;

var maybeToString = function (it) {
  return it === undefined ? it : String(it);
};

// @@replace logic
fixRegExpWellKnownSymbolLogic('replace', 2, function (REPLACE, nativeReplace, maybeCallNative, reason) {
  var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = reason.REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE;
  var REPLACE_KEEPS_$0 = reason.REPLACE_KEEPS_$0;
  var UNSAFE_SUBSTITUTE = REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE ? '$' : '$0';

  return [
    // `String.prototype.replace` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.replace
    function replace(searchValue, replaceValue) {
      var O = requireObjectCoercible(this);
      var replacer = searchValue == undefined ? undefined : searchValue[REPLACE];
      return replacer !== undefined
        ? replacer.call(searchValue, O, replaceValue)
        : nativeReplace.call(String(O), searchValue, replaceValue);
    },
    // `RegExp.prototype[@@replace]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
    function (regexp, replaceValue) {
      if (
        (!REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE && REPLACE_KEEPS_$0) ||
        (typeof replaceValue === 'string' && replaceValue.indexOf(UNSAFE_SUBSTITUTE) === -1)
      ) {
        var res = maybeCallNative(nativeReplace, regexp, this, replaceValue);
        if (res.done) return res.value;
      }

      var rx = anObject(regexp);
      var S = String(this);

      var functionalReplace = typeof replaceValue === 'function';
      if (!functionalReplace) replaceValue = String(replaceValue);

      var global = rx.global;
      if (global) {
        var fullUnicode = rx.unicode;
        rx.lastIndex = 0;
      }
      var results = [];
      while (true) {
        var result = regExpExec(rx, S);
        if (result === null) break;

        results.push(result);
        if (!global) break;

        var matchStr = String(result[0]);
        if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      }

      var accumulatedResult = '';
      var nextSourcePosition = 0;
      for (var i = 0; i < results.length; i++) {
        result = results[i];

        var matched = String(result[0]);
        var position = max(min(toInteger(result.index), S.length), 0);
        var captures = [];
        // NOTE: This is equivalent to
        //   captures = result.slice(1).map(maybeToString)
        // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
        // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
        // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.
        for (var j = 1; j < result.length; j++) captures.push(maybeToString(result[j]));
        var namedCaptures = result.groups;
        if (functionalReplace) {
          var replacerArgs = [matched].concat(captures, position, S);
          if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
          var replacement = String(replaceValue.apply(undefined, replacerArgs));
        } else {
          replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
        }
        if (position >= nextSourcePosition) {
          accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
          nextSourcePosition = position + matched.length;
        }
      }
      return accumulatedResult + S.slice(nextSourcePosition);
    }
  ];

  // https://tc39.github.io/ecma262/#sec-getsubstitution
  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;
    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }
    return nativeReplace.call(replacement, symbols, function (match, ch) {
      var capture;
      switch (ch.charAt(0)) {
        case '$': return '$';
        case '&': return matched;
        case '`': return str.slice(0, position);
        case "'": return str.slice(tailPos);
        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;
        default: // \d\d?
          var n = +ch;
          if (n === 0) return match;
          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }
          capture = captures[n - 1];
      }
      return capture === undefined ? '' : capture;
    });
  }
});


/***/ }),

/***/ "536c":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z\" opacity=\".6\"/><path d=\"M7 2h1v16H7V2zm5 0h1v16h-1V2z\" opacity=\".6\"/><path d=\"M1 6h18a1 1 0 0 1 1 1v6a1 1 0 0 1-1 1H1a1 1 0 0 1-1-1V7a1 1 0 0 1 1-1zm1 2v4h4V8H2zm6 0v4h4V8H8zm6 0v4h4V8h-4z\"/></svg>"

/***/ }),

/***/ "546e":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5.085 6.22L2.943 4.078a.75.75 0 1 1 1.06-1.06l2.592 2.59A11.094 11.094 0 0 1 10 5.068c4.738 0 8.578 3.101 8.578 5.083 0 1.197-1.401 2.803-3.555 3.887l1.714 1.713a.75.75 0 0 1-.09 1.138.488.488 0 0 1-.15.084.75.75 0 0 1-.821-.16L6.17 7.304c-.258.11-.51.233-.757.365l6.239 6.24-.006.005.78.78c-.388.094-.78.166-1.174.215l-1.11-1.11h.011L4.55 8.197a7.2 7.2 0 0 0-.665.514l-.112.098 4.897 4.897-.005.006 1.276 1.276a10.164 10.164 0 0 1-1.477-.117l-.479-.479-.009.009-4.863-4.863-.022.031a2.563 2.563 0 0 0-.124.2c-.043.077-.08.158-.108.241a.534.534 0 0 0-.028.133.29.29 0 0 0 .008.072.927.927 0 0 0 .082.226c.067.133.145.26.234.379l3.242 3.365.025.01.59.623c-3.265-.918-5.59-3.155-5.59-4.668 0-1.194 1.448-2.838 3.663-3.93zm7.07.531a4.632 4.632 0 0 1 1.108 5.992l.345.344.046-.018a9.313 9.313 0 0 0 2-1.112c.256-.187.5-.392.727-.613.137-.134.27-.277.392-.431.072-.091.141-.185.203-.286.057-.093.107-.19.148-.292a.72.72 0 0 0 .036-.12.29.29 0 0 0 .008-.072.492.492 0 0 0-.028-.133.999.999 0 0 0-.036-.096 2.165 2.165 0 0 0-.071-.145 2.917 2.917 0 0 0-.125-.2 3.592 3.592 0 0 0-.263-.335 5.444 5.444 0 0 0-.53-.523 7.955 7.955 0 0 0-1.054-.768 9.766 9.766 0 0 0-1.879-.891c-.337-.118-.68-.219-1.027-.301zm-2.85.21l-.069.002a.508.508 0 0 0-.254.097.496.496 0 0 0-.104.679.498.498 0 0 0 .326.199l.045.005c.091.003.181.003.272.012a2.45 2.45 0 0 1 2.017 1.513c.024.061.043.125.069.185a.494.494 0 0 0 .45.287h.008a.496.496 0 0 0 .35-.158.482.482 0 0 0 .13-.335.638.638 0 0 0-.048-.219 3.379 3.379 0 0 0-.36-.723 3.438 3.438 0 0 0-2.791-1.543l-.028-.001h-.013z\"/></svg>"

/***/ }),

/***/ "5692":
/***/ (function(module, exports, __webpack_require__) {

var IS_PURE = __webpack_require__("c430");
var store = __webpack_require__("c6cd");

(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: '3.6.5',
  mode: IS_PURE ? 'pure' : 'global',
  copyright: '© 2020 Denis Pushkarev (zloirock.ru)'
});


/***/ }),

/***/ "56ef":
/***/ (function(module, exports, __webpack_require__) {

var getBuiltIn = __webpack_require__("d066");
var getOwnPropertyNamesModule = __webpack_require__("241c");
var getOwnPropertySymbolsModule = __webpack_require__("7418");
var anObject = __webpack_require__("825a");

// all object keys, includes non-enumerable and symbols
module.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {
  var keys = getOwnPropertyNamesModule.f(anObject(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};


/***/ }),

/***/ "5899":
/***/ (function(module, exports) {

// a string of all valid unicode whitespaces
// eslint-disable-next-line max-len
module.exports = '\u0009\u000A\u000B\u000C\u000D\u0020\u00A0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF';


/***/ }),

/***/ "58a8":
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__("1d80");
var whitespaces = __webpack_require__("5899");

var whitespace = '[' + whitespaces + ']';
var ltrim = RegExp('^' + whitespace + whitespace + '*');
var rtrim = RegExp(whitespace + whitespace + '*$');

// `String.prototype.{ trim, trimStart, trimEnd, trimLeft, trimRight }` methods implementation
var createMethod = function (TYPE) {
  return function ($this) {
    var string = String(requireObjectCoercible($this));
    if (TYPE & 1) string = string.replace(ltrim, '');
    if (TYPE & 2) string = string.replace(rtrim, '');
    return string;
  };
};

module.exports = {
  // `String.prototype.{ trimLeft, trimStart }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimstart
  start: createMethod(1),
  // `String.prototype.{ trimRight, trimEnd }` methods
  // https://tc39.github.io/ecma262/#sec-string.prototype.trimend
  end: createMethod(2),
  // `String.prototype.trim` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.trim
  trim: createMethod(3)
};


/***/ }),

/***/ "58e0":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("26ee");
/* harmony import */ var _stubFalse_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("2f74");



/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || _stubFalse_js__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"];

/* harmony default export */ __webpack_exports__["a"] = (isBuffer);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("dd40")(module)))

/***/ }),

/***/ "5a34":
/***/ (function(module, exports, __webpack_require__) {

var isRegExp = __webpack_require__("44e7");

module.exports = function (it) {
  if (isRegExp(it)) {
    throw TypeError("The method doesn't accept regular expressions");
  } return it;
};


/***/ }),

/***/ "5c6c":
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};


/***/ }),

/***/ "5cc6":
/***/ (function(module, exports, __webpack_require__) {

var createTypedArrayConstructor = __webpack_require__("74e8");

// `Uint8Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint8', function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});


/***/ }),

/***/ "5d41":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var isObject = __webpack_require__("861d");
var anObject = __webpack_require__("825a");
var has = __webpack_require__("5135");
var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
var getPrototypeOf = __webpack_require__("e163");

// `Reflect.get` method
// https://tc39.github.io/ecma262/#sec-reflect.get
function get(target, propertyKey /* , receiver */) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var descriptor, prototype;
  if (anObject(target) === receiver) return target[propertyKey];
  if (descriptor = getOwnPropertyDescriptorModule.f(target, propertyKey)) return has(descriptor, 'value')
    ? descriptor.value
    : descriptor.get === undefined
      ? undefined
      : descriptor.get.call(receiver);
  if (isObject(prototype = getPrototypeOf(target))) return get(prototype, propertyKey, receiver);
}

$({ target: 'Reflect', stat: true }, {
  get: get
});


/***/ }),

/***/ "5dbf":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 16 16\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4 0v1H1v3H0V.5A.5.5 0 0 1 .5 0H4zm8 0h3.5a.5.5 0 0 1 .5.5V4h-1V1h-3V0zM4 16H.5a.5.5 0 0 1-.5-.5V12h1v3h3v1zm8 0v-1h3v-3h1v3.5a.5.5 0 0 1-.5.5H12z\"/><path fill-opacity=\".256\" d=\"M1 1h14v14H1z\"/><g class=\"ck-icon__selected-indicator\"><path d=\"M7 0h2v1H7V0zM0 7h1v2H0V7zm15 0h1v2h-1V7zm-8 8h2v1H7v-1z\"/><path fill-opacity=\".254\" d=\"M1 1h14v14H1z\"/></g></svg>"

/***/ }),

/***/ "5ea3":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

/* harmony default export */ __webpack_exports__["a"] = (freeGlobal);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "5f69":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "5f96":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $join = [].join;

// `%TypedArray%.prototype.join` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.join
// eslint-disable-next-line no-unused-vars
exportTypedArrayMethod('join', function join(separator) {
  return $join.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ "6062":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var collection = __webpack_require__("6d61");
var collectionStrong = __webpack_require__("6566");

// `Set` constructor
// https://tc39.github.io/ecma262/#sec-set-objects
module.exports = collection('Set', function (init) {
  return function Set() { return init(this, arguments.length ? arguments[0] : undefined); };
}, collectionStrong);


/***/ }),

/***/ "60bd":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("da84");
var ArrayBufferViewCore = __webpack_require__("ebb5");
var ArrayIterators = __webpack_require__("e260");
var wellKnownSymbol = __webpack_require__("b622");

var ITERATOR = wellKnownSymbol('iterator');
var Uint8Array = global.Uint8Array;
var arrayValues = ArrayIterators.values;
var arrayKeys = ArrayIterators.keys;
var arrayEntries = ArrayIterators.entries;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var nativeTypedArrayIterator = Uint8Array && Uint8Array.prototype[ITERATOR];

var CORRECT_ITER_NAME = !!nativeTypedArrayIterator
  && (nativeTypedArrayIterator.name == 'values' || nativeTypedArrayIterator.name == undefined);

var typedArrayValues = function values() {
  return arrayValues.call(aTypedArray(this));
};

// `%TypedArray%.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.entries
exportTypedArrayMethod('entries', function entries() {
  return arrayEntries.call(aTypedArray(this));
});
// `%TypedArray%.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.keys
exportTypedArrayMethod('keys', function keys() {
  return arrayKeys.call(aTypedArray(this));
});
// `%TypedArray%.prototype.values` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.values
exportTypedArrayMethod('values', typedArrayValues, !CORRECT_ITER_NAME);
// `%TypedArray%.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype-@@iterator
exportTypedArrayMethod(ITERATOR, typedArrayValues, !CORRECT_ITER_NAME);


/***/ }),

/***/ "60da":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__("83ab");
var fails = __webpack_require__("d039");
var objectKeys = __webpack_require__("df75");
var getOwnPropertySymbolsModule = __webpack_require__("7418");
var propertyIsEnumerableModule = __webpack_require__("d1e7");
var toObject = __webpack_require__("7b0b");
var IndexedObject = __webpack_require__("44ad");

var nativeAssign = Object.assign;
var defineProperty = Object.defineProperty;

// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
module.exports = !nativeAssign || fails(function () {
  // should have correct order of operations (Edge bug)
  if (DESCRIPTORS && nativeAssign({ b: 1 }, nativeAssign(defineProperty({}, 'a', {
    enumerable: true,
    get: function () {
      defineProperty(this, 'b', {
        value: 3,
        enumerable: false
      });
    }
  }), { b: 2 })).b !== 1) return true;
  // should work with symbols and should have deterministic property order (V8 bug)
  var A = {};
  var B = {};
  // eslint-disable-next-line no-undef
  var symbol = Symbol();
  var alphabet = 'abcdefghijklmnopqrst';
  A[symbol] = 7;
  alphabet.split('').forEach(function (chr) { B[chr] = chr; });
  return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var argumentsLength = arguments.length;
  var index = 1;
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  var propertyIsEnumerable = propertyIsEnumerableModule.f;
  while (argumentsLength > index) {
    var S = IndexedObject(arguments[index++]);
    var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
    var length = keys.length;
    var j = 0;
    var key;
    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || propertyIsEnumerable.call(S, key)) T[key] = S[key];
    }
  } return T;
} : nativeAssign;


/***/ }),

/***/ "6134":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "621a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("da84");
var DESCRIPTORS = __webpack_require__("83ab");
var NATIVE_ARRAY_BUFFER = __webpack_require__("a981");
var createNonEnumerableProperty = __webpack_require__("9112");
var redefineAll = __webpack_require__("e2cc");
var fails = __webpack_require__("d039");
var anInstance = __webpack_require__("19aa");
var toInteger = __webpack_require__("a691");
var toLength = __webpack_require__("50c4");
var toIndex = __webpack_require__("0b25");
var IEEE754 = __webpack_require__("77a7");
var getPrototypeOf = __webpack_require__("e163");
var setPrototypeOf = __webpack_require__("d2bb");
var getOwnPropertyNames = __webpack_require__("241c").f;
var defineProperty = __webpack_require__("9bf2").f;
var arrayFill = __webpack_require__("81d5");
var setToStringTag = __webpack_require__("d44e");
var InternalStateModule = __webpack_require__("69f3");

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer = global[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var $DataView = global[DATA_VIEW];
var $DataViewPrototype = $DataView && $DataView[PROTOTYPE];
var ObjectPrototype = Object.prototype;
var RangeError = global.RangeError;

var packIEEE754 = IEEE754.pack;
var unpackIEEE754 = IEEE754.unpack;

var packInt8 = function (number) {
  return [number & 0xFF];
};

var packInt16 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function (number) {
  return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var unpackInt32 = function (buffer) {
  return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packFloat32 = function (number) {
  return packIEEE754(number, 23, 4);
};

var packFloat64 = function (number) {
  return packIEEE754(number, 52, 8);
};

var addGetter = function (Constructor, key) {
  defineProperty(Constructor[PROTOTYPE], key, { get: function () { return getInternalState(this)[key]; } });
};

var get = function (view, count, index, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = bytes.slice(start, start + count);
  return isLittleEndian ? pack : pack.reverse();
};

var set = function (view, count, index, conversion, value, isLittleEndian) {
  var intIndex = toIndex(index);
  var store = getInternalState(view);
  if (intIndex + count > store.byteLength) throw RangeError(WRONG_INDEX);
  var bytes = getInternalState(store.buffer).bytes;
  var start = intIndex + store.byteOffset;
  var pack = conversion(+value);
  for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
};

if (!NATIVE_ARRAY_BUFFER) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    setInternalState(this, {
      bytes: arrayFill.call(new Array(byteLength), 0),
      byteLength: byteLength
    });
    if (!DESCRIPTORS) this.byteLength = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = getInternalState(buffer).byteLength;
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    setInternalState(this, {
      buffer: buffer,
      byteLength: byteLength,
      byteOffset: offset
    });
    if (!DESCRIPTORS) {
      this.buffer = buffer;
      this.byteLength = byteLength;
      this.byteOffset = offset;
    }
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, 'byteLength');
    addGetter($DataView, 'buffer');
    addGetter($DataView, 'byteLength');
    addGetter($DataView, 'byteOffset');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset /* , littleEndian */) {
      var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
    },
    getUint32: function getUint32(byteOffset /* , littleEndian */) {
      return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
    },
    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packInt8, value);
    },
    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {
      set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {
      set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
    },
    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {
      set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
    }
  });
} else {
  if (!fails(function () {
    NativeArrayBuffer(1);
  }) || !fails(function () {
    new NativeArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new NativeArrayBuffer(); // eslint-disable-line no-new
    new NativeArrayBuffer(1.5); // eslint-disable-line no-new
    new NativeArrayBuffer(NaN); // eslint-disable-line no-new
    return NativeArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new NativeArrayBuffer(toIndex(length));
    };
    var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];
    for (var keys = getOwnPropertyNames(NativeArrayBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) {
        createNonEnumerableProperty($ArrayBuffer, key, NativeArrayBuffer[key]);
      }
    }
    ArrayBufferPrototype.constructor = $ArrayBuffer;
  }

  // WebKit bug - the same parent prototype for typed arrays and data view
  if (setPrototypeOf && getPrototypeOf($DataViewPrototype) !== ObjectPrototype) {
    setPrototypeOf($DataViewPrototype, ObjectPrototype);
  }

  // iOS Safari 7.x bug
  var testView = new $DataView(new $ArrayBuffer(2));
  var nativeSetInt8 = $DataViewPrototype.setInt8;
  testView.setInt8(0, 2147483648);
  testView.setInt8(1, 2147483649);
  if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
    setInt8: function setInt8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, { unsafe: true });
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);

module.exports = {
  ArrayBuffer: $ArrayBuffer,
  DataView: $DataView
};


/***/ }),

/***/ "6378":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2 3.75c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0 4c0 .414.336.75.75.75h9.929a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75zm0-8c0 .414.336.75.75.75h14.5a.75.75 0 1 0 0-1.5H2.75a.75.75 0 0 0-.75.75z\"/></svg>"

/***/ }),

/***/ "649e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $some = __webpack_require__("b727").some;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.some` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.some
exportTypedArrayMethod('some', function some(callbackfn /* , thisArg */) {
  return $some(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "6547":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("a691");
var requireObjectCoercible = __webpack_require__("1d80");

// `String.prototype.{ codePointAt, at }` methods implementation
var createMethod = function (CONVERT_TO_STRING) {
  return function ($this, pos) {
    var S = String(requireObjectCoercible($this));
    var position = toInteger(pos);
    var size = S.length;
    var first, second;
    if (position < 0 || position >= size) return CONVERT_TO_STRING ? '' : undefined;
    first = S.charCodeAt(position);
    return first < 0xD800 || first > 0xDBFF || position + 1 === size
      || (second = S.charCodeAt(position + 1)) < 0xDC00 || second > 0xDFFF
        ? CONVERT_TO_STRING ? S.charAt(position) : first
        : CONVERT_TO_STRING ? S.slice(position, position + 2) : (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;
  };
};

module.exports = {
  // `String.prototype.codePointAt` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.codepointat
  codeAt: createMethod(false),
  // `String.prototype.at` method
  // https://github.com/mathiasbynens/String.prototype.at
  charAt: createMethod(true)
};


/***/ }),

/***/ "6566":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var defineProperty = __webpack_require__("9bf2").f;
var create = __webpack_require__("7c73");
var redefineAll = __webpack_require__("e2cc");
var bind = __webpack_require__("0366");
var anInstance = __webpack_require__("19aa");
var iterate = __webpack_require__("2266");
var defineIterator = __webpack_require__("7dd0");
var setSpecies = __webpack_require__("2626");
var DESCRIPTORS = __webpack_require__("83ab");
var fastKey = __webpack_require__("f183").fastKey;
var InternalStateModule = __webpack_require__("69f3");

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        index: create(null),
        first: undefined,
        last: undefined,
        size: 0
      });
      if (!DESCRIPTORS) that.size = 0;
      if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
    });

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var entry = getEntry(that, key);
      var previous, index;
      // change existing entry
      if (entry) {
        entry.value = value;
      // create new entry
      } else {
        state.last = entry = {
          index: index = fastKey(key, true),
          key: key,
          value: value,
          previous: previous = state.last,
          next: undefined,
          removed: false
        };
        if (!state.first) state.first = entry;
        if (previous) previous.next = entry;
        if (DESCRIPTORS) state.size++;
        else that.size++;
        // add to index
        if (index !== 'F') state.index[index] = entry;
      } return that;
    };

    var getEntry = function (that, key) {
      var state = getInternalState(that);
      // fast case
      var index = fastKey(key);
      var entry;
      if (index !== 'F') return state.index[index];
      // frozen object case
      for (entry = state.first; entry; entry = entry.next) {
        if (entry.key == key) return entry;
      }
    };

    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        var that = this;
        var state = getInternalState(that);
        var data = state.index;
        var entry = state.first;
        while (entry) {
          entry.removed = true;
          if (entry.previous) entry.previous = entry.previous.next = undefined;
          delete data[entry.index];
          entry = entry.next;
        }
        state.first = state.last = undefined;
        if (DESCRIPTORS) state.size = 0;
        else that.size = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function (key) {
        var that = this;
        var state = getInternalState(that);
        var entry = getEntry(that, key);
        if (entry) {
          var next = entry.next;
          var prev = entry.previous;
          delete state.index[entry.index];
          entry.removed = true;
          if (prev) prev.next = next;
          if (next) next.previous = prev;
          if (state.first == entry) state.first = next;
          if (state.last == entry) state.last = prev;
          if (DESCRIPTORS) state.size--;
          else that.size--;
        } return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn /* , that = undefined */) {
        var state = getInternalState(this);
        var boundFunction = bind(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;
        while (entry = entry ? entry.next : state.first) {
          boundFunction(entry.value, entry.key, this);
          // revert to the last existing entry
          while (entry && entry.removed) entry = entry.previous;
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(this, key);
      }
    });

    redefineAll(C.prototype, IS_MAP ? {
      // 23.1.3.6 Map.prototype.get(key)
      get: function get(key) {
        var entry = getEntry(this, key);
        return entry && entry.value;
      },
      // 23.1.3.9 Map.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key === 0 ? 0 : key, value);
      }
    } : {
      // 23.2.3.1 Set.prototype.add(value)
      add: function add(value) {
        return define(this, value = value === 0 ? 0 : value, value);
      }
    });
    if (DESCRIPTORS) defineProperty(C.prototype, 'size', {
      get: function () {
        return getInternalState(this).size;
      }
    });
    return C;
  },
  setStrong: function (C, CONSTRUCTOR_NAME, IS_MAP) {
    var ITERATOR_NAME = CONSTRUCTOR_NAME + ' Iterator';
    var getInternalCollectionState = internalStateGetterFor(CONSTRUCTOR_NAME);
    var getInternalIteratorState = internalStateGetterFor(ITERATOR_NAME);
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    defineIterator(C, CONSTRUCTOR_NAME, function (iterated, kind) {
      setInternalState(this, {
        type: ITERATOR_NAME,
        target: iterated,
        state: getInternalCollectionState(iterated),
        kind: kind,
        last: undefined
      });
    }, function () {
      var state = getInternalIteratorState(this);
      var kind = state.kind;
      var entry = state.last;
      // revert to the last existing entry
      while (entry && entry.removed) entry = entry.previous;
      // get next entry
      if (!state.target || !(state.last = entry = entry ? entry.next : state.state.first)) {
        // or finish the iteration
        state.target = undefined;
        return { value: undefined, done: true };
      }
      // return step by kind
      if (kind == 'keys') return { value: entry.key, done: false };
      if (kind == 'values') return { value: entry.value, done: false };
      return { value: [entry.key, entry.value], done: false };
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true);

    // add [@@species], 23.1.2.2, 23.2.2.2
    setSpecies(CONSTRUCTOR_NAME);
  }
};


/***/ }),

/***/ "65f0":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");
var isArray = __webpack_require__("e8b5");
var wellKnownSymbol = __webpack_require__("b622");

var SPECIES = wellKnownSymbol('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
module.exports = function (originalArray, length) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    // cross-realm fallback
    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  } return new (C === undefined ? Array : C)(length === 0 ? 0 : length);
};


/***/ }),

/***/ "660d":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2 4.5V3h16v1.5zm2.5 3V12h11V7.5h-11zM4.061 6H15.94c.586 0 1.061.407 1.061.91v5.68c0 .503-.475.91-1.061.91H4.06c-.585 0-1.06-.407-1.06-.91V6.91C3 6.406 3.475 6 4.061 6zM2 16.5V15h16v1.5z\"/></svg>"

/***/ }),

/***/ "6649":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "69f3":
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_WEAK_MAP = __webpack_require__("7f9a");
var global = __webpack_require__("da84");
var isObject = __webpack_require__("861d");
var createNonEnumerableProperty = __webpack_require__("9112");
var objectHas = __webpack_require__("5135");
var sharedKey = __webpack_require__("f772");
var hiddenKeys = __webpack_require__("d012");

var WeakMap = global.WeakMap;
var set, get, has;

var enforce = function (it) {
  return has(it) ? get(it) : set(it, {});
};

var getterFor = function (TYPE) {
  return function (it) {
    var state;
    if (!isObject(it) || (state = get(it)).type !== TYPE) {
      throw TypeError('Incompatible receiver, ' + TYPE + ' required');
    } return state;
  };
};

if (NATIVE_WEAK_MAP) {
  var store = new WeakMap();
  var wmget = store.get;
  var wmhas = store.has;
  var wmset = store.set;
  set = function (it, metadata) {
    wmset.call(store, it, metadata);
    return metadata;
  };
  get = function (it) {
    return wmget.call(store, it) || {};
  };
  has = function (it) {
    return wmhas.call(store, it);
  };
} else {
  var STATE = sharedKey('state');
  hiddenKeys[STATE] = true;
  set = function (it, metadata) {
    createNonEnumerableProperty(it, STATE, metadata);
    return metadata;
  };
  get = function (it) {
    return objectHas(it, STATE) ? it[STATE] : {};
  };
  has = function (it) {
    return objectHas(it, STATE);
  };
}

module.exports = {
  set: set,
  get: get,
  has: has,
  enforce: enforce,
  getterFor: getterFor
};


/***/ }),

/***/ "6aed":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "6cdf":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "6d61":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var isForced = __webpack_require__("94ca");
var redefine = __webpack_require__("6eeb");
var InternalMetadataModule = __webpack_require__("f183");
var iterate = __webpack_require__("2266");
var anInstance = __webpack_require__("19aa");
var isObject = __webpack_require__("861d");
var fails = __webpack_require__("d039");
var checkCorrectnessOfIteration = __webpack_require__("1c7e");
var setToStringTag = __webpack_require__("d44e");
var inheritIfRequired = __webpack_require__("7156");

module.exports = function (CONSTRUCTOR_NAME, wrapper, common) {
  var IS_MAP = CONSTRUCTOR_NAME.indexOf('Map') !== -1;
  var IS_WEAK = CONSTRUCTOR_NAME.indexOf('Weak') !== -1;
  var ADDER = IS_MAP ? 'set' : 'add';
  var NativeConstructor = global[CONSTRUCTOR_NAME];
  var NativePrototype = NativeConstructor && NativeConstructor.prototype;
  var Constructor = NativeConstructor;
  var exported = {};

  var fixMethod = function (KEY) {
    var nativeMethod = NativePrototype[KEY];
    redefine(NativePrototype, KEY,
      KEY == 'add' ? function add(value) {
        nativeMethod.call(this, value === 0 ? 0 : value);
        return this;
      } : KEY == 'delete' ? function (key) {
        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
      } : KEY == 'get' ? function get(key) {
        return IS_WEAK && !isObject(key) ? undefined : nativeMethod.call(this, key === 0 ? 0 : key);
      } : KEY == 'has' ? function has(key) {
        return IS_WEAK && !isObject(key) ? false : nativeMethod.call(this, key === 0 ? 0 : key);
      } : function set(key, value) {
        nativeMethod.call(this, key === 0 ? 0 : key, value);
        return this;
      }
    );
  };

  // eslint-disable-next-line max-len
  if (isForced(CONSTRUCTOR_NAME, typeof NativeConstructor != 'function' || !(IS_WEAK || NativePrototype.forEach && !fails(function () {
    new NativeConstructor().entries().next();
  })))) {
    // create collection constructor
    Constructor = common.getConstructor(wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER);
    InternalMetadataModule.REQUIRED = true;
  } else if (isForced(CONSTRUCTOR_NAME, true)) {
    var instance = new Constructor();
    // early implementations not supports chaining
    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance;
    // V8 ~ Chromium 40- weak-collections throws on primitives, but should return false
    var THROWS_ON_PRIMITIVES = fails(function () { instance.has(1); });
    // most early implementations doesn't supports iterables, most modern - not close it correctly
    // eslint-disable-next-line no-new
    var ACCEPT_ITERABLES = checkCorrectnessOfIteration(function (iterable) { new NativeConstructor(iterable); });
    // for early implementations -0 and +0 not the same
    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new NativeConstructor();
      var index = 5;
      while (index--) $instance[ADDER](index, index);
      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      Constructor = wrapper(function (dummy, iterable) {
        anInstance(dummy, Constructor, CONSTRUCTOR_NAME);
        var that = inheritIfRequired(new NativeConstructor(), dummy, Constructor);
        if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
        return that;
      });
      Constructor.prototype = NativePrototype;
      NativePrototype.constructor = Constructor;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER);

    // weak collections should not contains .clear method
    if (IS_WEAK && NativePrototype.clear) delete NativePrototype.clear;
  }

  exported[CONSTRUCTOR_NAME] = Constructor;
  $({ global: true, forced: Constructor != NativeConstructor }, exported);

  setToStringTag(Constructor, CONSTRUCTOR_NAME);

  if (!IS_WEAK) common.setStrong(Constructor, CONSTRUCTOR_NAME, IS_MAP);

  return Constructor;
};


/***/ }),

/***/ "6eeb":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var createNonEnumerableProperty = __webpack_require__("9112");
var has = __webpack_require__("5135");
var setGlobal = __webpack_require__("ce4e");
var inspectSource = __webpack_require__("8925");
var InternalStateModule = __webpack_require__("69f3");

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(module.exports = function (O, key, value, options) {
  var unsafe = options ? !!options.unsafe : false;
  var simple = options ? !!options.enumerable : false;
  var noTargetGet = options ? !!options.noTargetGet : false;
  if (typeof value == 'function') {
    if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
    enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
  }
  if (O === global) {
    if (simple) O[key] = value;
    else setGlobal(key, value);
    return;
  } else if (!unsafe) {
    delete O[key];
  } else if (!noTargetGet && O[key]) {
    simple = true;
  }
  if (simple) O[key] = value;
  else createNonEnumerableProperty(O, key, value);
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
  return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});


/***/ }),

/***/ "6f53":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var objectKeys = __webpack_require__("df75");
var toIndexedObject = __webpack_require__("fc6a");
var propertyIsEnumerable = __webpack_require__("d1e7").f;

// `Object.{ entries, values }` methods implementation
var createMethod = function (TO_ENTRIES) {
  return function (it) {
    var O = toIndexedObject(it);
    var keys = objectKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;
    while (length > i) {
      key = keys[i++];
      if (!DESCRIPTORS || propertyIsEnumerable.call(O, key)) {
        result.push(TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};

module.exports = {
  // `Object.entries` method
  // https://tc39.github.io/ecma262/#sec-object.entries
  entries: createMethod(true),
  // `Object.values` method
  // https://tc39.github.io/ecma262/#sec-object.values
  values: createMethod(false)
};


/***/ }),

/***/ "7039":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var fails = __webpack_require__("d039");
var nativeGetOwnPropertyNames = __webpack_require__("057f").f;

var FAILS_ON_PRIMITIVES = fails(function () { return !Object.getOwnPropertyNames(1); });

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  getOwnPropertyNames: nativeGetOwnPropertyNames
});


/***/ }),

/***/ "7156":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");
var setPrototypeOf = __webpack_require__("d2bb");

// makes subclassing work correct for wrapped built-ins
module.exports = function ($this, dummy, Wrapper) {
  var NewTarget, NewTargetPrototype;
  if (
    // it can work only with native `setPrototypeOf`
    setPrototypeOf &&
    // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
    typeof (NewTarget = dummy.constructor) == 'function' &&
    NewTarget !== Wrapper &&
    isObject(NewTargetPrototype = NewTarget.prototype) &&
    NewTargetPrototype !== Wrapper.prototype
  ) setPrototypeOf($this, NewTargetPrototype);
  return $this;
};


/***/ }),

/***/ "7201":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "72f7":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var exportTypedArrayMethod = __webpack_require__("ebb5").exportTypedArrayMethod;
var fails = __webpack_require__("d039");
var global = __webpack_require__("da84");

var Uint8Array = global.Uint8Array;
var Uint8ArrayPrototype = Uint8Array && Uint8Array.prototype || {};
var arrayToString = [].toString;
var arrayJoin = [].join;

if (fails(function () { arrayToString.call({}); })) {
  arrayToString = function toString() {
    return arrayJoin.call(this);
  };
}

var IS_NOT_ARRAY_METHOD = Uint8ArrayPrototype.toString != arrayToString;

// `%TypedArray%.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tostring
exportTypedArrayMethod('toString', arrayToString, IS_NOT_ARRAY_METHOD);


/***/ }),

/***/ "735e":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $fill = __webpack_require__("81d5");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
// eslint-disable-next-line no-unused-vars
exportTypedArrayMethod('fill', function fill(value /* , start, end */) {
  return $fill.apply(aTypedArray(this), arguments);
});


/***/ }),

/***/ "7418":
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;


/***/ }),

/***/ "746f":
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__("428f");
var has = __webpack_require__("5135");
var wrappedWellKnownSymbolModule = __webpack_require__("e538");
var defineProperty = __webpack_require__("9bf2").f;

module.exports = function (NAME) {
  var Symbol = path.Symbol || (path.Symbol = {});
  if (!has(Symbol, NAME)) defineProperty(Symbol, NAME, {
    value: wrappedWellKnownSymbolModule.f(NAME)
  });
};


/***/ }),

/***/ "74c7":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11.463 5.187a.888.888 0 1 1 1.254 1.255L9.16 10l3.557 3.557a.888.888 0 1 1-1.254 1.255L7.26 10.61a.888.888 0 0 1 .16-1.382l4.043-4.042z\"/></svg>"

/***/ }),

/***/ "74e8":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var DESCRIPTORS = __webpack_require__("83ab");
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = __webpack_require__("8aa7");
var ArrayBufferViewCore = __webpack_require__("ebb5");
var ArrayBufferModule = __webpack_require__("621a");
var anInstance = __webpack_require__("19aa");
var createPropertyDescriptor = __webpack_require__("5c6c");
var createNonEnumerableProperty = __webpack_require__("9112");
var toLength = __webpack_require__("50c4");
var toIndex = __webpack_require__("0b25");
var toOffset = __webpack_require__("182d");
var toPrimitive = __webpack_require__("c04e");
var has = __webpack_require__("5135");
var classof = __webpack_require__("f5df");
var isObject = __webpack_require__("861d");
var create = __webpack_require__("7c73");
var setPrototypeOf = __webpack_require__("d2bb");
var getOwnPropertyNames = __webpack_require__("241c").f;
var typedArrayFrom = __webpack_require__("a078");
var forEach = __webpack_require__("b727").forEach;
var setSpecies = __webpack_require__("2626");
var definePropertyModule = __webpack_require__("9bf2");
var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
var InternalStateModule = __webpack_require__("69f3");
var inheritIfRequired = __webpack_require__("7156");

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var round = Math.round;
var RangeError = global.RangeError;
var ArrayBuffer = ArrayBufferModule.ArrayBuffer;
var DataView = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_TAG = ArrayBufferViewCore.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore.TypedArray;
var TypedArrayPrototype = ArrayBufferViewCore.TypedArrayPrototype;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var isTypedArray = ArrayBufferViewCore.isTypedArray;
var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
var WRONG_LENGTH = 'Wrong length';

var fromList = function (C, list) {
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
};

var addGetter = function (it, key) {
  nativeDefineProperty(it, key, { get: function () {
    return getInternalState(this)[key];
  } });
};

var isArrayBuffer = function (it) {
  var klass;
  return it instanceof ArrayBuffer || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
};

var isTypedArrayIndex = function (target, key) {
  return isTypedArray(target)
    && typeof key != 'symbol'
    && key in target
    && String(+key) == String(key);
};

var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
  return isTypedArrayIndex(target, key = toPrimitive(key, true))
    ? createPropertyDescriptor(2, target[key])
    : nativeGetOwnPropertyDescriptor(target, key);
};

var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
  if (isTypedArrayIndex(target, key = toPrimitive(key, true))
    && isObject(descriptor)
    && has(descriptor, 'value')
    && !has(descriptor, 'get')
    && !has(descriptor, 'set')
    // TODO: add validation descriptor w/o calling accessors
    && !descriptor.configurable
    && (!has(descriptor, 'writable') || descriptor.writable)
    && (!has(descriptor, 'enumerable') || descriptor.enumerable)
  ) {
    target[key] = descriptor.value;
    return target;
  } return nativeDefineProperty(target, key, descriptor);
};

if (DESCRIPTORS) {
  if (!NATIVE_ARRAY_BUFFER_VIEWS) {
    getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
    definePropertyModule.f = wrappedDefineProperty;
    addGetter(TypedArrayPrototype, 'buffer');
    addGetter(TypedArrayPrototype, 'byteOffset');
    addGetter(TypedArrayPrototype, 'byteLength');
    addGetter(TypedArrayPrototype, 'length');
  }

  $({ target: 'Object', stat: true, forced: !NATIVE_ARRAY_BUFFER_VIEWS }, {
    getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
    defineProperty: wrappedDefineProperty
  });

  module.exports = function (TYPE, wrapper, CLAMPED) {
    var BYTES = TYPE.match(/\d+$/)[0] / 8;
    var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + TYPE;
    var SETTER = 'set' + TYPE;
    var NativeTypedArrayConstructor = global[CONSTRUCTOR_NAME];
    var TypedArrayConstructor = NativeTypedArrayConstructor;
    var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
    var exported = {};

    var getter = function (that, index) {
      var data = getInternalState(that);
      return data.view[GETTER](index * BYTES + data.byteOffset, true);
    };

    var setter = function (that, index, value) {
      var data = getInternalState(that);
      if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
      data.view[SETTER](index * BYTES + data.byteOffset, value, true);
    };

    var addElement = function (that, index) {
      nativeDefineProperty(that, index, {
        get: function () {
          return getter(this, index);
        },
        set: function (value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
      TypedArrayConstructor = wrapper(function (that, data, offset, $length) {
        anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
        var index = 0;
        var byteOffset = 0;
        var buffer, byteLength, length;
        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new ArrayBuffer(byteLength);
        } else if (isArrayBuffer(data)) {
          buffer = data;
          byteOffset = toOffset(offset, BYTES);
          var $len = data.byteLength;
          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - byteOffset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + byteOffset > $len) throw RangeError(WRONG_LENGTH);
          }
          length = byteLength / BYTES;
        } else if (isTypedArray(data)) {
          return fromList(TypedArrayConstructor, data);
        } else {
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }
        setInternalState(that, {
          buffer: buffer,
          byteOffset: byteOffset,
          byteLength: byteLength,
          length: length,
          view: new DataView(buffer)
        });
        while (index < length) addElement(that, index++);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
    } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
      TypedArrayConstructor = wrapper(function (dummy, data, typedArrayOffset, $length) {
        anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
        return inheritIfRequired(function () {
          if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
          if (isArrayBuffer(data)) return $length !== undefined
            ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES), $length)
            : typedArrayOffset !== undefined
              ? new NativeTypedArrayConstructor(data, toOffset(typedArrayOffset, BYTES))
              : new NativeTypedArrayConstructor(data);
          if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
          return typedArrayFrom.call(TypedArrayConstructor, data);
        }(), dummy, TypedArrayConstructor);
      });

      if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
      forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function (key) {
        if (!(key in TypedArrayConstructor)) {
          createNonEnumerableProperty(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
        }
      });
      TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
    }

    if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
    }

    if (TYPED_ARRAY_TAG) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
    }

    exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

    $({
      global: true, forced: TypedArrayConstructor != NativeTypedArrayConstructor, sham: !NATIVE_ARRAY_BUFFER_VIEWS
    }, exported);

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
      createNonEnumerableProperty(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
    }

    if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
      createNonEnumerableProperty(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
    }

    setSpecies(CONSTRUCTOR_NAME);
  };
} else module.exports = function () { /* empty */ };


/***/ }),

/***/ "74fe":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "7639":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.4 10.3L10 4.5l-2.4 5.8h4.8zm.5 1.2H7.1L5.7 15H4.2l5-12h1.6l5 12h-1.5L13 11.5zm3.1 7H4a1 1 0 0 1 0-2h12a1 1 0 0 1 0 2z\"/></svg>"

/***/ }),

/***/ "77a7":
/***/ (function(module, exports) {

// IEEE754 conversions based on https://github.com/feross/ieee754
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = 1 / 0;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;

var pack = function (number, mantissaLength, bytes) {
  var buffer = new Array(bytes);
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
  var index = 0;
  var exponent, mantissa, c;
  number = abs(number);
  // eslint-disable-next-line no-self-compare
  if (number != number || number === Infinity) {
    // eslint-disable-next-line no-self-compare
    mantissa = number != number ? 1 : 0;
    exponent = eMax;
  } else {
    exponent = floor(log(number) / LN2);
    if (number * (c = pow(2, -exponent)) < 1) {
      exponent--;
      c *= 2;
    }
    if (exponent + eBias >= 1) {
      number += rt / c;
    } else {
      number += rt * pow(2, 1 - eBias);
    }
    if (number * c >= 2) {
      exponent++;
      c /= 2;
    }
    if (exponent + eBias >= eMax) {
      mantissa = 0;
      exponent = eMax;
    } else if (exponent + eBias >= 1) {
      mantissa = (number * c - 1) * pow(2, mantissaLength);
      exponent = exponent + eBias;
    } else {
      mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
      exponent = 0;
    }
  }
  for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
  exponent = exponent << mantissaLength | mantissa;
  exponentLength += mantissaLength;
  for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
  buffer[--index] |= sign * 128;
  return buffer;
};

var unpack = function (buffer, mantissaLength) {
  var bytes = buffer.length;
  var exponentLength = bytes * 8 - mantissaLength - 1;
  var eMax = (1 << exponentLength) - 1;
  var eBias = eMax >> 1;
  var nBits = exponentLength - 7;
  var index = bytes - 1;
  var sign = buffer[index--];
  var exponent = sign & 127;
  var mantissa;
  sign >>= 7;
  for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
  mantissa = exponent & (1 << -nBits) - 1;
  exponent >>= -nBits;
  nBits += mantissaLength;
  for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
  if (exponent === 0) {
    exponent = 1 - eBias;
  } else if (exponent === eMax) {
    return mantissa ? NaN : sign ? -Infinity : Infinity;
  } else {
    mantissa = mantissa + pow(2, mantissaLength);
    exponent = exponent - eBias;
  } return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

module.exports = {
  pack: pack,
  unpack: unpack
};


/***/ }),

/***/ "77bd":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11.077 15l.991-1.416a.75.75 0 1 1 1.229.86l-1.148 1.64a.748.748 0 0 1-.217.206 5.251 5.251 0 0 1-8.503-5.955.741.741 0 0 1 .12-.274l1.147-1.639a.75.75 0 1 1 1.228.86L4.933 10.7l.006.003a3.75 3.75 0 0 0 6.132 4.294l.006.004zm5.494-5.335a.748.748 0 0 1-.12.274l-1.147 1.639a.75.75 0 1 1-1.228-.86l.86-1.23a3.75 3.75 0 0 0-6.144-4.301l-.86 1.229a.75.75 0 0 1-1.229-.86l1.148-1.64a.748.748 0 0 1 .217-.206 5.251 5.251 0 0 1 8.503 5.955zm-4.563-2.532a.75.75 0 0 1 .184 1.045l-3.155 4.505a.75.75 0 1 1-1.229-.86l3.155-4.506a.75.75 0 0 1 1.045-.184z\"/></svg>"

/***/ }),

/***/ "7839":
/***/ (function(module, exports) {

// IE8- don't enum bug keys
module.exports = [
  'constructor',
  'hasOwnProperty',
  'isPrototypeOf',
  'propertyIsEnumerable',
  'toLocaleString',
  'toString',
  'valueOf'
];


/***/ }),

/***/ "7b0b":
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__("1d80");

// `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject
module.exports = function (argument) {
  return Object(requireObjectCoercible(argument));
};


/***/ }),

/***/ "7c73":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var defineProperties = __webpack_require__("37e8");
var enumBugKeys = __webpack_require__("7839");
var hiddenKeys = __webpack_require__("d012");
var html = __webpack_require__("1be4");
var documentCreateElement = __webpack_require__("cc12");
var sharedKey = __webpack_require__("f772");

var GT = '>';
var LT = '<';
var PROTOTYPE = 'prototype';
var SCRIPT = 'script';
var IE_PROTO = sharedKey('IE_PROTO');

var EmptyConstructor = function () { /* empty */ };

var scriptTag = function (content) {
  return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function (activeXDocument) {
  activeXDocument.write(scriptTag(''));
  activeXDocument.close();
  var temp = activeXDocument.parentWindow.Object;
  activeXDocument = null; // avoid memory leak
  return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function () {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = documentCreateElement('iframe');
  var JS = 'java' + SCRIPT + ':';
  var iframeDocument;
  iframe.style.display = 'none';
  html.appendChild(iframe);
  // https://github.com/zloirock/core-js/issues/475
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag('document.F=Object'));
  iframeDocument.close();
  return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function () {
  try {
    /* global ActiveXObject */
    activeXDocument = document.domain && new ActiveXObject('htmlfile');
  } catch (error) { /* ignore */ }
  NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
  var length = enumBugKeys.length;
  while (length--) delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};

hiddenKeys[IE_PROTO] = true;

// `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create
module.exports = Object.create || function create(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    // add "__proto__" for Object.getPrototypeOf polyfill
    result[IE_PROTO] = O;
  } else result = NullProtoObject();
  return Properties === undefined ? result : defineProperties(result, Properties);
};


/***/ }),

/***/ "7db0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $find = __webpack_require__("b727").find;
var addToUnscopables = __webpack_require__("44d2");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var FIND = 'find';
var SKIPS_HOLES = true;

var USES_TO_LENGTH = arrayMethodUsesToLength(FIND);

// Shouldn't skip holes
if (FIND in []) Array(1)[FIND](function () { SKIPS_HOLES = false; });

// `Array.prototype.find` method
// https://tc39.github.io/ecma262/#sec-array.prototype.find
$({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, {
  find: function find(callbackfn /* , that = undefined */) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND);


/***/ }),

/***/ "7dd0":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var createIteratorConstructor = __webpack_require__("9ed3");
var getPrototypeOf = __webpack_require__("e163");
var setPrototypeOf = __webpack_require__("d2bb");
var setToStringTag = __webpack_require__("d44e");
var createNonEnumerableProperty = __webpack_require__("9112");
var redefine = __webpack_require__("6eeb");
var wellKnownSymbol = __webpack_require__("b622");
var IS_PURE = __webpack_require__("c430");
var Iterators = __webpack_require__("3f8c");
var IteratorsCore = __webpack_require__("ae93");

var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR = wellKnownSymbol('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function () { return this; };

module.exports = function (Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
  createIteratorConstructor(IteratorConstructor, NAME, next);

  var getIterationMethod = function (KIND) {
    if (KIND === DEFAULT && defaultIterator) return defaultIterator;
    if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
    switch (KIND) {
      case KEYS: return function keys() { return new IteratorConstructor(this, KIND); };
      case VALUES: return function values() { return new IteratorConstructor(this, KIND); };
      case ENTRIES: return function entries() { return new IteratorConstructor(this, KIND); };
    } return function () { return new IteratorConstructor(this); };
  };

  var TO_STRING_TAG = NAME + ' Iterator';
  var INCORRECT_VALUES_NAME = false;
  var IterablePrototype = Iterable.prototype;
  var nativeIterator = IterablePrototype[ITERATOR]
    || IterablePrototype['@@iterator']
    || DEFAULT && IterablePrototype[DEFAULT];
  var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
  var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
  var CurrentIteratorPrototype, methods, KEY;

  // fix native
  if (anyNativeIterator) {
    CurrentIteratorPrototype = getPrototypeOf(anyNativeIterator.call(new Iterable()));
    if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
      if (!IS_PURE && getPrototypeOf(CurrentIteratorPrototype) !== IteratorPrototype) {
        if (setPrototypeOf) {
          setPrototypeOf(CurrentIteratorPrototype, IteratorPrototype);
        } else if (typeof CurrentIteratorPrototype[ITERATOR] != 'function') {
          createNonEnumerableProperty(CurrentIteratorPrototype, ITERATOR, returnThis);
        }
      }
      // Set @@toStringTag to native iterators
      setToStringTag(CurrentIteratorPrototype, TO_STRING_TAG, true, true);
      if (IS_PURE) Iterators[TO_STRING_TAG] = returnThis;
    }
  }

  // fix Array#{values, @@iterator}.name in V8 / FF
  if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
    INCORRECT_VALUES_NAME = true;
    defaultIterator = function values() { return nativeIterator.call(this); };
  }

  // define iterator
  if ((!IS_PURE || FORCED) && IterablePrototype[ITERATOR] !== defaultIterator) {
    createNonEnumerableProperty(IterablePrototype, ITERATOR, defaultIterator);
  }
  Iterators[NAME] = defaultIterator;

  // export additional methods
  if (DEFAULT) {
    methods = {
      values: getIterationMethod(VALUES),
      keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
      entries: getIterationMethod(ENTRIES)
    };
    if (FORCED) for (KEY in methods) {
      if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
        redefine(IterablePrototype, KEY, methods[KEY]);
      }
    } else $({ target: NAME, proto: true, forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME }, methods);
  }

  return methods;
};


/***/ }),

/***/ "7de4":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M9.816 11.5L7.038 4.785 4.261 11.5h5.555zm.62 1.5H3.641l-1.666 4.028H.312l5.789-14h1.875l5.789 14h-1.663L10.436 13zm7.55 2.279l.779-.779.707.707-2.265 2.265-2.193-2.265.707-.707.765.765V4.825c0-.042 0-.083.002-.123l-.77.77-.707-.707L17.207 2.5l2.265 2.265-.707.707-.782-.782c.002.043.003.089.003.135v10.454z\"/></svg>"

/***/ }),

/***/ "7def":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "7eec":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0C1 4.784 1.777 4 2.75 4c.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75C1.784 7.5 1 6.723 1 5.75zm6 9c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zm-6 0c0-.966.777-1.75 1.75-1.75.966 0 1.75.777 1.75 1.75 0 .966-.777 1.75-1.75 1.75-.966 0-1.75-.777-1.75-1.75z\"/></svg>"

/***/ }),

/***/ "7f9a":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var inspectSource = __webpack_require__("8925");

var WeakMap = global.WeakMap;

module.exports = typeof WeakMap === 'function' && /native code/.test(inspectSource(WeakMap));


/***/ }),

/***/ "8030":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "807d":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M4 2h12a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2zm8.38 9.262H7.62L10 5.506l2.38 5.756zm.532 1.285L14.34 16h1.426L10.804 4H9.196L4.234 16H5.66l1.428-3.453h5.824z\"/></svg>"

/***/ }),

/***/ "8151":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _isNativeReflectConstruct; });
/* harmony import */ var core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("d3b7");
/* harmony import */ var core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_to_string__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var core_js_modules_es_reflect_construct__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("4ae1");
/* harmony import */ var core_js_modules_es_reflect_construct__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_reflect_construct__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("25f0");
/* harmony import */ var core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_regexp_to_string__WEBPACK_IMPORTED_MODULE_2__);



function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

/***/ }),

/***/ "81d5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toObject = __webpack_require__("7b0b");
var toAbsoluteIndex = __webpack_require__("23cb");
var toLength = __webpack_require__("50c4");

// `Array.prototype.fill` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
module.exports = function fill(value /* , start = 0, end = @length */) {
  var O = toObject(this);
  var length = toLength(O.length);
  var argumentsLength = arguments.length;
  var index = toAbsoluteIndex(argumentsLength > 1 ? arguments[1] : undefined, length);
  var end = argumentsLength > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);
  while (endPos > index) O[index++] = value;
  return O;
};


/***/ }),

/***/ "825a":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");

module.exports = function (it) {
  if (!isObject(it)) {
    throw TypeError(String(it) + ' is not an object');
  } return it;
};


/***/ }),

/***/ "82f8":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $includes = __webpack_require__("4d64").includes;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.includes
exportTypedArrayMethod('includes', function includes(searchElement /* , fromIndex */) {
  return $includes(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "83ab":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

// Thank's IE8 for his funny defineProperty
module.exports = !fails(function () {
  return Object.defineProperty({}, 1, { get: function () { return 7; } })[1] != 7;
});


/***/ }),

/***/ "8418":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toPrimitive = __webpack_require__("c04e");
var definePropertyModule = __webpack_require__("9bf2");
var createPropertyDescriptor = __webpack_require__("5c6c");

module.exports = function (object, key, value) {
  var propertyKey = toPrimitive(key);
  if (propertyKey in object) definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));
  else object[propertyKey] = value;
};


/***/ }),

/***/ "841c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fixRegExpWellKnownSymbolLogic = __webpack_require__("d784");
var anObject = __webpack_require__("825a");
var requireObjectCoercible = __webpack_require__("1d80");
var sameValue = __webpack_require__("129f");
var regExpExec = __webpack_require__("14c3");

// @@search logic
fixRegExpWellKnownSymbolLogic('search', 1, function (SEARCH, nativeSearch, maybeCallNative) {
  return [
    // `String.prototype.search` method
    // https://tc39.github.io/ecma262/#sec-string.prototype.search
    function search(regexp) {
      var O = requireObjectCoercible(this);
      var searcher = regexp == undefined ? undefined : regexp[SEARCH];
      return searcher !== undefined ? searcher.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
    },
    // `RegExp.prototype[@@search]` method
    // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
    function (regexp) {
      var res = maybeCallNative(nativeSearch, regexp, this);
      if (res.done) return res.value;

      var rx = anObject(regexp);
      var S = String(this);

      var previousLastIndex = rx.lastIndex;
      if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
      var result = regExpExec(rx, S);
      if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
      return result === null ? -1 : result.index;
    }
  ];
});


/***/ }),

/***/ "857a":
/***/ (function(module, exports, __webpack_require__) {

var requireObjectCoercible = __webpack_require__("1d80");

var quot = /"/g;

// B.2.3.2.1 CreateHTML(string, tag, attribute, value)
// https://tc39.github.io/ecma262/#sec-createhtml
module.exports = function (string, tag, attribute, value) {
  var S = String(requireObjectCoercible(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};


/***/ }),

/***/ "861d":
/***/ (function(module, exports) {

module.exports = function (it) {
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};


/***/ }),

/***/ "8708":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M10.187 17H5.773c-.637 0-1.092-.138-1.364-.415-.273-.277-.409-.718-.409-1.323V4.738c0-.617.14-1.062.419-1.332.279-.27.73-.406 1.354-.406h4.68c.69 0 1.288.041 1.793.124.506.083.96.242 1.36.478.341.197.644.447.906.75a3.262 3.262 0 0 1 .808 2.162c0 1.401-.722 2.426-2.167 3.075C15.05 10.175 16 11.315 16 13.01a3.756 3.756 0 0 1-2.296 3.504 6.1 6.1 0 0 1-1.517.377c-.571.073-1.238.11-2 .11zm-.217-6.217H7v4.087h3.069c1.977 0 2.965-.69 2.965-2.072 0-.707-.256-1.22-.768-1.537-.512-.319-1.277-.478-2.296-.478zM7 5.13v3.619h2.606c.729 0 1.292-.067 1.69-.2a1.6 1.6 0 0 0 .91-.765c.165-.267.247-.566.247-.897 0-.707-.26-1.176-.778-1.409-.519-.232-1.31-.348-2.375-.348H7z\"/></svg>"

/***/ }),

/***/ "875d":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M8.636 9.531l-2.758 3.94a.5.5 0 0 0 .122.696l3.224 2.284h1.314l2.636-3.736L8.636 9.53zm.288 8.451L5.14 15.396a2 2 0 0 1-.491-2.786l6.673-9.53a2 2 0 0 1 2.785-.49l3.742 2.62a2 2 0 0 1 .491 2.785l-7.269 10.053-2.147-.066z\"/><path d=\"M4 18h5.523v-1H4zm-2 0h1v-1H2z\"/></svg>"

/***/ }),

/***/ "8875":
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// addapted from the document.currentScript polyfill by Adam Miller
// MIT license
// source: https://github.com/amiller-gh/currentScript-polyfill

// added support for Firefox https://bugzilla.mozilla.org/show_bug.cgi?id=1620505

(function (root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
}(typeof self !== 'undefined' ? self : this, function () {
  function getCurrentScript () {
    var descriptor = Object.getOwnPropertyDescriptor(document, 'currentScript')
    // for chrome
    if (!descriptor && 'currentScript' in document && document.currentScript) {
      return document.currentScript
    }

    // for other browsers with native support for currentScript
    if (descriptor && descriptor.get !== getCurrentScript && document.currentScript) {
      return document.currentScript
    }
  
    // IE 8-10 support script readyState
    // IE 11+ & Firefox support stack trace
    try {
      throw new Error();
    }
    catch (err) {
      // Find the second match for the "at" string to get file src url from stack.
      var ieStackRegExp = /.*at [^(]*\((.*):(.+):(.+)\)$/ig,
        ffStackRegExp = /@([^@]*):(\d+):(\d+)\s*$/ig,
        stackDetails = ieStackRegExp.exec(err.stack) || ffStackRegExp.exec(err.stack),
        scriptLocation = (stackDetails && stackDetails[1]) || false,
        line = (stackDetails && stackDetails[2]) || false,
        currentLocation = document.location.href.replace(document.location.hash, ''),
        pageSource,
        inlineScriptSourceRegExp,
        inlineScriptSource,
        scripts = document.getElementsByTagName('script'); // Live NodeList collection
  
      if (scriptLocation === currentLocation) {
        pageSource = document.documentElement.outerHTML;
        inlineScriptSourceRegExp = new RegExp('(?:[^\\n]+?\\n){0,' + (line - 2) + '}[^<]*<script>([\\d\\D]*?)<\\/script>[\\d\\D]*', 'i');
        inlineScriptSource = pageSource.replace(inlineScriptSourceRegExp, '$1').trim();
      }
  
      for (var i = 0; i < scripts.length; i++) {
        // If ready state is interactive, return the script tag
        if (scripts[i].readyState === 'interactive') {
          return scripts[i];
        }
  
        // If src matches, return the script tag
        if (scripts[i].src === scriptLocation) {
          return scripts[i];
        }
  
        // If inline source matches, return the script tag
        if (
          scriptLocation === currentLocation &&
          scripts[i].innerHTML &&
          scripts[i].innerHTML.trim() === inlineScriptSource
        ) {
          return scripts[i];
        }
      }
  
      // If no match, return null
      return null;
    }
  };

  return getCurrentScript
}));


/***/ }),

/***/ "8925":
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__("c6cd");

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store.inspectSource != 'function') {
  store.inspectSource = function (it) {
    return functionToString.call(it);
  };
}

module.exports = store.inspectSource;


/***/ }),

/***/ "8a79":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var toLength = __webpack_require__("50c4");
var notARegExp = __webpack_require__("5a34");
var requireObjectCoercible = __webpack_require__("1d80");
var correctIsRegExpLogic = __webpack_require__("ab13");
var IS_PURE = __webpack_require__("c430");

var nativeEndsWith = ''.endsWith;
var min = Math.min;

var CORRECT_IS_REGEXP_LOGIC = correctIsRegExpLogic('endsWith');
// https://github.com/zloirock/core-js/pull/702
var MDN_POLYFILL_BUG = !IS_PURE && !CORRECT_IS_REGEXP_LOGIC && !!function () {
  var descriptor = getOwnPropertyDescriptor(String.prototype, 'endsWith');
  return descriptor && !descriptor.writable;
}();

// `String.prototype.endsWith` method
// https://tc39.github.io/ecma262/#sec-string.prototype.endswith
$({ target: 'String', proto: true, forced: !MDN_POLYFILL_BUG && !CORRECT_IS_REGEXP_LOGIC }, {
  endsWith: function endsWith(searchString /* , endPosition = @length */) {
    var that = String(requireObjectCoercible(this));
    notARegExp(searchString);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : min(toLength(endPosition), len);
    var search = String(searchString);
    return nativeEndsWith
      ? nativeEndsWith.call(that, search, end)
      : that.slice(end - search.length, end) === search;
  }
});


/***/ }),

/***/ "8aa5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var charAt = __webpack_require__("6547").charAt;

// `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex
module.exports = function (S, index, unicode) {
  return index + (unicode ? charAt(S, index).length : 1);
};


/***/ }),

/***/ "8aa7":
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable no-new */
var global = __webpack_require__("da84");
var fails = __webpack_require__("d039");
var checkCorrectnessOfIteration = __webpack_require__("1c7e");
var NATIVE_ARRAY_BUFFER_VIEWS = __webpack_require__("ebb5").NATIVE_ARRAY_BUFFER_VIEWS;

var ArrayBuffer = global.ArrayBuffer;
var Int8Array = global.Int8Array;

module.exports = !NATIVE_ARRAY_BUFFER_VIEWS || !fails(function () {
  Int8Array(1);
}) || !fails(function () {
  new Int8Array(-1);
}) || !checkCorrectnessOfIteration(function (iterable) {
  new Int8Array();
  new Int8Array(null);
  new Int8Array(1.5);
  new Int8Array(iterable);
}, true) || fails(function () {
  // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
  return new Int8Array(new ArrayBuffer(2), 1, undefined).length !== 1;
});


/***/ }),

/***/ "8b56":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "8de7":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path class=\"ck-icon__fill\" d=\"M16.935 5.328a2 2 0 0 1 0 2.829l-7.778 7.778a2 2 0 0 1-2.829 0L3.5 13.107a1.999 1.999 0 1 1 2.828-2.829l.707.707a1 1 0 0 0 1.414 0l5.658-5.657a2 2 0 0 1 2.828 0z\"/><path d=\"M14.814 6.035L8.448 12.4a1 1 0 0 1-1.414 0l-1.413-1.415A1 1 0 1 0 4.207 12.4l2.829 2.829a1 1 0 0 0 1.414 0l7.778-7.778a1 1 0 1 0-1.414-1.415z\"/></svg>"

/***/ }),

/***/ "8ef8":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M11.591 10.177l4.243 4.242a1 1 0 0 1-1.415 1.415l-4.242-4.243-4.243 4.243a1 1 0 0 1-1.414-1.415l4.243-4.242L4.52 5.934A1 1 0 0 1 5.934 4.52l4.243 4.243 4.242-4.243a1 1 0 1 1 1.415 1.414l-4.243 4.243z\"/></svg>"

/***/ }),

/***/ "90e3":
/***/ (function(module, exports) {

var id = 0;
var postfix = Math.random();

module.exports = function (key) {
  return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};


/***/ }),

/***/ "9112":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var definePropertyModule = __webpack_require__("9bf2");
var createPropertyDescriptor = __webpack_require__("5c6c");

module.exports = DESCRIPTORS ? function (object, key, value) {
  return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};


/***/ }),

/***/ "920b":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _inherits; });
/* harmony import */ var _setPrototypeOf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("0de3");

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) Object(_setPrototypeOf__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(subClass, superClass);
}

/***/ }),

/***/ "9263":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var regexpFlags = __webpack_require__("ad6d");
var stickyHelpers = __webpack_require__("9f7f");

var nativeExec = RegExp.prototype.exec;
// This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.
var nativeReplace = String.prototype.replace;

var patchedExec = nativeExec;

var UPDATES_LAST_INDEX_WRONG = (function () {
  var re1 = /a/;
  var re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1.lastIndex !== 0 || re2.lastIndex !== 0;
})();

var UNSUPPORTED_Y = stickyHelpers.UNSUPPORTED_Y || stickyHelpers.BROKEN_CARET;

// nonparticipating capturing group, copied from es5-shim's String#split patch.
var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;

var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED || UNSUPPORTED_Y;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;
    var sticky = UNSUPPORTED_Y && re.sticky;
    var flags = regexpFlags.call(re);
    var source = re.source;
    var charsAdded = 0;
    var strCopy = str;

    if (sticky) {
      flags = flags.replace('y', '');
      if (flags.indexOf('g') === -1) {
        flags += 'g';
      }

      strCopy = String(str).slice(re.lastIndex);
      // Support anchored sticky behavior.
      if (re.lastIndex > 0 && (!re.multiline || re.multiline && str[re.lastIndex - 1] !== '\n')) {
        source = '(?: ' + source + ')';
        strCopy = ' ' + strCopy;
        charsAdded++;
      }
      // ^(? + rx + ) is needed, in combination with some str slicing, to
      // simulate the 'y' flag.
      reCopy = new RegExp('^(?:' + source + ')', flags);
    }

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + source + '$(?!\\s)', flags);
    }
    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re.lastIndex;

    match = nativeExec.call(sticky ? reCopy : re, strCopy);

    if (sticky) {
      if (match) {
        match.input = match.input.slice(charsAdded);
        match[0] = match[0].slice(charsAdded);
        match.index = re.lastIndex;
        re.lastIndex += match[0].length;
      } else re.lastIndex = 0;
    } else if (UPDATES_LAST_INDEX_WRONG && match) {
      re.lastIndex = re.global ? match.index + match[0].length : lastIndex;
    }
    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;


/***/ }),

/***/ "92a6":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ _createSuper; });

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.reflect.construct.js
var es_reflect_construct = __webpack_require__("4ae1");

// EXTERNAL MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
var getPrototypeOf = __webpack_require__("f20d");

// EXTERNAL MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
var isNativeReflectConstruct = __webpack_require__("8151");

// EXTERNAL MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__("0122");

// EXTERNAL MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
var assertThisInitialized = __webpack_require__("2c4c");

// CONCATENATED MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js


function _possibleConstructorReturn(self, call) {
  if (call && (Object(esm_typeof["a" /* default */])(call) === "object" || typeof call === "function")) {
    return call;
  }

  return Object(assertThisInitialized["a" /* default */])(self);
}
// CONCATENATED MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/createSuper.js




function _createSuper(Derived) {
  var hasNativeReflectConstruct = Object(isNativeReflectConstruct["a" /* default */])();
  return function _createSuperInternal() {
    var Super = Object(getPrototypeOf["a" /* default */])(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = Object(getPrototypeOf["a" /* default */])(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

/***/ }),

/***/ "92bd":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "94ca":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

var replacement = /#|\.prototype\./;

var isForced = function (feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true
    : value == NATIVE ? false
    : typeof detection == 'function' ? fails(detection)
    : !!detection;
};

var normalize = isForced.normalize = function (string) {
  return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced.data = {};
var NATIVE = isForced.NATIVE = 'N';
var POLYFILL = isForced.POLYFILL = 'P';

module.exports = isForced;


/***/ }),

/***/ "96cf":
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
   true ? module.exports : undefined
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}


/***/ }),

/***/ "99af":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var fails = __webpack_require__("d039");
var isArray = __webpack_require__("e8b5");
var isObject = __webpack_require__("861d");
var toObject = __webpack_require__("7b0b");
var toLength = __webpack_require__("50c4");
var createProperty = __webpack_require__("8418");
var arraySpeciesCreate = __webpack_require__("65f0");
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
var wellKnownSymbol = __webpack_require__("b622");
var V8_VERSION = __webpack_require__("2d00");

var IS_CONCAT_SPREADABLE = wellKnownSymbol('isConcatSpreadable');
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_INDEX_EXCEEDED = 'Maximum allowed index exceeded';

// We can't use this feature detection in V8 since it causes
// deoptimization and serious performance degradation
// https://github.com/zloirock/core-js/issues/679
var IS_CONCAT_SPREADABLE_SUPPORT = V8_VERSION >= 51 || !fails(function () {
  var array = [];
  array[IS_CONCAT_SPREADABLE] = false;
  return array.concat()[0] !== array;
});

var SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('concat');

var isConcatSpreadable = function (O) {
  if (!isObject(O)) return false;
  var spreadable = O[IS_CONCAT_SPREADABLE];
  return spreadable !== undefined ? !!spreadable : isArray(O);
};

var FORCED = !IS_CONCAT_SPREADABLE_SUPPORT || !SPECIES_SUPPORT;

// `Array.prototype.concat` method
// https://tc39.github.io/ecma262/#sec-array.prototype.concat
// with adding support of @@isConcatSpreadable and @@species
$({ target: 'Array', proto: true, forced: FORCED }, {
  concat: function concat(arg) { // eslint-disable-line no-unused-vars
    var O = toObject(this);
    var A = arraySpeciesCreate(O, 0);
    var n = 0;
    var i, k, length, len, E;
    for (i = -1, length = arguments.length; i < length; i++) {
      E = i === -1 ? O : arguments[i];
      if (isConcatSpreadable(E)) {
        len = toLength(E.length);
        if (n + len > MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        for (k = 0; k < len; k++, n++) if (k in E) createProperty(A, n, E[k]);
      } else {
        if (n >= MAX_SAFE_INTEGER) throw TypeError(MAXIMUM_ALLOWED_INDEX_EXCEEDED);
        createProperty(A, n++, E);
      }
    }
    A.length = n;
    return A;
  }
});


/***/ }),

/***/ "9a8c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $copyWithin = __webpack_require__("145e");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.copyWithin` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.copywithin
exportTypedArrayMethod('copyWithin', function copyWithin(target, start /* , end */) {
  return $copyWithin.call(aTypedArray(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
});


/***/ }),

/***/ "9bdd":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");

// call something on iterator step with safe closing on error
module.exports = function (iterator, fn, value, ENTRIES) {
  try {
    return ENTRIES ? fn(anObject(value)[0], value[1]) : fn(value);
  // 7.4.6 IteratorClose(iterator, completion)
  } catch (error) {
    var returnMethod = iterator['return'];
    if (returnMethod !== undefined) anObject(returnMethod.call(iterator));
    throw error;
  }
};


/***/ }),

/***/ "9bf2":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var IE8_DOM_DEFINE = __webpack_require__("0cfb");
var anObject = __webpack_require__("825a");
var toPrimitive = __webpack_require__("c04e");

var nativeDefineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
exports.f = DESCRIPTORS ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return nativeDefineProperty(O, P, Attributes);
  } catch (error) { /* empty */ }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};


/***/ }),

/***/ "9ed3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var IteratorPrototype = __webpack_require__("ae93").IteratorPrototype;
var create = __webpack_require__("7c73");
var createPropertyDescriptor = __webpack_require__("5c6c");
var setToStringTag = __webpack_require__("d44e");
var Iterators = __webpack_require__("3f8c");

var returnThis = function () { return this; };

module.exports = function (IteratorConstructor, NAME, next) {
  var TO_STRING_TAG = NAME + ' Iterator';
  IteratorConstructor.prototype = create(IteratorPrototype, { next: createPropertyDescriptor(1, next) });
  setToStringTag(IteratorConstructor, TO_STRING_TAG, false, true);
  Iterators[TO_STRING_TAG] = returnThis;
  return IteratorConstructor;
};


/***/ }),

/***/ "9f7f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__("d039");

// babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError,
// so we use an intermediate function.
function RE(s, f) {
  return RegExp(s, f);
}

exports.UNSUPPORTED_Y = fails(function () {
  // babel-minify transpiles RegExp('a', 'y') -> /a/y and it causes SyntaxError
  var re = RE('a', 'y');
  re.lastIndex = 2;
  return re.exec('abcd') != null;
});

exports.BROKEN_CARET = fails(function () {
  // https://bugzilla.mozilla.org/show_bug.cgi?id=773687
  var re = RE('^r', 'gy');
  re.lastIndex = 2;
  return re.exec('str') != null;
});


/***/ }),

/***/ "a078":
/***/ (function(module, exports, __webpack_require__) {

var toObject = __webpack_require__("7b0b");
var toLength = __webpack_require__("50c4");
var getIteratorMethod = __webpack_require__("35a1");
var isArrayIteratorMethod = __webpack_require__("e95a");
var bind = __webpack_require__("0366");
var aTypedArrayConstructor = __webpack_require__("ebb5").aTypedArrayConstructor;

module.exports = function from(source /* , mapfn, thisArg */) {
  var O = toObject(source);
  var argumentsLength = arguments.length;
  var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
  var mapping = mapfn !== undefined;
  var iteratorMethod = getIteratorMethod(O);
  var i, length, result, step, iterator, next;
  if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
    iterator = iteratorMethod.call(O);
    next = iterator.next;
    O = [];
    while (!(step = next.call(iterator)).done) {
      O.push(step.value);
    }
  }
  if (mapping && argumentsLength > 2) {
    mapfn = bind(mapfn, arguments[2], 2);
  }
  length = toLength(O.length);
  result = new (aTypedArrayConstructor(this))(length);
  for (i = 0; length > i; i++) {
    result[i] = mapping ? mapfn(O[i], i) : O[i];
  }
  return result;
};


/***/ }),

/***/ "a15b":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var IndexedObject = __webpack_require__("44ad");
var toIndexedObject = __webpack_require__("fc6a");
var arrayMethodIsStrict = __webpack_require__("a640");

var nativeJoin = [].join;

var ES3_STRINGS = IndexedObject != Object;
var STRICT_METHOD = arrayMethodIsStrict('join', ',');

// `Array.prototype.join` method
// https://tc39.github.io/ecma262/#sec-array.prototype.join
$({ target: 'Array', proto: true, forced: ES3_STRINGS || !STRICT_METHOD }, {
  join: function join(separator) {
    return nativeJoin.call(toIndexedObject(this), separator === undefined ? ',' : separator);
  }
});


/***/ }),

/***/ "a2bf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isArray = __webpack_require__("e8b5");
var toLength = __webpack_require__("50c4");
var bind = __webpack_require__("0366");

// `FlattenIntoArray` abstract operation
// https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray
var flattenIntoArray = function (target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? bind(mapper, thisArg, 3) : false;
  var element;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];

      if (depth > 0 && isArray(element)) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1FFFFFFFFFFFFF) throw TypeError('Exceed the acceptable array length');
        target[targetIndex] = element;
      }

      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
};

module.exports = flattenIntoArray;


/***/ }),

/***/ "a434":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var toAbsoluteIndex = __webpack_require__("23cb");
var toInteger = __webpack_require__("a691");
var toLength = __webpack_require__("50c4");
var toObject = __webpack_require__("7b0b");
var arraySpeciesCreate = __webpack_require__("65f0");
var createProperty = __webpack_require__("8418");
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('splice');
var USES_TO_LENGTH = arrayMethodUsesToLength('splice', { ACCESSORS: true, 0: 0, 1: 2 });

var max = Math.max;
var min = Math.min;
var MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;
var MAXIMUM_ALLOWED_LENGTH_EXCEEDED = 'Maximum allowed length exceeded';

// `Array.prototype.splice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.splice
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  splice: function splice(start, deleteCount /* , ...items */) {
    var O = toObject(this);
    var len = toLength(O.length);
    var actualStart = toAbsoluteIndex(start, len);
    var argumentsLength = arguments.length;
    var insertCount, actualDeleteCount, A, k, from, to;
    if (argumentsLength === 0) {
      insertCount = actualDeleteCount = 0;
    } else if (argumentsLength === 1) {
      insertCount = 0;
      actualDeleteCount = len - actualStart;
    } else {
      insertCount = argumentsLength - 2;
      actualDeleteCount = min(max(toInteger(deleteCount), 0), len - actualStart);
    }
    if (len + insertCount - actualDeleteCount > MAX_SAFE_INTEGER) {
      throw TypeError(MAXIMUM_ALLOWED_LENGTH_EXCEEDED);
    }
    A = arraySpeciesCreate(O, actualDeleteCount);
    for (k = 0; k < actualDeleteCount; k++) {
      from = actualStart + k;
      if (from in O) createProperty(A, k, O[from]);
    }
    A.length = actualDeleteCount;
    if (insertCount < actualDeleteCount) {
      for (k = actualStart; k < len - actualDeleteCount; k++) {
        from = k + actualDeleteCount;
        to = k + insertCount;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
      for (k = len; k > len - actualDeleteCount + insertCount; k--) delete O[k - 1];
    } else if (insertCount > actualDeleteCount) {
      for (k = len - actualDeleteCount; k > actualStart; k--) {
        from = k + actualDeleteCount - 1;
        to = k + insertCount - 1;
        if (from in O) O[to] = O[from];
        else delete O[to];
      }
    }
    for (k = 0; k < insertCount; k++) {
      O[k + actualStart] = arguments[k + 2];
    }
    O.length = len - actualDeleteCount + insertCount;
    return A;
  }
});


/***/ }),

/***/ "a4d3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var global = __webpack_require__("da84");
var getBuiltIn = __webpack_require__("d066");
var IS_PURE = __webpack_require__("c430");
var DESCRIPTORS = __webpack_require__("83ab");
var NATIVE_SYMBOL = __webpack_require__("4930");
var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");
var fails = __webpack_require__("d039");
var has = __webpack_require__("5135");
var isArray = __webpack_require__("e8b5");
var isObject = __webpack_require__("861d");
var anObject = __webpack_require__("825a");
var toObject = __webpack_require__("7b0b");
var toIndexedObject = __webpack_require__("fc6a");
var toPrimitive = __webpack_require__("c04e");
var createPropertyDescriptor = __webpack_require__("5c6c");
var nativeObjectCreate = __webpack_require__("7c73");
var objectKeys = __webpack_require__("df75");
var getOwnPropertyNamesModule = __webpack_require__("241c");
var getOwnPropertyNamesExternal = __webpack_require__("057f");
var getOwnPropertySymbolsModule = __webpack_require__("7418");
var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
var definePropertyModule = __webpack_require__("9bf2");
var propertyIsEnumerableModule = __webpack_require__("d1e7");
var createNonEnumerableProperty = __webpack_require__("9112");
var redefine = __webpack_require__("6eeb");
var shared = __webpack_require__("5692");
var sharedKey = __webpack_require__("f772");
var hiddenKeys = __webpack_require__("d012");
var uid = __webpack_require__("90e3");
var wellKnownSymbol = __webpack_require__("b622");
var wrappedWellKnownSymbolModule = __webpack_require__("e538");
var defineWellKnownSymbol = __webpack_require__("746f");
var setToStringTag = __webpack_require__("d44e");
var InternalStateModule = __webpack_require__("69f3");
var $forEach = __webpack_require__("b727").forEach;

var HIDDEN = sharedKey('hidden');
var SYMBOL = 'Symbol';
var PROTOTYPE = 'prototype';
var TO_PRIMITIVE = wellKnownSymbol('toPrimitive');
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(SYMBOL);
var ObjectPrototype = Object[PROTOTYPE];
var $Symbol = global.Symbol;
var $stringify = getBuiltIn('JSON', 'stringify');
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyNames = getOwnPropertyNamesExternal.f;
var nativePropertyIsEnumerable = propertyIsEnumerableModule.f;
var AllSymbols = shared('symbols');
var ObjectPrototypeSymbols = shared('op-symbols');
var StringToSymbolRegistry = shared('string-to-symbol-registry');
var SymbolToStringRegistry = shared('symbol-to-string-registry');
var WellKnownSymbolsStore = shared('wks');
var QObject = global.QObject;
// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173
var USE_SETTER = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;

// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687
var setSymbolDescriptor = DESCRIPTORS && fails(function () {
  return nativeObjectCreate(nativeDefineProperty({}, 'a', {
    get: function () { return nativeDefineProperty(this, 'a', { value: 7 }).a; }
  })).a != 7;
}) ? function (O, P, Attributes) {
  var ObjectPrototypeDescriptor = nativeGetOwnPropertyDescriptor(ObjectPrototype, P);
  if (ObjectPrototypeDescriptor) delete ObjectPrototype[P];
  nativeDefineProperty(O, P, Attributes);
  if (ObjectPrototypeDescriptor && O !== ObjectPrototype) {
    nativeDefineProperty(ObjectPrototype, P, ObjectPrototypeDescriptor);
  }
} : nativeDefineProperty;

var wrap = function (tag, description) {
  var symbol = AllSymbols[tag] = nativeObjectCreate($Symbol[PROTOTYPE]);
  setInternalState(symbol, {
    type: SYMBOL,
    tag: tag,
    description: description
  });
  if (!DESCRIPTORS) symbol.description = description;
  return symbol;
};

var isSymbol = USE_SYMBOL_AS_UID ? function (it) {
  return typeof it == 'symbol';
} : function (it) {
  return Object(it) instanceof $Symbol;
};

var $defineProperty = function defineProperty(O, P, Attributes) {
  if (O === ObjectPrototype) $defineProperty(ObjectPrototypeSymbols, P, Attributes);
  anObject(O);
  var key = toPrimitive(P, true);
  anObject(Attributes);
  if (has(AllSymbols, key)) {
    if (!Attributes.enumerable) {
      if (!has(O, HIDDEN)) nativeDefineProperty(O, HIDDEN, createPropertyDescriptor(1, {}));
      O[HIDDEN][key] = true;
    } else {
      if (has(O, HIDDEN) && O[HIDDEN][key]) O[HIDDEN][key] = false;
      Attributes = nativeObjectCreate(Attributes, { enumerable: createPropertyDescriptor(0, false) });
    } return setSymbolDescriptor(O, key, Attributes);
  } return nativeDefineProperty(O, key, Attributes);
};

var $defineProperties = function defineProperties(O, Properties) {
  anObject(O);
  var properties = toIndexedObject(Properties);
  var keys = objectKeys(properties).concat($getOwnPropertySymbols(properties));
  $forEach(keys, function (key) {
    if (!DESCRIPTORS || $propertyIsEnumerable.call(properties, key)) $defineProperty(O, key, properties[key]);
  });
  return O;
};

var $create = function create(O, Properties) {
  return Properties === undefined ? nativeObjectCreate(O) : $defineProperties(nativeObjectCreate(O), Properties);
};

var $propertyIsEnumerable = function propertyIsEnumerable(V) {
  var P = toPrimitive(V, true);
  var enumerable = nativePropertyIsEnumerable.call(this, P);
  if (this === ObjectPrototype && has(AllSymbols, P) && !has(ObjectPrototypeSymbols, P)) return false;
  return enumerable || !has(this, P) || !has(AllSymbols, P) || has(this, HIDDEN) && this[HIDDEN][P] ? enumerable : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(O, P) {
  var it = toIndexedObject(O);
  var key = toPrimitive(P, true);
  if (it === ObjectPrototype && has(AllSymbols, key) && !has(ObjectPrototypeSymbols, key)) return;
  var descriptor = nativeGetOwnPropertyDescriptor(it, key);
  if (descriptor && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) {
    descriptor.enumerable = true;
  }
  return descriptor;
};

var $getOwnPropertyNames = function getOwnPropertyNames(O) {
  var names = nativeGetOwnPropertyNames(toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (!has(AllSymbols, key) && !has(hiddenKeys, key)) result.push(key);
  });
  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(O) {
  var IS_OBJECT_PROTOTYPE = O === ObjectPrototype;
  var names = nativeGetOwnPropertyNames(IS_OBJECT_PROTOTYPE ? ObjectPrototypeSymbols : toIndexedObject(O));
  var result = [];
  $forEach(names, function (key) {
    if (has(AllSymbols, key) && (!IS_OBJECT_PROTOTYPE || has(ObjectPrototype, key))) {
      result.push(AllSymbols[key]);
    }
  });
  return result;
};

// `Symbol` constructor
// https://tc39.github.io/ecma262/#sec-symbol-constructor
if (!NATIVE_SYMBOL) {
  $Symbol = function Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor');
    var description = !arguments.length || arguments[0] === undefined ? undefined : String(arguments[0]);
    var tag = uid(description);
    var setter = function (value) {
      if (this === ObjectPrototype) setter.call(ObjectPrototypeSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDescriptor(this, tag, createPropertyDescriptor(1, value));
    };
    if (DESCRIPTORS && USE_SETTER) setSymbolDescriptor(ObjectPrototype, tag, { configurable: true, set: setter });
    return wrap(tag, description);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return getInternalState(this).tag;
  });

  redefine($Symbol, 'withoutSetter', function (description) {
    return wrap(uid(description), description);
  });

  propertyIsEnumerableModule.f = $propertyIsEnumerable;
  definePropertyModule.f = $defineProperty;
  getOwnPropertyDescriptorModule.f = $getOwnPropertyDescriptor;
  getOwnPropertyNamesModule.f = getOwnPropertyNamesExternal.f = $getOwnPropertyNames;
  getOwnPropertySymbolsModule.f = $getOwnPropertySymbols;

  wrappedWellKnownSymbolModule.f = function (name) {
    return wrap(wellKnownSymbol(name), name);
  };

  if (DESCRIPTORS) {
    // https://github.com/tc39/proposal-Symbol-description
    nativeDefineProperty($Symbol[PROTOTYPE], 'description', {
      configurable: true,
      get: function description() {
        return getInternalState(this).description;
      }
    });
    if (!IS_PURE) {
      redefine(ObjectPrototype, 'propertyIsEnumerable', $propertyIsEnumerable, { unsafe: true });
    }
  }
}

$({ global: true, wrap: true, forced: !NATIVE_SYMBOL, sham: !NATIVE_SYMBOL }, {
  Symbol: $Symbol
});

$forEach(objectKeys(WellKnownSymbolsStore), function (name) {
  defineWellKnownSymbol(name);
});

$({ target: SYMBOL, stat: true, forced: !NATIVE_SYMBOL }, {
  // `Symbol.for` method
  // https://tc39.github.io/ecma262/#sec-symbol.for
  'for': function (key) {
    var string = String(key);
    if (has(StringToSymbolRegistry, string)) return StringToSymbolRegistry[string];
    var symbol = $Symbol(string);
    StringToSymbolRegistry[string] = symbol;
    SymbolToStringRegistry[symbol] = string;
    return symbol;
  },
  // `Symbol.keyFor` method
  // https://tc39.github.io/ecma262/#sec-symbol.keyfor
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol');
    if (has(SymbolToStringRegistry, sym)) return SymbolToStringRegistry[sym];
  },
  useSetter: function () { USE_SETTER = true; },
  useSimple: function () { USE_SETTER = false; }
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL, sham: !DESCRIPTORS }, {
  // `Object.create` method
  // https://tc39.github.io/ecma262/#sec-object.create
  create: $create,
  // `Object.defineProperty` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperty
  defineProperty: $defineProperty,
  // `Object.defineProperties` method
  // https://tc39.github.io/ecma262/#sec-object.defineproperties
  defineProperties: $defineProperties,
  // `Object.getOwnPropertyDescriptor` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptors
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor
});

$({ target: 'Object', stat: true, forced: !NATIVE_SYMBOL }, {
  // `Object.getOwnPropertyNames` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertynames
  getOwnPropertyNames: $getOwnPropertyNames,
  // `Object.getOwnPropertySymbols` method
  // https://tc39.github.io/ecma262/#sec-object.getownpropertysymbols
  getOwnPropertySymbols: $getOwnPropertySymbols
});

// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443
$({ target: 'Object', stat: true, forced: fails(function () { getOwnPropertySymbolsModule.f(1); }) }, {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return getOwnPropertySymbolsModule.f(toObject(it));
  }
});

// `JSON.stringify` method behavior with symbols
// https://tc39.github.io/ecma262/#sec-json.stringify
if ($stringify) {
  var FORCED_JSON_STRINGIFY = !NATIVE_SYMBOL || fails(function () {
    var symbol = $Symbol();
    // MS Edge converts symbol values to JSON as {}
    return $stringify([symbol]) != '[null]'
      // WebKit converts symbol values to JSON as null
      || $stringify({ a: symbol }) != '{}'
      // V8 throws on boxed symbols
      || $stringify(Object(symbol)) != '{}';
  });

  $({ target: 'JSON', stat: true, forced: FORCED_JSON_STRINGIFY }, {
    // eslint-disable-next-line no-unused-vars
    stringify: function stringify(it, replacer, space) {
      var args = [it];
      var index = 1;
      var $replacer;
      while (arguments.length > index) args.push(arguments[index++]);
      $replacer = replacer;
      if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined
      if (!isArray(replacer)) replacer = function (key, value) {
        if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
        if (!isSymbol(value)) return value;
      };
      args[1] = replacer;
      return $stringify.apply(null, args);
    }
  });
}

// `Symbol.prototype[@@toPrimitive]` method
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@toprimitive
if (!$Symbol[PROTOTYPE][TO_PRIMITIVE]) {
  createNonEnumerableProperty($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);
}
// `Symbol.prototype[@@toStringTag]` property
// https://tc39.github.io/ecma262/#sec-symbol.prototype-@@tostringtag
setToStringTag($Symbol, SYMBOL);

hiddenKeys[HIDDEN] = true;


/***/ }),

/***/ "a623":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $every = __webpack_require__("b727").every;
var arrayMethodIsStrict = __webpack_require__("a640");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var STRICT_METHOD = arrayMethodIsStrict('every');
var USES_TO_LENGTH = arrayMethodUsesToLength('every');

// `Array.prototype.every` method
// https://tc39.github.io/ecma262/#sec-array.prototype.every
$({ target: 'Array', proto: true, forced: !STRICT_METHOD || !USES_TO_LENGTH }, {
  every: function every(callbackfn /* , thisArg */) {
    return $every(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "a630":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var from = __webpack_require__("4df4");
var checkCorrectnessOfIteration = __webpack_require__("1c7e");

var INCORRECT_ITERATION = !checkCorrectnessOfIteration(function (iterable) {
  Array.from(iterable);
});

// `Array.from` method
// https://tc39.github.io/ecma262/#sec-array.from
$({ target: 'Array', stat: true, forced: INCORRECT_ITERATION }, {
  from: from
});


/***/ }),

/***/ "a640":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var fails = __webpack_require__("d039");

module.exports = function (METHOD_NAME, argument) {
  var method = [][METHOD_NAME];
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call,no-throw-literal
    method.call(null, argument || function () { throw 1; }, 1);
  });
};


/***/ }),

/***/ "a691":
/***/ (function(module, exports) {

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger
module.exports = function (argument) {
  return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};


/***/ }),

/***/ "a975":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $every = __webpack_require__("b727").every;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.every` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.every
exportTypedArrayMethod('every', function every(callbackfn /* , thisArg */) {
  return $every(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "a981":
/***/ (function(module, exports) {

module.exports = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';


/***/ }),

/***/ "a9e3":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var DESCRIPTORS = __webpack_require__("83ab");
var global = __webpack_require__("da84");
var isForced = __webpack_require__("94ca");
var redefine = __webpack_require__("6eeb");
var has = __webpack_require__("5135");
var classof = __webpack_require__("c6b6");
var inheritIfRequired = __webpack_require__("7156");
var toPrimitive = __webpack_require__("c04e");
var fails = __webpack_require__("d039");
var create = __webpack_require__("7c73");
var getOwnPropertyNames = __webpack_require__("241c").f;
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var defineProperty = __webpack_require__("9bf2").f;
var trim = __webpack_require__("58a8").trim;

var NUMBER = 'Number';
var NativeNumber = global[NUMBER];
var NumberPrototype = NativeNumber.prototype;

// Opera ~12 has broken Object#toString
var BROKEN_CLASSOF = classof(create(NumberPrototype)) == NUMBER;

// `ToNumber` abstract operation
// https://tc39.github.io/ecma262/#sec-tonumber
var toNumber = function (argument) {
  var it = toPrimitive(argument, false);
  var first, third, radix, maxCode, digits, length, index, code;
  if (typeof it == 'string' && it.length > 2) {
    it = trim(it);
    first = it.charCodeAt(0);
    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66: case 98: radix = 2; maxCode = 49; break; // fast equal of /^0b[01]+$/i
        case 79: case 111: radix = 8; maxCode = 55; break; // fast equal of /^0o[0-7]+$/i
        default: return +it;
      }
      digits = it.slice(2);
      length = digits.length;
      for (index = 0; index < length; index++) {
        code = digits.charCodeAt(index);
        // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols
        if (code < 48 || code > maxCode) return NaN;
      } return parseInt(digits, radix);
    }
  } return +it;
};

// `Number` constructor
// https://tc39.github.io/ecma262/#sec-number-constructor
if (isForced(NUMBER, !NativeNumber(' 0o1') || !NativeNumber('0b1') || NativeNumber('+0x1'))) {
  var NumberWrapper = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var dummy = this;
    return dummy instanceof NumberWrapper
      // check on 1..constructor(foo) case
      && (BROKEN_CLASSOF ? fails(function () { NumberPrototype.valueOf.call(dummy); }) : classof(dummy) != NUMBER)
        ? inheritIfRequired(new NativeNumber(toNumber(it)), dummy, NumberWrapper) : toNumber(it);
  };
  for (var keys = DESCRIPTORS ? getOwnPropertyNames(NativeNumber) : (
    // ES3:
    'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' +
    // ES2015 (in case, if modules with ES2015 Number statics required before):
    'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' +
    'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger'
  ).split(','), j = 0, key; keys.length > j; j++) {
    if (has(NativeNumber, key = keys[j]) && !has(NumberWrapper, key)) {
      defineProperty(NumberWrapper, key, getOwnPropertyDescriptor(NativeNumber, key));
    }
  }
  NumberWrapper.prototype = NumberPrototype;
  NumberPrototype.constructor = NumberWrapper;
  redefine(global, NUMBER, NumberWrapper);
}


/***/ }),

/***/ "ab13":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

var MATCH = wellKnownSymbol('match');

module.exports = function (METHOD_NAME) {
  var regexp = /./;
  try {
    '/./'[METHOD_NAME](regexp);
  } catch (e) {
    try {
      regexp[MATCH] = false;
      return '/./'[METHOD_NAME](regexp);
    } catch (f) { /* empty */ }
  } return false;
};


/***/ }),

/***/ "ac1f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var exec = __webpack_require__("9263");

$({ target: 'RegExp', proto: true, forced: /./.exec !== exec }, {
  exec: exec
});


/***/ }),

/***/ "acac":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var redefineAll = __webpack_require__("e2cc");
var getWeakData = __webpack_require__("f183").getWeakData;
var anObject = __webpack_require__("825a");
var isObject = __webpack_require__("861d");
var anInstance = __webpack_require__("19aa");
var iterate = __webpack_require__("2266");
var ArrayIterationModule = __webpack_require__("b727");
var $has = __webpack_require__("5135");
var InternalStateModule = __webpack_require__("69f3");

var setInternalState = InternalStateModule.set;
var internalStateGetterFor = InternalStateModule.getterFor;
var find = ArrayIterationModule.find;
var findIndex = ArrayIterationModule.findIndex;
var id = 0;

// fallback for uncaught frozen keys
var uncaughtFrozenStore = function (store) {
  return store.frozen || (store.frozen = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function () {
  this.entries = [];
};

var findUncaughtFrozen = function (store, key) {
  return find(store.entries, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function (key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function (key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function (key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;
    else this.entries.push([key, value]);
  },
  'delete': function (key) {
    var index = findIndex(this.entries, function (it) {
      return it[0] === key;
    });
    if (~index) this.entries.splice(index, 1);
    return !!~index;
  }
};

module.exports = {
  getConstructor: function (wrapper, CONSTRUCTOR_NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, CONSTRUCTOR_NAME);
      setInternalState(that, {
        type: CONSTRUCTOR_NAME,
        id: id++,
        frozen: undefined
      });
      if (iterable != undefined) iterate(iterable, that[ADDER], that, IS_MAP);
    });

    var getInternalState = internalStateGetterFor(CONSTRUCTOR_NAME);

    var define = function (that, key, value) {
      var state = getInternalState(that);
      var data = getWeakData(anObject(key), true);
      if (data === true) uncaughtFrozenStore(state).set(key, value);
      else data[state.id] = value;
      return that;
    };

    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function (key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state)['delete'](key);
        return data && $has(data, state.id) && delete data[state.id];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        var state = getInternalState(this);
        if (!isObject(key)) return false;
        var data = getWeakData(key);
        if (data === true) return uncaughtFrozenStore(state).has(key);
        return data && $has(data, state.id);
      }
    });

    redefineAll(C.prototype, IS_MAP ? {
      // 23.3.3.3 WeakMap.prototype.get(key)
      get: function get(key) {
        var state = getInternalState(this);
        if (isObject(key)) {
          var data = getWeakData(key);
          if (data === true) return uncaughtFrozenStore(state).get(key);
          return data ? data[state.id] : undefined;
        }
      },
      // 23.3.3.5 WeakMap.prototype.set(key, value)
      set: function set(key, value) {
        return define(this, key, value);
      }
    } : {
      // 23.4.3.1 WeakSet.prototype.add(value)
      add: function add(value) {
        return define(this, value, true);
      }
    });

    return C;
  }
};


/***/ }),

/***/ "ad6d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var anObject = __webpack_require__("825a");

// `RegExp.prototype.flags` getter implementation
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.dotAll) result += 's';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};


/***/ }),

/***/ "ae40":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var fails = __webpack_require__("d039");
var has = __webpack_require__("5135");

var defineProperty = Object.defineProperty;
var cache = {};

var thrower = function (it) { throw it; };

module.exports = function (METHOD_NAME, options) {
  if (has(cache, METHOD_NAME)) return cache[METHOD_NAME];
  if (!options) options = {};
  var method = [][METHOD_NAME];
  var ACCESSORS = has(options, 'ACCESSORS') ? options.ACCESSORS : false;
  var argument0 = has(options, 0) ? options[0] : thrower;
  var argument1 = has(options, 1) ? options[1] : undefined;

  return cache[METHOD_NAME] = !!method && !fails(function () {
    if (ACCESSORS && !DESCRIPTORS) return true;
    var O = { length: -1 };

    if (ACCESSORS) defineProperty(O, 1, { enumerable: true, get: thrower });
    else O[1] = 1;

    method.call(O, argument0, argument1);
  });
};


/***/ }),

/***/ "ae93":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var getPrototypeOf = __webpack_require__("e163");
var createNonEnumerableProperty = __webpack_require__("9112");
var has = __webpack_require__("5135");
var wellKnownSymbol = __webpack_require__("b622");
var IS_PURE = __webpack_require__("c430");

var ITERATOR = wellKnownSymbol('iterator');
var BUGGY_SAFARI_ITERATORS = false;

var returnThis = function () { return this; };

// `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
  arrayIterator = [].keys();
  // Safari 8 has buggy iterators w/o `next`
  if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS = true;
  else {
    PrototypeOfArrayIteratorPrototype = getPrototypeOf(getPrototypeOf(arrayIterator));
    if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype = PrototypeOfArrayIteratorPrototype;
  }
}

if (IteratorPrototype == undefined) IteratorPrototype = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if (!IS_PURE && !has(IteratorPrototype, ITERATOR)) {
  createNonEnumerableProperty(IteratorPrototype, ITERATOR, returnThis);
}

module.exports = {
  IteratorPrototype: IteratorPrototype,
  BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS
};


/***/ }),

/***/ "aeed":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "af03":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

// check the existence of a method, lowercase
// of a tag and escaping quotes in arguments
module.exports = function (METHOD_NAME) {
  return fails(function () {
    var test = ''[METHOD_NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  });
};


/***/ }),

/***/ "b041":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
var classof = __webpack_require__("f5df");

// `Object.prototype.toString` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
module.exports = TO_STRING_TAG_SUPPORT ? {}.toString : function toString() {
  return '[object ' + classof(this) + ']';
};


/***/ }),

/***/ "b0c0":
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__("83ab");
var defineProperty = __webpack_require__("9bf2").f;

var FunctionPrototype = Function.prototype;
var FunctionPrototypeToString = FunctionPrototype.toString;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name';

// Function instances `.name` property
// https://tc39.github.io/ecma262/#sec-function-instances-name
if (DESCRIPTORS && !(NAME in FunctionPrototype)) {
  defineProperty(FunctionPrototype, NAME, {
    configurable: true,
    get: function () {
      try {
        return FunctionPrototypeToString.call(this).match(nameRE)[1];
      } catch (error) {
        return '';
      }
    }
  });
}


/***/ }),

/***/ "b0d6":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "b39a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var global = __webpack_require__("da84");
var ArrayBufferViewCore = __webpack_require__("ebb5");
var fails = __webpack_require__("d039");

var Int8Array = global.Int8Array;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $toLocaleString = [].toLocaleString;
var $slice = [].slice;

// iOS Safari 6.x fails here
var TO_LOCALE_STRING_BUG = !!Int8Array && fails(function () {
  $toLocaleString.call(new Int8Array(1));
});

var FORCED = fails(function () {
  return [1, 2].toLocaleString() != new Int8Array([1, 2]).toLocaleString();
}) || !fails(function () {
  Int8Array.prototype.toLocaleString.call([1, 2]);
});

// `%TypedArray%.prototype.toLocaleString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring
exportTypedArrayMethod('toLocaleString', function toLocaleString() {
  return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice.call(aTypedArray(this)) : aTypedArray(this), arguments);
}, FORCED);


/***/ }),

/***/ "b3ce":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "b575":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var getOwnPropertyDescriptor = __webpack_require__("06cf").f;
var classof = __webpack_require__("c6b6");
var macrotask = __webpack_require__("2cf4").set;
var IS_IOS = __webpack_require__("1cdc");

var MutationObserver = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var IS_NODE = classof(process) == 'process';
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

var flush, head, last, notify, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
  flush = function () {
    var parent, fn;
    if (IS_NODE && (parent = process.domain)) parent.exit();
    while (head) {
      fn = head.fn;
      head = head.next;
      try {
        fn();
      } catch (error) {
        if (head) notify();
        else last = undefined;
        throw error;
      }
    } last = undefined;
    if (parent) parent.enter();
  };

  // Node.js
  if (IS_NODE) {
    notify = function () {
      process.nextTick(flush);
    };
  // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
  } else if (MutationObserver && !IS_IOS) {
    toggle = true;
    node = document.createTextNode('');
    new MutationObserver(flush).observe(node, { characterData: true });
    notify = function () {
      node.data = toggle = !toggle;
    };
  // environments with maybe non-completely correct, but existent Promise
  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    promise = Promise.resolve(undefined);
    then = promise.then;
    notify = function () {
      then.call(promise, flush);
    };
  // for other environments - macrotask based on:
  // - setImmediate
  // - MessageChannel
  // - window.postMessag
  // - onreadystatechange
  // - setTimeout
  } else {
    notify = function () {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }
}

module.exports = queueMicrotask || function (fn) {
  var task = { fn: fn, next: undefined };
  if (last) last.next = task;
  if (!head) {
    head = task;
    notify();
  } last = task;
};


/***/ }),

/***/ "b622":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var shared = __webpack_require__("5692");
var has = __webpack_require__("5135");
var uid = __webpack_require__("90e3");
var NATIVE_SYMBOL = __webpack_require__("4930");
var USE_SYMBOL_AS_UID = __webpack_require__("fdbf");

var WellKnownSymbolsStore = shared('wks');
var Symbol = global.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol : Symbol && Symbol.withoutSetter || uid;

module.exports = function (name) {
  if (!has(WellKnownSymbolsStore, name)) {
    if (NATIVE_SYMBOL && has(Symbol, name)) WellKnownSymbolsStore[name] = Symbol[name];
    else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
  } return WellKnownSymbolsStore[name];
};


/***/ }),

/***/ "b64b":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var toObject = __webpack_require__("7b0b");
var nativeKeys = __webpack_require__("df75");
var fails = __webpack_require__("d039");

var FAILS_ON_PRIMITIVES = fails(function () { nativeKeys(1); });

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
$({ target: 'Object', stat: true, forced: FAILS_ON_PRIMITIVES }, {
  keys: function keys(it) {
    return nativeKeys(toObject(it));
  }
});


/***/ }),

/***/ "b727":
/***/ (function(module, exports, __webpack_require__) {

var bind = __webpack_require__("0366");
var IndexedObject = __webpack_require__("44ad");
var toObject = __webpack_require__("7b0b");
var toLength = __webpack_require__("50c4");
var arraySpeciesCreate = __webpack_require__("65f0");

var push = [].push;

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
var createMethod = function (TYPE) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  return function ($this, callbackfn, that, specificCreate) {
    var O = toObject($this);
    var self = IndexedObject(O);
    var boundFunction = bind(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var create = specificCreate || arraySpeciesCreate;
    var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var value, result;
    for (;length > index; index++) if (NO_HOLES || index in self) {
      value = self[index];
      result = boundFunction(value, index, O);
      if (TYPE) {
        if (IS_MAP) target[index] = result; // map
        else if (result) switch (TYPE) {
          case 3: return true;              // some
          case 5: return value;             // find
          case 6: return index;             // findIndex
          case 2: push.call(target, value); // filter
        } else if (IS_EVERY) return false;  // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
  };
};

module.exports = {
  // `Array.prototype.forEach` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
  forEach: createMethod(0),
  // `Array.prototype.map` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.map
  map: createMethod(1),
  // `Array.prototype.filter` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.filter
  filter: createMethod(2),
  // `Array.prototype.some` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.some
  some: createMethod(3),
  // `Array.prototype.every` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.every
  every: createMethod(4),
  // `Array.prototype.find` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.find
  find: createMethod(5),
  // `Array.prototype.findIndex` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
  findIndex: createMethod(6)
};


/***/ }),

/***/ "baa5":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var lastIndexOf = __webpack_require__("e58c");

// `Array.prototype.lastIndexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
$({ target: 'Array', proto: true, forced: lastIndexOf !== [].lastIndexOf }, {
  lastIndexOf: lastIndexOf
});


/***/ }),

/***/ "bb2f":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

module.exports = !fails(function () {
  return Object.isExtensible(Object.preventExtensions({}));
});


/***/ }),

/***/ "bcf9":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "bf19":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");

// `URL.prototype.toJSON` method
// https://url.spec.whatwg.org/#dom-url-tojson
$({ target: 'URL', proto: true, enumerable: true }, {
  toJSON: function toJSON() {
    return URL.prototype.toString.call(this);
  }
});


/***/ }),

/***/ "c04e":
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__("861d");

// `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function (input, PREFERRED_STRING) {
  if (!isObject(input)) return input;
  var fn, val;
  if (PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  if (typeof (fn = input.valueOf) == 'function' && !isObject(val = fn.call(input))) return val;
  if (!PREFERRED_STRING && typeof (fn = input.toString) == 'function' && !isObject(val = fn.call(input))) return val;
  throw TypeError("Can't convert object to primitive value");
};


/***/ }),

/***/ "c1ac":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $filter = __webpack_require__("b727").filter;
var speciesConstructor = __webpack_require__("4840");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var aTypedArrayConstructor = ArrayBufferViewCore.aTypedArrayConstructor;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.filter` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.filter
exportTypedArrayMethod('filter', function filter(callbackfn /* , thisArg */) {
  var list = $filter(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  var C = speciesConstructor(this, this.constructor);
  var index = 0;
  var length = list.length;
  var result = new (aTypedArrayConstructor(C))(length);
  while (length > index) result[index] = list[index++];
  return result;
});


/***/ }),

/***/ "c1f9":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var iterate = __webpack_require__("2266");
var createProperty = __webpack_require__("8418");

// `Object.fromEntries` method
// https://github.com/tc39/proposal-object-from-entries
$({ target: 'Object', stat: true }, {
  fromEntries: function fromEntries(iterable) {
    var obj = {};
    iterate(iterable, function (k, v) {
      createProperty(obj, k, v);
    }, undefined, true);
    return obj;
  }
});


/***/ }),

/***/ "c20d":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var trim = __webpack_require__("58a8").trim;
var whitespaces = __webpack_require__("5899");

var $parseInt = global.parseInt;
var hex = /^[+-]?0[Xx]/;
var FORCED = $parseInt(whitespaces + '08') !== 8 || $parseInt(whitespaces + '0x16') !== 22;

// `parseInt` method
// https://tc39.github.io/ecma262/#sec-parseint-string-radix
module.exports = FORCED ? function parseInt(string, radix) {
  var S = trim(String(string));
  return $parseInt(S, (radix >>> 0) || (hex.test(S) ? 16 : 10));
} : $parseInt;


/***/ }),

/***/ "c430":
/***/ (function(module, exports) {

module.exports = false;


/***/ }),

/***/ "c44c":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "c6b6":
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};


/***/ }),

/***/ "c6cd":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var setGlobal = __webpack_require__("ce4e");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || setGlobal(SHARED, {});

module.exports = store;


/***/ }),

/***/ "c6eb":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("5ea3");


/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && _freeGlobal_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

/* harmony default export */ __webpack_exports__["a"] = (nodeUtil);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("dd40")(module)))

/***/ }),

/***/ "c740":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $findIndex = __webpack_require__("b727").findIndex;
var addToUnscopables = __webpack_require__("44d2");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var FIND_INDEX = 'findIndex';
var SKIPS_HOLES = true;

var USES_TO_LENGTH = arrayMethodUsesToLength(FIND_INDEX);

// Shouldn't skip holes
if (FIND_INDEX in []) Array(1)[FIND_INDEX](function () { SKIPS_HOLES = false; });

// `Array.prototype.findIndex` method
// https://tc39.github.io/ecma262/#sec-array.prototype.findindex
$({ target: 'Array', proto: true, forced: SKIPS_HOLES || !USES_TO_LENGTH }, {
  findIndex: function findIndex(callbackfn /* , that = undefined */) {
    return $findIndex(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables(FIND_INDEX);


/***/ }),

/***/ "c7cb":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 10 8\" xmlns=\"http://www.w3.org/2000/svg\"><polyline points=\"8.05541992 0.263427734 8.05541992 4.23461914 1.28417969 4.23461914\" transform=\"translate(1,0)\"></polyline><line x1=\"0\" y1=\"4.21581031\" x2=\"2\" y2=\"2.17810059\" transform=\"translate(1, 0)\"></line><line x1=\"0\" y1=\"6.21581031\" x2=\"2\" y2=\"4.17810059\" transform=\"translate(2, 5.196955) scale(1, -1) translate(-1, -5.196955)\"></line></svg>\n"

/***/ }),

/***/ "c8ba":
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "c8d2":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");
var whitespaces = __webpack_require__("5899");

var non = '\u200B\u0085\u180E';

// check that a method works with the correct list
// of whitespaces and has a correct name
module.exports = function (METHOD_NAME) {
  return fails(function () {
    return !!whitespaces[METHOD_NAME]() || non[METHOD_NAME]() != non || whitespaces[METHOD_NAME].name !== METHOD_NAME;
  });
};


/***/ }),

/***/ "c975":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $indexOf = __webpack_require__("4d64").indexOf;
var arrayMethodIsStrict = __webpack_require__("a640");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var nativeIndexOf = [].indexOf;

var NEGATIVE_ZERO = !!nativeIndexOf && 1 / [1].indexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('indexOf');
var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

// `Array.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-array.prototype.indexof
$({ target: 'Array', proto: true, forced: NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH }, {
  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {
    return NEGATIVE_ZERO
      // convert -0 to +0
      ? nativeIndexOf.apply(this, arguments) || 0
      : $indexOf(this, searchElement, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "ca84":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("5135");
var toIndexedObject = __webpack_require__("fc6a");
var indexOf = __webpack_require__("4d64").indexOf;
var hiddenKeys = __webpack_require__("d012");

module.exports = function (object, names) {
  var O = toIndexedObject(object);
  var i = 0;
  var result = [];
  var key;
  for (key in O) !has(hiddenKeys, key) && has(O, key) && result.push(key);
  // Don't enum bug & hidden keys
  while (names.length > i) if (has(O, key = names[i++])) {
    ~indexOf(result, key) || result.push(key);
  }
  return result;
};


/***/ }),

/***/ "ca91":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $reduce = __webpack_require__("d58f").left;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.reduce` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reduce
exportTypedArrayMethod('reduce', function reduce(callbackfn /* , initialValue */) {
  return $reduce(aTypedArray(this), callbackfn, arguments.length, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "caad":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $includes = __webpack_require__("4d64").includes;
var addToUnscopables = __webpack_require__("44d2");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });

// `Array.prototype.includes` method
// https://tc39.github.io/ecma262/#sec-array.prototype.includes
$({ target: 'Array', proto: true, forced: !USES_TO_LENGTH }, {
  includes: function includes(el /* , fromIndex = 0 */) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('includes');


/***/ }),

/***/ "cb29":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var fill = __webpack_require__("81d5");
var addToUnscopables = __webpack_require__("44d2");

// `Array.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
$({ target: 'Array', proto: true }, {
  fill: fill
});

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('fill');


/***/ }),

/***/ "cc12":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var isObject = __webpack_require__("861d");

var document = global.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return EXISTS ? document.createElement(it) : {};
};


/***/ }),

/***/ "cca6":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var assign = __webpack_require__("60da");

// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
$({ target: 'Object', stat: true, forced: Object.assign !== assign }, {
  assign: assign
});


/***/ }),

/***/ "cd26":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var floor = Math.floor;

// `%TypedArray%.prototype.reverse` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.reverse
exportTypedArrayMethod('reverse', function reverse() {
  var that = this;
  var length = aTypedArray(that).length;
  var middle = floor(length / 2);
  var index = 0;
  var value;
  while (index < middle) {
    value = that[index];
    that[index++] = that[--length];
    that[length] = value;
  } return that;
});


/***/ }),

/***/ "cdf9":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var isObject = __webpack_require__("861d");
var newPromiseCapability = __webpack_require__("f069");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};


/***/ }),

/***/ "ce4e":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var createNonEnumerableProperty = __webpack_require__("9112");

module.exports = function (key, value) {
  try {
    createNonEnumerableProperty(global, key, value);
  } catch (error) {
    global[key] = value;
  } return value;
};


/***/ }),

/***/ "cf28":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "d012":
/***/ (function(module, exports) {

module.exports = {};


/***/ }),

/***/ "d039":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (error) {
    return true;
  }
};


/***/ }),

/***/ "d066":
/***/ (function(module, exports, __webpack_require__) {

var path = __webpack_require__("428f");
var global = __webpack_require__("da84");

var aFunction = function (variable) {
  return typeof variable == 'function' ? variable : undefined;
};

module.exports = function (namespace, method) {
  return arguments.length < 2 ? aFunction(path[namespace]) || aFunction(global[namespace])
    : path[namespace] && path[namespace][method] || global[namespace] && global[namespace][method];
};


/***/ }),

/***/ "d139":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $find = __webpack_require__("b727").find;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.find` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.find
exportTypedArrayMethod('find', function find(predicate /* , thisArg */) {
  return $find(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "d1e7":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor && !nativePropertyIsEnumerable.call({ 1: 2 }, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
exports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
  var descriptor = getOwnPropertyDescriptor(this, V);
  return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;


/***/ }),

/***/ "d28b":
/***/ (function(module, exports, __webpack_require__) {

var defineWellKnownSymbol = __webpack_require__("746f");

// `Symbol.iterator` well-known symbol
// https://tc39.github.io/ecma262/#sec-symbol.iterator
defineWellKnownSymbol('iterator');


/***/ }),

/***/ "d2bb":
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__("825a");
var aPossiblePrototype = __webpack_require__("3bbe");

// `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
module.exports = Object.setPrototypeOf || ('__proto__' in {} ? function () {
  var CORRECT_SETTER = false;
  var test = {};
  var setter;
  try {
    setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
    setter.call(test, []);
    CORRECT_SETTER = test instanceof Array;
  } catch (error) { /* empty */ }
  return function setPrototypeOf(O, proto) {
    anObject(O);
    aPossiblePrototype(proto);
    if (CORRECT_SETTER) setter.call(O, proto);
    else O.__proto__ = proto;
    return O;
  };
}() : undefined);


/***/ }),

/***/ "d2df":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "d3b7":
/***/ (function(module, exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
var redefine = __webpack_require__("6eeb");
var toString = __webpack_require__("b041");

// `Object.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-object.prototype.tostring
if (!TO_STRING_TAG_SUPPORT) {
  redefine(Object.prototype, 'toString', toString, { unsafe: true });
}


/***/ }),

/***/ "d44e":
/***/ (function(module, exports, __webpack_require__) {

var defineProperty = __webpack_require__("9bf2").f;
var has = __webpack_require__("5135");
var wellKnownSymbol = __webpack_require__("b622");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');

module.exports = function (it, TAG, STATIC) {
  if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG)) {
    defineProperty(it, TO_STRING_TAG, { configurable: true, value: TAG });
  }
};


/***/ }),

/***/ "d58f":
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__("1c0b");
var toObject = __webpack_require__("7b0b");
var IndexedObject = __webpack_require__("44ad");
var toLength = __webpack_require__("50c4");

// `Array.prototype.{ reduce, reduceRight }` methods implementation
var createMethod = function (IS_RIGHT) {
  return function (that, callbackfn, argumentsLength, memo) {
    aFunction(callbackfn);
    var O = toObject(that);
    var self = IndexedObject(O);
    var length = toLength(O.length);
    var index = IS_RIGHT ? length - 1 : 0;
    var i = IS_RIGHT ? -1 : 1;
    if (argumentsLength < 2) while (true) {
      if (index in self) {
        memo = self[index];
        index += i;
        break;
      }
      index += i;
      if (IS_RIGHT ? index < 0 : length <= index) {
        throw TypeError('Reduce of empty array with no initial value');
      }
    }
    for (;IS_RIGHT ? index >= 0 : length > index; index += i) if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
    return memo;
  };
};

module.exports = {
  // `Array.prototype.reduce` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduce
  left: createMethod(false),
  // `Array.prototype.reduceRight` method
  // https://tc39.github.io/ecma262/#sec-array.prototype.reduceright
  right: createMethod(true)
};


/***/ }),

/***/ "d5d6":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $forEach = __webpack_require__("b727").forEach;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.forEach` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.foreach
exportTypedArrayMethod('forEach', function forEach(callbackfn /* , thisArg */) {
  $forEach(aTypedArray(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "d784":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// TODO: Remove from `core-js@4` since it's moved to entry points
__webpack_require__("ac1f");
var redefine = __webpack_require__("6eeb");
var fails = __webpack_require__("d039");
var wellKnownSymbol = __webpack_require__("b622");
var regexpExec = __webpack_require__("9263");
var createNonEnumerableProperty = __webpack_require__("9112");

var SPECIES = wellKnownSymbol('species');

var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;
  re.exec = function () {
    var result = [];
    result.groups = { a: '7' };
    return result;
  };
  return ''.replace(re, '$<a>') !== '7';
});

// IE <= 11 replaces $0 with the whole match, as if it was $&
// https://stackoverflow.com/questions/6024666/getting-ie-to-replace-a-regex-with-the-literal-string-0
var REPLACE_KEEPS_$0 = (function () {
  return 'a'.replace(/./, '$0') === '$0';
})();

var REPLACE = wellKnownSymbol('replace');
// Safari <= 13.0.3(?) substitutes nth capture where n>m with an empty string
var REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE = (function () {
  if (/./[REPLACE]) {
    return /./[REPLACE]('a', '$0') === '';
  }
  return false;
})();

// Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
// Weex JS has frozen built-in prototypes, so use try / catch wrapper
var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = !fails(function () {
  var re = /(?:)/;
  var originalExec = re.exec;
  re.exec = function () { return originalExec.apply(this, arguments); };
  var result = 'ab'.split(re);
  return result.length !== 2 || result[0] !== 'a' || result[1] !== 'b';
});

module.exports = function (KEY, length, exec, sham) {
  var SYMBOL = wellKnownSymbol(KEY);

  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};
    O[SYMBOL] = function () { return 7; };
    return ''[KEY](O) != 7;
  });

  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL && !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    if (KEY === 'split') {
      // We can't use real regex here since it causes deoptimization
      // and serious performance degradation in V8
      // https://github.com/zloirock/core-js/issues/306
      re = {};
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};
      re.constructor[SPECIES] = function () { return re; };
      re.flags = '';
      re[SYMBOL] = /./[SYMBOL];
    }

    re.exec = function () { execCalled = true; return null; };

    re[SYMBOL]('');
    return !execCalled;
  });

  if (
    !DELEGATES_TO_SYMBOL ||
    !DELEGATES_TO_EXEC ||
    (KEY === 'replace' && !(
      REPLACE_SUPPORTS_NAMED_GROUPS &&
      REPLACE_KEEPS_$0 &&
      !REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    )) ||
    (KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC)
  ) {
    var nativeRegExpMethod = /./[SYMBOL];
    var methods = exec(SYMBOL, ''[KEY], function (nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return { done: true, value: nativeRegExpMethod.call(regexp, str, arg2) };
        }
        return { done: true, value: nativeMethod.call(str, regexp, arg2) };
      }
      return { done: false };
    }, {
      REPLACE_KEEPS_$0: REPLACE_KEEPS_$0,
      REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE: REGEXP_REPLACE_SUBSTITUTES_UNDEFINED_CAPTURE
    });
    var stringMethod = methods[0];
    var regexMethod = methods[1];

    redefine(String.prototype, KEY, stringMethod);
    redefine(RegExp.prototype, SYMBOL, length == 2
      // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
      // 21.2.5.11 RegExp.prototype[@@split](string, limit)
      ? function (string, arg) { return regexMethod.call(string, this, arg); }
      // 21.2.5.6 RegExp.prototype[@@match](string)
      // 21.2.5.9 RegExp.prototype[@@search](string)
      : function (string) { return regexMethod.call(string, this); }
    );
  }

  if (sham) createNonEnumerableProperty(RegExp.prototype[SYMBOL], 'sham', true);
};


/***/ }),

/***/ "d81d":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var $map = __webpack_require__("b727").map;
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('map');
// FF49- issue
var USES_TO_LENGTH = arrayMethodUsesToLength('map');

// `Array.prototype.map` method
// https://tc39.github.io/ecma262/#sec-array.prototype.map
// with adding support of @@species
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  map: function map(callbackfn /* , thisArg */) {
    return $map(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});


/***/ }),

/***/ "da84":
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var check = function (it) {
  return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
module.exports =
  // eslint-disable-next-line no-undef
  check(typeof globalThis == 'object' && globalThis) ||
  check(typeof window == 'object' && window) ||
  check(typeof self == 'object' && self) ||
  check(typeof global == 'object' && global) ||
  // eslint-disable-next-line no-new-func
  Function('return this')();

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "da88":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "da97":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "dd40":
/***/ (function(module, exports) {

module.exports = function(originalModule) {
	if (!originalModule.webpackPolyfill) {
		var module = Object.create(originalModule);
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		Object.defineProperty(module, "exports", {
			enumerable: true
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "ddb0":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");
var DOMIterables = __webpack_require__("fdbc");
var ArrayIteratorMethods = __webpack_require__("e260");
var createNonEnumerableProperty = __webpack_require__("9112");
var wellKnownSymbol = __webpack_require__("b622");

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

for (var COLLECTION_NAME in DOMIterables) {
  var Collection = global[COLLECTION_NAME];
  var CollectionPrototype = Collection && Collection.prototype;
  if (CollectionPrototype) {
    // some Chrome versions have non-configurable methods on DOMTokenList
    if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
      createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
    } catch (error) {
      CollectionPrototype[ITERATOR] = ArrayValues;
    }
    if (!CollectionPrototype[TO_STRING_TAG]) {
      createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
    }
    if (DOMIterables[COLLECTION_NAME]) for (var METHOD_NAME in ArrayIteratorMethods) {
      // some Chrome versions have non-configurable methods on DOMTokenList
      if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
        createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
      } catch (error) {
        CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
      }
    }
  }
}


/***/ }),

/***/ "dde1":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M7 5.75c0 .414.336.75.75.75h9.5a.75.75 0 1 0 0-1.5h-9.5a.75.75 0 0 0-.75.75zM3.5 3v5H2V3.7H1v-1h2.5V3zM.343 17.857l2.59-3.257H2.92a.6.6 0 1 0-1.04 0H.302a2 2 0 1 1 3.995 0h-.001c-.048.405-.16.734-.333.988-.175.254-.59.692-1.244 1.312H4.3v1h-4l.043-.043zM7 14.75a.75.75 0 0 1 .75-.75h9.5a.75.75 0 1 1 0 1.5h-9.5a.75.75 0 0 1-.75-.75z\"/></svg>"

/***/ }),

/***/ "df75":
/***/ (function(module, exports, __webpack_require__) {

var internalObjectKeys = __webpack_require__("ca84");
var enumBugKeys = __webpack_require__("7839");

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
module.exports = Object.keys || function keys(O) {
  return internalObjectKeys(O, enumBugKeys);
};


/***/ }),

/***/ "dff1":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var _root_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("26ee");


/** Detect free variable `exports`. */
var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? _root_js__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"].Buffer : undefined,
    allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined;

/**
 * Creates a clone of  `buffer`.
 *
 * @private
 * @param {Buffer} buffer The buffer to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Buffer} Returns the cloned buffer.
 */
function cloneBuffer(buffer, isDeep) {
  if (isDeep) {
    return buffer.slice();
  }
  var length = buffer.length,
      result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  buffer.copy(result);
  return result;
}

/* harmony default export */ __webpack_exports__["a"] = (cloneBuffer);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("dd40")(module)))

/***/ }),

/***/ "e01a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// `Symbol.prototype.description` getter
// https://tc39.github.io/ecma262/#sec-symbol.prototype.description

var $ = __webpack_require__("23e7");
var DESCRIPTORS = __webpack_require__("83ab");
var global = __webpack_require__("da84");
var has = __webpack_require__("5135");
var isObject = __webpack_require__("861d");
var defineProperty = __webpack_require__("9bf2").f;
var copyConstructorProperties = __webpack_require__("e893");

var NativeSymbol = global.Symbol;

if (DESCRIPTORS && typeof NativeSymbol == 'function' && (!('description' in NativeSymbol.prototype) ||
  // Safari 12 bug
  NativeSymbol().description !== undefined
)) {
  var EmptyStringDescriptionStore = {};
  // wrap Symbol constructor for correct work with undefined description
  var SymbolWrapper = function Symbol() {
    var description = arguments.length < 1 || arguments[0] === undefined ? undefined : String(arguments[0]);
    var result = this instanceof SymbolWrapper
      ? new NativeSymbol(description)
      // in Edge 13, String(Symbol(undefined)) === 'Symbol(undefined)'
      : description === undefined ? NativeSymbol() : NativeSymbol(description);
    if (description === '') EmptyStringDescriptionStore[result] = true;
    return result;
  };
  copyConstructorProperties(SymbolWrapper, NativeSymbol);
  var symbolPrototype = SymbolWrapper.prototype = NativeSymbol.prototype;
  symbolPrototype.constructor = SymbolWrapper;

  var symbolToString = symbolPrototype.toString;
  var native = String(NativeSymbol('test')) == 'Symbol(test)';
  var regexp = /^Symbol\((.*)\)[^)]+$/;
  defineProperty(symbolPrototype, 'description', {
    configurable: true,
    get: function description() {
      var symbol = isObject(this) ? this.valueOf() : this;
      var string = symbolToString.call(symbol);
      if (has(EmptyStringDescriptionStore, symbol)) return '';
      var desc = native ? string.slice(7, -1) : string.replace(regexp, '$1');
      return desc === '' ? undefined : desc;
    }
  });

  $({ global: true, forced: true }, {
    Symbol: SymbolWrapper
  });
}


/***/ }),

/***/ "e046":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M18 3.75a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 8a.75.75 0 0 1-.75.75H2.75a.75.75 0 1 1 0-1.5h14.5a.75.75 0 0 1 .75.75zm0 4a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75zm0-8a.75.75 0 0 1-.75.75H7.321a.75.75 0 1 1 0-1.5h9.929a.75.75 0 0 1 .75.75z\"/></svg>"

/***/ }),

/***/ "e163":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("5135");
var toObject = __webpack_require__("7b0b");
var sharedKey = __webpack_require__("f772");
var CORRECT_PROTOTYPE_GETTER = __webpack_require__("e177");

var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
module.exports = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];
  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  } return O instanceof Object ? ObjectPrototype : null;
};


/***/ }),

/***/ "e177":
/***/ (function(module, exports, __webpack_require__) {

var fails = __webpack_require__("d039");

module.exports = !fails(function () {
  function F() { /* empty */ }
  F.prototype.constructor = null;
  return Object.getPrototypeOf(new F()) !== F.prototype;
});


/***/ }),

/***/ "e260":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__("fc6a");
var addToUnscopables = __webpack_require__("44d2");
var Iterators = __webpack_require__("3f8c");
var InternalStateModule = __webpack_require__("69f3");
var defineIterator = __webpack_require__("7dd0");

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState = InternalStateModule.set;
var getInternalState = InternalStateModule.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator
module.exports = defineIterator(Array, 'Array', function (iterated, kind) {
  setInternalState(this, {
    type: ARRAY_ITERATOR,
    target: toIndexedObject(iterated), // target
    index: 0,                          // next index
    kind: kind                         // kind
  });
// `%ArrayIteratorPrototype%.next` method
// https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
}, function () {
  var state = getInternalState(this);
  var target = state.target;
  var kind = state.kind;
  var index = state.index++;
  if (!target || index >= target.length) {
    state.target = undefined;
    return { value: undefined, done: true };
  }
  if (kind == 'keys') return { value: index, done: false };
  if (kind == 'values') return { value: target[index], done: false };
  return { value: [index, target[index]], done: false };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
Iterators.Arguments = Iterators.Array;

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');


/***/ }),

/***/ "e281":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "e2cc":
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__("6eeb");

module.exports = function (target, src, options) {
  for (var key in src) redefine(target, key, src[key], options);
  return target;
};


/***/ }),

/***/ "e348":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "e439":
/***/ (function(module, exports, __webpack_require__) {

var $ = __webpack_require__("23e7");
var fails = __webpack_require__("d039");
var toIndexedObject = __webpack_require__("fc6a");
var nativeGetOwnPropertyDescriptor = __webpack_require__("06cf").f;
var DESCRIPTORS = __webpack_require__("83ab");

var FAILS_ON_PRIMITIVES = fails(function () { nativeGetOwnPropertyDescriptor(1); });
var FORCED = !DESCRIPTORS || FAILS_ON_PRIMITIVES;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
$({ target: 'Object', stat: true, forced: FORCED, sham: !DESCRIPTORS }, {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(it, key) {
    return nativeGetOwnPropertyDescriptor(toIndexedObject(it), key);
  }
});


/***/ }),

/***/ "e472":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "e538":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");

exports.f = wellKnownSymbol;


/***/ }),

/***/ "e58c":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var toIndexedObject = __webpack_require__("fc6a");
var toInteger = __webpack_require__("a691");
var toLength = __webpack_require__("50c4");
var arrayMethodIsStrict = __webpack_require__("a640");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var min = Math.min;
var nativeLastIndexOf = [].lastIndexOf;
var NEGATIVE_ZERO = !!nativeLastIndexOf && 1 / [1].lastIndexOf(1, -0) < 0;
var STRICT_METHOD = arrayMethodIsStrict('lastIndexOf');
// For preventing possible almost infinite loop in non-standard implementations, test the forward version of the method
var USES_TO_LENGTH = arrayMethodUsesToLength('indexOf', { ACCESSORS: true, 1: 0 });
var FORCED = NEGATIVE_ZERO || !STRICT_METHOD || !USES_TO_LENGTH;

// `Array.prototype.lastIndexOf` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.lastindexof
module.exports = FORCED ? function lastIndexOf(searchElement /* , fromIndex = @[*-1] */) {
  // convert -0 to +0
  if (NEGATIVE_ZERO) return nativeLastIndexOf.apply(this, arguments) || 0;
  var O = toIndexedObject(this);
  var length = toLength(O.length);
  var index = length - 1;
  if (arguments.length > 1) index = min(index, toInteger(arguments[1]));
  if (index < 0) index = length + index;
  for (;index >= 0; index--) if (index in O && O[index] === searchElement) return index || 0;
  return -1;
} : nativeLastIndexOf;


/***/ }),

/***/ "e667":
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return { error: false, value: exec() };
  } catch (error) {
    return { error: true, value: error };
  }
};


/***/ }),

/***/ "e6cf":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var IS_PURE = __webpack_require__("c430");
var global = __webpack_require__("da84");
var getBuiltIn = __webpack_require__("d066");
var NativePromise = __webpack_require__("fea9");
var redefine = __webpack_require__("6eeb");
var redefineAll = __webpack_require__("e2cc");
var setToStringTag = __webpack_require__("d44e");
var setSpecies = __webpack_require__("2626");
var isObject = __webpack_require__("861d");
var aFunction = __webpack_require__("1c0b");
var anInstance = __webpack_require__("19aa");
var classof = __webpack_require__("c6b6");
var inspectSource = __webpack_require__("8925");
var iterate = __webpack_require__("2266");
var checkCorrectnessOfIteration = __webpack_require__("1c7e");
var speciesConstructor = __webpack_require__("4840");
var task = __webpack_require__("2cf4").set;
var microtask = __webpack_require__("b575");
var promiseResolve = __webpack_require__("cdf9");
var hostReportErrors = __webpack_require__("44de");
var newPromiseCapabilityModule = __webpack_require__("f069");
var perform = __webpack_require__("e667");
var InternalStateModule = __webpack_require__("69f3");
var isForced = __webpack_require__("94ca");
var wellKnownSymbol = __webpack_require__("b622");
var V8_VERSION = __webpack_require__("2d00");

var SPECIES = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var PromiseConstructor = NativePromise;
var TypeError = global.TypeError;
var document = global.document;
var process = global.process;
var $fetch = getBuiltIn('fetch');
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var IS_NODE = classof(process) == 'process';
var DISPATCH_EVENT = !!(document && document.createEvent && global.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

var FORCED = isForced(PROMISE, function () {
  var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
  if (!GLOBAL_CORE_JS_PROMISE) {
    // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // We can't detect it synchronously, so just check versions
    if (V8_VERSION === 66) return true;
    // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
    if (!IS_NODE && typeof PromiseRejectionEvent != 'function') return true;
  }
  // We need Promise#finally in the pure version for preventing prototype pollution
  if (IS_PURE && !PromiseConstructor.prototype['finally']) return true;
  // We can't use @@species feature detection in V8 since it causes
  // deoptimization and performance degradation
  // https://github.com/zloirock/core-js/issues/679
  if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor)) return false;
  // Detect correctness of subclassing with @@species support
  var promise = PromiseConstructor.resolve(1);
  var FakePromise = function (exec) {
    exec(function () { /* empty */ }, function () { /* empty */ });
  };
  var constructor = promise.constructor = {};
  constructor[SPECIES] = FakePromise;
  return !(promise.then(function () { /* empty */ }) instanceof FakePromise);
});

var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function (iterable) {
  PromiseConstructor.all(iterable)['catch'](function () { /* empty */ });
});

// helpers
var isThenable = function (it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function (promise, state, isReject) {
  if (state.notified) return;
  state.notified = true;
  var chain = state.reactions;
  microtask(function () {
    var value = state.value;
    var ok = state.state == FULFILLED;
    var index = 0;
    // variable length - can't use forEach
    while (chain.length > index) {
      var reaction = chain[index++];
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;
      try {
        if (handler) {
          if (!ok) {
            if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
            state.rejection = HANDLED;
          }
          if (handler === true) result = value;
          else {
            if (domain) domain.enter();
            result = handler(value); // can throw
            if (domain) {
              domain.exit();
              exited = true;
            }
          }
          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (error) {
        if (domain && !exited) domain.exit();
        reject(error);
      }
    }
    state.reactions = [];
    state.notified = false;
    if (isReject && !state.rejection) onUnhandled(promise, state);
  });
};

var dispatchEvent = function (name, promise, reason) {
  var event, handler;
  if (DISPATCH_EVENT) {
    event = document.createEvent('Event');
    event.promise = promise;
    event.reason = reason;
    event.initEvent(name, false, true);
    global.dispatchEvent(event);
  } else event = { promise: promise, reason: reason };
  if (handler = global['on' + name]) handler(event);
  else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function (promise, state) {
  task.call(global, function () {
    var value = state.value;
    var IS_UNHANDLED = isUnhandled(state);
    var result;
    if (IS_UNHANDLED) {
      result = perform(function () {
        if (IS_NODE) {
          process.emit('unhandledRejection', value, promise);
        } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
      });
      // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
      state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
      if (result.error) throw result.value;
    }
  });
};

var isUnhandled = function (state) {
  return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function (promise, state) {
  task.call(global, function () {
    if (IS_NODE) {
      process.emit('rejectionHandled', promise);
    } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
  });
};

var bind = function (fn, promise, state, unwrap) {
  return function (value) {
    fn(promise, state, value, unwrap);
  };
};

var internalReject = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  state.value = value;
  state.state = REJECTED;
  notify(promise, state, true);
};

var internalResolve = function (promise, state, value, unwrap) {
  if (state.done) return;
  state.done = true;
  if (unwrap) state = unwrap;
  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");
    var then = isThenable(value);
    if (then) {
      microtask(function () {
        var wrapper = { done: false };
        try {
          then.call(value,
            bind(internalResolve, promise, wrapper, state),
            bind(internalReject, promise, wrapper, state)
          );
        } catch (error) {
          internalReject(promise, wrapper, error, state);
        }
      });
    } else {
      state.value = value;
      state.state = FULFILLED;
      notify(promise, state, false);
    }
  } catch (error) {
    internalReject(promise, { done: false }, error, state);
  }
};

// constructor polyfill
if (FORCED) {
  // 25.4.3.1 Promise(executor)
  PromiseConstructor = function Promise(executor) {
    anInstance(this, PromiseConstructor, PROMISE);
    aFunction(executor);
    Internal.call(this);
    var state = getInternalState(this);
    try {
      executor(bind(internalResolve, this, state), bind(internalReject, this, state));
    } catch (error) {
      internalReject(this, state, error);
    }
  };
  // eslint-disable-next-line no-unused-vars
  Internal = function Promise(executor) {
    setInternalState(this, {
      type: PROMISE,
      done: false,
      notified: false,
      parent: false,
      reactions: [],
      rejection: false,
      state: PENDING,
      value: undefined
    });
  };
  Internal.prototype = redefineAll(PromiseConstructor.prototype, {
    // `Promise.prototype.then` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.then
    then: function then(onFulfilled, onRejected) {
      var state = getInternalPromiseState(this);
      var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = IS_NODE ? process.domain : undefined;
      state.parent = true;
      state.reactions.push(reaction);
      if (state.state != PENDING) notify(this, state, false);
      return reaction.promise;
    },
    // `Promise.prototype.catch` method
    // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
    'catch': function (onRejected) {
      return this.then(undefined, onRejected);
    }
  });
  OwnPromiseCapability = function () {
    var promise = new Internal();
    var state = getInternalState(promise);
    this.promise = promise;
    this.resolve = bind(internalResolve, promise, state);
    this.reject = bind(internalReject, promise, state);
  };
  newPromiseCapabilityModule.f = newPromiseCapability = function (C) {
    return C === PromiseConstructor || C === PromiseWrapper
      ? new OwnPromiseCapability(C)
      : newGenericPromiseCapability(C);
  };

  if (!IS_PURE && typeof NativePromise == 'function') {
    nativeThen = NativePromise.prototype.then;

    // wrap native Promise#then for native async functions
    redefine(NativePromise.prototype, 'then', function then(onFulfilled, onRejected) {
      var that = this;
      return new PromiseConstructor(function (resolve, reject) {
        nativeThen.call(that, resolve, reject);
      }).then(onFulfilled, onRejected);
    // https://github.com/zloirock/core-js/issues/640
    }, { unsafe: true });

    // wrap fetch result
    if (typeof $fetch == 'function') $({ global: true, enumerable: true, forced: true }, {
      // eslint-disable-next-line no-unused-vars
      fetch: function fetch(input /* , init */) {
        return promiseResolve(PromiseConstructor, $fetch.apply(global, arguments));
      }
    });
  }
}

$({ global: true, wrap: true, forced: FORCED }, {
  Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false, true);
setSpecies(PROMISE);

PromiseWrapper = getBuiltIn(PROMISE);

// statics
$({ target: PROMISE, stat: true, forced: FORCED }, {
  // `Promise.reject` method
  // https://tc39.github.io/ecma262/#sec-promise.reject
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    capability.reject.call(undefined, r);
    return capability.promise;
  }
});

$({ target: PROMISE, stat: true, forced: IS_PURE || FORCED }, {
  // `Promise.resolve` method
  // https://tc39.github.io/ecma262/#sec-promise.resolve
  resolve: function resolve(x) {
    return promiseResolve(IS_PURE && this === PromiseWrapper ? PromiseConstructor : this, x);
  }
});

$({ target: PROMISE, stat: true, forced: INCORRECT_ITERATION }, {
  // `Promise.all` method
  // https://tc39.github.io/ecma262/#sec-promise.all
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      var values = [];
      var counter = 0;
      var remaining = 1;
      iterate(iterable, function (promise) {
        var index = counter++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        $promiseResolve.call(C, promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.error) reject(result.value);
    return capability.promise;
  },
  // `Promise.race` method
  // https://tc39.github.io/ecma262/#sec-promise.race
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      var $promiseResolve = aFunction(C.resolve);
      iterate(iterable, function (promise) {
        $promiseResolve.call(C, promise).then(capability.resolve, reject);
      });
    });
    if (result.error) reject(result.value);
    return capability.promise;
  }
});


/***/ }),

/***/ "e7f1":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _construct; });
/* harmony import */ var core_js_modules_es_reflect_construct__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("4ae1");
/* harmony import */ var core_js_modules_es_reflect_construct__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_reflect_construct__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _setPrototypeOf__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("0de3");
/* harmony import */ var _isNativeReflectConstruct__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__("8151");



function _construct(Parent, args, Class) {
  if (Object(_isNativeReflectConstruct__WEBPACK_IMPORTED_MODULE_2__[/* default */ "a"])()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) Object(_setPrototypeOf__WEBPACK_IMPORTED_MODULE_1__[/* default */ "a"])(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

/***/ }),

/***/ "e800":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/* harmony import */ var F_Work_bootstrap_editor_node_modules_vue_babel_preset_app_node_modules_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("0122");
/* harmony import */ var _ckeditorerror__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("f2ea");


/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/version
 */

/* globals window, global */

var version = '20.0.0';
/* istanbul ignore next */

var windowOrGlobal = (typeof window === "undefined" ? "undefined" : Object(F_Work_bootstrap_editor_node_modules_vue_babel_preset_app_node_modules_babel_runtime_helpers_esm_typeof__WEBPACK_IMPORTED_MODULE_0__[/* default */ "a"])(window)) === 'object' ? window : global;
/* istanbul ignore next */

if (windowOrGlobal.CKEDITOR_VERSION) {
  /**
   * This error is thrown when due to a mistake in how CKEditor 5 was installed or initialized, some
   * of its modules were duplicated (evaluated and executed twice). Module duplication leads to inevitable runtime
   * errors.
   *
   * There are many situations in which some modules can be loaded twice. In the worst case scenario,
   * you may need to check your project for each of these issues and fix them all.
   *
   * # Trying to add a plugin to an existing build
   *
   * If you import an existing CKEditor 5 build and a plugin like this:
   *
   *		import ClassicEditor from '@ckeditor/ckeditor5-build-classic';
   *		import Highlight from '@ckeditor/ckeditor5-highlight/src/highlight';
   *
   * Then your project loads some CKEditor 5 packages twice. How does it happen?
   *
   * The build package contains a file which is already compiled with webpack. This means
   * that it contains all the necessary code from e.g. `@ckeditor/ckeditor5-engine` and `@ckeditor/ckeditor5-utils`.
   *
   * However, the `Highlight` plugin imports some of the modules from these packages, too. If you ask webpack to
   * build such a project, you will end up with the modules being included (and run) twice &mdash; first, because they are
   * included inside the build package, and second, because they are required by the `Highlight` plugin.
   *
   * Therefore, **you must never add plugins to an existing build** unless your plugin has no dependencies.
   *
   * Adding plugins to a build is done by taking the source version of this build (so, before it was built with webpack)
   * and adding plugins there. In this situation, webpack will know that it only needs to load each plugin once.
   *
   * Read more in the {@glink builds/guides/integration/installing-plugins "Installing plugins"} guide.
   *
   * # Confused an editor build with an editor implementation
   *
   * This scenario is very similar to the previous one, but has a different origin.
   *
   * Let's assume that you wanted to use CKEditor 5 from source, as explained in the
   * {@glink builds/guides/integration/advanced-setup#scenario-2-building-from-source "Building from source"} section
   * or in the {@glink framework/guides/quick-start "Quick start"} guide of CKEditor 5 Framework.
   *
   * The correct way to do so is to import an editor and plugins and run them together like this:
   *
   *		import ClassicEditor from '@ckeditor/ckeditor5-editor-classic/src/classiceditor';
   *		import Essentials from '@ckeditor/ckeditor5-essentials/src/essentials';
   *		import Paragraph from '@ckeditor/ckeditor5-paragraph/src/paragraph';
   *		import Bold from '@ckeditor/ckeditor5-basic-styles/src/bold';
   *		import Italic from '@ckeditor/ckeditor5-basic-styles/src/italic';
   *
   *		ClassicEditor
   *			.create( document.querySelector( '#editor' ), {
   *				plugins: [ Essentials, Paragraph, Bold, Italic ],
   *				toolbar: [ 'bold', 'italic' ]
   *			} )
   *			.then( editor => {
   *				console.log( 'Editor was initialized', editor );
   *			} )
   *			.catch( error => {
   *				console.error( error.stack );
   *			} );
   *
   * However, you might have mistakenly imported a build instead of the source `ClassicEditor`. In this case
   * your imports will look like this:
   *
   *		import ClassicEditor from '@ckeditor/ckeditor5-build-classic';
   *		import Essentials from '@ckeditor/ckeditor5-essentials/src/essentials';
   *		import Paragraph from '@ckeditor/ckeditor5-paragraph/src/paragraph';
   *		import Bold from '@ckeditor/ckeditor5-basic-styles/src/bold';
   *		import Italic from '@ckeditor/ckeditor5-basic-styles/src/italic';
   *
   * This creates the same situation as in the previous section because you use a build together with source plugins.
   *
   * Remember: `@ckeditor/ckeditor5-build-*` packages contain editor builds and `@ckeditor/ckeditor5-editor-*` contain source editors.
   *
   * # Loading two or more builds on one page
   *
   * If you use CKEditor 5 builds, you might have loaded two (or more) `ckeditor.js` files on one web page.
   * Check your web page for duplicated `<script>` elements or make sure your page builder/bundler includes CKEditor only once.
   *
   * If you want to use two different types of editors at once, see the
   * {@glink builds/guides/integration/advanced-setup#scenario-3-using-two-different-editors "Using two different editors"}
   * section.
   *
   * # Using outdated packages
   *
   * Building CKEditor 5 from source requires using multiple npm packages. These packages have their dependencies
   * to other packages. If you use the latest version of, for example, `@ckeditor/ckeditor5-editor-classic` with
   * an outdated version of `@ckeditor/ckeditor5-image`, npm or yarn will need to install two different versions of
   * `@ckeditor/ckeditor5-core` because `@ckeditor/ckeditor5-editor-classic` and `@ckeditor/ckeditor5-image` may require
   * different versions of the core package.
   *
   * The solution to this issue is to update all packages to their latest version. We recommend
   * using tools like [`node-check-updates`](https://www.npmjs.com/package/npm-check-updates) which simplify this process.
   *
   * # Conflicting version of dependencies
   *
   * This is a special case of the previous scenario. If you use CKEditor 5 with some third-party plugins,
   * it may happen that even if you use the latest versions of the official packages and the latest version of
   * these third-party packages, there will be a conflict between some of their dependencies.
   *
   * Such a problem can be resolved by either downgrading CKEditor 5 packages (which we do not recommend) or
   * asking the author of the third-party package to upgrade its depdendencies (or forking their project and doing this yourself).
   *
   * **Note:** All official CKEditor 5 packages (excluding integrations and `ckeditor5-dev-*` packages) are released in the
   * same major version. This is &mdash; in the `x.y.z`, the `x` is the same for all packages. This is the simplest way to check
   * whether you use packages coming from the same CKEditor 5 version. You can read more about versioning in the
   * {@glink framework/guides/support/versioning-policy Versioning policy} guide.
   *
   * # Packages were duplicated in `node_modules`
   *
   * In some situations, especially when calling `npm install` multiple times, it may happen
   * that npm will not correctly "deduplicate" packages.
   *
   * Normally, npm deduplicates all packages so, for example, `@ckeditor/ckeditor5-core` is installed only once in `node_modules/`.
   * However, it is known to fail to do so from time to time.
   *
   * We recommend checking if any of the steps listed below help:
   *
   * * `rm -rf node_modules && npm install` to make sure you have a clean `node_modules/` directory. This step
   * is known to help in most cases.
   * * If you use `yarn.lock` or `package-lock.json`, remove it before `npm install`.
   * * Check whether all CKEditor 5 packages are up to date and reinstall them
   * if you changed anything (`rm -rf node_modules && npm install`).
   *
   * If all packages are correct and compatible with each other, the steps above are known to help. If not, you may
   * try to check with `npm ls` how many times packages like `@ckeditor/ckeditor5-core`, `@ckeditor/ckeditor5-engine` and
   *`@ckeditor/ckeditor5-utils` are installed. If more than once, verify which package causes that.
   *
   * @error ckeditor-duplicated-modules
   */
  throw new _ckeditorerror__WEBPACK_IMPORTED_MODULE_1__[/* default */ "b"]('ckeditor-duplicated-modules: Some CKEditor 5 modules are duplicated.', null);
} else {
  windowOrGlobal.CKEDITOR_VERSION = version;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__("c8ba")))

/***/ }),

/***/ "e893":
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__("5135");
var ownKeys = __webpack_require__("56ef");
var getOwnPropertyDescriptorModule = __webpack_require__("06cf");
var definePropertyModule = __webpack_require__("9bf2");

module.exports = function (target, source) {
  var keys = ownKeys(source);
  var defineProperty = definePropertyModule.f;
  var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    if (!has(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
  }
};


/***/ }),

/***/ "e8b5":
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__("c6b6");

// `IsArray` abstract operation
// https://tc39.github.io/ecma262/#sec-isarray
module.exports = Array.isArray || function isArray(arg) {
  return classof(arg) == 'Array';
};


/***/ }),

/***/ "e8dd":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "e91f":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ArrayBufferViewCore = __webpack_require__("ebb5");
var $indexOf = __webpack_require__("4d64").indexOf;

var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;

// `%TypedArray%.prototype.indexOf` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.indexof
exportTypedArrayMethod('indexOf', function indexOf(searchElement /* , fromIndex */) {
  return $indexOf(aTypedArray(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
});


/***/ }),

/***/ "e954":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _createClass; });
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

/***/ }),

/***/ "e95a":
/***/ (function(module, exports, __webpack_require__) {

var wellKnownSymbol = __webpack_require__("b622");
var Iterators = __webpack_require__("3f8c");

var ITERATOR = wellKnownSymbol('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);
};


/***/ }),

/***/ "ebb5":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var NATIVE_ARRAY_BUFFER = __webpack_require__("a981");
var DESCRIPTORS = __webpack_require__("83ab");
var global = __webpack_require__("da84");
var isObject = __webpack_require__("861d");
var has = __webpack_require__("5135");
var classof = __webpack_require__("f5df");
var createNonEnumerableProperty = __webpack_require__("9112");
var redefine = __webpack_require__("6eeb");
var defineProperty = __webpack_require__("9bf2").f;
var getPrototypeOf = __webpack_require__("e163");
var setPrototypeOf = __webpack_require__("d2bb");
var wellKnownSymbol = __webpack_require__("b622");
var uid = __webpack_require__("90e3");

var Int8Array = global.Int8Array;
var Int8ArrayPrototype = Int8Array && Int8Array.prototype;
var Uint8ClampedArray = global.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray = Int8Array && getPrototypeOf(Int8Array);
var TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var isPrototypeOf = ObjectPrototype.isPrototypeOf;

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQIRED = false;
var NAME;

var TypedArrayConstructorsList = {
  Int8Array: 1,
  Uint8Array: 1,
  Uint8ClampedArray: 1,
  Int16Array: 2,
  Uint16Array: 2,
  Int32Array: 4,
  Uint32Array: 4,
  Float32Array: 4,
  Float64Array: 8
};

var isView = function isView(it) {
  var klass = classof(it);
  return klass === 'DataView' || has(TypedArrayConstructorsList, klass);
};

var isTypedArray = function (it) {
  return isObject(it) && has(TypedArrayConstructorsList, classof(it));
};

var aTypedArray = function (it) {
  if (isTypedArray(it)) return it;
  throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor = function (C) {
  if (setPrototypeOf) {
    if (isPrototypeOf.call(TypedArray, C)) return C;
  } else for (var ARRAY in TypedArrayConstructorsList) if (has(TypedArrayConstructorsList, NAME)) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
      return C;
    }
  } throw TypeError('Target is not a typed array constructor');
};

var exportTypedArrayMethod = function (KEY, property, forced) {
  if (!DESCRIPTORS) return;
  if (forced) for (var ARRAY in TypedArrayConstructorsList) {
    var TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && has(TypedArrayConstructor.prototype, KEY)) {
      delete TypedArrayConstructor.prototype[KEY];
    }
  }
  if (!TypedArrayPrototype[KEY] || forced) {
    redefine(TypedArrayPrototype, KEY, forced ? property
      : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property);
  }
};

var exportTypedArrayStaticMethod = function (KEY, property, forced) {
  var ARRAY, TypedArrayConstructor;
  if (!DESCRIPTORS) return;
  if (setPrototypeOf) {
    if (forced) for (ARRAY in TypedArrayConstructorsList) {
      TypedArrayConstructor = global[ARRAY];
      if (TypedArrayConstructor && has(TypedArrayConstructor, KEY)) {
        delete TypedArrayConstructor[KEY];
      }
    }
    if (!TypedArray[KEY] || forced) {
      // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
      try {
        return redefine(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8Array[KEY] || property);
      } catch (error) { /* empty */ }
    } else return;
  }
  for (ARRAY in TypedArrayConstructorsList) {
    TypedArrayConstructor = global[ARRAY];
    if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
      redefine(TypedArrayConstructor, KEY, property);
    }
  }
};

for (NAME in TypedArrayConstructorsList) {
  if (!global[NAME]) NATIVE_ARRAY_BUFFER_VIEWS = false;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS || typeof TypedArray != 'function' || TypedArray === Function.prototype) {
  // eslint-disable-next-line no-shadow
  TypedArray = function TypedArray() {
    throw TypeError('Incorrect invocation');
  };
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME], TypedArray);
  }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {
  TypedArrayPrototype = TypedArray.prototype;
  if (NATIVE_ARRAY_BUFFER_VIEWS) for (NAME in TypedArrayConstructorsList) {
    if (global[NAME]) setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);
  }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {
  setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);
}

if (DESCRIPTORS && !has(TypedArrayPrototype, TO_STRING_TAG)) {
  TYPED_ARRAY_TAG_REQIRED = true;
  defineProperty(TypedArrayPrototype, TO_STRING_TAG, { get: function () {
    return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;
  } });
  for (NAME in TypedArrayConstructorsList) if (global[NAME]) {
    createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);
  }
}

module.exports = {
  NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,
  TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG,
  aTypedArray: aTypedArray,
  aTypedArrayConstructor: aTypedArrayConstructor,
  exportTypedArrayMethod: exportTypedArrayMethod,
  exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
  isView: isView,
  isTypedArray: isTypedArray,
  TypedArray: TypedArray,
  TypedArrayPrototype: TypedArrayPrototype
};


/***/ }),

/***/ "f069":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var aFunction = __webpack_require__("1c0b");

var PromiseCapability = function (C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
};

// 25.4.1.5 NewPromiseCapability(C)
module.exports.f = function (C) {
  return new PromiseCapability(C);
};


/***/ }),

/***/ "f183":
/***/ (function(module, exports, __webpack_require__) {

var hiddenKeys = __webpack_require__("d012");
var isObject = __webpack_require__("861d");
var has = __webpack_require__("5135");
var defineProperty = __webpack_require__("9bf2").f;
var uid = __webpack_require__("90e3");
var FREEZING = __webpack_require__("bb2f");

var METADATA = uid('meta');
var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var setMetadata = function (it) {
  defineProperty(it, METADATA, { value: {
    objectID: 'O' + ++id, // object ID
    weakData: {}          // weak collections IDs
  } });
};

var fastKey = function (it, create) {
  // return a primitive with prefix
  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F';
    // not necessary to add metadata
    if (!create) return 'E';
    // add missing metadata
    setMetadata(it);
  // return object ID
  } return it[METADATA].objectID;
};

var getWeakData = function (it, create) {
  if (!has(it, METADATA)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true;
    // not necessary to add metadata
    if (!create) return false;
    // add missing metadata
    setMetadata(it);
  // return the store of weak collections IDs
  } return it[METADATA].weakData;
};

// add metadata on freeze-family methods calling
var onFreeze = function (it) {
  if (FREEZING && meta.REQUIRED && isExtensible(it) && !has(it, METADATA)) setMetadata(it);
  return it;
};

var meta = module.exports = {
  REQUIRED: false,
  fastKey: fastKey,
  getWeakData: getWeakData,
  onFreeze: onFreeze
};

hiddenKeys[METADATA] = true;


/***/ }),

/***/ "f20d":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return _getPrototypeOf; });
/* harmony import */ var core_js_modules_es_object_get_prototype_of__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("3410");
/* harmony import */ var core_js_modules_es_object_get_prototype_of__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(core_js_modules_es_object_get_prototype_of__WEBPACK_IMPORTED_MODULE_0__);

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

/***/ }),

/***/ "f2ea":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";

// EXPORTS
__webpack_require__.d(__webpack_exports__, "b", function() { return /* binding */ ckeditorerror_CKEditorError; });
__webpack_require__.d(__webpack_exports__, "a", function() { return /* binding */ attachLinkToDocumentation; });

// UNUSED EXPORTS: DOCUMENTATION_URL

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.function.name.js
var es_function_name = __webpack_require__("b0c0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
var es_regexp_exec = __webpack_require__("ac1f");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.match.js
var es_string_match = __webpack_require__("466d");

// EXTERNAL MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js
var classCallCheck = __webpack_require__("276c");

// EXTERNAL MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/createClass.js
var createClass = __webpack_require__("e954");

// EXTERNAL MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/inherits.js
var inherits = __webpack_require__("920b");

// EXTERNAL MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/createSuper.js + 1 modules
var createSuper = __webpack_require__("92a6");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.iterator.js
var es_array_iterator = __webpack_require__("e260");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.map.js
var es_map = __webpack_require__("4ec9");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.iterator.js
var es_string_iterator = __webpack_require__("3ca3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js
var web_dom_collections_iterator = __webpack_require__("ddb0");

// EXTERNAL MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
var getPrototypeOf = __webpack_require__("f20d");

// EXTERNAL MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
var setPrototypeOf = __webpack_require__("0de3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.index-of.js
var es_array_index_of = __webpack_require__("c975");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.to-string.js
var es_regexp_to_string = __webpack_require__("25f0");

// CONCATENATED MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/isNativeFunction.js



function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
// EXTERNAL MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/construct.js
var construct = __webpack_require__("e7f1");

// CONCATENATED MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/wrapNativeSuper.js









function wrapNativeSuper_wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  wrapNativeSuper_wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return Object(construct["a" /* default */])(Class, arguments, Object(getPrototypeOf["a" /* default */])(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return Object(setPrototypeOf["a" /* default */])(Wrapper, Class);
  };

  return wrapNativeSuper_wrapNativeSuper(Class);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/ckeditorerror.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/ckeditorerror
 */

/**
 * URL to the documentation with error codes.
 */
var DOCUMENTATION_URL = 'https://ckeditor.com/docs/ckeditor5/latest/framework/guides/support/error-codes.html';
/**
 * The CKEditor error class.
 *
 * You should throw `CKEditorError` when:
 *
 * * An unexpected situation occurred and the editor (most probably) will not work properly. Such exception will be handled
 * by the {@link module:watchdog/watchdog~Watchdog watchdog} (if it is integrated),
 * * If the editor is incorrectly integrated or the editor API is used in the wrong way. This way you will give
 * feedback to the developer as soon as possible. Keep in mind that for common integration issues which should not
 * stop editor initialization (like missing upload adapter, wrong name of a toolbar component) we use `console.warn()` with
 * {@link module:utils/ckeditorerror~attachLinkToDocumentation `attachLinkToDocumentation()`}
 * to improve developers experience and let them see the working editor as soon as possible.
 *
 *		/**
 *		 * Error thrown when a plugin cannot be loaded due to JavaScript errors, lack of plugins with a given name, etc.
 *		 *
 *		 * @error plugin-load
 *		 * @param pluginName The name of the plugin that could not be loaded.
 *		 * @param moduleName The name of the module which tried to load this plugin.
 *		 * /
 *		throw new CKEditorError( 'plugin-load: It was not possible to load the "{$pluginName}" plugin in module "{$moduleName}', {
 *			pluginName: 'foo',
 *			moduleName: 'bar'
 *		} );
 *
 * @extends Error
 */

var ckeditorerror_CKEditorError = /*#__PURE__*/function (_Error) {
  Object(inherits["a" /* default */])(CKEditorError, _Error);

  var _super = Object(createSuper["a" /* default */])(CKEditorError);

  /**
   * Creates an instance of the CKEditorError class.
   *
   * @param {String} message The error message in an `error-name: Error message.` format.
   * During the minification process the "Error message" part will be removed to limit the code size
   * and a link to this error documentation will be added to the `message`.
   * @param {Object|null} context A context of the error by which the {@link module:watchdog/watchdog~Watchdog watchdog}
   * is able to determine which editor crashed. It should be an editor instance or a property connected to it. It can be also
   * a `null` value if the editor should not be restarted in case of the error (e.g. during the editor initialization).
   * The error context should be checked using the `areConnectedThroughProperties( editor, context )` utility
   * to check if the object works as the context.
   * @param {Object} [data] Additional data describing the error. A stringified version of this object
   * will be appended to the error message, so the data are quickly visible in the console. The original
   * data object will also be later available under the {@link #data} property.
   */
  function CKEditorError(message, context, data) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, CKEditorError);

    message = attachLinkToDocumentation(message);

    if (data) {
      message += ' ' + JSON.stringify(data);
    }

    _this = _super.call(this, message);
    /**
     * @type {String}
     */

    _this.name = 'CKEditorError';
    /**
     * A context of the error by which the Watchdog is able to determine which editor crashed.
     *
     * @type {Object|null}
     */

    _this.context = context;
    /**
     * The additional error data passed to the constructor. Undefined if none was passed.
     *
     * @type {Object|undefined}
     */

    _this.data = data;
    return _this;
  }
  /**
   * Checks if the error is of the `CKEditorError` type.
   */


  Object(createClass["a" /* default */])(CKEditorError, [{
    key: "is",
    value: function is(type) {
      return type === 'CKEditorError';
    }
    /**
     * A utility that ensures the the thrown error is a {@link module:utils/ckeditorerror~CKEditorError} one.
     * It is useful when combined with the {@link module:watchdog/watchdog~Watchdog} feature, which can restart the editor in case
     * of a {@link module:utils/ckeditorerror~CKEditorError} error.
     *
     * @param {Error} err An error.
     * @param {Object} context An object connected through properties with the editor instance. This context will be used
     * by the watchdog to verify which editor should be restarted.
     */

  }], [{
    key: "rethrowUnexpectedError",
    value: function rethrowUnexpectedError(err, context) {
      if (err.is && err.is('CKEditorError')) {
        throw err;
      }
      /**
       * An unexpected error occurred inside the CKEditor 5 codebase. This error will look like the original one
       * to make the debugging easier.
       *
       * This error is only useful when the editor is initialized using the {@link module:watchdog/watchdog~Watchdog} feature.
       * In case of such error (or any {@link module:utils/ckeditorerror~CKEditorError} error) the watchdog should restart the editor.
       *
       * @error unexpected-error
       */


      var error = new CKEditorError(err.message, context); // Restore the original stack trace to make the error look like the original one.
      // See https://github.com/ckeditor/ckeditor5/issues/5595 for more details.

      error.stack = err.stack;
      throw error;
    }
  }]);

  return CKEditorError;
}( /*#__PURE__*/wrapNativeSuper_wrapNativeSuper(Error));
/**
 * Attaches the link to the documentation at the end of the error message. Use whenever you log a warning or error on the
 * console. It is also used by {@link module:utils/ckeditorerror~CKEditorError}.
 *
 *		 /**
 *		  * There was a problem processing the configuration of the toolbar. The item with the given
 *		  * name does not exist so it was omitted when rendering the toolbar.
 *		  *
 *		  * @error toolbarview-item-unavailable
 *		  * @param {String} name The name of the component.
 *		  * /
 *		 console.warn( attachLinkToDocumentation(
 *		 	'toolbarview-item-unavailable: The requested toolbar item is unavailable.' ), { name } );
 *
 * @param {String} message Message to be logged.
 * @returns {String}
 */



function attachLinkToDocumentation(message) {
  var matchedErrorName = message.match(/^([^:]+):/);

  if (!matchedErrorName) {
    return message;
  }

  return message + " Read more: ".concat(DOCUMENTATION_URL, "#error-").concat(matchedErrorName[1], "\n");
}

/***/ }),

/***/ "f422":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M8.537 14.813a.888.888 0 1 1-1.254-1.255L10.84 10 7.283 6.442a.888.888 0 1 1 1.254-1.255L12.74 9.39a.888.888 0 0 1-.16 1.382l-4.043 4.042z\"/></svg>"

/***/ }),

/***/ "f5df":
/***/ (function(module, exports, __webpack_require__) {

var TO_STRING_TAG_SUPPORT = __webpack_require__("00ee");
var classofRaw = __webpack_require__("c6b6");
var wellKnownSymbol = __webpack_require__("b622");

var TO_STRING_TAG = wellKnownSymbol('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function () { return arguments; }()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function (it, key) {
  try {
    return it[key];
  } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
module.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {
  var O, tag, result;
  return it === undefined ? 'Undefined' : it === null ? 'Null'
    // @@toStringTag case
    : typeof (tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
    // builtinTag case
    : CORRECT_ARGUMENTS ? classofRaw(O)
    // ES3 arguments fallback
    : (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};


/***/ }),

/***/ "f5e9":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "f67e":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M2.5 1h15A1.5 1.5 0 0 1 19 2.5v15a1.5 1.5 0 0 1-1.5 1.5h-15A1.5 1.5 0 0 1 1 17.5v-15A1.5 1.5 0 0 1 2.5 1zM2 2v16h16V2H2z\" opacity=\".6\"/><path d=\"M7 2h1v16H7V2zm5 0h1v7h-1V2zm6 5v1H2V7h16zM8 12v1H2v-1h6z\" opacity=\".6\"/><path d=\"M7 7h12a1 1 0 0 1 1 1v11a1 1 0 0 1-1 1H7a1 1 0 0 1-1-1V8a1 1 0 0 1 1-1zm1 2v9h10V9H8z\"/></svg>"

/***/ }),

/***/ "f772":
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__("5692");
var uid = __webpack_require__("90e3");

var keys = shared('keys');

module.exports = function (key) {
  return keys[key] || (keys[key] = uid(key));
};


/***/ }),

/***/ "f8cd":
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__("a691");

module.exports = function (it) {
  var result = toInteger(it);
  if (result < 0) throw RangeError("The argument can't be less than 0");
  return result;
};


/***/ }),

/***/ "f945":
/***/ (function(module, exports) {

module.exports = "<svg viewBox=\"0 0 20 20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M5.042 9.367l2.189 1.837a.75.75 0 0 1-.965 1.149l-3.788-3.18a.747.747 0 0 1-.21-.284.75.75 0 0 1 .17-.945L6.23 4.762a.75.75 0 1 1 .964 1.15L4.863 7.866h8.917A.75.75 0 0 1 14 7.9a4 4 0 1 1-1.477 7.718l.344-1.489a2.5 2.5 0 1 0 1.094-4.73l.008-.032H5.042z\"/></svg>"

/***/ }),

/***/ "fa71":
/***/ (function(module, exports) {

module.exports = "<svg width=\"20\" height=\"20\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M.75 15.5a.75.75 0 0 1 .75.75V18l.008.09A.5.5 0 0 0 2 18.5h1.75a.75.75 0 1 1 0 1.5H1.5l-.144-.007a1.5 1.5 0 0 1-1.35-1.349L0 18.5v-2.25a.75.75 0 0 1 .75-.75zm18.5 0a.75.75 0 0 1 .75.75v2.25l-.007.144a1.5 1.5 0 0 1-1.349 1.35L18.5 20h-2.25a.75.75 0 1 1 0-1.5H18a.5.5 0 0 0 .492-.41L18.5 18v-1.75a.75.75 0 0 1 .75-.75zm-10.45 3c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2v-1.1c0-.11.09-.2.2-.2h1.6zm.45-5.5a.75.75 0 1 1 0 1.5h-8.5a.75.75 0 1 1 0-1.5h8.5zM1.3 11c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2v-1.6c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5H4.75a.75.75 0 1 1 0-1.5h10.5zM1.3 7c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2H.2a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm18.5 0c.11 0 .2.09.2.2v1.6a.2.2 0 0 1-.2.2h-1.1a.2.2 0 0 1-.2-.2V7.2c0-.11.09-.2.2-.2h1.1zm-4.55-2a.75.75 0 1 1 0 1.5h-2.5a.75.75 0 1 1 0-1.5h2.5zm-5 0a.75.75 0 1 1 0 1.5h-5.5a.75.75 0 0 1 0-1.5h5.5zm-6.5-5a.75.75 0 0 1 0 1.5H2a.5.5 0 0 0-.492.41L1.5 2v1.75a.75.75 0 0 1-1.5 0V1.5l.007-.144A1.5 1.5 0 0 1 1.356.006L1.5 0h2.25zM18.5 0l.144.007a1.5 1.5 0 0 1 1.35 1.349L20 1.5v2.25a.75.75 0 1 1-1.5 0V2l-.008-.09A.5.5 0 0 0 18 1.5h-1.75a.75.75 0 1 1 0-1.5h2.25zM8.8 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2H7.2a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6zm4 0c.11 0 .2.09.2.2v1.1a.2.2 0 0 1-.2.2h-1.6a.2.2 0 0 1-.2-.2V.2c0-.11.09-.2.2-.2h1.6z\"/></svg>"

/***/ }),

/***/ "fb15":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/setPublicPath.js
// This file is imported into lib/wc client bundles.

if (typeof window !== 'undefined') {
  var currentScript = window.document.currentScript
  if (true) {
    var getCurrentScript = __webpack_require__("8875")
    currentScript = getCurrentScript()

    // for backward compatibility, because previously we directly included the polyfill
    if (!('currentScript' in document)) {
      Object.defineProperty(document, 'currentScript', { get: getCurrentScript })
    }
  }

  var setPublicPath_src = currentScript && currentScript.src.match(/(.+\/)[^/]+\.js(\?.*)?$/)
  if (setPublicPath_src) {
    __webpack_require__.p = setPublicPath_src[1] // eslint-disable-line
  }
}

// Indicate to webpack that this file can be concatenated
/* harmony default export */ var setPublicPath = (null);

// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js?{"cacheDirectory":"node_modules/.cache/vue-loader","cacheIdentifier":"5c9188f9-vue-loader-template"}!./node_modules/vue-loader/lib/loaders/templateLoader.js??vue-loader-options!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/tmeditor/ckeditor.vue?vue&type=template&id=6135df79&
var ckeditorvue_type_template_id_6135df79_render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _vm._m(0)}
var staticRenderFns = [function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',{staticClass:"tm-editor",domProps:{"innerHTML":_vm._s(_vm.value)}})}]


// CONCATENATED MODULE: ./src/components/tmeditor/ckeditor.vue?vue&type=template&id=6135df79&

// EXTERNAL MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/classCallCheck.js
var classCallCheck = __webpack_require__("276c");

// EXTERNAL MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/inherits.js
var inherits = __webpack_require__("920b");

// EXTERNAL MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/createSuper.js + 1 modules
var createSuper = __webpack_require__("92a6");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.to-string.js
var es_object_to_string = __webpack_require__("d3b7");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.promise.js
var es_promise = __webpack_require__("e6cf");

// EXTERNAL MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/createClass.js
var createClass = __webpack_require__("e954");

// EXTERNAL MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
var assertThisInitialized = __webpack_require__("2c4c");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.get-own-property-descriptor.js
var es_object_get_own_property_descriptor = __webpack_require__("e439");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.reflect.get.js
var es_reflect_get = __webpack_require__("5d41");

// EXTERNAL MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
var getPrototypeOf = __webpack_require__("f20d");

// CONCATENATED MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/superPropBase.js

function _superPropBase(object, property) {
  while (!Object.prototype.hasOwnProperty.call(object, property)) {
    object = Object(getPrototypeOf["a" /* default */])(object);
    if (object === null) break;
  }

  return object;
}
// CONCATENATED MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/get.js



function get_get(target, property, receiver) {
  if (typeof Reflect !== "undefined" && Reflect.get) {
    get_get = Reflect.get;
  } else {
    get_get = function _get(target, property, receiver) {
      var base = _superPropBase(target, property);
      if (!base) return;
      var desc = Object.getOwnPropertyDescriptor(base, property);

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return desc.value;
    };
  }

  return get_get(target, property, receiver || target);
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.concat.js
var es_array_concat = __webpack_require__("99af");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.from.js
var es_array_from = __webpack_require__("a630");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.iterator.js
var es_string_iterator = __webpack_require__("3ca3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.includes.js
var es_array_includes = __webpack_require__("caad");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.iterator.js
var es_array_iterator = __webpack_require__("e260");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.iterator.js
var web_dom_collections_iterator = __webpack_require__("ddb0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.js
var es_symbol = __webpack_require__("a4d3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.description.js
var es_symbol_description = __webpack_require__("e01a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.symbol.iterator.js
var es_symbol_iterator = __webpack_require__("d28b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.slice.js
var es_array_slice = __webpack_require__("fb6a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.function.name.js
var es_function_name = __webpack_require__("b0c0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.to-string.js
var es_regexp_to_string = __webpack_require__("25f0");

// CONCATENATED MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
// CONCATENATED MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js







function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
// CONCATENATED MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js








function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;

  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function F() {};

      return {
        s: F,
        n: function n() {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function e(_e) {
          throw _e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function s() {
      it = o[Symbol.iterator]();
    },
    n: function n() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function e(_e2) {
      didErr = true;
      err = _e2;
    },
    f: function f() {
      try {
        if (!normalCompletion && it["return"] != null) it["return"]();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.for-each.js
var es_array_for_each = __webpack_require__("4160");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.keys.js
var es_object_keys = __webpack_require__("b64b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.exec.js
var es_regexp_exec = __webpack_require__("ac1f");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.split.js
var es_string_split = __webpack_require__("1276");

// EXTERNAL MODULE: ./node_modules/core-js/modules/web.dom-collections.for-each.js
var web_dom_collections_for_each = __webpack_require__("159b");

// EXTERNAL MODULE: ./node_modules/regenerator-runtime/runtime.js
var runtime = __webpack_require__("96cf");

// EXTERNAL MODULE: ./node_modules/lodash-es/_root.js
var _root = __webpack_require__("26ee");

// CONCATENATED MODULE: ./node_modules/lodash-es/_Symbol.js


/** Built-in value references. */
var _Symbol_Symbol = _root["a" /* default */].Symbol;

/* harmony default export */ var _Symbol = (_Symbol_Symbol);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getRawTag.js


/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _getRawTag_hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = _getRawTag_hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

/* harmony default export */ var _getRawTag = (getRawTag);

// CONCATENATED MODULE: ./node_modules/lodash-es/_objectToString.js
/** Used for built-in method references. */
var _objectToString_objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var _objectToString_nativeObjectToString = _objectToString_objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return _objectToString_nativeObjectToString.call(value);
}

/* harmony default export */ var _objectToString = (objectToString);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseGetTag.js




/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var _baseGetTag_symToStringTag = _Symbol ? _Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (_baseGetTag_symToStringTag && _baseGetTag_symToStringTag in Object(value))
    ? _getRawTag(value)
    : _objectToString(value);
}

/* harmony default export */ var _baseGetTag = (baseGetTag);

// CONCATENATED MODULE: ./node_modules/lodash-es/_overArg.js
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

/* harmony default export */ var _overArg = (overArg);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getPrototype.js


/** Built-in value references. */
var getPrototype = _overArg(Object.getPrototypeOf, Object);

/* harmony default export */ var _getPrototype = (getPrototype);

// CONCATENATED MODULE: ./node_modules/lodash-es/isObjectLike.js
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

/* harmony default export */ var lodash_es_isObjectLike = (isObjectLike);

// CONCATENATED MODULE: ./node_modules/lodash-es/isPlainObject.js




/** `Object#toString` result references. */
var objectTag = '[object Object]';

/** Used for built-in method references. */
var funcProto = Function.prototype,
    isPlainObject_objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var isPlainObject_hasOwnProperty = isPlainObject_objectProto.hasOwnProperty;

/** Used to infer the `Object` constructor. */
var objectCtorString = funcToString.call(Object);

/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */
function isPlainObject(value) {
  if (!lodash_es_isObjectLike(value) || _baseGetTag(value) != objectTag) {
    return false;
  }
  var proto = _getPrototype(value);
  if (proto === null) {
    return true;
  }
  var Ctor = isPlainObject_hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  return typeof Ctor == 'function' && Ctor instanceof Ctor &&
    funcToString.call(Ctor) == objectCtorString;
}

/* harmony default export */ var lodash_es_isPlainObject = (isPlainObject);

// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheClear.js
/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

/* harmony default export */ var _listCacheClear = (listCacheClear);

// CONCATENATED MODULE: ./node_modules/lodash-es/eq.js
/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

/* harmony default export */ var lodash_es_eq = (eq);

// CONCATENATED MODULE: ./node_modules/lodash-es/_assocIndexOf.js


/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (lodash_es_eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

/* harmony default export */ var _assocIndexOf = (assocIndexOf);

// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheDelete.js


/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

/* harmony default export */ var _listCacheDelete = (listCacheDelete);

// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheGet.js


/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

/* harmony default export */ var _listCacheGet = (listCacheGet);

// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheHas.js


/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return _assocIndexOf(this.__data__, key) > -1;
}

/* harmony default export */ var _listCacheHas = (listCacheHas);

// CONCATENATED MODULE: ./node_modules/lodash-es/_listCacheSet.js


/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = _assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

/* harmony default export */ var _listCacheSet = (listCacheSet);

// CONCATENATED MODULE: ./node_modules/lodash-es/_ListCache.js






/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = _listCacheClear;
ListCache.prototype['delete'] = _listCacheDelete;
ListCache.prototype.get = _listCacheGet;
ListCache.prototype.has = _listCacheHas;
ListCache.prototype.set = _listCacheSet;

/* harmony default export */ var _ListCache = (ListCache);

// CONCATENATED MODULE: ./node_modules/lodash-es/_stackClear.js


/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new _ListCache;
  this.size = 0;
}

/* harmony default export */ var _stackClear = (stackClear);

// CONCATENATED MODULE: ./node_modules/lodash-es/_stackDelete.js
/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

/* harmony default export */ var _stackDelete = (stackDelete);

// CONCATENATED MODULE: ./node_modules/lodash-es/_stackGet.js
/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

/* harmony default export */ var _stackGet = (stackGet);

// CONCATENATED MODULE: ./node_modules/lodash-es/_stackHas.js
/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

/* harmony default export */ var _stackHas = (stackHas);

// CONCATENATED MODULE: ./node_modules/lodash-es/isObject.js
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

/* harmony default export */ var lodash_es_isObject = (isObject);

// CONCATENATED MODULE: ./node_modules/lodash-es/isFunction.js



/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!lodash_es_isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = _baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

/* harmony default export */ var lodash_es_isFunction = (isFunction);

// CONCATENATED MODULE: ./node_modules/lodash-es/_coreJsData.js


/** Used to detect overreaching core-js shims. */
var coreJsData = _root["a" /* default */]['__core-js_shared__'];

/* harmony default export */ var _coreJsData = (coreJsData);

// CONCATENATED MODULE: ./node_modules/lodash-es/_isMasked.js


/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(_coreJsData && _coreJsData.keys && _coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

/* harmony default export */ var _isMasked = (isMasked);

// CONCATENATED MODULE: ./node_modules/lodash-es/_toSource.js
/** Used for built-in method references. */
var _toSource_funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var _toSource_funcToString = _toSource_funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return _toSource_funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

/* harmony default export */ var _toSource = (toSource);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsNative.js





/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var _baseIsNative_funcProto = Function.prototype,
    _baseIsNative_objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var _baseIsNative_funcToString = _baseIsNative_funcProto.toString;

/** Used to check objects for own properties. */
var _baseIsNative_hasOwnProperty = _baseIsNative_objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  _baseIsNative_funcToString.call(_baseIsNative_hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!lodash_es_isObject(value) || _isMasked(value)) {
    return false;
  }
  var pattern = lodash_es_isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(_toSource(value));
}

/* harmony default export */ var _baseIsNative = (baseIsNative);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getValue.js
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function _getValue_getValue(object, key) {
  return object == null ? undefined : object[key];
}

/* harmony default export */ var lodash_es_getValue = (_getValue_getValue);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getNative.js



/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = lodash_es_getValue(object, key);
  return _baseIsNative(value) ? value : undefined;
}

/* harmony default export */ var _getNative = (getNative);

// CONCATENATED MODULE: ./node_modules/lodash-es/_Map.js



/* Built-in method references that are verified to be native. */
var _Map_Map = _getNative(_root["a" /* default */], 'Map');

/* harmony default export */ var _Map = (_Map_Map);

// CONCATENATED MODULE: ./node_modules/lodash-es/_nativeCreate.js


/* Built-in method references that are verified to be native. */
var nativeCreate = _getNative(Object, 'create');

/* harmony default export */ var _nativeCreate = (nativeCreate);

// CONCATENATED MODULE: ./node_modules/lodash-es/_hashClear.js


/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = _nativeCreate ? _nativeCreate(null) : {};
  this.size = 0;
}

/* harmony default export */ var _hashClear = (hashClear);

// CONCATENATED MODULE: ./node_modules/lodash-es/_hashDelete.js
/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

/* harmony default export */ var _hashDelete = (hashDelete);

// CONCATENATED MODULE: ./node_modules/lodash-es/_hashGet.js


/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var _hashGet_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _hashGet_hasOwnProperty = _hashGet_objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (_nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return _hashGet_hasOwnProperty.call(data, key) ? data[key] : undefined;
}

/* harmony default export */ var _hashGet = (hashGet);

// CONCATENATED MODULE: ./node_modules/lodash-es/_hashHas.js


/** Used for built-in method references. */
var _hashHas_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _hashHas_hasOwnProperty = _hashHas_objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return _nativeCreate ? (data[key] !== undefined) : _hashHas_hasOwnProperty.call(data, key);
}

/* harmony default export */ var _hashHas = (hashHas);

// CONCATENATED MODULE: ./node_modules/lodash-es/_hashSet.js


/** Used to stand-in for `undefined` hash values. */
var _hashSet_HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (_nativeCreate && value === undefined) ? _hashSet_HASH_UNDEFINED : value;
  return this;
}

/* harmony default export */ var _hashSet = (hashSet);

// CONCATENATED MODULE: ./node_modules/lodash-es/_Hash.js






/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = _hashClear;
Hash.prototype['delete'] = _hashDelete;
Hash.prototype.get = _hashGet;
Hash.prototype.has = _hashHas;
Hash.prototype.set = _hashSet;

/* harmony default export */ var _Hash = (Hash);

// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheClear.js




/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new _Hash,
    'map': new (_Map || _ListCache),
    'string': new _Hash
  };
}

/* harmony default export */ var _mapCacheClear = (mapCacheClear);

// CONCATENATED MODULE: ./node_modules/lodash-es/_isKeyable.js
/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

/* harmony default export */ var _isKeyable = (isKeyable);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getMapData.js


/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return _isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

/* harmony default export */ var _getMapData = (getMapData);

// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheDelete.js


/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = _getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

/* harmony default export */ var _mapCacheDelete = (mapCacheDelete);

// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheGet.js


/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return _getMapData(this, key).get(key);
}

/* harmony default export */ var _mapCacheGet = (mapCacheGet);

// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheHas.js


/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return _getMapData(this, key).has(key);
}

/* harmony default export */ var _mapCacheHas = (mapCacheHas);

// CONCATENATED MODULE: ./node_modules/lodash-es/_mapCacheSet.js


/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = _getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

/* harmony default export */ var _mapCacheSet = (mapCacheSet);

// CONCATENATED MODULE: ./node_modules/lodash-es/_MapCache.js






/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = _mapCacheClear;
MapCache.prototype['delete'] = _mapCacheDelete;
MapCache.prototype.get = _mapCacheGet;
MapCache.prototype.has = _mapCacheHas;
MapCache.prototype.set = _mapCacheSet;

/* harmony default export */ var _MapCache = (MapCache);

// CONCATENATED MODULE: ./node_modules/lodash-es/_stackSet.js




/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof _ListCache) {
    var pairs = data.__data__;
    if (!_Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new _MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

/* harmony default export */ var _stackSet = (stackSet);

// CONCATENATED MODULE: ./node_modules/lodash-es/_Stack.js







/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new _ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = _stackClear;
Stack.prototype['delete'] = _stackDelete;
Stack.prototype.get = _stackGet;
Stack.prototype.has = _stackHas;
Stack.prototype.set = _stackSet;

/* harmony default export */ var _Stack = (Stack);

// CONCATENATED MODULE: ./node_modules/lodash-es/_arrayEach.js
/**
 * A specialized version of `_.forEach` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns `array`.
 */
function arrayEach(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (iteratee(array[index], index, array) === false) {
      break;
    }
  }
  return array;
}

/* harmony default export */ var _arrayEach = (arrayEach);

// CONCATENATED MODULE: ./node_modules/lodash-es/_defineProperty.js


var defineProperty = (function() {
  try {
    var func = _getNative(Object, 'defineProperty');
    func({}, '', {});
    return func;
  } catch (e) {}
}());

/* harmony default export */ var _defineProperty = (defineProperty);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseAssignValue.js


/**
 * The base implementation of `assignValue` and `assignMergeValue` without
 * value checks.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function baseAssignValue(object, key, value) {
  if (key == '__proto__' && _defineProperty) {
    _defineProperty(object, key, {
      'configurable': true,
      'enumerable': true,
      'value': value,
      'writable': true
    });
  } else {
    object[key] = value;
  }
}

/* harmony default export */ var _baseAssignValue = (baseAssignValue);

// CONCATENATED MODULE: ./node_modules/lodash-es/_assignValue.js



/** Used for built-in method references. */
var _assignValue_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _assignValue_hasOwnProperty = _assignValue_objectProto.hasOwnProperty;

/**
 * Assigns `value` to `key` of `object` if the existing value is not equivalent
 * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * for equality comparisons.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignValue(object, key, value) {
  var objValue = object[key];
  if (!(_assignValue_hasOwnProperty.call(object, key) && lodash_es_eq(objValue, value)) ||
      (value === undefined && !(key in object))) {
    _baseAssignValue(object, key, value);
  }
}

/* harmony default export */ var _assignValue = (assignValue);

// CONCATENATED MODULE: ./node_modules/lodash-es/_copyObject.js



/**
 * Copies properties of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy properties from.
 * @param {Array} props The property identifiers to copy.
 * @param {Object} [object={}] The object to copy properties to.
 * @param {Function} [customizer] The function to customize copied values.
 * @returns {Object} Returns `object`.
 */
function copyObject(source, props, object, customizer) {
  var isNew = !object;
  object || (object = {});

  var index = -1,
      length = props.length;

  while (++index < length) {
    var key = props[index];

    var newValue = customizer
      ? customizer(object[key], source[key], key, object, source)
      : undefined;

    if (newValue === undefined) {
      newValue = source[key];
    }
    if (isNew) {
      _baseAssignValue(object, key, newValue);
    } else {
      _assignValue(object, key, newValue);
    }
  }
  return object;
}

/* harmony default export */ var _copyObject = (copyObject);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseTimes.js
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

/* harmony default export */ var _baseTimes = (baseTimes);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsArguments.js



/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return lodash_es_isObjectLike(value) && _baseGetTag(value) == argsTag;
}

/* harmony default export */ var _baseIsArguments = (baseIsArguments);

// CONCATENATED MODULE: ./node_modules/lodash-es/isArguments.js



/** Used for built-in method references. */
var isArguments_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var isArguments_hasOwnProperty = isArguments_objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = isArguments_objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = _baseIsArguments(function() { return arguments; }()) ? _baseIsArguments : function(value) {
  return lodash_es_isObjectLike(value) && isArguments_hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

/* harmony default export */ var lodash_es_isArguments = (isArguments);

// CONCATENATED MODULE: ./node_modules/lodash-es/isArray.js
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

/* harmony default export */ var lodash_es_isArray = (isArray);

// EXTERNAL MODULE: ./node_modules/lodash-es/isBuffer.js
var isBuffer = __webpack_require__("58e0");

// CONCATENATED MODULE: ./node_modules/lodash-es/_isIndex.js
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

/* harmony default export */ var _isIndex = (isIndex);

// CONCATENATED MODULE: ./node_modules/lodash-es/isLength.js
/** Used as references for various `Number` constants. */
var isLength_MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= isLength_MAX_SAFE_INTEGER;
}

/* harmony default export */ var lodash_es_isLength = (isLength);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsTypedArray.js




/** `Object#toString` result references. */
var _baseIsTypedArray_argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    _baseIsTypedArray_funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    _baseIsTypedArray_objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[_baseIsTypedArray_argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[_baseIsTypedArray_funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[_baseIsTypedArray_objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return lodash_es_isObjectLike(value) &&
    lodash_es_isLength(value.length) && !!typedArrayTags[_baseGetTag(value)];
}

/* harmony default export */ var _baseIsTypedArray = (baseIsTypedArray);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseUnary.js
/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

/* harmony default export */ var _baseUnary = (baseUnary);

// EXTERNAL MODULE: ./node_modules/lodash-es/_nodeUtil.js
var _nodeUtil = __webpack_require__("c6eb");

// CONCATENATED MODULE: ./node_modules/lodash-es/isTypedArray.js




/* Node.js helper references. */
var nodeIsTypedArray = _nodeUtil["a" /* default */] && _nodeUtil["a" /* default */].isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? _baseUnary(nodeIsTypedArray) : _baseIsTypedArray;

/* harmony default export */ var lodash_es_isTypedArray = (isTypedArray);

// CONCATENATED MODULE: ./node_modules/lodash-es/_arrayLikeKeys.js







/** Used for built-in method references. */
var _arrayLikeKeys_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _arrayLikeKeys_hasOwnProperty = _arrayLikeKeys_objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = lodash_es_isArray(value),
      isArg = !isArr && lodash_es_isArguments(value),
      isBuff = !isArr && !isArg && Object(isBuffer["a" /* default */])(value),
      isType = !isArr && !isArg && !isBuff && lodash_es_isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? _baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || _arrayLikeKeys_hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           _isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ var _arrayLikeKeys = (arrayLikeKeys);

// CONCATENATED MODULE: ./node_modules/lodash-es/_isPrototype.js
/** Used for built-in method references. */
var _isPrototype_objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || _isPrototype_objectProto;

  return value === proto;
}

/* harmony default export */ var _isPrototype = (isPrototype);

// CONCATENATED MODULE: ./node_modules/lodash-es/_nativeKeys.js


/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = _overArg(Object.keys, Object);

/* harmony default export */ var _nativeKeys = (nativeKeys);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseKeys.js



/** Used for built-in method references. */
var _baseKeys_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _baseKeys_hasOwnProperty = _baseKeys_objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!_isPrototype(object)) {
    return _nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (_baseKeys_hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ var _baseKeys = (baseKeys);

// CONCATENATED MODULE: ./node_modules/lodash-es/isArrayLike.js



/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && lodash_es_isLength(value.length) && !lodash_es_isFunction(value);
}

/* harmony default export */ var lodash_es_isArrayLike = (isArrayLike);

// CONCATENATED MODULE: ./node_modules/lodash-es/keys.js




/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys_keys(object) {
  return lodash_es_isArrayLike(object) ? _arrayLikeKeys(object) : _baseKeys(object);
}

/* harmony default export */ var lodash_es_keys = (keys_keys);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseAssign.js



/**
 * The base implementation of `_.assign` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssign(object, source) {
  return object && _copyObject(source, lodash_es_keys(source), object);
}

/* harmony default export */ var _baseAssign = (baseAssign);

// CONCATENATED MODULE: ./node_modules/lodash-es/_nativeKeysIn.js
/**
 * This function is like
 * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * except that it includes inherited enumerable properties.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function nativeKeysIn(object) {
  var result = [];
  if (object != null) {
    for (var key in Object(object)) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ var _nativeKeysIn = (nativeKeysIn);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseKeysIn.js




/** Used for built-in method references. */
var _baseKeysIn_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _baseKeysIn_hasOwnProperty = _baseKeysIn_objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeysIn(object) {
  if (!lodash_es_isObject(object)) {
    return _nativeKeysIn(object);
  }
  var isProto = _isPrototype(object),
      result = [];

  for (var key in object) {
    if (!(key == 'constructor' && (isProto || !_baseKeysIn_hasOwnProperty.call(object, key)))) {
      result.push(key);
    }
  }
  return result;
}

/* harmony default export */ var _baseKeysIn = (baseKeysIn);

// CONCATENATED MODULE: ./node_modules/lodash-es/keysIn.js




/**
 * Creates an array of the own and inherited enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keysIn(new Foo);
 * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
 */
function keysIn_keysIn(object) {
  return lodash_es_isArrayLike(object) ? _arrayLikeKeys(object, true) : _baseKeysIn(object);
}

/* harmony default export */ var lodash_es_keysIn = (keysIn_keysIn);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseAssignIn.js



/**
 * The base implementation of `_.assignIn` without support for multiple sources
 * or `customizer` functions.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @returns {Object} Returns `object`.
 */
function baseAssignIn(object, source) {
  return object && _copyObject(source, lodash_es_keysIn(source), object);
}

/* harmony default export */ var _baseAssignIn = (baseAssignIn);

// EXTERNAL MODULE: ./node_modules/lodash-es/_cloneBuffer.js
var _cloneBuffer = __webpack_require__("dff1");

// CONCATENATED MODULE: ./node_modules/lodash-es/_copyArray.js
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

/* harmony default export */ var _copyArray = (copyArray);

// CONCATENATED MODULE: ./node_modules/lodash-es/_arrayFilter.js
/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

/* harmony default export */ var _arrayFilter = (arrayFilter);

// CONCATENATED MODULE: ./node_modules/lodash-es/stubArray.js
/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

/* harmony default export */ var lodash_es_stubArray = (stubArray);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getSymbols.js



/** Used for built-in method references. */
var _getSymbols_objectProto = Object.prototype;

/** Built-in value references. */
var _getSymbols_propertyIsEnumerable = _getSymbols_objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? lodash_es_stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return _arrayFilter(nativeGetSymbols(object), function(symbol) {
    return _getSymbols_propertyIsEnumerable.call(object, symbol);
  });
};

/* harmony default export */ var _getSymbols = (getSymbols);

// CONCATENATED MODULE: ./node_modules/lodash-es/_copySymbols.js



/**
 * Copies own symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbols(source, object) {
  return _copyObject(source, _getSymbols(source), object);
}

/* harmony default export */ var _copySymbols = (copySymbols);

// CONCATENATED MODULE: ./node_modules/lodash-es/_arrayPush.js
/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

/* harmony default export */ var _arrayPush = (arrayPush);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getSymbolsIn.js





/* Built-in method references for those with the same name as other `lodash` methods. */
var _getSymbolsIn_nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own and inherited enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbolsIn = !_getSymbolsIn_nativeGetSymbols ? lodash_es_stubArray : function(object) {
  var result = [];
  while (object) {
    _arrayPush(result, _getSymbols(object));
    object = _getPrototype(object);
  }
  return result;
};

/* harmony default export */ var _getSymbolsIn = (getSymbolsIn);

// CONCATENATED MODULE: ./node_modules/lodash-es/_copySymbolsIn.js



/**
 * Copies own and inherited symbols of `source` to `object`.
 *
 * @private
 * @param {Object} source The object to copy symbols from.
 * @param {Object} [object={}] The object to copy symbols to.
 * @returns {Object} Returns `object`.
 */
function copySymbolsIn(source, object) {
  return _copyObject(source, _getSymbolsIn(source), object);
}

/* harmony default export */ var _copySymbolsIn = (copySymbolsIn);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseGetAllKeys.js



/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return lodash_es_isArray(object) ? result : _arrayPush(result, symbolsFunc(object));
}

/* harmony default export */ var _baseGetAllKeys = (baseGetAllKeys);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getAllKeys.js




/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return _baseGetAllKeys(object, lodash_es_keys, _getSymbols);
}

/* harmony default export */ var _getAllKeys = (getAllKeys);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getAllKeysIn.js




/**
 * Creates an array of own and inherited enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeysIn(object) {
  return _baseGetAllKeys(object, lodash_es_keysIn, _getSymbolsIn);
}

/* harmony default export */ var _getAllKeysIn = (getAllKeysIn);

// CONCATENATED MODULE: ./node_modules/lodash-es/_DataView.js



/* Built-in method references that are verified to be native. */
var DataView = _getNative(_root["a" /* default */], 'DataView');

/* harmony default export */ var _DataView = (DataView);

// CONCATENATED MODULE: ./node_modules/lodash-es/_Promise.js



/* Built-in method references that are verified to be native. */
var _Promise_Promise = _getNative(_root["a" /* default */], 'Promise');

/* harmony default export */ var _Promise = (_Promise_Promise);

// CONCATENATED MODULE: ./node_modules/lodash-es/_Set.js



/* Built-in method references that are verified to be native. */
var _Set_Set = _getNative(_root["a" /* default */], 'Set');

/* harmony default export */ var _Set = (_Set_Set);

// CONCATENATED MODULE: ./node_modules/lodash-es/_WeakMap.js



/* Built-in method references that are verified to be native. */
var _WeakMap_WeakMap = _getNative(_root["a" /* default */], 'WeakMap');

/* harmony default export */ var _WeakMap = (_WeakMap_WeakMap);

// CONCATENATED MODULE: ./node_modules/lodash-es/_getTag.js








/** `Object#toString` result references. */
var _getTag_mapTag = '[object Map]',
    _getTag_objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    _getTag_setTag = '[object Set]',
    _getTag_weakMapTag = '[object WeakMap]';

var _getTag_dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = _toSource(_DataView),
    mapCtorString = _toSource(_Map),
    promiseCtorString = _toSource(_Promise),
    setCtorString = _toSource(_Set),
    weakMapCtorString = _toSource(_WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = _baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((_DataView && getTag(new _DataView(new ArrayBuffer(1))) != _getTag_dataViewTag) ||
    (_Map && getTag(new _Map) != _getTag_mapTag) ||
    (_Promise && getTag(_Promise.resolve()) != promiseTag) ||
    (_Set && getTag(new _Set) != _getTag_setTag) ||
    (_WeakMap && getTag(new _WeakMap) != _getTag_weakMapTag)) {
  getTag = function(value) {
    var result = _baseGetTag(value),
        Ctor = result == _getTag_objectTag ? value.constructor : undefined,
        ctorString = Ctor ? _toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return _getTag_dataViewTag;
        case mapCtorString: return _getTag_mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return _getTag_setTag;
        case weakMapCtorString: return _getTag_weakMapTag;
      }
    }
    return result;
  };
}

/* harmony default export */ var _getTag = (getTag);

// CONCATENATED MODULE: ./node_modules/lodash-es/_initCloneArray.js
/** Used for built-in method references. */
var _initCloneArray_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _initCloneArray_hasOwnProperty = _initCloneArray_objectProto.hasOwnProperty;

/**
 * Initializes an array clone.
 *
 * @private
 * @param {Array} array The array to clone.
 * @returns {Array} Returns the initialized clone.
 */
function initCloneArray(array) {
  var length = array.length,
      result = new array.constructor(length);

  // Add properties assigned by `RegExp#exec`.
  if (length && typeof array[0] == 'string' && _initCloneArray_hasOwnProperty.call(array, 'index')) {
    result.index = array.index;
    result.input = array.input;
  }
  return result;
}

/* harmony default export */ var _initCloneArray = (initCloneArray);

// CONCATENATED MODULE: ./node_modules/lodash-es/_Uint8Array.js


/** Built-in value references. */
var _Uint8Array_Uint8Array = _root["a" /* default */].Uint8Array;

/* harmony default export */ var _Uint8Array = (_Uint8Array_Uint8Array);

// CONCATENATED MODULE: ./node_modules/lodash-es/_cloneArrayBuffer.js


/**
 * Creates a clone of `arrayBuffer`.
 *
 * @private
 * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
 * @returns {ArrayBuffer} Returns the cloned array buffer.
 */
function cloneArrayBuffer(arrayBuffer) {
  var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  new _Uint8Array(result).set(new _Uint8Array(arrayBuffer));
  return result;
}

/* harmony default export */ var _cloneArrayBuffer = (cloneArrayBuffer);

// CONCATENATED MODULE: ./node_modules/lodash-es/_cloneDataView.js


/**
 * Creates a clone of `dataView`.
 *
 * @private
 * @param {Object} dataView The data view to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned data view.
 */
function cloneDataView(dataView, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
}

/* harmony default export */ var _cloneDataView = (cloneDataView);

// CONCATENATED MODULE: ./node_modules/lodash-es/_cloneRegExp.js
/** Used to match `RegExp` flags from their coerced string values. */
var reFlags = /\w*$/;

/**
 * Creates a clone of `regexp`.
 *
 * @private
 * @param {Object} regexp The regexp to clone.
 * @returns {Object} Returns the cloned regexp.
 */
function cloneRegExp(regexp) {
  var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  result.lastIndex = regexp.lastIndex;
  return result;
}

/* harmony default export */ var _cloneRegExp = (cloneRegExp);

// CONCATENATED MODULE: ./node_modules/lodash-es/_cloneSymbol.js


/** Used to convert symbols to primitives and strings. */
var symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * Creates a clone of the `symbol` object.
 *
 * @private
 * @param {Object} symbol The symbol object to clone.
 * @returns {Object} Returns the cloned symbol object.
 */
function cloneSymbol(symbol) {
  return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
}

/* harmony default export */ var _cloneSymbol = (cloneSymbol);

// CONCATENATED MODULE: ./node_modules/lodash-es/_cloneTypedArray.js


/**
 * Creates a clone of `typedArray`.
 *
 * @private
 * @param {Object} typedArray The typed array to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the cloned typed array.
 */
function cloneTypedArray(typedArray, isDeep) {
  var buffer = isDeep ? _cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
}

/* harmony default export */ var _cloneTypedArray = (cloneTypedArray);

// CONCATENATED MODULE: ./node_modules/lodash-es/_initCloneByTag.js






/** `Object#toString` result references. */
var _initCloneByTag_boolTag = '[object Boolean]',
    _initCloneByTag_dateTag = '[object Date]',
    _initCloneByTag_mapTag = '[object Map]',
    _initCloneByTag_numberTag = '[object Number]',
    _initCloneByTag_regexpTag = '[object RegExp]',
    _initCloneByTag_setTag = '[object Set]',
    _initCloneByTag_stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var _initCloneByTag_arrayBufferTag = '[object ArrayBuffer]',
    _initCloneByTag_dataViewTag = '[object DataView]',
    _initCloneByTag_float32Tag = '[object Float32Array]',
    _initCloneByTag_float64Tag = '[object Float64Array]',
    _initCloneByTag_int8Tag = '[object Int8Array]',
    _initCloneByTag_int16Tag = '[object Int16Array]',
    _initCloneByTag_int32Tag = '[object Int32Array]',
    _initCloneByTag_uint8Tag = '[object Uint8Array]',
    _initCloneByTag_uint8ClampedTag = '[object Uint8ClampedArray]',
    _initCloneByTag_uint16Tag = '[object Uint16Array]',
    _initCloneByTag_uint32Tag = '[object Uint32Array]';

/**
 * Initializes an object clone based on its `toStringTag`.
 *
 * **Note:** This function only supports cloning values with tags of
 * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
 *
 * @private
 * @param {Object} object The object to clone.
 * @param {string} tag The `toStringTag` of the object to clone.
 * @param {boolean} [isDeep] Specify a deep clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneByTag(object, tag, isDeep) {
  var Ctor = object.constructor;
  switch (tag) {
    case _initCloneByTag_arrayBufferTag:
      return _cloneArrayBuffer(object);

    case _initCloneByTag_boolTag:
    case _initCloneByTag_dateTag:
      return new Ctor(+object);

    case _initCloneByTag_dataViewTag:
      return _cloneDataView(object, isDeep);

    case _initCloneByTag_float32Tag: case _initCloneByTag_float64Tag:
    case _initCloneByTag_int8Tag: case _initCloneByTag_int16Tag: case _initCloneByTag_int32Tag:
    case _initCloneByTag_uint8Tag: case _initCloneByTag_uint8ClampedTag: case _initCloneByTag_uint16Tag: case _initCloneByTag_uint32Tag:
      return _cloneTypedArray(object, isDeep);

    case _initCloneByTag_mapTag:
      return new Ctor;

    case _initCloneByTag_numberTag:
    case _initCloneByTag_stringTag:
      return new Ctor(object);

    case _initCloneByTag_regexpTag:
      return _cloneRegExp(object);

    case _initCloneByTag_setTag:
      return new Ctor;

    case symbolTag:
      return _cloneSymbol(object);
  }
}

/* harmony default export */ var _initCloneByTag = (initCloneByTag);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseCreate.js


/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} proto The object to inherit from.
 * @returns {Object} Returns the new object.
 */
var baseCreate = (function() {
  function object() {}
  return function(proto) {
    if (!lodash_es_isObject(proto)) {
      return {};
    }
    if (objectCreate) {
      return objectCreate(proto);
    }
    object.prototype = proto;
    var result = new object;
    object.prototype = undefined;
    return result;
  };
}());

/* harmony default export */ var _baseCreate = (baseCreate);

// CONCATENATED MODULE: ./node_modules/lodash-es/_initCloneObject.js




/**
 * Initializes an object clone.
 *
 * @private
 * @param {Object} object The object to clone.
 * @returns {Object} Returns the initialized clone.
 */
function initCloneObject(object) {
  return (typeof object.constructor == 'function' && !_isPrototype(object))
    ? _baseCreate(_getPrototype(object))
    : {};
}

/* harmony default export */ var _initCloneObject = (initCloneObject);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsMap.js



/** `Object#toString` result references. */
var _baseIsMap_mapTag = '[object Map]';

/**
 * The base implementation of `_.isMap` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 */
function baseIsMap(value) {
  return lodash_es_isObjectLike(value) && _getTag(value) == _baseIsMap_mapTag;
}

/* harmony default export */ var _baseIsMap = (baseIsMap);

// CONCATENATED MODULE: ./node_modules/lodash-es/isMap.js




/* Node.js helper references. */
var nodeIsMap = _nodeUtil["a" /* default */] && _nodeUtil["a" /* default */].isMap;

/**
 * Checks if `value` is classified as a `Map` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a map, else `false`.
 * @example
 *
 * _.isMap(new Map);
 * // => true
 *
 * _.isMap(new WeakMap);
 * // => false
 */
var isMap = nodeIsMap ? _baseUnary(nodeIsMap) : _baseIsMap;

/* harmony default export */ var lodash_es_isMap = (isMap);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsSet.js



/** `Object#toString` result references. */
var _baseIsSet_setTag = '[object Set]';

/**
 * The base implementation of `_.isSet` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 */
function baseIsSet(value) {
  return lodash_es_isObjectLike(value) && _getTag(value) == _baseIsSet_setTag;
}

/* harmony default export */ var _baseIsSet = (baseIsSet);

// CONCATENATED MODULE: ./node_modules/lodash-es/isSet.js




/* Node.js helper references. */
var nodeIsSet = _nodeUtil["a" /* default */] && _nodeUtil["a" /* default */].isSet;

/**
 * Checks if `value` is classified as a `Set` object.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a set, else `false`.
 * @example
 *
 * _.isSet(new Set);
 * // => true
 *
 * _.isSet(new WeakSet);
 * // => false
 */
var isSet = nodeIsSet ? _baseUnary(nodeIsSet) : _baseIsSet;

/* harmony default export */ var lodash_es_isSet = (isSet);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseClone.js






















/** Used to compose bitmasks for cloning. */
var CLONE_DEEP_FLAG = 1,
    CLONE_FLAT_FLAG = 2,
    CLONE_SYMBOLS_FLAG = 4;

/** `Object#toString` result references. */
var _baseClone_argsTag = '[object Arguments]',
    _baseClone_arrayTag = '[object Array]',
    _baseClone_boolTag = '[object Boolean]',
    _baseClone_dateTag = '[object Date]',
    _baseClone_errorTag = '[object Error]',
    _baseClone_funcTag = '[object Function]',
    _baseClone_genTag = '[object GeneratorFunction]',
    _baseClone_mapTag = '[object Map]',
    _baseClone_numberTag = '[object Number]',
    _baseClone_objectTag = '[object Object]',
    _baseClone_regexpTag = '[object RegExp]',
    _baseClone_setTag = '[object Set]',
    _baseClone_stringTag = '[object String]',
    _baseClone_symbolTag = '[object Symbol]',
    _baseClone_weakMapTag = '[object WeakMap]';

var _baseClone_arrayBufferTag = '[object ArrayBuffer]',
    _baseClone_dataViewTag = '[object DataView]',
    _baseClone_float32Tag = '[object Float32Array]',
    _baseClone_float64Tag = '[object Float64Array]',
    _baseClone_int8Tag = '[object Int8Array]',
    _baseClone_int16Tag = '[object Int16Array]',
    _baseClone_int32Tag = '[object Int32Array]',
    _baseClone_uint8Tag = '[object Uint8Array]',
    _baseClone_uint8ClampedTag = '[object Uint8ClampedArray]',
    _baseClone_uint16Tag = '[object Uint16Array]',
    _baseClone_uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values supported by `_.clone`. */
var cloneableTags = {};
cloneableTags[_baseClone_argsTag] = cloneableTags[_baseClone_arrayTag] =
cloneableTags[_baseClone_arrayBufferTag] = cloneableTags[_baseClone_dataViewTag] =
cloneableTags[_baseClone_boolTag] = cloneableTags[_baseClone_dateTag] =
cloneableTags[_baseClone_float32Tag] = cloneableTags[_baseClone_float64Tag] =
cloneableTags[_baseClone_int8Tag] = cloneableTags[_baseClone_int16Tag] =
cloneableTags[_baseClone_int32Tag] = cloneableTags[_baseClone_mapTag] =
cloneableTags[_baseClone_numberTag] = cloneableTags[_baseClone_objectTag] =
cloneableTags[_baseClone_regexpTag] = cloneableTags[_baseClone_setTag] =
cloneableTags[_baseClone_stringTag] = cloneableTags[_baseClone_symbolTag] =
cloneableTags[_baseClone_uint8Tag] = cloneableTags[_baseClone_uint8ClampedTag] =
cloneableTags[_baseClone_uint16Tag] = cloneableTags[_baseClone_uint32Tag] = true;
cloneableTags[_baseClone_errorTag] = cloneableTags[_baseClone_funcTag] =
cloneableTags[_baseClone_weakMapTag] = false;

/**
 * The base implementation of `_.clone` and `_.cloneDeep` which tracks
 * traversed objects.
 *
 * @private
 * @param {*} value The value to clone.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Deep clone
 *  2 - Flatten inherited properties
 *  4 - Clone symbols
 * @param {Function} [customizer] The function to customize cloning.
 * @param {string} [key] The key of `value`.
 * @param {Object} [object] The parent object of `value`.
 * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
 * @returns {*} Returns the cloned value.
 */
function baseClone(value, bitmask, customizer, key, object, stack) {
  var result,
      isDeep = bitmask & CLONE_DEEP_FLAG,
      isFlat = bitmask & CLONE_FLAT_FLAG,
      isFull = bitmask & CLONE_SYMBOLS_FLAG;

  if (customizer) {
    result = object ? customizer(value, key, object, stack) : customizer(value);
  }
  if (result !== undefined) {
    return result;
  }
  if (!lodash_es_isObject(value)) {
    return value;
  }
  var isArr = lodash_es_isArray(value);
  if (isArr) {
    result = _initCloneArray(value);
    if (!isDeep) {
      return _copyArray(value, result);
    }
  } else {
    var tag = _getTag(value),
        isFunc = tag == _baseClone_funcTag || tag == _baseClone_genTag;

    if (Object(isBuffer["a" /* default */])(value)) {
      return Object(_cloneBuffer["a" /* default */])(value, isDeep);
    }
    if (tag == _baseClone_objectTag || tag == _baseClone_argsTag || (isFunc && !object)) {
      result = (isFlat || isFunc) ? {} : _initCloneObject(value);
      if (!isDeep) {
        return isFlat
          ? _copySymbolsIn(value, _baseAssignIn(result, value))
          : _copySymbols(value, _baseAssign(result, value));
      }
    } else {
      if (!cloneableTags[tag]) {
        return object ? value : {};
      }
      result = _initCloneByTag(value, tag, isDeep);
    }
  }
  // Check for circular references and return its corresponding clone.
  stack || (stack = new _Stack);
  var stacked = stack.get(value);
  if (stacked) {
    return stacked;
  }
  stack.set(value, result);

  if (lodash_es_isSet(value)) {
    value.forEach(function(subValue) {
      result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
    });
  } else if (lodash_es_isMap(value)) {
    value.forEach(function(subValue, key) {
      result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
    });
  }

  var keysFunc = isFull
    ? (isFlat ? _getAllKeysIn : _getAllKeys)
    : (isFlat ? keysIn : lodash_es_keys);

  var props = isArr ? undefined : keysFunc(value);
  _arrayEach(props || value, function(subValue, key) {
    if (props) {
      key = subValue;
      subValue = value[key];
    }
    // Recursively populate clone (susceptible to call stack limits).
    _assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  });
  return result;
}

/* harmony default export */ var _baseClone = (baseClone);

// CONCATENATED MODULE: ./node_modules/lodash-es/cloneDeepWith.js


/** Used to compose bitmasks for cloning. */
var cloneDeepWith_CLONE_DEEP_FLAG = 1,
    cloneDeepWith_CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.cloneWith` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @param {Function} [customizer] The function to customize cloning.
 * @returns {*} Returns the deep cloned value.
 * @see _.cloneWith
 * @example
 *
 * function customizer(value) {
 *   if (_.isElement(value)) {
 *     return value.cloneNode(true);
 *   }
 * }
 *
 * var el = _.cloneDeepWith(document.body, customizer);
 *
 * console.log(el === document.body);
 * // => false
 * console.log(el.nodeName);
 * // => 'BODY'
 * console.log(el.childNodes.length);
 * // => 20
 */
function cloneDeepWith(value, customizer) {
  customizer = typeof customizer == 'function' ? customizer : undefined;
  return _baseClone(value, cloneDeepWith_CLONE_DEEP_FLAG | cloneDeepWith_CLONE_SYMBOLS_FLAG, customizer);
}

/* harmony default export */ var lodash_es_cloneDeepWith = (cloneDeepWith);

// CONCATENATED MODULE: ./node_modules/lodash-es/isElement.js



/**
 * Checks if `value` is likely a DOM element.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
 * @example
 *
 * _.isElement(document.body);
 * // => true
 *
 * _.isElement('<body>');
 * // => false
 */
function isElement(value) {
  return lodash_es_isObjectLike(value) && value.nodeType === 1 && !lodash_es_isPlainObject(value);
}

/* harmony default export */ var lodash_es_isElement = (isElement);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/config.js










/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/config
 */

/**
 * Handles a configuration dictionary.
 */

var config_Config = /*#__PURE__*/function () {
  /**
   * Creates an instance of the {@link ~Config} class.
   *
   * @param {Object} [configurations] The initial configurations to be set. Usually, provided by the user.
   * @param {Object} [defaultConfigurations] The default configurations. Usually, provided by the system.
   */
  function Config(configurations, defaultConfigurations) {
    Object(classCallCheck["a" /* default */])(this, Config);

    /**
     * Store for the whole configuration.
     *
     * @private
     * @member {Object}
     */
    this._config = {}; // Set default configuration.

    if (defaultConfigurations) {
      // Clone the configuration to make sure that the properties will not be shared
      // between editors and make the watchdog feature work correctly.
      this.define(cloneConfig(defaultConfigurations));
    } // Set initial configuration.


    if (configurations) {
      this._setObjectToTarget(this._config, configurations);
    }
  }
  /**
   * Set configuration values.
   *
   * It accepts both a name/value pair or an object, which properties and values will be used to set
   * configurations.
   *
   * It also accepts setting a "deep configuration" by using dots in the name. For example, `'resize.width'` sets
   * the value for the `width` configuration in the `resize` subset.
   *
   *		config.set( 'width', 500 );
   *		config.set( 'toolbar.collapsed', true );
   *
   *		// Equivalent to:
   *		config.set( {
   *			width: 500
   *			toolbar: {
   *				collapsed: true
   *			}
   *		} );
   *
   * Passing an object as the value will amend the configuration, not replace it.
   *
   *		config.set( 'toolbar', {
   *			collapsed: true,
   *		} );
   *
   *		config.set( 'toolbar', {
   *			color: 'red',
   *		} );
   *
   *		config.get( 'toolbar.collapsed' ); // true
   *		config.get( 'toolbar.color' ); // 'red'
   *
   * @param {String|Object} name The configuration name or an object from which take properties as
   * configuration entries. Configuration names are case-sensitive.
   * @param {*} value The configuration value. Used if a name is passed.
   */


  Object(createClass["a" /* default */])(Config, [{
    key: "set",
    value: function set(name, value) {
      this._setToTarget(this._config, name, value);
    }
    /**
     * Does exactly the same as {@link #set} with one exception – passed configuration extends
     * existing one, but does not overwrite already defined values.
     *
     * This method is supposed to be called by plugin developers to setup plugin's configurations. It would be
     * rarely used for other needs.
     *
     * @param {String|Object} name The configuration name or an object from which take properties as
     * configuration entries. Configuration names are case-sensitive.
     * @param {*} value The configuration value. Used if a name is passed.
     */

  }, {
    key: "define",
    value: function define(name, value) {
      var isDefine = true;

      this._setToTarget(this._config, name, value, isDefine);
    }
    /**
     * Gets the value for a configuration entry.
     *
     *		config.get( 'name' );
     *
     * Deep configurations can be retrieved by separating each part with a dot.
     *
     *		config.get( 'toolbar.collapsed' );
     *
     * @param {String} name The configuration name. Configuration names are case-sensitive.
     * @returns {*} The configuration value or `undefined` if the configuration entry was not found.
     */

  }, {
    key: "get",
    value: function get(name) {
      return this._getFromSource(this._config, name);
    }
    /**
     * Iterates over all top level configuration names.
     *
     * @returns {Iterable.<String>}
     */

  }, {
    key: "names",
    value: /*#__PURE__*/regeneratorRuntime.mark(function names() {
      var _i, _Object$keys, name;

      return regeneratorRuntime.wrap(function names$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _i = 0, _Object$keys = Object.keys(this._config);

            case 1:
              if (!(_i < _Object$keys.length)) {
                _context.next = 8;
                break;
              }

              name = _Object$keys[_i];
              _context.next = 5;
              return name;

            case 5:
              _i++;
              _context.next = 1;
              break;

            case 8:
            case "end":
              return _context.stop();
          }
        }
      }, names, this);
    })
    /**
     * Saves passed configuration to the specified target (nested object).
     *
     * @private
     * @param {Object} target Nested config object.
     * @param {String|Object} name The configuration name or an object from which take properties as
     * configuration entries. Configuration names are case-sensitive.
     * @param {*} value The configuration value. Used if a name is passed.
     * @param {Boolean} [isDefine=false] Define if passed configuration should overwrite existing one.
     */

  }, {
    key: "_setToTarget",
    value: function _setToTarget(target, name, value) {
      var isDefine = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      // In case of an object, iterate through it and call `_setToTarget` again for each property.
      if (lodash_es_isPlainObject(name)) {
        this._setObjectToTarget(target, name, isDefine);

        return;
      } // The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].


      var parts = name.split('.'); // Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.

      name = parts.pop(); // Iterate over parts to check if currently stored configuration has proper structure.

      var _iterator = _createForOfIteratorHelper(parts),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var part = _step.value;

          // If there is no object for specified part then create one.
          if (!lodash_es_isPlainObject(target[part])) {
            target[part] = {};
          } // Nested object becomes a target.


          target = target[part];
        } // In case of value is an object.

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if (lodash_es_isPlainObject(value)) {
        // We take care of proper config structure.
        if (!lodash_es_isPlainObject(target[name])) {
          target[name] = {};
        }

        target = target[name]; // And iterate through this object calling `_setToTarget` again for each property.

        this._setObjectToTarget(target, value, isDefine);

        return;
      } // Do nothing if we are defining configuration for non empty name.


      if (isDefine && typeof target[name] != 'undefined') {
        return;
      }

      target[name] = value;
    }
    /**
     * Get specified configuration from specified source (nested object).
     *
     * @private
     * @param {Object} source level of nested object.
     * @param {String} name The configuration name. Configuration names are case-sensitive.
     * @returns {*} The configuration value or `undefined` if the configuration entry was not found.
     */

  }, {
    key: "_getFromSource",
    value: function _getFromSource(source, name) {
      // The configuration name should be split into parts if it has dots. E.g. `resize.width` -> [`resize`, `width`].
      var parts = name.split('.'); // Take the name of the configuration out of the parts. E.g. `resize.width` -> `width`.

      name = parts.pop(); // Iterate over parts to check if currently stored configuration has proper structure.

      var _iterator2 = _createForOfIteratorHelper(parts),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var part = _step2.value;

          if (!lodash_es_isPlainObject(source[part])) {
            source = null;
            break;
          } // Nested object becomes a source.


          source = source[part];
        } // Always returns undefined for non existing configuration.

      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return source ? cloneConfig(source[name]) : undefined;
    }
    /**
     * Iterates through passed object and calls {@link #_setToTarget} method with object key and value for each property.
     *
     * @private
     * @param {Object} target Nested config object.
     * @param {Object} configuration Configuration data set
     * @param {Boolean} [isDefine] Defines if passed configuration is default configuration or not.
     */

  }, {
    key: "_setObjectToTarget",
    value: function _setObjectToTarget(target, configuration, isDefine) {
      var _this = this;

      Object.keys(configuration).forEach(function (key) {
        _this._setToTarget(target, key, configuration[key], isDefine);
      });
    }
  }]);

  return Config;
}(); // Clones configuration object or value.
// @param {*} source Source configuration
// @returns {*} Cloned configuration value.




function cloneConfig(source) {
  return lodash_es_cloneDeepWith(source, leaveDOMReferences);
} // A customized function for cloneDeepWith.
// It will leave references to DOM Elements instead of cloning them.
//
// @param {*} value
// @returns {Element|undefined}


function leaveDOMReferences(value) {
  return lodash_es_isElement(value) ? value : undefined;
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.filter.js
var es_array_filter = __webpack_require__("4de4");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.find.js
var es_array_find = __webpack_require__("7db0");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.index-of.js
var es_array_index_of = __webpack_require__("c975");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.map.js
var es_array_map = __webpack_require__("d81d");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.reduce.js
var es_array_reduce = __webpack_require__("13d5");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.splice.js
var es_array_splice = __webpack_require__("a434");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.map.js
var es_map = __webpack_require__("4ec9");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.weak-map.js
var es_weak_map = __webpack_require__("10d1");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.last-index-of.js
var es_array_last_index_of = __webpack_require__("baa5");

// CONCATENATED MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
// CONCATENATED MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/iterableToArray.js








function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
}
// CONCATENATED MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
// CONCATENATED MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
// CONCATENATED MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
// CONCATENATED MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js







function _iterableToArrayLimit(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = undefined;

  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}
// CONCATENATED MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
// CONCATENATED MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/slicedToArray.js




function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/spy.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/spy
 */

/**
 * Creates a spy function (ala Sinon.js) that can be used to inspect call to it.
 *
 * The following are the present features:
 *
 * * spy.called: property set to `true` if the function has been called at least once.
 *
 * @returns {Function} The spy function.
 */
function spy() {
  return function spy() {
    spy.called = true;
  };
}

/* harmony default export */ var src_spy = (spy);
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/eventinfo.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/eventinfo
 */

/**
 * The event object passed to event callbacks. It is used to provide information about the event as well as a tool to
 * manipulate it.
 */

var eventinfo_EventInfo =
/**
 * @param {Object} source The emitter.
 * @param {String} name The event name.
 */
function EventInfo(source, name) {
  Object(classCallCheck["a" /* default */])(this, EventInfo);

  /**
   * The object that fired the event.
   *
   * @readonly
   * @member {Object}
   */
  this.source = source;
  /**
   * The event name.
   *
   * @readonly
   * @member {String}
   */

  this.name = name;
  /**
   * Path this event has followed. See {@link module:utils/emittermixin~EmitterMixin#delegate}.
   *
   * @readonly
   * @member {Array.<Object>}
   */

  this.path = []; // The following methods are defined in the constructor because they must be re-created per instance.

  /**
   * Stops the event emitter to call further callbacks for this event interaction.
   *
   * @method #stop
   */

  this.stop = src_spy();
  /**
   * Removes the current callback from future interactions of this event.
   *
   * @method #off
   */

  this.off = src_spy();
  /**
   * The value which will be returned by {@link module:utils/emittermixin~EmitterMixin#fire}.
   *
   * It's `undefined` by default and can be changed by an event listener:
   *
   *		dataController.fire( 'getSelectedContent', ( evt ) => {
   *			// This listener will make `dataController.fire( 'getSelectedContent' )`
   *			// always return an empty DocumentFragment.
   *			evt.return = new DocumentFragment();
   *
   *			// Make sure no other listeners are executed.
   *			evt.stop();
   *		} );
   *
   * @member #return
   */
};


// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.fill.js
var es_array_fill = __webpack_require__("cb29");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/uid.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/uid
 */
// A hash table of hex numbers to avoid using toString() in uid() which is costly.
// [ '00', '01', '02', ..., 'fe', 'ff' ]
var HEX_NUMBERS = new Array(256).fill().map(function (val, index) {
  return ('0' + index.toString(16)).slice(-2);
});
/**
 * Returns a unique id. The id starts with an "e" character and a randomly generated string of
 * 32 alphanumeric characters.
 *
 * **Note**: The characters the unique id is built from correspond to the hex number notation
 * (from "0" to "9", from "a" to "f"). In other words, each id corresponds to an "e" followed
 * by 16 8-bit numbers next to each other.
 *
 * @returns {String} An unique id string.
 */

function uid_uid() {
  // Let's create some positive random 32bit integers first.
  //
  // 1. Math.random() is a float between 0 and 1.
  // 2. 0x100000000 is 2^32 = 4294967296.
  // 3. >>> 0 enforces integer (in JS all numbers are floating point).
  //
  // For instance:
  //		Math.random() * 0x100000000 = 3366450031.853859
  // but
  //		Math.random() * 0x100000000 >>> 0 = 3366450031.
  var r1 = Math.random() * 0x100000000 >>> 0;
  var r2 = Math.random() * 0x100000000 >>> 0;
  var r3 = Math.random() * 0x100000000 >>> 0;
  var r4 = Math.random() * 0x100000000 >>> 0; // Make sure that id does not start with number.

  return 'e' + HEX_NUMBERS[r1 >> 0 & 0xFF] + HEX_NUMBERS[r1 >> 8 & 0xFF] + HEX_NUMBERS[r1 >> 16 & 0xFF] + HEX_NUMBERS[r1 >> 24 & 0xFF] + HEX_NUMBERS[r2 >> 0 & 0xFF] + HEX_NUMBERS[r2 >> 8 & 0xFF] + HEX_NUMBERS[r2 >> 16 & 0xFF] + HEX_NUMBERS[r2 >> 24 & 0xFF] + HEX_NUMBERS[r3 >> 0 & 0xFF] + HEX_NUMBERS[r3 >> 8 & 0xFF] + HEX_NUMBERS[r3 >> 16 & 0xFF] + HEX_NUMBERS[r3 >> 24 & 0xFF] + HEX_NUMBERS[r4 >> 0 & 0xFF] + HEX_NUMBERS[r4 >> 8 & 0xFF] + HEX_NUMBERS[r4 >> 16 & 0xFF] + HEX_NUMBERS[r4 >> 24 & 0xFF];
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/priorities.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/priorities
 */

/**
 * String representing a priority value.
 *
 * @typedef {'highest'|'high'|'normal'|'low'|'lowest'} module:utils/priorities~PriorityString
 */

/**
 * Provides group of constants to use instead of hardcoding numeric priority values.
 *
 * @namespace
 */
var priorities = {
  /**
   * Converts a string with priority name to it's numeric value. If `Number` is given, it just returns it.
   *
   * @static
   * @param {module:utils/priorities~PriorityString|Number} priority Priority to convert.
   * @returns {Number} Converted priority.
   */
  get: function get(priority) {
    if (typeof priority != 'number') {
      return this[priority] || this.normal;
    } else {
      return priority;
    }
  },
  highest: 100000,
  high: 1000,
  normal: 0,
  low: -1000,
  lowest: -100000
};
/* harmony default export */ var src_priorities = (priorities);
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/version.js
var src_version = __webpack_require__("e800");

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/ckeditorerror.js + 2 modules
var ckeditorerror = __webpack_require__("f2ea");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/emittermixin.js




















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/emittermixin
 */


 // To check if component is loaded more than once.




var _listeningTo = Symbol('listeningTo');

var _emitterId = Symbol('emitterId');
/**
 * Mixin that injects the {@link ~Emitter events API} into its host.
 *
 * @mixin EmitterMixin
 * @implements module:utils/emittermixin~Emitter
 */


var EmitterMixin = {
  /**
   * @inheritDoc
   */
  on: function on(event, callback) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    this.listenTo(this, event, callback, options);
  },

  /**
   * @inheritDoc
   */
  once: function once(event, callback, options) {
    var wasFired = false;

    var onceCallback = function onceCallback(event) {
      // Ensure the callback is called only once even if the callback itself leads to re-firing the event
      // (which would call the callback again).
      if (!wasFired) {
        wasFired = true; // Go off() at the first call.

        event.off(); // Go with the original callback.

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        callback.call.apply(callback, [this, event].concat(args));
      }
    }; // Make a similar on() call, simply replacing the callback.


    this.listenTo(this, event, onceCallback, options);
  },

  /**
   * @inheritDoc
   */
  off: function off(event, callback) {
    this.stopListening(this, event, callback);
  },

  /**
   * @inheritDoc
   */
  listenTo: function listenTo(emitter, event, callback) {
    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    var emitterInfo, eventCallbacks; // _listeningTo contains a list of emitters that this object is listening to.
    // This list has the following format:
    //
    // _listeningTo: {
    //     emitterId: {
    //         emitter: emitter,
    //         callbacks: {
    //             event1: [ callback1, callback2, ... ]
    //             ....
    //         }
    //     },
    //     ...
    // }

    if (!this[_listeningTo]) {
      this[_listeningTo] = {};
    }

    var emitters = this[_listeningTo];

    if (!_getEmitterId(emitter)) {
      _setEmitterId(emitter);
    }

    var emitterId = _getEmitterId(emitter);

    if (!(emitterInfo = emitters[emitterId])) {
      emitterInfo = emitters[emitterId] = {
        emitter: emitter,
        callbacks: {}
      };
    }

    if (!(eventCallbacks = emitterInfo.callbacks[event])) {
      eventCallbacks = emitterInfo.callbacks[event] = [];
    }

    eventCallbacks.push(callback); // Finally register the callback to the event.

    createEventNamespace(emitter, event);
    var lists = getCallbacksListsForNamespace(emitter, event);
    var priority = src_priorities.get(options.priority);
    var callbackDefinition = {
      callback: callback,
      priority: priority
    }; // Add the callback to all callbacks list.

    var _iterator = _createForOfIteratorHelper(lists),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var callbacks = _step.value;
        // Add the callback to the list in the right priority position.
        var added = false;

        for (var i = 0; i < callbacks.length; i++) {
          if (callbacks[i].priority < priority) {
            callbacks.splice(i, 0, callbackDefinition);
            added = true;
            break;
          }
        } // Add at the end, if right place was not found.


        if (!added) {
          callbacks.push(callbackDefinition);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  },

  /**
   * @inheritDoc
   */
  stopListening: function stopListening(emitter, event, callback) {
    var emitters = this[_listeningTo];

    var emitterId = emitter && _getEmitterId(emitter);

    var emitterInfo = emitters && emitterId && emitters[emitterId];
    var eventCallbacks = emitterInfo && event && emitterInfo.callbacks[event]; // Stop if nothing has been listened.

    if (!emitters || emitter && !emitterInfo || event && !eventCallbacks) {
      return;
    } // All params provided. off() that single callback.


    if (callback) {
      removeCallback(emitter, event, callback);
    } // Only `emitter` and `event` provided. off() all callbacks for that event.
    else if (eventCallbacks) {
        while (callback = eventCallbacks.pop()) {
          removeCallback(emitter, event, callback);
        }

        delete emitterInfo.callbacks[event];
      } // Only `emitter` provided. off() all events for that emitter.
      else if (emitterInfo) {
          for (event in emitterInfo.callbacks) {
            this.stopListening(emitter, event);
          }

          delete emitters[emitterId];
        } // No params provided. off() all emitters.
        else {
            for (emitterId in emitters) {
              this.stopListening(emitters[emitterId].emitter);
            }

            delete this[_listeningTo];
          }
  },

  /**
   * @inheritDoc
   */
  fire: function fire(eventOrInfo) {
    try {
      var eventInfo = eventOrInfo instanceof eventinfo_EventInfo ? eventOrInfo : new eventinfo_EventInfo(this, eventOrInfo);
      var event = eventInfo.name;
      var callbacks = getCallbacksForEvent(this, event); // Record that the event passed this emitter on its path.

      eventInfo.path.push(this); // Handle event listener callbacks first.

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      if (callbacks) {
        // Arguments passed to each callback.
        var callbackArgs = [eventInfo].concat(args); // Copying callbacks array is the easiest and most secure way of preventing infinite loops, when event callbacks
        // are added while processing other callbacks. Previous solution involved adding counters (unique ids) but
        // failed if callbacks were added to the queue before currently processed callback.
        // If this proves to be too inefficient, another method is to change `.on()` so callbacks are stored if same
        // event is currently processed. Then, `.fire()` at the end, would have to add all stored events.

        callbacks = Array.from(callbacks);

        for (var i = 0; i < callbacks.length; i++) {
          callbacks[i].callback.apply(this, callbackArgs); // Remove the callback from future requests if off() has been called.

          if (eventInfo.off.called) {
            // Remove the called mark for the next calls.
            delete eventInfo.off.called;
            removeCallback(this, event, callbacks[i].callback);
          } // Do not execute next callbacks if stop() was called.


          if (eventInfo.stop.called) {
            break;
          }
        }
      } // Delegate event to other emitters if needed.


      if (this._delegations) {
        var destinations = this._delegations.get(event);

        var passAllDestinations = this._delegations.get('*');

        if (destinations) {
          fireDelegatedEvents(destinations, eventInfo, args);
        }

        if (passAllDestinations) {
          fireDelegatedEvents(passAllDestinations, eventInfo, args);
        }
      }

      return eventInfo.return;
    } catch (err) {
      // @if CK_DEBUG // throw err;

      /* istanbul ignore next */
      ckeditorerror["b" /* default */].rethrowUnexpectedError(err, this);
    }
  },

  /**
   * @inheritDoc
   */
  delegate: function delegate() {
    var _this = this;

    for (var _len3 = arguments.length, events = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      events[_key3] = arguments[_key3];
    }

    return {
      to: function to(emitter, nameOrFunction) {
        if (!_this._delegations) {
          _this._delegations = new Map();
        } // Originally there was a for..of loop which unfortunately caused an error in Babel that didn't allow
        // build an application. See: https://github.com/ckeditor/ckeditor5-react/issues/40.


        events.forEach(function (eventName) {
          var destinations = _this._delegations.get(eventName);

          if (!destinations) {
            _this._delegations.set(eventName, new Map([[emitter, nameOrFunction]]));
          } else {
            destinations.set(emitter, nameOrFunction);
          }
        });
      }
    };
  },

  /**
   * @inheritDoc
   */
  stopDelegating: function stopDelegating(event, emitter) {
    if (!this._delegations) {
      return;
    }

    if (!event) {
      this._delegations.clear();
    } else if (!emitter) {
      this._delegations.delete(event);
    } else {
      var destinations = this._delegations.get(event);

      if (destinations) {
        destinations.delete(emitter);
      }
    }
  }
};
/* harmony default export */ var emittermixin = (EmitterMixin);
/**
 * Emitter/listener interface.
 *
 * Can be easily implemented by a class by mixing the {@link module:utils/emittermixin~EmitterMixin} mixin.
 *
 * @interface Emitter
 */

/**
 * Registers a callback function to be executed when an event is fired.
 *
 * Shorthand for {@link #listenTo `this.listenTo( this, event, callback, options )`} (it makes the emitter
 * listen on itself).
 *
 * @method #on
 * @param {String} event The name of the event.
 * @param {Function} callback The function to be called on event.
 * @param {Object} [options={}] Additional options.
 * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher
 * the priority value the sooner the callback will be fired. Events having the same priority are called in the
 * order they were added.
 */

/**
 * Registers a callback function to be executed on the next time the event is fired only. This is similar to
 * calling {@link #on} followed by {@link #off} in the callback.
 *
 * @method #once
 * @param {String} event The name of the event.
 * @param {Function} callback The function to be called on event.
 * @param {Object} [options={}] Additional options.
 * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher
 * the priority value the sooner the callback will be fired. Events having the same priority are called in the
 * order they were added.
 */

/**
 * Stops executing the callback on the given event.
 * Shorthand for {@link #stopListening `this.stopListening( this, event, callback )`}.
 *
 * @method #off
 * @param {String} event The name of the event.
 * @param {Function} callback The function to stop being called.
 */

/**
 * Registers a callback function to be executed when an event is fired in a specific (emitter) object.
 *
 * Events can be grouped in namespaces using `:`.
 * When namespaced event is fired, it additionally fires all callbacks for that namespace.
 *
 *		// myEmitter.on( ... ) is a shorthand for myEmitter.listenTo( myEmitter, ... ).
 *		myEmitter.on( 'myGroup', genericCallback );
 *		myEmitter.on( 'myGroup:myEvent', specificCallback );
 *
 *		// genericCallback is fired.
 *		myEmitter.fire( 'myGroup' );
 *		// both genericCallback and specificCallback are fired.
 *		myEmitter.fire( 'myGroup:myEvent' );
 *		// genericCallback is fired even though there are no callbacks for "foo".
 *		myEmitter.fire( 'myGroup:foo' );
 *
 * An event callback can {@link module:utils/eventinfo~EventInfo#stop stop the event} and
 * set the {@link module:utils/eventinfo~EventInfo#return return value} of the {@link #fire} method.
 *
 * @method #listenTo
 * @param {module:utils/emittermixin~Emitter} emitter The object that fires the event.
 * @param {String} event The name of the event.
 * @param {Function} callback The function to be called on event.
 * @param {Object} [options={}] Additional options.
 * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher
 * the priority value the sooner the callback will be fired. Events having the same priority are called in the
 * order they were added.
 */

/**
 * Stops listening for events. It can be used at different levels:
 *
 * * To stop listening to a specific callback.
 * * To stop listening to a specific event.
 * * To stop listening to all events fired by a specific object.
 * * To stop listening to all events fired by all objects.
 *
 * @method #stopListening
 * @param {module:utils/emittermixin~Emitter} [emitter] The object to stop listening to. If omitted, stops it for all objects.
 * @param {String} [event] (Requires the `emitter`) The name of the event to stop listening to. If omitted, stops it
 * for all events from `emitter`.
 * @param {Function} [callback] (Requires the `event`) The function to be removed from the call list for the given
 * `event`.
 */

/**
 * Fires an event, executing all callbacks registered for it.
 *
 * The first parameter passed to callbacks is an {@link module:utils/eventinfo~EventInfo} object,
 * followed by the optional `args` provided in the `fire()` method call.
 *
 * @method #fire
 * @param {String|module:utils/eventinfo~EventInfo} eventOrInfo The name of the event or `EventInfo` object if event is delegated.
 * @param {...*} [args] Additional arguments to be passed to the callbacks.
 * @returns {*} By default the method returns `undefined`. However, the return value can be changed by listeners
 * through modification of the {@link module:utils/eventinfo~EventInfo#return `evt.return`}'s property (the event info
 * is the first param of every callback).
 */

/**
 * Delegates selected events to another {@link module:utils/emittermixin~Emitter}. For instance:
 *
 *		emitterA.delegate( 'eventX' ).to( emitterB );
 *		emitterA.delegate( 'eventX', 'eventY' ).to( emitterC );
 *
 * then `eventX` is delegated (fired by) `emitterB` and `emitterC` along with `data`:
 *
 *		emitterA.fire( 'eventX', data );
 *
 * and `eventY` is delegated (fired by) `emitterC` along with `data`:
 *
 *		emitterA.fire( 'eventY', data );
 *
 * @method #delegate
 * @param {...String} events Event names that will be delegated to another emitter.
 * @returns {module:utils/emittermixin~EmitterMixinDelegateChain}
 */

/**
 * Stops delegating events. It can be used at different levels:
 *
 * * To stop delegating all events.
 * * To stop delegating a specific event to all emitters.
 * * To stop delegating a specific event to a specific emitter.
 *
 * @method #stopDelegating
 * @param {String} [event] The name of the event to stop delegating. If omitted, stops it all delegations.
 * @param {module:utils/emittermixin~Emitter} [emitter] (requires `event`) The object to stop delegating a particular event to.
 * If omitted, stops delegation of `event` to all emitters.
 */

/**
 * Checks if `listeningEmitter` listens to an emitter with given `listenedToEmitterId` and if so, returns that emitter.
 * If not, returns `null`.
 *
 * @protected
 * @param {module:utils/emittermixin~Emitter} listeningEmitter An emitter that listens.
 * @param {String} listenedToEmitterId Unique emitter id of emitter listened to.
 * @returns {module:utils/emittermixin~Emitter|null}
 */

function _getEmitterListenedTo(listeningEmitter, listenedToEmitterId) {
  if (listeningEmitter[_listeningTo] && listeningEmitter[_listeningTo][listenedToEmitterId]) {
    return listeningEmitter[_listeningTo][listenedToEmitterId].emitter;
  }

  return null;
}
/**
 * Sets emitter's unique id.
 *
 * **Note:** `_emitterId` can be set only once.
 *
 * @protected
 * @param {module:utils/emittermixin~Emitter} emitter An emitter for which id will be set.
 * @param {String} [id] Unique id to set. If not passed, random unique id will be set.
 */

function _setEmitterId(emitter, id) {
  if (!emitter[_emitterId]) {
    emitter[_emitterId] = id || uid_uid();
  }
}
/**
 * Returns emitter's unique id.
 *
 * @protected
 * @param {module:utils/emittermixin~Emitter} emitter An emitter which id will be returned.
 */

function _getEmitterId(emitter) {
  return emitter[_emitterId];
} // Gets the internal `_events` property of the given object.
// `_events` property store all lists with callbacks for registered event names.
// If there were no events registered on the object, empty `_events` object is created.

function getEvents(source) {
  if (!source._events) {
    Object.defineProperty(source, '_events', {
      value: {}
    });
  }

  return source._events;
} // Creates event node for generic-specific events relation architecture.


function makeEventNode() {
  return {
    callbacks: [],
    childEvents: []
  };
} // Creates an architecture for generic-specific events relation.
// If needed, creates all events for given eventName, i.e. if the first registered event
// is foo:bar:abc, it will create foo:bar:abc, foo:bar and foo event and tie them together.
// It also copies callbacks from more generic events to more specific events when
// specific events are created.


function createEventNamespace(source, eventName) {
  var events = getEvents(source); // First, check if the event we want to add to the structure already exists.

  if (events[eventName]) {
    // If it exists, we don't have to do anything.
    return;
  } // In other case, we have to create the structure for the event.
  // Note, that we might need to create intermediate events too.
  // I.e. if foo:bar:abc is being registered and we only have foo in the structure,
  // we need to also register foo:bar.
  // Currently processed event name.


  var name = eventName; // Name of the event that is a child event for currently processed event.

  var childEventName = null; // Array containing all newly created specific events.

  var newEventNodes = []; // While loop can't check for ':' index because we have to handle generic events too.
  // In each loop, we truncate event name, going from the most specific name to the generic one.
  // I.e. foo:bar:abc -> foo:bar -> foo.

  while (name !== '') {
    if (events[name]) {
      // If the currently processed event name is already registered, we can be sure
      // that it already has all the structure created, so we can break the loop here
      // as no more events need to be registered.
      break;
    } // If this event is not yet registered, create a new object for it.


    events[name] = makeEventNode(); // Add it to the array with newly created events.

    newEventNodes.push(events[name]); // Add previously processed event name as a child of this event.

    if (childEventName) {
      events[name].childEvents.push(childEventName);
    }

    childEventName = name; // If `.lastIndexOf()` returns -1, `.substr()` will return '' which will break the loop.

    name = name.substr(0, name.lastIndexOf(':'));
  }

  if (name !== '') {
    // If name is not empty, we found an already registered event that was a parent of the
    // event we wanted to register.
    // Copy that event's callbacks to newly registered events.
    var _iterator2 = _createForOfIteratorHelper(newEventNodes),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var node = _step2.value;
        node.callbacks = events[name].callbacks.slice();
      } // Add last newly created event to the already registered event.

    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    events[name].childEvents.push(childEventName);
  }
} // Gets an array containing callbacks list for a given event and it's more specific events.
// I.e. if given event is foo:bar and there is also foo:bar:abc event registered, this will
// return callback list of foo:bar and foo:bar:abc (but not foo).


function getCallbacksListsForNamespace(source, eventName) {
  var eventNode = getEvents(source)[eventName];

  if (!eventNode) {
    return [];
  }

  var callbacksLists = [eventNode.callbacks];

  for (var i = 0; i < eventNode.childEvents.length; i++) {
    var childCallbacksLists = getCallbacksListsForNamespace(source, eventNode.childEvents[i]);
    callbacksLists = callbacksLists.concat(childCallbacksLists);
  }

  return callbacksLists;
} // Get the list of callbacks for a given event, but only if there any callbacks have been registered.
// If there are no callbacks registered for given event, it checks if this is a specific event and looks
// for callbacks for it's more generic version.


function getCallbacksForEvent(source, eventName) {
  var event;

  if (!source._events || !(event = source._events[eventName]) || !event.callbacks.length) {
    // There are no callbacks registered for specified eventName.
    // But this could be a specific-type event that is in a namespace.
    if (eventName.indexOf(':') > -1) {
      // If the eventName is specific, try to find callback lists for more generic event.
      return getCallbacksForEvent(source, eventName.substr(0, eventName.lastIndexOf(':')));
    } else {
      // If this is a top-level generic event, return null;
      return null;
    }
  }

  return event.callbacks;
} // Fires delegated events for given map of destinations.
//
// @private
// * @param {Map.<utils.Emitter>} destinations A map containing
// `[ {@link module:utils/emittermixin~Emitter}, "event name" ]` pair destinations.
// * @param {utils.EventInfo} eventInfo The original event info object.
// * @param {Array.<*>} fireArgs Arguments the original event was fired with.


function fireDelegatedEvents(destinations, eventInfo, fireArgs) {
  var _iterator3 = _createForOfIteratorHelper(destinations),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _step3$value = _slicedToArray(_step3.value, 2),
          emitter = _step3$value[0],
          name = _step3$value[1];

      if (!name) {
        name = eventInfo.name;
      } else if (typeof name == 'function') {
        name = name(eventInfo.name);
      }

      var delegatedInfo = new eventinfo_EventInfo(eventInfo.source, name);
      delegatedInfo.path = _toConsumableArray(eventInfo.path);
      emitter.fire.apply(emitter, [delegatedInfo].concat(_toConsumableArray(fireArgs)));
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
} // Removes callback from emitter for given event.
//
// @param {module:utils/emittermixin~Emitter} emitter
// @param {String} event
// @param {Function} callback


function removeCallback(emitter, event, callback) {
  var lists = getCallbacksListsForNamespace(emitter, event);

  var _iterator4 = _createForOfIteratorHelper(lists),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var callbacks = _step4.value;

      for (var i = 0; i < callbacks.length; i++) {
        if (callbacks[i].callback == callback) {
          // Remove the callback from the list (fixing the next index).
          callbacks.splice(i, 1);
          i--;
        }
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
}
/**
 * The return value of {@link ~EmitterMixin#delegate}.
 *
 * @interface module:utils/emittermixin~EmitterMixinDelegateChain
 */

/**
 * Selects destination for {@link module:utils/emittermixin~EmitterMixin#delegate} events.
 *
 * @method #to
 * @param {module:utils/emittermixin~Emitter} emitter An `EmitterMixin` instance which is the destination for delegated events.
 * @param {String|Function} [nameOrFunction] A custom event name or function which converts the original name string.
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/isiterable.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/isiterable
 */

/**
 * Checks if value implements iterator interface.
 *
 * @param {*} value The value to check.
 * @returns {Boolean} True if value implements iterator interface.
 */
function isIterable(value) {
  return !!(value && value[Symbol.iterator]);
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.get-own-property-names.js
var es_object_get_own_property_names = __webpack_require__("7039");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/mix.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/mix
 */

/**
 * Copies enumerable properties and symbols from the objects given as 2nd+ parameters to the
 * prototype of first object (a constructor).
 *
 *		class Editor {
 *			...
 *		}
 *
 *		const SomeMixin = {
 *			a() {
 *				return 'a';
 *			}
 *		};
 *
 *		mix( Editor, SomeMixin, ... );
 *
 *		new Editor().a(); // -> 'a'
 *
 * Note: Properties which already exist in the base class will not be overriden.
 *
 * @param {Function} [baseClass] Class which prototype will be extended.
 * @param {Object} [...mixins] Objects from which to get properties.
 */
function mix(baseClass) {
  for (var _len = arguments.length, mixins = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    mixins[_key - 1] = arguments[_key];
  }

  mixins.forEach(function (mixin) {
    Object.getOwnPropertyNames(mixin).concat(Object.getOwnPropertySymbols(mixin)).forEach(function (key) {
      if (key in baseClass.prototype) {
        return;
      }

      var sourceDescriptor = Object.getOwnPropertyDescriptor(mixin, key);
      sourceDescriptor.enumerable = false;
      Object.defineProperty(baseClass.prototype, key, sourceDescriptor);
    });
  });
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/collection.js



















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/collection
 */





/**
 * Collections are ordered sets of objects. Items in the collection can be retrieved by their indexes
 * in the collection (like in an array) or by their ids.
 *
 * If an object without an `id` property is being added to the collection, the `id` property will be generated
 * automatically. Note that the automatically generated id is unique only within this single collection instance.
 *
 * By default an item in the collection is identified by its `id` property. The name of the identifier can be
 * configured through the constructor of the collection.
 *
 * @mixes module:utils/emittermixin~EmitterMixin
 */

var collection_Collection = /*#__PURE__*/function () {
  /**
   * Creates a new Collection instance.
   *
   * You can provide an iterable of initial items the collection will be created with:
   *
   *		const collection = new Collection( [ { id: 'John' }, { id: 'Mike' } ] );
   *
   *		console.log( collection.get( 0 ) ); // -> { id: 'John' }
   *		console.log( collection.get( 1 ) ); // -> { id: 'Mike' }
   *		console.log( collection.get( 'Mike' ) ); // -> { id: 'Mike' }
   *
   * Or you can first create a collection and then add new items using the {@link #add} method:
   *
   *		const collection = new Collection();
   *
   *		collection.add( { id: 'John' } );
   *		console.log( collection.get( 0 ) ); // -> { id: 'John' }
   *
   * Whatever option you choose, you can always pass a configuration object as the last argument
   * of the constructor:
   *
   *		const emptyCollection = new Collection( { idProperty: 'name' } );
   *		emptyCollection.add( { name: 'John' } );
   *		console.log( collection.get( 'John' ) ); // -> { name: 'John' }
   *
   *		const nonEmptyCollection = new Collection( [ { name: 'John' } ], { idProperty: 'name' } );
   *		nonEmptyCollection.add( { name: 'George' } );
   *		console.log( collection.get( 'George' ) ); // -> { name: 'George' }
   *		console.log( collection.get( 'John' ) ); // -> { name: 'John' }
   *
   * @param {Iterable.<Object>|Object} initialItemsOrOptions The initial items of the collection or
   * the options object.
   * @param {Object} [options={}] The options object, when the first argument is an array of initial items.
   * @param {String} [options.idProperty='id'] The name of the property which is used to identify an item.
   * Items that do not have such a property will be assigned one when added to the collection.
   */
  function Collection() {
    var initialItemsOrOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    Object(classCallCheck["a" /* default */])(this, Collection);

    var hasInitialItems = isIterable(initialItemsOrOptions);

    if (!hasInitialItems) {
      options = initialItemsOrOptions;
    }
    /**
     * The internal list of items in the collection.
     *
     * @private
     * @member {Object[]}
     */


    this._items = [];
    /**
     * The internal map of items in the collection.
     *
     * @private
     * @member {Map}
     */

    this._itemMap = new Map();
    /**
     * The name of the property which is considered to identify an item.
     *
     * @private
     * @member {String}
     */

    this._idProperty = options.idProperty || 'id';
    /**
     * A helper mapping external items of a bound collection ({@link #bindTo})
     * and actual items of this collection. It provides information
     * necessary to properly remove items bound to another collection.
     *
     * See {@link #_bindToInternalToExternalMap}.
     *
     * @protected
     * @member {WeakMap}
     */

    this._bindToExternalToInternalMap = new WeakMap();
    /**
     * A helper mapping items of this collection to external items of a bound collection
     * ({@link #bindTo}). It provides information necessary to manage the bindings, e.g.
     * to avoid loops in two–way bindings.
     *
     * See {@link #_bindToExternalToInternalMap}.
     *
     * @protected
     * @member {WeakMap}
     */

    this._bindToInternalToExternalMap = new WeakMap();
    /**
     * Stores indexes of skipped items from bound external collection.
     *
     * @private
     * @member {Array}
     */

    this._skippedIndexesFromExternal = []; // Set the initial content of the collection (if provided in the constructor).

    if (hasInitialItems) {
      var _iterator = _createForOfIteratorHelper(initialItemsOrOptions),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var item = _step.value;

          this._items.push(item);

          this._itemMap.set(this._getItemIdBeforeAdding(item), item);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * A collection instance this collection is bound to as a result
     * of calling {@link #bindTo} method.
     *
     * @protected
     * @member {module:utils/collection~Collection} #_bindToCollection
     */

  }
  /**
   * The number of items available in the collection.
   *
   * @member {Number} #length
   */


  Object(createClass["a" /* default */])(Collection, [{
    key: "add",

    /**
     * Adds an item into the collection.
     *
     * If the item does not have an id, then it will be automatically generated and set on the item.
     *
     * @chainable
     * @param {Object} item
     * @param {Number} [index] The position of the item in the collection. The item
     * is pushed to the collection when `index` not specified.
     * @fires add
     */
    value: function add(item, index) {
      var itemId = this._getItemIdBeforeAdding(item); // TODO: Use ES6 default function argument.


      if (index === undefined) {
        index = this._items.length;
      } else if (index > this._items.length || index < 0) {
        /**
         * The index number has invalid value.
         *
         * @error collection-add-item-bad-index
         */
        throw new ckeditorerror["b" /* default */]('collection-add-item-invalid-index', this);
      }

      this._items.splice(index, 0, item);

      this._itemMap.set(itemId, item);

      this.fire('add', item, index);
      return this;
    }
    /**
     * Gets item by its id or index.
     *
     * @param {String|Number} idOrIndex The item id or index in the collection.
     * @returns {Object|null} The requested item or `null` if such item does not exist.
     */

  }, {
    key: "get",
    value: function get(idOrIndex) {
      var item;

      if (typeof idOrIndex == 'string') {
        item = this._itemMap.get(idOrIndex);
      } else if (typeof idOrIndex == 'number') {
        item = this._items[idOrIndex];
      } else {
        /**
         * Index or id must be given.
         *
         * @error collection-get-invalid-arg
         */
        throw new ckeditorerror["b" /* default */]('collection-get-invalid-arg: Index or id must be given.', this);
      }

      return item || null;
    }
    /**
     * Returns a boolean indicating whether the collection contains an item.
     *
     * @param {Object|String} itemOrId The item or its id in the collection.
     * @returns {Boolean} `true` if the collection contains the item, `false` otherwise.
     */

  }, {
    key: "has",
    value: function has(itemOrId) {
      if (typeof itemOrId == 'string') {
        return this._itemMap.has(itemOrId);
      } else {
        // Object
        var idProperty = this._idProperty;
        var id = itemOrId[idProperty];
        return this._itemMap.has(id);
      }
    }
    /**
     * Gets index of item in the collection.
     * When item is not defined in the collection then index will be equal -1.
     *
     * @param {Object|String} itemOrId The item or its id in the collection.
     * @returns {Number} Index of given item.
     */

  }, {
    key: "getIndex",
    value: function getIndex(itemOrId) {
      var item;

      if (typeof itemOrId == 'string') {
        item = this._itemMap.get(itemOrId);
      } else {
        item = itemOrId;
      }

      return this._items.indexOf(item);
    }
    /**
     * Removes an item from the collection.
     *
     * @param {Object|Number|String} subject The item to remove, its id or index in the collection.
     * @returns {Object} The removed item.
     * @fires remove
     */

  }, {
    key: "remove",
    value: function remove(subject) {
      var index, id, item;
      var itemDoesNotExist = false;
      var idProperty = this._idProperty;

      if (typeof subject == 'string') {
        id = subject;
        item = this._itemMap.get(id);
        itemDoesNotExist = !item;

        if (item) {
          index = this._items.indexOf(item);
        }
      } else if (typeof subject == 'number') {
        index = subject;
        item = this._items[index];
        itemDoesNotExist = !item;

        if (item) {
          id = item[idProperty];
        }
      } else {
        item = subject;
        id = item[idProperty];
        index = this._items.indexOf(item);
        itemDoesNotExist = index == -1 || !this._itemMap.get(id);
      }

      if (itemDoesNotExist) {
        /**
         * Item not found.
         *
         * @error collection-remove-404
         */
        throw new ckeditorerror["b" /* default */]('collection-remove-404: Item not found.', this);
      }

      this._items.splice(index, 1);

      this._itemMap.delete(id);

      var externalItem = this._bindToInternalToExternalMap.get(item);

      this._bindToInternalToExternalMap.delete(item);

      this._bindToExternalToInternalMap.delete(externalItem);

      this.fire('remove', item, index);
      return item;
    }
    /**
     * Executes the callback for each item in the collection and composes an array or values returned by this callback.
     *
     * @param {Function} callback
     * @param {Object} callback.item
     * @param {Number} callback.index
     * @param {Object} ctx Context in which the `callback` will be called.
     * @returns {Array} The result of mapping.
     */

  }, {
    key: "map",
    value: function map(callback, ctx) {
      return this._items.map(callback, ctx);
    }
    /**
     * Finds the first item in the collection for which the `callback` returns a true value.
     *
     * @param {Function} callback
     * @param {Object} callback.item
     * @param {Number} callback.index
     * @param {Object} ctx Context in which the `callback` will be called.
     * @returns {Object} The item for which `callback` returned a true value.
     */

  }, {
    key: "find",
    value: function find(callback, ctx) {
      return this._items.find(callback, ctx);
    }
    /**
     * Returns an array with items for which the `callback` returned a true value.
     *
     * @param {Function} callback
     * @param {Object} callback.item
     * @param {Number} callback.index
     * @param {Object} ctx Context in which the `callback` will be called.
     * @returns {Object[]} The array with matching items.
     */

  }, {
    key: "filter",
    value: function filter(callback, ctx) {
      return this._items.filter(callback, ctx);
    }
    /**
     * Removes all items from the collection and destroys the binding created using
     * {@link #bindTo}.
     */

  }, {
    key: "clear",
    value: function clear() {
      if (this._bindToCollection) {
        this.stopListening(this._bindToCollection);
        this._bindToCollection = null;
      }

      while (this.length) {
        this.remove(0);
      }
    }
    /**
     * Binds and synchronizes the collection with another one.
     *
     * The binding can be a simple factory:
     *
     *		class FactoryClass {
     *			constructor( data ) {
     *				this.label = data.label;
     *			}
     *		}
     *
     *		const source = new Collection( { idProperty: 'label' } );
     *		const target = new Collection();
     *
     *		target.bindTo( source ).as( FactoryClass );
     *
     *		source.add( { label: 'foo' } );
     *		source.add( { label: 'bar' } );
     *
     *		console.log( target.length ); // 2
     *		console.log( target.get( 1 ).label ); // 'bar'
     *
     *		source.remove( 0 );
     *		console.log( target.length ); // 1
     *		console.log( target.get( 0 ).label ); // 'bar'
     *
     * or the factory driven by a custom callback:
     *
     *		class FooClass {
     *			constructor( data ) {
     *				this.label = data.label;
     *			}
     *		}
     *
     *		class BarClass {
     *			constructor( data ) {
     *				this.label = data.label;
     *			}
     *		}
     *
     *		const source = new Collection( { idProperty: 'label' } );
     *		const target = new Collection();
     *
     *		target.bindTo( source ).using( ( item ) => {
     *			if ( item.label == 'foo' ) {
     *				return new FooClass( item );
     *			} else {
     *				return new BarClass( item );
     *			}
     *		} );
     *
     *		source.add( { label: 'foo' } );
     *		source.add( { label: 'bar' } );
     *
     *		console.log( target.length ); // 2
     *		console.log( target.get( 0 ) instanceof FooClass ); // true
     *		console.log( target.get( 1 ) instanceof BarClass ); // true
     *
     * or the factory out of property name:
     *
     *		const source = new Collection( { idProperty: 'label' } );
     *		const target = new Collection();
     *
     *		target.bindTo( source ).using( 'label' );
     *
     *		source.add( { label: { value: 'foo' } } );
     *		source.add( { label: { value: 'bar' } } );
     *
     *		console.log( target.length ); // 2
     *		console.log( target.get( 0 ).value ); // 'foo'
     *		console.log( target.get( 1 ).value ); // 'bar'
     *
     * It's possible to skip specified items by returning falsy value:
     *
     *		const source = new Collection();
     *		const target = new Collection();
     *
     *		target.bindTo( source ).using( item => {
     *			if ( item.hidden ) {
     *				return null;
     *			}
     *
     *			return item;
     *		} );
     *
     *		source.add( { hidden: true } );
     *		source.add( { hidden: false } );
     *
     *		console.log( source.length ); // 2
     *		console.log( target.length ); // 1
     *
     * **Note**: {@link #clear} can be used to break the binding.
     *
     * @param {module:utils/collection~Collection} externalCollection A collection to be bound.
     * @returns {Object}
     * @returns {module:utils/collection~CollectionBindToChain} The binding chain object.
     */

  }, {
    key: "bindTo",
    value: function bindTo(externalCollection) {
      var _this = this;

      if (this._bindToCollection) {
        /**
         * The collection cannot be bound more than once.
         *
         * @error collection-bind-to-rebind
         */
        throw new ckeditorerror["b" /* default */]('collection-bind-to-rebind: The collection cannot be bound more than once.', this);
      }

      this._bindToCollection = externalCollection;
      return {
        as: function as(Class) {
          _this._setUpBindToBinding(function (item) {
            return new Class(item);
          });
        },
        using: function using(callbackOrProperty) {
          if (typeof callbackOrProperty == 'function') {
            _this._setUpBindToBinding(function (item) {
              return callbackOrProperty(item);
            });
          } else {
            _this._setUpBindToBinding(function (item) {
              return item[callbackOrProperty];
            });
          }
        }
      };
    }
    /**
     * Finalizes and activates a binding initiated by {#bindTo}.
     *
     * @protected
     * @param {Function} factory A function which produces collection items.
     */

  }, {
    key: "_setUpBindToBinding",
    value: function _setUpBindToBinding(factory) {
      var _this2 = this;

      var externalCollection = this._bindToCollection; // Adds the item to the collection once a change has been done to the external collection.
      //
      // @private

      var addItem = function addItem(evt, externalItem, index) {
        var isExternalBoundToThis = externalCollection._bindToCollection == _this2;

        var externalItemBound = externalCollection._bindToInternalToExternalMap.get(externalItem); // If an external collection is bound to this collection, which makes it a 2–way binding,
        // and the particular external collection item is already bound, don't add it here.
        // The external item has been created **out of this collection's item** and (re)adding it will
        // cause a loop.


        if (isExternalBoundToThis && externalItemBound) {
          _this2._bindToExternalToInternalMap.set(externalItem, externalItemBound);

          _this2._bindToInternalToExternalMap.set(externalItemBound, externalItem);
        } else {
          var item = factory(externalItem); // When there is no item we need to remember skipped index first and then we can skip this item.

          if (!item) {
            _this2._skippedIndexesFromExternal.push(index);

            return;
          } // Lets try to put item at the same index as index in external collection
          // but when there are a skipped items in one or both collections we need to recalculate this index.


          var finalIndex = index; // When we try to insert item after some skipped items from external collection we need
          // to include this skipped items and decrease index.
          //
          // For the following example:
          // external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal' ]
          // internal -> [ A ]
          //
          // Another item is been added at the end of external collection:
          // external.add( 'D' )
          // external -> [ 'A', 'B - skipped for internal', 'C - skipped for internal', 'D' ]
          //
          // We can't just add 'D' to internal at the same index as index in external because
          // this will produce empty indexes what is invalid:
          // internal -> [ 'A', empty, empty, 'D' ]
          //
          // So we need to include skipped items and decrease index
          // internal -> [ 'A', 'D' ]

          var _iterator2 = _createForOfIteratorHelper(_this2._skippedIndexesFromExternal),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var skipped = _step2.value;

              if (index > skipped) {
                finalIndex--;
              }
            } // We need to take into consideration that external collection could skip some items from
            // internal collection.
            //
            // For the following example:
            // internal -> [ 'A', 'B - skipped for external', 'C - skipped for external' ]
            // external -> [ A ]
            //
            // Another item is been added at the end of external collection:
            // external.add( 'D' )
            // external -> [ 'A', 'D' ]
            //
            // We need to include skipped items and place new item after them:
            // internal -> [ 'A', 'B - skipped for external', 'C - skipped for external', 'D' ]

          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          var _iterator3 = _createForOfIteratorHelper(externalCollection._skippedIndexesFromExternal),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var _skipped = _step3.value;

              if (finalIndex >= _skipped) {
                finalIndex++;
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          _this2._bindToExternalToInternalMap.set(externalItem, item);

          _this2._bindToInternalToExternalMap.set(item, externalItem);

          _this2.add(item, finalIndex); // After adding new element to internal collection we need update indexes
          // of skipped items in external collection.


          for (var i = 0; i < externalCollection._skippedIndexesFromExternal.length; i++) {
            if (finalIndex <= externalCollection._skippedIndexesFromExternal[i]) {
              externalCollection._skippedIndexesFromExternal[i]++;
            }
          }
        }
      }; // Load the initial content of the collection.


      var _iterator4 = _createForOfIteratorHelper(externalCollection),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var externalItem = _step4.value;
          addItem(null, externalItem, externalCollection.getIndex(externalItem));
        } // Synchronize the with collection as new items are added.

      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      this.listenTo(externalCollection, 'add', addItem); // Synchronize the with collection as new items are removed.

      this.listenTo(externalCollection, 'remove', function (evt, externalItem, index) {
        var item = _this2._bindToExternalToInternalMap.get(externalItem);

        if (item) {
          _this2.remove(item);
        } // After removing element from external collection we need update/remove indexes
        // of skipped items in internal collection.


        _this2._skippedIndexesFromExternal = _this2._skippedIndexesFromExternal.reduce(function (result, skipped) {
          if (index < skipped) {
            result.push(skipped - 1);
          }

          if (index > skipped) {
            result.push(skipped);
          }

          return result;
        }, []);
      });
    }
    /**
     * Returns an unique id property for a given `item`.
     *
     * The method will generate new id and assign it to the `item` if it doesn't have any.
     *
     * @private
     * @param {Object} item Item to be added.
     * @returns {String}
     */

  }, {
    key: "_getItemIdBeforeAdding",
    value: function _getItemIdBeforeAdding(item) {
      var idProperty = this._idProperty;
      var itemId;

      if (idProperty in item) {
        itemId = item[idProperty];

        if (typeof itemId != 'string') {
          /**
           * This item's id should be a string.
           *
           * @error collection-add-invalid-id
           */
          throw new ckeditorerror["b" /* default */]('collection-add-invalid-id', this);
        }

        if (this.get(itemId)) {
          /**
           * This item already exists in the collection.
           *
           * @error collection-add-item-already-exists
           */
          throw new ckeditorerror["b" /* default */]('collection-add-item-already-exists', this);
        }
      } else {
        item[idProperty] = itemId = uid_uid();
      }

      return itemId;
    }
    /**
     * Iterable interface.
     *
     * @returns {Iterable.<*>}
     */

  }, {
    key: Symbol.iterator,
    value: function value() {
      return this._items[Symbol.iterator]();
    }
    /**
     * Fired when an item is added to the collection.
     *
     * @event add
     * @param {Object} item The added item.
     */

    /**
     * Fired when an item is removed from the collection.
     *
     * @event remove
     * @param {Object} item The removed item.
     * @param {Number} index Index from which item was removed.
     */

  }, {
    key: "length",
    get: function get() {
      return this._items.length;
    }
    /**
     * Returns the first item from the collection or null when collection is empty.
     *
     * @returns {Object|null} The first item or `null` if collection is empty.
     */

  }, {
    key: "first",
    get: function get() {
      return this._items[0] || null;
    }
    /**
     * Returns the last item from the collection or null when collection is empty.
     *
     * @returns {Object|null} The last item or `null` if collection is empty.
     */

  }, {
    key: "last",
    get: function get() {
      return this._items[this.length - 1] || null;
    }
  }]);

  return Collection;
}();


mix(collection_Collection, emittermixin);
/**
 * An object returned by the {@link module:utils/collection~Collection#bindTo `bindTo()`} method
 * providing functions that specify the type of the binding.
 *
 * See the {@link module:utils/collection~Collection#bindTo `bindTo()`} documentation for examples.
 *
 * @interface module:utils/collection~CollectionBindToChain
 */

/**
 * Creates a callback or a property binding.
 *
 * @method #using
 * @param {Function|String} callbackOrProperty  When the function is passed, it should return
 * the collection items. When the string is provided, the property value is used to create the bound collection items.
 */

/**
 * Creates the class factory binding in which items of the source collection are passed to
 * the constructor of the specified class.
 *
 * @method #as
 * @param {Function} Class The class constructor used to create instances in the factory.
 */
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.set.js
var es_set = __webpack_require__("6062");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.includes.js
var es_string_includes = __webpack_require__("2532");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-core/src/plugincollection.js
























/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module core/plugincollection
 */

/* globals console */



/**
 * Manages a list of CKEditor plugins, including loading, resolving dependencies and initialization.
 *
 * @mixes module:utils/emittermixin~EmitterMixin
 */

var plugincollection_PluginCollection = /*#__PURE__*/function () {
  /**
   * Creates an instance of the plugin collection class.
   * Allows loading and initializing plugins and their dependencies.
   * Allows to provide a list of already loaded plugins. These plugins will not be destroyed along with this collection.
   *
   * @param {module:core/editor/editor~Editor|module:core/context~Context} context
   * @param {Array.<Function>} [availablePlugins] Plugins (constructors) which the collection will be able to use
   * when {@link module:core/plugincollection~PluginCollection#init} is used with plugin names (strings, instead of constructors).
   * Usually, the editor will pass its built-in plugins to the collection so they can later be
   * used in `config.plugins` or `config.removePlugins` by names.
   * @param {Iterable.<Array>} contextPlugins A list of already initialized plugins represented by a
   * `[ PluginConstructor, pluginInstance ]` pair.
   */
  function PluginCollection(context) {
    var availablePlugins = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
    var contextPlugins = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

    Object(classCallCheck["a" /* default */])(this, PluginCollection);

    /**
     * @protected
     * @type {module:core/editor/editor~Editor|module:core/context~Context}
     */
    this._context = context;
    /**
     * @protected
     * @type {Map}
     */

    this._plugins = new Map();
    /**
     * A map of plugin constructors that can be retrieved by their names.
     *
     * @protected
     * @type {Map.<String|Function,Function>}
     */

    this._availablePlugins = new Map();

    var _iterator = _createForOfIteratorHelper(availablePlugins),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var PluginConstructor = _step.value;

        if (PluginConstructor.pluginName) {
          this._availablePlugins.set(PluginConstructor.pluginName, PluginConstructor);
        }
      }
      /**
       * Map of {@link module:core/contextplugin~ContextPlugin context plugins} which can be retrieved by their constructors or instances.
       *
       * @protected
       * @type {Map<Function,Function>}
       */

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    this._contextPlugins = new Map();

    var _iterator2 = _createForOfIteratorHelper(contextPlugins),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var _step2$value = _slicedToArray(_step2.value, 2),
            _PluginConstructor = _step2$value[0],
            pluginInstance = _step2$value[1];

        this._contextPlugins.set(_PluginConstructor, pluginInstance);

        this._contextPlugins.set(pluginInstance, _PluginConstructor); // To make it possible to require a plugin by its name.


        if (_PluginConstructor.pluginName) {
          this._availablePlugins.set(_PluginConstructor.pluginName, _PluginConstructor);
        }
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }
  /**
   * Iterable interface.
   *
   * Returns `[ PluginConstructor, pluginInstance ]` pairs.
   *
   * @returns {Iterable.<Array>}
   */


  Object(createClass["a" /* default */])(PluginCollection, [{
    key: Symbol.iterator,
    value: /*#__PURE__*/regeneratorRuntime.mark(function value() {
      var _iterator3, _step3, entry;

      return regeneratorRuntime.wrap(function value$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _iterator3 = _createForOfIteratorHelper(this._plugins);
              _context.prev = 1;

              _iterator3.s();

            case 3:
              if ((_step3 = _iterator3.n()).done) {
                _context.next = 10;
                break;
              }

              entry = _step3.value;

              if (!(typeof entry[0] == 'function')) {
                _context.next = 8;
                break;
              }

              _context.next = 8;
              return entry;

            case 8:
              _context.next = 3;
              break;

            case 10:
              _context.next = 15;
              break;

            case 12:
              _context.prev = 12;
              _context.t0 = _context["catch"](1);

              _iterator3.e(_context.t0);

            case 15:
              _context.prev = 15;

              _iterator3.f();

              return _context.finish(15);

            case 18:
            case "end":
              return _context.stop();
          }
        }
      }, value, this, [[1, 12, 15, 18]]);
    })
    /**
     * Gets the plugin instance by its constructor or name.
     *
     *		// Check if 'Clipboard' plugin was loaded.
     *		if ( editor.plugins.has( 'Clipboard' ) ) {
     *			// Get clipboard plugin instance
     *			const clipboard = editor.plugins.get( 'Clipboard' );
     *
     *			this.listenTo( clipboard, 'inputTransformation', ( evt, data ) => {
     *				// Do something on clipboard input.
     *			} );
     *		}
     *
     * **Note**: This method will throw error if plugin is not loaded. Use `{@link #has editor.plugins.has()}`
     * to check if plugin is available.
     *
     * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.
     * @returns {module:core/plugin~PluginInterface}
     */

  }, {
    key: "get",
    value: function get(key) {
      var plugin = this._plugins.get(key);

      if (!plugin) {
        /**
         * The plugin is not loaded and could not be obtained.
         *
         * Plugin classes (constructors) need to be provided to the editor and must be loaded before they can be obtained from
         * the plugin collection.
         * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}
         * property.
         *
         * **Note**: You can use `{@link module:core/plugincollection~PluginCollection#has editor.plugins.has()}`
         * to check if plugin was loaded.
         *
         * @error plugincollection-plugin-not-loaded
         * @param {String} plugin The name of the plugin which is not loaded.
         */
        var errorMsg = 'plugincollection-plugin-not-loaded: The requested plugin is not loaded.';
        var pluginName = key;

        if (typeof key == 'function') {
          pluginName = key.pluginName || key.name;
        }

        throw new ckeditorerror["b" /* default */](errorMsg, this._context, {
          plugin: pluginName
        });
      }

      return plugin;
    }
    /**
     * Checks if a plugin is loaded.
     *
     *		// Check if the 'Clipboard' plugin was loaded.
     *		if ( editor.plugins.has( 'Clipboard' ) ) {
     *			// Now use the clipboard plugin instance:
     *			const clipboard = editor.plugins.get( 'Clipboard' );
     *
     *			// ...
     *		}
     *
     * @param {Function|String} key The plugin constructor or {@link module:core/plugin~PluginInterface.pluginName name}.
     * @returns {Boolean}
     */

  }, {
    key: "has",
    value: function has(key) {
      return this._plugins.has(key);
    }
    /**
     * Initializes a set of plugins and adds them to the collection.
     *
     * @param {Array.<Function|String>} plugins An array of {@link module:core/plugin~PluginInterface plugin constructors}
     * or {@link module:core/plugin~PluginInterface.pluginName plugin names}. The second option (names) works only if
     * `availablePlugins` were passed to the {@link #constructor}.
     * @param {Array.<String|Function>} [removePlugins] Names of plugins or plugin constructors
     * that should not be loaded (despite being specified in the `plugins` array).
     * @returns {Promise.<module:core/plugin~LoadedPlugins>} A promise which gets resolved once all plugins are loaded
     * and available in the collection.
     */

  }, {
    key: "init",
    value: function init(plugins) {
      var removePlugins = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
      var that = this;
      var context = this._context;
      var loading = new Set();
      var loaded = [];
      var pluginConstructors = mapToAvailableConstructors(plugins);
      var removePluginConstructors = mapToAvailableConstructors(removePlugins);
      var missingPlugins = getMissingPluginNames(plugins);

      if (missingPlugins) {
        /**
         * Some plugins are not available and could not be loaded.
         *
         * Plugin classes (constructors) need to be provided to the editor before they can be loaded by name.
         * This is usually done in CKEditor 5 builds by setting the {@link module:core/editor/editor~Editor.builtinPlugins}
         * property.
         *
         * **If you see this warning when using one of the {@glink builds/index CKEditor 5 Builds}**, it means
         * that you try to enable a plugin which was not included in that build. This may be due to a typo
         * in the plugin name or simply because that plugin is not a part of this build. In the latter scenario,
         * read more about {@glink builds/guides/development/custom-builds custom builds}.
         *
         * **If you see this warning when using one of the editor creators directly** (not a build), then it means
         * that you tried loading plugins by name. However, unlike CKEditor 4, CKEditor 5 does not implement a "plugin loader".
         * This means that CKEditor 5 does not know where to load the plugin modules from. Therefore, you need to
         * provide each plugin through reference (as a constructor function). Check out the examples in
         * {@glink builds/guides/integration/advanced-setup#scenario-2-building-from-source "Building from source"}.
         *
         * @error plugincollection-plugin-not-found
         * @param {Array.<String>} plugins The name of the plugins which could not be loaded.
         */
        var errorMsg = 'plugincollection-plugin-not-found: Some plugins are not available and could not be loaded.'; // Log the error so it's more visible on the console. Hopefully, for better DX.

        console.error(Object(ckeditorerror["a" /* attachLinkToDocumentation */])(errorMsg), {
          plugins: missingPlugins
        });
        return Promise.reject(new ckeditorerror["b" /* default */](errorMsg, context, {
          plugins: missingPlugins
        }));
      }

      return Promise.all(pluginConstructors.map(loadPlugin)).then(function () {
        return initPlugins(loaded, 'init');
      }).then(function () {
        return initPlugins(loaded, 'afterInit');
      }).then(function () {
        return loaded;
      });

      function loadPlugin(PluginConstructor) {
        if (removePluginConstructors.includes(PluginConstructor)) {
          return;
        } // The plugin is already loaded or being loaded - do nothing.


        if (that._plugins.has(PluginConstructor) || loading.has(PluginConstructor)) {
          return;
        }

        return instantiatePlugin(PluginConstructor).catch(function (err) {
          /**
           * It was not possible to load the plugin.
           *
           * This is a generic error logged to the console when a JavaSript error is thrown during the initialization
           * of one of the plugins.
           *
           * If you correctly handled the promise returned by the editor's `create()` method (like shown below),
           * you will find the original error logged to the console, too:
           *
           *		ClassicEditor.create( document.getElementById( 'editor' ) )
           *			.then( editor => {
           *				// ...
           * 			} )
           *			.catch( error => {
           *				console.error( error );
           *			} );
           *
           * @error plugincollection-load
           * @param {String} plugin The name of the plugin that could not be loaded.
           */
          console.error(Object(ckeditorerror["a" /* attachLinkToDocumentation */])('plugincollection-load: It was not possible to load the plugin.'), {
            plugin: PluginConstructor
          });
          throw err;
        });
      }

      function initPlugins(loadedPlugins, method) {
        return loadedPlugins.reduce(function (promise, plugin) {
          if (!plugin[method]) {
            return promise;
          }

          if (that._contextPlugins.has(plugin)) {
            return promise;
          }

          return promise.then(plugin[method].bind(plugin));
        }, Promise.resolve());
      }

      function instantiatePlugin(PluginConstructor) {
        return new Promise(function (resolve) {
          loading.add(PluginConstructor);

          if (PluginConstructor.requires) {
            PluginConstructor.requires.forEach(function (RequiredPluginConstructorOrName) {
              var RequiredPluginConstructor = getPluginConstructor(RequiredPluginConstructorOrName);

              if (PluginConstructor.isContextPlugin && !RequiredPluginConstructor.isContextPlugin) {
                /**
                 * If a plugin is a context plugin, all plugins it requires should also be context plugins
                 * instead of plugins. In other words, if one plugin can be used in the context,
                 * all its requirements should also be ready to be used in the context. Note that the context
                 * provides only a part of the API provided by the editor. If one plugin needs a full
                 * editor API, all plugins which require it are considered as plugins that need a full
                 * editor API.
                 *
                 * @error plugincollection-context-required
                 * @param {String} plugin The name of the required plugin.
                 * @param {String} requiredBy The name of the parent plugin.
                 */
                throw new ckeditorerror["b" /* default */]('plugincollection-context-required: Context plugin can not require plugin which is not a context plugin', null, {
                  plugin: RequiredPluginConstructor.name,
                  requiredBy: PluginConstructor.name
                });
              }

              if (removePlugins.includes(RequiredPluginConstructor)) {
                /**
                 * Cannot load a plugin because one of its dependencies is listed in the `removePlugins` option.
                 *
                 * @error plugincollection-required
                 * @param {String} plugin The name of the required plugin.
                 * @param {String} requiredBy The name of the parent plugin.
                 */
                throw new ckeditorerror["b" /* default */]('plugincollection-required: Cannot load a plugin because one of its dependencies is listed in' + 'the `removePlugins` option.', context, {
                  plugin: RequiredPluginConstructor.name,
                  requiredBy: PluginConstructor.name
                });
              }

              loadPlugin(RequiredPluginConstructor);
            });
          }

          var plugin = that._contextPlugins.get(PluginConstructor) || new PluginConstructor(context);

          that._add(PluginConstructor, plugin);

          loaded.push(plugin);
          resolve();
        });
      }

      function getPluginConstructor(PluginConstructorOrName) {
        if (typeof PluginConstructorOrName == 'function') {
          return PluginConstructorOrName;
        }

        return that._availablePlugins.get(PluginConstructorOrName);
      }

      function getMissingPluginNames(plugins) {
        var missingPlugins = [];

        var _iterator4 = _createForOfIteratorHelper(plugins),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var pluginNameOrConstructor = _step4.value;

            if (!getPluginConstructor(pluginNameOrConstructor)) {
              missingPlugins.push(pluginNameOrConstructor);
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        return missingPlugins.length ? missingPlugins : null;
      }

      function mapToAvailableConstructors(plugins) {
        return plugins.map(function (pluginNameOrConstructor) {
          return getPluginConstructor(pluginNameOrConstructor);
        }).filter(function (PluginConstructor) {
          return !!PluginConstructor;
        });
      }
    }
    /**
     * Destroys all loaded plugins.
     *
     * @returns {Promise}
     */

  }, {
    key: "destroy",
    value: function destroy() {
      var promises = [];

      var _iterator5 = _createForOfIteratorHelper(this),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _step5$value = _slicedToArray(_step5.value, 2),
              pluginInstance = _step5$value[1];

          if (typeof pluginInstance.destroy == 'function' && !this._contextPlugins.has(pluginInstance)) {
            promises.push(pluginInstance.destroy());
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return Promise.all(promises);
    }
    /**
     * Adds the plugin to the collection. Exposed mainly for testing purposes.
     *
     * @protected
     * @param {Function} PluginConstructor The plugin constructor.
     * @param {module:core/plugin~PluginInterface} plugin The instance of the plugin.
     */

  }, {
    key: "_add",
    value: function _add(PluginConstructor, plugin) {
      this._plugins.set(PluginConstructor, plugin);

      var pluginName = PluginConstructor.pluginName;

      if (!pluginName) {
        return;
      }

      if (this._plugins.has(pluginName)) {
        /**
         * Two plugins with the same {@link module:core/plugin~PluginInterface.pluginName} were loaded.
         * This will lead to runtime conflicts between these plugins.
         *
         * In practice, this warning usually means that new plugins were added to an existing CKEditor 5 build.
         * Plugins should always be added to a source version of the editor (`@ckeditor/ckeditor5-editor-*`),
         * not to an editor imported from one of the `@ckeditor/ckeditor5-build-*` packages.
         *
         * Check your import paths and the list of plugins passed to
         * {@link module:core/editor/editor~Editor.create `Editor.create()`}
         * or specified in {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}.
         *
         * The second option is that your `node_modules/` directory contains duplicated versions of the same
         * CKEditor 5 packages. Normally, on clean installations, npm deduplicates packages in `node_modules/`, so
         * it may be enough to call `rm -rf node_modules && npm i`. However, if you installed conflicting versions
         * of packages, their dependencies may need to be installed in more than one version which may lead to this
         * warning.
         *
         * Technically speaking, this error occurs because after adding a plugin to an existing editor build
         * dependencies of this plugin are being duplicated.
         * They are already built into that editor build and now get added for the second time as dependencies
         * of the plugin you are installing.
         *
         * Read more about {@glink builds/guides/integration/installing-plugins installing plugins}.
         *
         * @error plugincollection-plugin-name-conflict
         * @param {String} pluginName The duplicated plugin name.
         * @param {Function} plugin1 The first plugin constructor.
         * @param {Function} plugin2 The second plugin constructor.
         */
        throw new ckeditorerror["b" /* default */]('plugincollection-plugin-name-conflict: Two plugins with the same name were loaded.', null, {
          pluginName: pluginName,
          plugin1: this._plugins.get(pluginName).constructor,
          plugin2: PluginConstructor
        });
      }

      this._plugins.set(pluginName, plugin);
    }
  }]);

  return PluginCollection;
}();


mix(plugincollection_PluginCollection, emittermixin);
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.replace.js
var es_string_replace = __webpack_require__("5319");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.constructor.js
var es_number_constructor = __webpack_require__("a9e3");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.assign.js
var es_object_assign = __webpack_require__("cca6");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/translation-service.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* globals window */

/**
 * @module utils/translation-service
 */

/* istanbul ignore else */

if (!window.CKEDITOR_TRANSLATIONS) {
  window.CKEDITOR_TRANSLATIONS = {};
}
/**
 * Adds translations to existing ones or overrides the existing translations. These translations will later
 * be available for the {@link module:utils/locale~Locale#t `t()`} function.
 *
 * The `translations` is an object which consists of `messageId: translation` pairs. Note that the message ID can be
 * either constructed from the message string or from the message ID if it was passed
 * (this happens rarely and mostly for short messages or messages with placeholders).
 * Since the editor displays only the message string, the message ID can be found either in the source code or in the
 * built translations for another language.
 *
 *		add( 'pl', {
 *			'Cancel': 'Anuluj',
 *			'IMAGE': 'obraz', // Note that the `IMAGE` comes from the message ID, while the string can be `image`.
 *		} );
 *
 * If the message is supposed to support various plural forms, make sure to provide an array with the singular form and all plural forms:
 *
 *		add( 'pl', {
 *	 		'Add space': [ 'Dodaj spację', 'Dodaj %0 spacje', 'Dodaj %0 spacji' ]
 * 		} );
 *
 * You should also specify the third argument (the `getPluralForm()` function) that will be used to determine the plural form if no
 * language file was loaded for that language. All language files coming from CKEditor 5 sources will have this option set, so
 * these plural form rules will be reused by other translations added to the registered languages. The `getPluralForm()` function
 * can return either a Boolean or a number.
 *
 * 		add( 'en', {
 *	 		// ... Translations.
 * 		}, n => n !== 1 );
 * 		add( 'pl', {
 *	 		// ... Translations.
 * 		}, n => n == 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && ( n % 100 < 10 || n % 100 >= 20 ) ? 1 : 2 );
 *
 * All translations extend the global `window.CKEDITOR_TRANSLATIONS` object. An example of this object can be found below:
 *
 * 		{
 * 			pl: {
 *				dictionary: {
 *					'Cancel': 'Anuluj',
 *					'Add space': [ 'Dodaj spację', 'Dodaj %0 spacje', 'Dodaj %0 spacji' ]
 *				},
 *				// A function that returns the plural form index.
 *				getPluralForm: n => n !==1
 *			}
 *			// Other languages.
 *		}
 *
 * If you cannot import this function from this module (e.g. because you use a CKEditor 5 build), you can
 * still add translations by extending the global `window.CKEDITOR_TRANSLATIONS` object by using a function like
 * the one below:
 *
 *		function addTranslations( language, translations, getPluralForm ) {
 *			if ( !window.CKEDITOR_TRANSLATIONS ) {
 *				window.CKEDITOR_TRANSLATIONS = {};
 *			}

 *			if ( !window.CKEDITOR_TRANSLATIONS[ language ] ) {
 *				window.CKEDITOR_TRANSLATIONS[ language ] = {};
 *			}
 *
 *			const languageTranslations = window.CKEDITOR_TRANSLATIONS[ language ];
 *
 * 			languageTranslations.dictionary = languageTranslations.dictionary || {};
 * 			languageTranslations.getPluralForm = getPluralForm || languageTranslations.getPluralForm;
 *
 *			// Extend the dictionary for the given language.
 *			Object.assign( languageTranslations.dictionary, translations );
 *		}
 *
 * @param {String} language Target language.
 * @param {Object.<String,*>} translations An object with translations which will be added to the dictionary.
 * For each message ID the value should be either a translation or an array of translations if the message
 * should support plural forms.
 * @param {Function} getPluralForm A function that returns the plural form index (a number).
 */


function translation_service_add(language, translations, getPluralForm) {
  if (!window.CKEDITOR_TRANSLATIONS[language]) {
    window.CKEDITOR_TRANSLATIONS[language] = {};
  }

  var languageTranslations = window.CKEDITOR_TRANSLATIONS[language];
  languageTranslations.dictionary = languageTranslations.dictionary || {};
  languageTranslations.getPluralForm = getPluralForm || languageTranslations.getPluralForm;
  Object.assign(languageTranslations.dictionary, translations);
}
/**
 * **Note:** This method is internal, use {@link module:utils/locale~Locale#t the `t()` function} instead to translate
 * the editor UI parts.
 *
 * This function is responsible for translating messages to the specified language. It uses translations added perviously
 * by {@link module:utils/translation-service~add} (a translations dictionary and the `getPluralForm()` function
 * to provide accurate translations of plural forms).
 *
 * When no translation is defined in the dictionary or the dictionary does not exist, this function returns
 * the original message string or the message plural depending on the number of elements.
 *
 *		translate( 'pl', { string: 'Cancel' } ); // 'Cancel'
 *
 * The third optional argument is the number of elements, based on which the single form or one of the plural forms
 * should be picked when the message is supposed to support various plural forms.
 *
 * 		translate( 'en', { string: 'Add a space', plural: 'Add %0 spaces' }, 1 ); // 'Add a space'
 * 		translate( 'en', { string: 'Add a space', plural: 'Add %0 spaces' }, 3 ); // 'Add %0 spaces'
 *
 * The message should provide an ID using the `id` property when the message strings are not unique and their
 * translations should be different.
 *
 *		translate( 'en', { string: 'image', id: 'ADD_IMAGE' } );
 *		translate( 'en', { string: 'image', id: 'AN_IMAGE' } );
 *
 * @protected
 * @param {String} language Target language.
 * @param {module:utils/translation-service~Message|String} message A message that will be translated.
 * @param {Number} [quantity] The number of elements for which a plural form should be picked from the target language dictionary.
 * @returns {String} Translated sentence.
 */

function _translate(language, message) {
  var quantity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

  if (typeof quantity !== 'number') {
    /**
     * An incorrect value was passed to the translation function. This was probably caused
     * by an incorrect message interpolation of a plural form. Note that for messages supporting plural forms
     * the second argument of the `t()` function should always be a number or an array with a number as the first element.
     *
     * @error translation-service-quantity-not-a-number
     */
    throw new ckeditorerror["b" /* default */]('translation-service-quantity-not-a-number: Expecting `quantity` to be a number.', null, {
      quantity: quantity
    });
  }

  var numberOfLanguages = getNumberOfLanguages();

  if (numberOfLanguages === 1) {
    // Override the language to the only supported one.
    // This can't be done in the `Locale` class, because the translations comes after the `Locale` class initialization.
    language = Object.keys(window.CKEDITOR_TRANSLATIONS)[0];
  }

  var messageId = message.id || message.string;

  if (numberOfLanguages === 0 || !hasTranslation(language, messageId)) {
    if (quantity !== 1) {
      // Return the default plural form that was passed in the `message.plural` parameter.
      return message.plural;
    }

    return message.string;
  }

  var dictionary = window.CKEDITOR_TRANSLATIONS[language].dictionary;

  var getPluralForm = window.CKEDITOR_TRANSLATIONS[language].getPluralForm || function (n) {
    return n === 1 ? 0 : 1;
  };

  if (typeof dictionary[messageId] === 'string') {
    return dictionary[messageId];
  }

  var pluralFormIndex = Number(getPluralForm(quantity)); // Note: The `translate` function is not responsible for replacing `%0, %1, ...` with values.

  return dictionary[messageId][pluralFormIndex];
}
/**
 * Clears dictionaries for test purposes.
 *
 * @protected
 */

function _clear() {
  window.CKEDITOR_TRANSLATIONS = {};
} // Checks whether the dictionary exists and translation in that dictionary exists.

function hasTranslation(language, messageId) {
  return !!window.CKEDITOR_TRANSLATIONS[language] && !!window.CKEDITOR_TRANSLATIONS[language].dictionary[messageId];
}

function getNumberOfLanguages() {
  return Object.keys(window.CKEDITOR_TRANSLATIONS).length;
}
/**
 * The internationalization message interface. A message that implements this interface can be passed to the `t()` function
 * to be translated to the target UI language.
 *
 * @typedef {Object} module:utils/translation-service~Message
 *
 * @property {String} string The message string to translate. Acts as a default translation if the translation for a given language
 * is not defined. When the message is supposed to support plural forms, the string should be the English singular form of the message.
 * @property {String} [id] The message ID. If passed, the message ID is taken from this property instead of the `message.string`.
 * This property is useful when various messages share the same message string, for example, the `editor` string in `in the editor`
 * and `my editor` sentences.
 * @property {String} [plural] The plural form of the message. This property should be skipped when a message is not supposed
 * to support plural forms. Otherwise it should always be set to a string with the English plural form of the message.
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/locale.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/locale
 */

/* globals console */

var RTL_LANGUAGE_CODES = ['ar', 'fa', 'he', 'ku', 'ug'];
/**
 * Represents the localization services.
 */

var locale_Locale = /*#__PURE__*/function () {
  /**
   * Creates a new instance of the locale class. Learn more about
   * {@glink features/ui-language configuring the language of the editor}.
   *
   * @param {Object} [options] Locale configuration.
   * @param {String} [options.uiLanguage='en'] The editor UI language code in the
   * [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format. See {@link #uiLanguage}.
   * @param {String} [options.contentLanguage] The editor content language code in the
   * [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format. If not specified, the same as `options.language`.
   * See {@link #contentLanguage}.
   */
  function Locale() {
    var _this = this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    Object(classCallCheck["a" /* default */])(this, Locale);

    /**
     * The editor UI language code in the [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
     *
     * If the {@link #contentLanguage content language} was not specified in the `Locale` constructor,
     * it also defines the language of the content.
     *
     * @readonly
     * @member {String}
     */
    this.uiLanguage = options.uiLanguage || 'en';
    /**
     * The editor content language code in the [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
     *
     * Usually the same as the {@link #uiLanguage editor language}, it can be customized by passing an optional
     * argument to the `Locale` constructor.
     *
     * @readonly
     * @member {String}
     */

    this.contentLanguage = options.contentLanguage || this.uiLanguage;
    /**
     * Text direction of the {@link #uiLanguage editor UI language}. Either `'ltr'` or `'rtl'`.
     *
     * @readonly
     * @member {String}
     */

    this.uiLanguageDirection = getLanguageDirection(this.uiLanguage);
    /**
     * Text direction of the {@link #contentLanguage editor content language}.
     *
     * If the content language was passed directly to the `Locale` constructor, this property represents the
     * direction of that language.
     *
     * If the {@link #contentLanguage editor content language} was derived from the {@link #uiLanguage editor language},
     * the content language direction is the same as the {@link #uiLanguageDirection UI language direction}.
     *
     * The value is either `'ltr'` or `'rtl'`.
     *
     * @readonly
     * @member {String}
     */

    this.contentLanguageDirection = getLanguageDirection(this.contentLanguage);
    /**
     * Translates the given message to the {@link #uiLanguage}. This method is also available in
     * {@link module:core/editor/editor~Editor#t `Editor`} and {@link module:ui/view~View#t `View`}.
     *
     * This method's context is statically bound to the `Locale` instance and **should always be called as a function**:
     *
     *		const t = locale.t;
     *		t( 'Label' );
     *
     * The message can be either a string or an object implementing the {@link module:utils/translation-service~Message} interface.
     *
     * The message may contain placeholders (`%<index>`) for value(s) that are passed as a `values` parameter.
     * For an array of values, the `%<index>` will be changed to an element of that array at the given index.
     * For a single value passed as the second argument, only the `%0` placeholders will be changed to the provided value.
     *
     *		t( 'Created file "%0" in %1ms.', [ fileName, timeTaken ] );
     * 		t( 'Created file "%0", fileName );
     *
     * The message supports plural forms. To specify the plural form, use the `plural` property. Singular or plural form
     * will be chosen depending on the first value from the passed `values`. The value of the `plural` property is used
     * as a default plural translation when the translation for the target language is missing.
     *
     *		t( { string: 'Add a space', plural: 'Add %0 spaces' }, 1 ); // 'Add a space' for the English language.
     *		t( { string: 'Add a space', plural: 'Add %0 spaces' }, 5 ); // 'Add 5 spaces' for the English language.
     *		t( { string: '%1 a space', plural: '%1 %0 spaces' }, [ 2, 'Add' ] ); // 'Add 2 spaces' for the English language.
     *
     * 		t( { string: 'Add a space', plural: 'Add %0 spaces' }, 1 ); // 'Dodaj spację' for the Polish language.
     *		t( { string: 'Add a space', plural: 'Add %0 spaces' }, 5 ); // 'Dodaj 5 spacji' for the Polish language.
     *		t( { string: '%1 a space', plural: '%1 %0 spaces' }, [ 2, 'Add' ] ); // 'Dodaj 2 spacje' for the Polish language.
     *
     *  * The message should provide an ID using the `id` property when the message strings are not unique and their
     * translations should be different.
     *
     *		translate( 'en', { string: 'image', id: 'ADD_IMAGE' } );
     *		translate( 'en', { string: 'image', id: 'AN_IMAGE' } );
     *
     * @method #t
     * @param {String|module:utils/translation-service~Message} message A message that will be localized (translated).
     * @param {String|Number|Array.<String|Number>} [values] A value or an array of values that will fill message placeholders.
     * For messages supporting plural forms the first value will determine the plural form.
     * @returns {String}
     */

    this.t = function (message, values) {
      return _this._t(message, values);
    };
  }
  /**
   * The editor UI language code in the [ISO 639-1](https://en.wikipedia.org/wiki/ISO_639-1) format.
   *
   * **Note**: This property was deprecated. Please use {@link #uiLanguage} and {@link #contentLanguage}
   * properties instead.
   *
   * @deprecated
   * @member {String}
   */


  Object(createClass["a" /* default */])(Locale, [{
    key: "_t",

    /**
     * An unbound version of the {@link #t} method.
     *
     * @private
     * @param {String|module:utils/translation-service~Message} message
     * @param {Number|String|Array.<Number|String>} [values]
     * @returns {String}
     */
    value: function _t(message) {
      var values = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

      if (!Array.isArray(values)) {
        values = [values];
      }

      if (typeof message === 'string') {
        message = {
          string: message
        };
      }

      var hasPluralForm = !!message.plural;
      var quantity = hasPluralForm ? values[0] : 1;

      var translatedString = _translate(this.uiLanguage, message, quantity);

      return interpolateString(translatedString, values);
    }
  }, {
    key: "language",
    get: function get() {
      /**
       * The {@link module:utils/locale~Locale#language `Locale#language`} property was deprecated and will
       * be removed in the near future. Please use the {@link #uiLanguage} and {@link #contentLanguage} properties instead.
       *
       * @error locale-deprecated-language-property
       */
      console.warn('locale-deprecated-language-property: ' + 'The Locale#language property has been deprecated and will be removed in the near future. ' + 'Please use #uiLanguage and #contentLanguage properties instead.');
      return this.uiLanguage;
    }
  }]);

  return Locale;
}(); // Fills the `%0, %1, ...` string placeholders with values.




function interpolateString(string, values) {
  return string.replace(/%(\d+)/g, function (match, index) {
    return index < values.length ? values[index] : match;
  });
} // Helps determine whether a language is LTR or RTL.
//
// @param {String} language The ISO 639-1 language code.
// @returns {String} 'ltr' or 'rtl


function getLanguageDirection(languageCode) {
  return RTL_LANGUAGE_CODES.includes(languageCode) ? 'rtl' : 'ltr';
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-core/src/context.js











/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module core/context
 */





/**
 * Provides a common, higher-level environment for solutions that use multiple {@link module:core/editor/editor~Editor editors}
 * or plugins that work outside the editor. Use it instead of {@link module:core/editor/editor~Editor.create `Editor.create()`}
 * in advanced application integrations.
 *
 * All configuration options passed to a context will be used as default options for editor instances initialized in that context.
 *
 * {@link module:core/contextplugin~ContextPlugin Context plugins} passed to a context instance will be shared among all
 * editor instances initialized in this context. These will be the same plugin instances for all the editors.
 *
 * **Note:** The context can only be initialized with {@link module:core/contextplugin~ContextPlugin context plugins}
 * (e.g. [comments](https://ckeditor.com/collaboration/comments/)). Regular {@link module:core/plugin~Plugin plugins} require an
 * editor instance to work and cannot be added to a context.
 *
 * **Note:** You can add a context plugin to an editor instance, though.
 *
 * If you are using multiple editor instances on one page and use any context plugins, create a context to share the configuration and
 * plugins among these editors. Some plugins will use the information about all existing editors to better integrate between them.
 *
 * If you are using plugins that do not require an editor to work (e.g. [comments](https://ckeditor.com/collaboration/comments/)),
 * enable and configure them using the context.
 *
 * If you are using only a single editor on each page, use {@link module:core/editor/editor~Editor.create `Editor.create()`} instead.
 * In such case, a context instance will be created by the editor instance in a transparent way.
 *
 * See {@link module:core/context~Context.create `Context.create()`} for usage examples.
 */

var context_Context = /*#__PURE__*/function () {
  /**
   * Creates a context instance with a given configuration.
   *
   * Usually not to be used directly. See the static {@link module:core/context~Context.create `create()`} method.
   *
   * @param {Object} [config={}] The context configuration.
   */
  function Context(config) {
    Object(classCallCheck["a" /* default */])(this, Context);

    /**
     * Stores all the configurations specific to this context instance.
     *
     * @readonly
     * @type {module:utils/config~Config}
     */
    this.config = new config_Config(config, this.constructor.defaultConfig);
    var availablePlugins = this.constructor.builtinPlugins;
    this.config.define('plugins', availablePlugins);
    /**
     * The plugins loaded and in use by this context instance.
     *
     * @readonly
     * @type {module:core/plugincollection~PluginCollection}
     */

    this.plugins = new plugincollection_PluginCollection(this, availablePlugins);
    var languageConfig = this.config.get('language') || {};
    /**
     * @readonly
     * @type {module:utils/locale~Locale}
     */

    this.locale = new locale_Locale({
      uiLanguage: typeof languageConfig === 'string' ? languageConfig : languageConfig.ui,
      contentLanguage: this.config.get('language.content')
    });
    /**
     * Shorthand for {@link module:utils/locale~Locale#t}.
     *
     * @see module:utils/locale~Locale#t
     * @method #t
     */

    this.t = this.locale.t;
    /**
     * A list of editors that this context instance is injected to.
     *
     * @readonly
     * @type {module:utils/collection~Collection}
     */

    this.editors = new collection_Collection();
    /**
     * Reference to the editor which created the context.
     * Null when the context was created outside of the editor.
     *
     * It is used to destroy the context when removing the editor that has created the context.
     *
     * @private
     * @type {module:core/editor/editor~Editor|null}
     */

    this._contextOwner = null;
  }
  /**
   * Loads and initializes plugins specified in the configuration.
   *
   * @returns {Promise.<module:core/plugin~LoadedPlugins>} A promise which resolves
   * once the initialization is completed, providing an array of loaded plugins.
   */


  Object(createClass["a" /* default */])(Context, [{
    key: "initPlugins",
    value: function initPlugins() {
      var plugins = this.config.get('plugins') || [];

      var _iterator = _createForOfIteratorHelper(plugins),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var Plugin = _step.value;

          if (typeof Plugin != 'function') {
            /**
             * Only a constructor function is allowed as a {@link module:core/contextplugin~ContextPlugin context plugin}.
             *
             * @error context-initplugins-constructor-only
             */
            throw new ckeditorerror["b" /* default */]('context-initplugins-constructor-only: Only a constructor function is allowed as a context plugin.', null, {
              Plugin: Plugin
            });
          }

          if (Plugin.isContextPlugin !== true) {
            /**
             * Only a plugin marked as a {@link module:core/contextplugin~ContextPlugin.isContextPlugin context plugin}
             * is allowed to be used with a context.
             *
             * @error context-initplugins-invalid-plugin
             */
            throw new ckeditorerror["b" /* default */]('context-initplugins-invalid-plugin: Only a plugin marked as a context plugin is allowed to be used with a context.', null, {
              Plugin: Plugin
            });
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return this.plugins.init(plugins);
    }
    /**
     * Destroys the context instance and all editors used with the context,
     * releasing all resources used by the context.
     *
     * @returns {Promise} A promise that resolves once the context instance is fully destroyed.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      var _this = this;

      return Promise.all(Array.from(this.editors, function (editor) {
        return editor.destroy();
      })).then(function () {
        return _this.plugins.destroy();
      });
    }
    /**
     * Adds a reference to the editor which is used with this context.
     *
     * When the given editor has created the context, the reference to this editor will be stored
     * as a {@link ~Context#_contextOwner}.
     *
     * This method should only be used by the editor.
     *
     * @protected
     * @param {module:core/editor/editor~Editor} editor
     * @param {Boolean} isContextOwner Stores the given editor as a context owner.
     */

  }, {
    key: "_addEditor",
    value: function _addEditor(editor, isContextOwner) {
      if (this._contextOwner) {
        /**
         * Cannot add multiple editors to the context which is created by the editor.
         *
         * @error context-addEditor-private-context
         */
        throw new ckeditorerror["b" /* default */]('context-addEditor-private-context: Cannot add multiple editors to the context which is created by the editor.');
      }

      this.editors.add(editor);

      if (isContextOwner) {
        this._contextOwner = editor;
      }
    }
    /**
     * Removes a reference to the editor which was used with this context.
     * When the context was created by the given editor, the context will be destroyed.
     *
     * This method should only be used by the editor.
     *
     * @protected
     * @param {module:core/editor/editor~Editor} editor
     * @return {Promise} A promise that resolves once the editor is removed from the context or when the context was destroyed.
     */

  }, {
    key: "_removeEditor",
    value: function _removeEditor(editor) {
      if (this.editors.has(editor)) {
        this.editors.remove(editor);
      }

      if (this._contextOwner === editor) {
        return this.destroy();
      }

      return Promise.resolve();
    }
    /**
     * Returns the context configuration which will be copied to the editors created using this context.
     *
     * The configuration returned by this method has the plugins configuration removed &mdash; plugins are shared with all editors
     * through another mechanism.
     *
     * This method should only be used by the editor.
     *
     * @protected
     * @returns {Object} Configuration as a plain object.
     */

  }, {
    key: "_getEditorConfig",
    value: function _getEditorConfig() {
      var result = {};

      var _iterator2 = _createForOfIteratorHelper(this.config.names()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var name = _step2.value;

          if (!['plugins', 'removePlugins', 'extraPlugins'].includes(name)) {
            result[name] = this.config.get(name);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return result;
    }
    /**
     * Creates and initializes a new context instance.
     *
     *		const commonConfig = { ... }; // Configuration for all the plugins and editors.
     *		const editorPlugins = [ ... ]; // Regular plugins here.
     *
     *		Context
     *			.create( {
     *				// Only context plugins here.
     *				plugins: [ ... ],
     *
     *				// Configure the language for all the editors (it cannot be overwritten).
     *				language: { ... },
     *
     *				// Configuration for context plugins.
     *				comments: { ... },
     *				...
     *
     *				// Default configuration for editor plugins.
     *				toolbar: { ... },
     *				image: { ... },
     *				...
     *			} )
     *			.then( context => {
     *				const promises = [];
     *
     *				promises.push( ClassicEditor.create(
     *					document.getElementById( 'editor1' ),
     *					{
     *						editorPlugins,
     *						context
     *					}
     *				) );
     *
     *				promises.push( ClassicEditor.create(
     *					document.getElementById( 'editor2' ),
     *					{
     *						editorPlugins,
     *						context,
     *						toolbar: { ... } // You can overwrite the configuration of the context.
     *					}
     *				) );
     *
     *				return Promise.all( promises );
     *			} );
     *
     * @param {Object} [config] The context configuration.
     * @returns {Promise} A promise resolved once the context is ready. The promise resolves with the created context instance.
     */

  }], [{
    key: "create",
    value: function create(config) {
      var _this2 = this;

      return new Promise(function (resolve) {
        var context = new _this2(config);
        resolve(context.initPlugins().then(function () {
          return context;
        }));
      });
    }
  }]);

  return Context;
}();
/**
 * An array of plugins built into the `Context` class.
 *
 * It is used in CKEditor 5 builds featuring `Context` to provide a list of context plugins which are later automatically initialized
 * during the context initialization.
 *
 * They will be automatically initialized by `Context` unless `config.plugins` is passed.
 *
 *		// Build some context plugins into the Context class first.
 *		Context.builtinPlugins = [ FooPlugin, BarPlugin ];
 *
 *		// Normally, you need to define config.plugins, but since Context.builtinPlugins was
 *		// defined, now you can call create() without any configuration.
 *		Context
 *			.create()
 *			.then( context => {
 *				context.plugins.get( FooPlugin ); // -> An instance of the Foo plugin.
 *				context.plugins.get( BarPlugin ); // -> An instance of the Bar plugin.
 *			} );
 *
 * See also {@link module:core/context~Context.defaultConfig `Context.defaultConfig`}
 * and {@link module:core/editor/editor~Editor.builtinPlugins `Editor.builtinPlugins`}.
 *
 * @static
 * @member {Array.<Function>} module:core/context~Context.builtinPlugins
 */

/**
 * The default configuration which is built into the `Context` class.
 *
 * It is used in CKEditor 5 builds featuring `Context` to provide the default configuration options which are later used during the
 * context initialization.
 *
 *		Context.defaultConfig = {
 *			foo: 1,
 *			bar: 2
 *		};
 *
 *		Context
 *			.create()
 *			.then( context => {
 *				context.config.get( 'foo' ); // -> 1
 *				context.config.get( 'bar' ); // -> 2
 *			} );
 *
 *		// The default options can be overridden by the configuration passed to create().
 *		Context
 *			.create( { bar: 3 } )
 *			.then( context => {
 *				context.config.get( 'foo' ); // -> 1
 *				context.config.get( 'bar' ); // -> 3
 *			} );
 *
 * See also {@link module:core/context~Context.builtinPlugins `Context.builtinPlugins`}
 * and {@link module:core/editor/editor~Editor.defaultConfig `Editor.defaultConfig`}.
 *
 * @static
 * @member {Object} module:core/context~Context.defaultConfig
 */



// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.join.js
var es_array_join = __webpack_require__("a15b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.match.js
var es_string_match = __webpack_require__("466d");

// EXTERNAL MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/construct.js
var construct = __webpack_require__("e7f1");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/comparearrays.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/comparearrays
 */

/**
 * Compares how given arrays relate to each other. One array can be: same as another array, prefix of another array
 * or completely different. If arrays are different, first index at which they differ is returned. Otherwise,
 * a flag specifying the relation is returned. Flags are negative numbers, so whenever a number >= 0 is returned
 * it means that arrays differ.
 *
 *		compareArrays( [ 0, 2 ], [ 0, 2 ] );		// 'same'
 *		compareArrays( [ 0, 2 ], [ 0, 2, 1 ] );		// 'prefix'
 *		compareArrays( [ 0, 2 ], [ 0 ] );			// 'extension'
 *		compareArrays( [ 0, 2 ], [ 1, 2 ] );		// 0
 *		compareArrays( [ 0, 2 ], [ 0, 1 ] );		// 1
 *
 * @param {Array} a Array that is compared.
 * @param {Array} b Array to compare with.
 * @returns {module:utils/comparearrays~ArrayRelation} How array `a` is related to `b`.
 */
function compareArrays(a, b) {
  var minLen = Math.min(a.length, b.length);

  for (var i = 0; i < minLen; i++) {
    if (a[i] != b[i]) {
      // The arrays are different.
      return i;
    }
  } // Both arrays were same at all points.


  if (a.length == b.length) {
    // If their length is also same, they are the same.
    return 'same';
  } else if (a.length < b.length) {
    // Compared array is shorter so it is a prefix of the other array.
    return 'prefix';
  } else {
    // Compared array is longer so it is an extension of the other array.
    return 'extension';
  }
}
/**
 * @typedef {'extension'|'same'|'prefix'} module:utils/comparearrays~ArrayRelation
 */
// CONCATENATED MODULE: ./node_modules/lodash-es/clone.js


/** Used to compose bitmasks for cloning. */
var clone_CLONE_SYMBOLS_FLAG = 4;

/**
 * Creates a shallow clone of `value`.
 *
 * **Note:** This method is loosely based on the
 * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
 * and supports cloning arrays, array buffers, booleans, date objects, maps,
 * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
 * arrays. The own enumerable properties of `arguments` objects are cloned
 * as plain objects. An empty object is returned for uncloneable values such
 * as error objects, functions, DOM nodes, and WeakMaps.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to clone.
 * @returns {*} Returns the cloned value.
 * @see _.cloneDeep
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var shallow = _.clone(objects);
 * console.log(shallow[0] === objects[0]);
 * // => true
 */
function clone_clone(value) {
  return _baseClone(value, clone_CLONE_SYMBOLS_FLAG);
}

/* harmony default export */ var lodash_es_clone = (clone_clone);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/node.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/node
 */




 // To check if component is loaded more than once.


/**
 * Abstract view node class.
 *
 * This is an abstract class. Its constructor should not be used directly.
 * Use the {@link module:engine/view/downcastwriter~DowncastWriter} or {@link module:engine/view/upcastwriter~UpcastWriter}
 * to create new instances of view nodes.
 *
 * @abstract
 */

var node_Node = /*#__PURE__*/function () {
  /**
   * Creates a tree view node.
   *
   * @protected
   * @param {module:engine/view/document~Document} document The document instance to which this node belongs.
   */
  function Node(document) {
    Object(classCallCheck["a" /* default */])(this, Node);

    /**
     * The document instance to which this node belongs.
     *
     * @readonly
     * @member {module:engine/view/document~Document}
     */
    this.document = document;
    /**
     * Parent element. Null by default. Set by {@link module:engine/view/element~Element#_insertChild}.
     *
     * @readonly
     * @member {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|null}
     */

    this.parent = null;
  }
  /**
   * Index of the node in the parent element or null if the node has no parent.
   *
   * Accessing this property throws an error if this node's parent element does not contain it.
   * This means that view tree got broken.
   *
   * @readonly
   * @type {Number|null}
   */


  Object(createClass["a" /* default */])(Node, [{
    key: "isAttached",

    /**
     * Returns true if the node is in a tree rooted in the document (is a descendant of one of its roots).
     *
     * @returns {Boolean}
     */
    value: function isAttached() {
      return this.root.is('rootElement');
    }
    /**
     * Gets a path to the node. The path is an array containing indices of consecutive ancestors of this node,
     * beginning from {@link module:engine/view/node~Node#root root}, down to this node's index.
     *
     *		const abc = downcastWriter.createText( 'abc' );
     *		const foo = downcastWriter.createText( 'foo' );
     *		const h1 = downcastWriter.createElement( 'h1', null, downcastWriter.createText( 'header' ) );
     *		const p = downcastWriter.createElement( 'p', null, [ abc, foo ] );
     *		const div = downcastWriter.createElement( 'div', null, [ h1, p ] );
     *		foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
     *		h1.getPath(); // Returns [ 0 ].
     *		div.getPath(); // Returns [].
     *
     * @returns {Array.<Number>} The path.
     */

  }, {
    key: "getPath",
    value: function getPath() {
      var path = [];
      var node = this; // eslint-disable-line consistent-this

      while (node.parent) {
        path.unshift(node.index);
        node = node.parent;
      }

      return path;
    }
    /**
     * Returns ancestors array of this node.
     *
     * @param {Object} options Options object.
     * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included in parent's array.
     * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from node's parent to root element,
     * otherwise root element will be the first item in the array.
     * @returns {Array} Array with ancestors.
     */

  }, {
    key: "getAncestors",
    value: function getAncestors() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        includeSelf: false,
        parentFirst: false
      };
      var ancestors = [];
      var parent = options.includeSelf ? this : this.parent;

      while (parent) {
        ancestors[options.parentFirst ? 'push' : 'unshift'](parent);
        parent = parent.parent;
      }

      return ancestors;
    }
    /**
     * Returns a {@link module:engine/view/element~Element} or {@link module:engine/view/documentfragment~DocumentFragment}
     * which is a common ancestor of both nodes.
     *
     * @param {module:engine/view/node~Node} node The second node.
     * @param {Object} options Options object.
     * @param {Boolean} [options.includeSelf=false] When set to `true` both nodes will be considered "ancestors" too.
     * Which means that if e.g. node A is inside B, then their common ancestor will be B.
     * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|null}
     */

  }, {
    key: "getCommonAncestor",
    value: function getCommonAncestor(node) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var ancestorsA = this.getAncestors(options);
      var ancestorsB = node.getAncestors(options);
      var i = 0;

      while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
        i++;
      }

      return i === 0 ? null : ancestorsA[i - 1];
    }
    /**
     * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,
     * in different {@link module:engine/view/documentfragment~DocumentFragment}s).
     *
     * @param {module:engine/view/node~Node} node Node to compare with.
     * @returns {Boolean}
     */

  }, {
    key: "isBefore",
    value: function isBefore(node) {
      // Given node is not before this node if they are same.
      if (this == node) {
        return false;
      } // Return `false` if it is impossible to compare nodes.


      if (this.root !== node.root) {
        return false;
      }

      var thisPath = this.getPath();
      var nodePath = node.getPath();
      var result = compareArrays(thisPath, nodePath);

      switch (result) {
        case 'prefix':
          return true;

        case 'extension':
          return false;

        default:
          return thisPath[result] < nodePath[result];
      }
    }
    /**
     * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,
     * in different {@link module:engine/view/documentfragment~DocumentFragment}s).
     *
     * @param {module:engine/view/node~Node} node Node to compare with.
     * @returns {Boolean}
     */

  }, {
    key: "isAfter",
    value: function isAfter(node) {
      // Given node is not before this node if they are same.
      if (this == node) {
        return false;
      } // Return `false` if it is impossible to compare nodes.


      if (this.root !== node.root) {
        return false;
      } // In other cases, just check if the `node` is before, and return the opposite.


      return !this.isBefore(node);
    }
    /**
     * Removes node from parent.
     *
     * @protected
     */

  }, {
    key: "_remove",
    value: function _remove() {
      this.parent._removeChildren(this.index);
    }
    /**
     * @protected
     * @param {module:engine/view/document~ChangeType} type Type of the change.
     * @param {module:engine/view/node~Node} node Changed node.
     * @fires change
     */

  }, {
    key: "_fireChange",
    value: function _fireChange(type, node) {
      this.fire('change:' + type, node);

      if (this.parent) {
        this.parent._fireChange(type, node);
      }
    }
    /**
     * Custom toJSON method to solve child-parent circular dependencies.
     *
     * @returns {Object} Clone of this object with the parent property removed.
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = lodash_es_clone(this); // Due to circular references we need to remove parent reference.

      delete json.parent;
      return json;
    }
    /**
     * Checks whether this object is of the given type.
     *
     * This method is useful when processing view objects that are of unknown type. For example, a function
     * may return a {@link module:engine/view/documentfragment~DocumentFragment} or a {@link module:engine/view/node~Node}
     * that can be either a text node or an element. This method can be used to check what kind of object is returned.
     *
     *		someObject.is( 'element' ); // -> true if this is an element
     *		someObject.is( 'node' ); // -> true if this is a node (a text node or an element)
     *		someObject.is( 'documentFragment' ); // -> true if this is a document fragment
     *
     * Since this method is also available on a range of model objects, you can prefix the type of the object with
     * `model:` or `view:` to check, for example, if this is the model's or view's element:
     *
     *		viewElement.is( 'view:element' ); // -> true
     *		viewElement.is( 'model:element' ); // -> false
     *
     * By using this method it is also possible to check a name of an element:
     *
     *		imgElement.is( 'img' ); // -> true
     *		imgElement.is( 'element', 'img' ); // -> same as above
     *		imgElement.is( 'view:element', 'img' ); // -> same as above, but more precise
     *
     * The list of view objects which implement the `is()` method:
     *
     * * {@link module:engine/view/attributeelement~AttributeElement#is `AttributeElement#is()`}
     * * {@link module:engine/view/containerelement~ContainerElement#is `ContainerElement#is()`}
     * * {@link module:engine/view/documentfragment~DocumentFragment#is `DocumentFragment#is()`}
     * * {@link module:engine/view/documentselection~DocumentSelection#is `DocumentSelection#is()`}
     * * {@link module:engine/view/editableelement~EditableElement#is `EditableElement#is()`}
     * * {@link module:engine/view/element~Element#is `Element#is()`}
     * * {@link module:engine/view/emptyelement~EmptyElement#is `EmptyElement#is()`}
     * * {@link module:engine/view/node~Node#is `Node#is()`}
     * * {@link module:engine/view/position~Position#is `Position#is()`}
     * * {@link module:engine/view/range~Range#is `Range#is()`}
     * * {@link module:engine/view/rooteditableelement~RootEditableElement#is `RootEditableElement#is()`}
     * * {@link module:engine/view/selection~Selection#is `Selection#is()`}
     * * {@link module:engine/view/text~Text#is `Text#is()`}
     * * {@link module:engine/view/textproxy~TextProxy#is `TextProxy#is()`}
     * * {@link module:engine/view/uielement~UIElement#is `UIElement#is()`}
     *
     * @method #is
     * @param {String} type
     * @returns {Boolean}
     */

  }, {
    key: "is",
    value: function is(type) {
      return type === 'node' || type === 'view:node';
    }
    /**
     * Clones this node.
     *
     * @protected
     * @method #_clone
     * @returns {module:engine/view/node~Node} Clone of this node.
     */

    /**
     * Checks if provided node is similar to this node.
     *
     * @method #isSimilar
     * @returns {Boolean} True if nodes are similar.
     */

  }, {
    key: "index",
    get: function get() {
      var pos;

      if (!this.parent) {
        return null;
      } // No parent or child doesn't exist in parent's children.


      if ((pos = this.parent.getChildIndex(this)) == -1) {
        /**
         * The node's parent does not contain this node. It means that the document tree is corrupted.
         *
         * @error view-node-not-found-in-parent
         */
        throw new ckeditorerror["b" /* default */]('view-node-not-found-in-parent: The node\'s parent does not contain this node.', this);
      }

      return pos;
    }
    /**
     * Node's next sibling, or `null` if it is the last child.
     *
     * @readonly
     * @type {module:engine/view/node~Node|null}
     */

  }, {
    key: "nextSibling",
    get: function get() {
      var index = this.index;
      return index !== null && this.parent.getChild(index + 1) || null;
    }
    /**
     * Node's previous sibling, or `null` if it is the first child.
     *
     * @readonly
     * @type {module:engine/view/node~Node|null}
     */

  }, {
    key: "previousSibling",
    get: function get() {
      var index = this.index;
      return index !== null && this.parent.getChild(index - 1) || null;
    }
    /**
     * Top-most ancestor of the node. If the node has no parent it is the root itself.
     *
     * @readonly
     * @type {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}
     */

  }, {
    key: "root",
    get: function get() {
      var root = this; // eslint-disable-line consistent-this

      while (root.parent) {
        root = root.parent;
      }

      return root;
    }
  }]);

  return Node;
}();
/**
 * Fired when list of {@link module:engine/view/element~Element elements} children changes.
 *
 * Change event is bubbled – it is fired on all ancestors.
 *
 * @event change:children
 * @param {module:engine/view/node~Node} changedNode
 */

/**
 * Fired when list of {@link module:engine/view/element~Element elements} attributes changes.
 *
 * Change event is bubbled – it is fired on all ancestors.
 *
 * @event change:attributes
 * @param {module:engine/view/node~Node} changedNode
 */

/**
 * Fired when {@link module:engine/view/text~Text text nodes} data changes.
 *
 * Change event is bubbled – it is fired on all ancestors.
 *
 * @event change:text
 * @param {module:engine/view/node~Node} changedNode
 */

/**
 * @event change
 */



mix(node_Node, emittermixin);
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/text.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/text
 */

/**
 * Tree view text node.
 *
 * The constructor of this class should not be used directly. To create a new text node instance
 * use the {@link module:engine/view/downcastwriter~DowncastWriter#createText `DowncastWriter#createText()`}
 * method when working on data downcasted from the model or the
 * {@link module:engine/view/upcastwriter~UpcastWriter#createText `UpcastWriter#createText()`}
 * method when working on non-semantic views.
 *
 * @extends module:engine/view/node~Node
 */

var text_Text = /*#__PURE__*/function (_Node) {
  Object(inherits["a" /* default */])(Text, _Node);

  var _super = Object(createSuper["a" /* default */])(Text);

  /**
   * Creates a tree view text node.
   *
   * @protected
   * @param {module:engine/view/document~Document} document The document instance to which this text node belongs.
   * @param {String} data The text's data.
   */
  function Text(document, data) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Text);

    _this = _super.call(this, document);
    /**
     * The text content.
     *
     * Setting the data fires the {@link module:engine/view/node~Node#event:change:text change event}.
     *
     * @protected
     * @member {String} module:engine/view/text~Text#_textData
     */

    _this._textData = data;
    return _this;
  }
  /**
   * Checks whether this object is of the given type.
   *
   *		text.is( 'text' ); // -> true
   *		text.is( 'node' ); // -> true
   *		text.is( 'view:text' ); // -> true
   *		text.is( 'view:node' ); // -> true
   *
   *		text.is( 'model:text' ); // -> false
   *		text.is( 'element' ); // -> false
   *		text.is( 'range' ); // -> false
   *
   * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.
   *
   * @param {String} type
   * @returns {Boolean}
   */


  Object(createClass["a" /* default */])(Text, [{
    key: "is",
    value: function is(type) {
      return type === 'text' || type === 'view:text' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
      type === 'node' || type === 'view:node';
    }
    /**
     * The text content.
     *
     * @readonly
     * @type {String}
     */

  }, {
    key: "isSimilar",

    /**
     * Checks if this text node is similar to other text node.
     * Both nodes should have the same data to be considered as similar.
     *
     * @param {module:engine/view/text~Text} otherNode Node to check if it is same as this node.
     * @returns {Boolean}
     */
    value: function isSimilar(otherNode) {
      if (!(otherNode instanceof Text)) {
        return false;
      }

      return this === otherNode || this.data === otherNode.data;
    }
    /**
     * Clones this node.
     *
     * @protected
     * @returns {module:engine/view/text~Text} Text node that is a clone of this node.
     */

  }, {
    key: "_clone",
    value: function _clone() {
      return new Text(this.document, this.data);
    } // @if CK_DEBUG_ENGINE // toString() {
    // @if CK_DEBUG_ENGINE // 	return `#${ this.data }`;
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // log() {
    // @if CK_DEBUG_ENGINE // 	console.log( 'ViewText: ' + this );
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // logExtended() {
    // @if CK_DEBUG_ENGINE // 	console.log( 'ViewText: ' + this );
    // @if CK_DEBUG_ENGINE // }

  }, {
    key: "data",
    get: function get() {
      return this._textData;
    }
    /**
     * This getter is required when using the addition assignment operator on protected property:
     *
     *		const foo = downcastWriter.createText( 'foo' );
     *		const bar = downcastWriter.createText( 'bar' );
     *
     *		foo._data += bar.data;   // executes: `foo._data = foo._data + bar.data`
     *		console.log( foo.data ); // prints: 'foobar'
     *
     * If the protected getter didn't exist, `foo._data` will return `undefined` and result of the merge will be invalid.
     *
     * @protected
     * @type {String}
     */

  }, {
    key: "_data",
    get: function get() {
      return this.data;
    }
    /**
     * Sets data and fires the {@link module:engine/view/node~Node#event:change:text change event}.
     *
     * @protected
     * @fires change:text
     * @param {String} data New data for the text node.
     */
    ,
    set: function set(data) {
      this._fireChange('text', this);

      this._textData = data;
    }
  }]);

  return Text;
}(node_Node);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/textproxy.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/textproxy
 */

/**
 * TextProxy is a wrapper for substring of {@link module:engine/view/text~Text}. Instance of this class is created by
 * {@link module:engine/view/treewalker~TreeWalker} when only a part of {@link module:engine/view/text~Text} needs to be returned.
 *
 * `TextProxy` has an API similar to {@link module:engine/view/text~Text Text} and allows to do most of the common tasks performed
 * on view nodes.
 *
 * **Note:** Some `TextProxy` instances may represent whole text node, not just a part of it.
 * See {@link module:engine/view/textproxy~TextProxy#isPartial}.
 *
 * **Note:** `TextProxy` is a readonly interface.
 *
 * **Note:** `TextProxy` instances are created on the fly basing on the current state of parent {@link module:engine/view/text~Text}.
 * Because of this it is highly unrecommended to store references to `TextProxy instances because they might get
 * invalidated due to operations on Document. Also TextProxy is not a {@link module:engine/view/node~Node} so it can not be
 * inserted as a child of {@link module:engine/view/element~Element}.
 *
 * `TextProxy` instances are created by {@link module:engine/view/treewalker~TreeWalker view tree walker}. You should not need to create
 * an instance of this class by your own.
 */

var textproxy_TextProxy = /*#__PURE__*/function () {
  /**
   * Creates a text proxy.
   *
   * @protected
   * @param {module:engine/view/text~Text} textNode Text node which part is represented by this text proxy.
   * @param {Number} offsetInText Offset in {@link module:engine/view/textproxy~TextProxy#textNode text node}
   * from which the text proxy starts.
   * @param {Number} length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
   * @constructor
   */
  function TextProxy(textNode, offsetInText, length) {
    Object(classCallCheck["a" /* default */])(this, TextProxy);

    /**
     * Reference to the {@link module:engine/view/text~Text} element which TextProxy is a substring.
     *
     * @readonly
     * @member {module:engine/view/text~Text} module:engine/view/textproxy~TextProxy#textNode
     */
    this.textNode = textNode;

    if (offsetInText < 0 || offsetInText > textNode.data.length) {
      /**
       * Given offsetInText value is incorrect.
       *
       * @error view-textproxy-wrong-offsetintext
       */
      throw new ckeditorerror["b" /* default */]('view-textproxy-wrong-offsetintext: Given offsetInText value is incorrect.', this);
    }

    if (length < 0 || offsetInText + length > textNode.data.length) {
      /**
       * Given length value is incorrect.
       *
       * @error view-textproxy-wrong-length
       */
      throw new ckeditorerror["b" /* default */]('view-textproxy-wrong-length: Given length value is incorrect.', this);
    }
    /**
     * Text data represented by this text proxy.
     *
     * @readonly
     * @member {String} module:engine/view/textproxy~TextProxy#data
     */


    this.data = textNode.data.substring(offsetInText, offsetInText + length);
    /**
     * Offset in the `textNode` where this `TextProxy` instance starts.
     *
     * @readonly
     * @member {Number} module:engine/view/textproxy~TextProxy#offsetInText
     */

    this.offsetInText = offsetInText;
  }
  /**
   * Offset size of this node.
   *
   * @readonly
   * @type {Number}
   */


  Object(createClass["a" /* default */])(TextProxy, [{
    key: "is",

    /**
     * Checks whether this object is of the given type.
     *
     *		textProxy.is( 'textProxy' ); // -> true
     *		textProxy.is( 'view:textProxy' ); // -> true
     *
     *		textProxy.is( 'model:textProxy' ); // -> false
     *		textProxy.is( 'element' ); // -> false
     *		textProxy.is( 'range' ); // -> false
     *
     * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.
     *
     * @param {String} type
     * @returns {Boolean}
     */
    value: function is(type) {
      return type === 'textProxy' || type === 'view:textProxy';
    }
    /**
     * Returns ancestors array of this text proxy.
     *
     * @param {Object} options Options object.
     * @param {Boolean} [options.includeSelf=false] When set to `true` {#textNode} will be also included in parent's array.
     * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from text proxy parent to
     * root element, otherwise root element will be the first item in the array.
     * @returns {Array} Array with ancestors.
     */

  }, {
    key: "getAncestors",
    value: function getAncestors() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        includeSelf: false,
        parentFirst: false
      };
      var ancestors = [];
      var parent = options.includeSelf ? this.textNode : this.parent;

      while (parent !== null) {
        ancestors[options.parentFirst ? 'push' : 'unshift'](parent);
        parent = parent.parent;
      }

      return ancestors;
    } // @if CK_DEBUG_ENGINE // toString() {
    // @if CK_DEBUG_ENGINE // 	return `#${ this.data }`;
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // log() {
    // @if CK_DEBUG_ENGINE // 	console.log( 'ViewTextProxy: ' + this );
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // logExtended() {
    // @if CK_DEBUG_ENGINE // 	console.log( 'ViewTextProxy: ' + this );
    // @if CK_DEBUG_ENGINE // }

  }, {
    key: "offsetSize",
    get: function get() {
      return this.data.length;
    }
    /**
     * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/view/text~Text text node}
     * (`true`) or the whole text node (`false`).
     *
     * This is `false` when text proxy starts at the very beginning of {@link module:engine/view/textproxy~TextProxy#textNode textNode}
     * ({@link module:engine/view/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
     * text node size.
     *
     * @readonly
     * @type {Boolean}
     */

  }, {
    key: "isPartial",
    get: function get() {
      return this.data.length !== this.textNode.data.length;
    }
    /**
     * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
     *
     * @readonly
     * @type {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|null}
     */

  }, {
    key: "parent",
    get: function get() {
      return this.textNode.parent;
    }
    /**
     * Root of this text proxy, which is same as root of text node represented by this text proxy.
     *
     * @readonly
     * @type {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}
     */

  }, {
    key: "root",
    get: function get() {
      return this.textNode.root;
    }
    /**
     * {@link module:engine/view/document~Document View document} that owns this text proxy, or `null` if the text proxy is inside
     * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
     *
     * @readonly
     * @type {module:engine/view/document~Document|null}
     */

  }, {
    key: "document",
    get: function get() {
      return this.textNode.document;
    }
  }]);

  return TextProxy;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/objecttomap.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/objecttomap
 */

/**
 * Transforms object to map.
 *
 *		const map = objectToMap( { 'foo': 1, 'bar': 2 } );
 *		map.get( 'foo' ); // 1
 *
 * **Note**: For mixed data (`Object` or `Iterable`) there's a dedicated {@link module:utils/tomap~toMap} function.
 *
 * @param {Object} obj Object to transform.
 * @returns {Map} Map created from object.
 */
function objectToMap(obj) {
  var map = new Map();

  for (var key in obj) {
    map.set(key, obj[key]);
  }

  return map;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/tomap.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/tomap
 */


/**
 * Transforms object or iterable to map. Iterable needs to be in the format acceptable by the `Map` constructor.
 *
 *		map = toMap( { 'foo': 1, 'bar': 2 } );
 *		map = toMap( [ [ 'foo', 1 ], [ 'bar', 2 ] ] );
 *		map = toMap( anotherMap );
 *
 * @param {Object|Iterable} data Object or iterable to transform.
 * @returns {Map} Map created from data.
 */

function toMap(data) {
  if (isIterable(data)) {
    return new Map(data);
  } else {
    return objectToMap(data);
  }
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.regexp.constructor.js
var es_regexp_constructor = __webpack_require__("4d63");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/matcher.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/matcher
 */

/**
 * View matcher class.
 * Instance of this class can be used to find {@link module:engine/view/element~Element elements} that match given pattern.
 */
var matcher_Matcher = /*#__PURE__*/function () {
  /**
   * Creates new instance of Matcher.
   *
   * @param {String|RegExp|Object} [pattern] Match patterns. See {@link module:engine/view/matcher~Matcher#add add method} for
   * more information.
   */
  function Matcher() {
    Object(classCallCheck["a" /* default */])(this, Matcher);

    /**
     * @private
     * @type {Array<String|RegExp|Object>}
     */
    this._patterns = [];
    this.add.apply(this, arguments);
  }
  /**
   * Adds pattern or patterns to matcher instance.
   *
   *		// String.
   *		matcher.add( 'div' );
   *
   *		// Regular expression.
   *		matcher.add( /^\w/ );
   *
   *		// Single class.
   *		matcher.add( {
   *			classes: 'foobar'
   *		} );
   *
   * See {@link module:engine/view/matcher~MatcherPattern} for more examples.
   *
   * Multiple patterns can be added in one call:
   *
   * 		matcher.add( 'div', { classes: 'foobar' } );
   *
   * @param {Object|String|RegExp|Function} pattern Object describing pattern details. If string or regular expression
   * is provided it will be used to match element's name. Pattern can be also provided in a form
   * of a function - then this function will be called with each {@link module:engine/view/element~Element element} as a parameter.
   * Function's return value will be stored under `match` key of the object returned from
   * {@link module:engine/view/matcher~Matcher#match match} or {@link module:engine/view/matcher~Matcher#matchAll matchAll} methods.
   * @param {String|RegExp} [pattern.name] Name or regular expression to match element's name.
   * @param {Object} [pattern.attributes] Object with key-value pairs representing attributes to match. Each object key
   * represents attribute name. Value under that key can be either:
   * * `true` - then attribute is just required (can be empty),
   * * a string - then attribute has to be equal, or
   * * a regular expression - then attribute has to match the expression.
   * @param {String|RegExp|Array} [pattern.classes] Class name or array of class names to match. Each name can be
   * provided in a form of string or regular expression.
   * @param {Object} [pattern.styles] Object with key-value pairs representing styles to match. Each object key
   * represents style name. Value under that key can be either a string or a regular expression and it will be used
   * to match style value.
   */


  Object(createClass["a" /* default */])(Matcher, [{
    key: "add",
    value: function add() {
      for (var _len = arguments.length, pattern = new Array(_len), _key = 0; _key < _len; _key++) {
        pattern[_key] = arguments[_key];
      }

      for (var _i = 0, _pattern = pattern; _i < _pattern.length; _i++) {
        var item = _pattern[_i];

        // String or RegExp pattern is used as element's name.
        if (typeof item == 'string' || item instanceof RegExp) {
          item = {
            name: item
          };
        } // Single class name/RegExp can be provided.


        if (item.classes && (typeof item.classes == 'string' || item.classes instanceof RegExp)) {
          item.classes = [item.classes];
        }

        this._patterns.push(item);
      }
    }
    /**
     * Matches elements for currently stored patterns. Returns match information about first found
     * {@link module:engine/view/element~Element element}, otherwise returns `null`.
     *
     * Example of returned object:
     *
     *		{
     *			element: <instance of found element>,
     *			pattern: <pattern used to match found element>,
     *			match: {
     *				name: true,
     *				attributes: [ 'title', 'href' ],
     *				classes: [ 'foo' ],
     *				styles: [ 'color', 'position' ]
     *			}
     *		}
     *
     * @see module:engine/view/matcher~Matcher#add
     * @see module:engine/view/matcher~Matcher#matchAll
     * @param {...module:engine/view/element~Element} element View element to match against stored patterns.
     * @returns {Object|null} result
     * @returns {module:engine/view/element~Element} result.element Matched view element.
     * @returns {Object|String|RegExp|Function} result.pattern Pattern that was used to find matched element.
     * @returns {Object} result.match Object representing matched element parts.
     * @returns {Boolean} [result.match.name] True if name of the element was matched.
     * @returns {Array} [result.match.attributes] Array with matched attribute names.
     * @returns {Array} [result.match.classes] Array with matched class names.
     * @returns {Array} [result.match.styles] Array with matched style names.
     */

  }, {
    key: "match",
    value: function match() {
      for (var _len2 = arguments.length, element = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        element[_key2] = arguments[_key2];
      }

      for (var _i2 = 0, _element = element; _i2 < _element.length; _i2++) {
        var singleElement = _element[_i2];

        var _iterator = _createForOfIteratorHelper(this._patterns),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var pattern = _step.value;
            var match = isElementMatching(singleElement, pattern);

            if (match) {
              return {
                element: singleElement,
                pattern: pattern,
                match: match
              };
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return null;
    }
    /**
     * Matches elements for currently stored patterns. Returns array of match information with all found
     * {@link module:engine/view/element~Element elements}. If no element is found - returns `null`.
     *
     * @see module:engine/view/matcher~Matcher#add
     * @see module:engine/view/matcher~Matcher#match
     * @param {...module:engine/view/element~Element} element View element to match against stored patterns.
     * @returns {Array.<Object>|null} Array with match information about found elements or `null`. For more information
     * see {@link module:engine/view/matcher~Matcher#match match method} description.
     */

  }, {
    key: "matchAll",
    value: function matchAll() {
      var results = [];

      for (var _len3 = arguments.length, element = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        element[_key3] = arguments[_key3];
      }

      for (var _i3 = 0, _element2 = element; _i3 < _element2.length; _i3++) {
        var singleElement = _element2[_i3];

        var _iterator2 = _createForOfIteratorHelper(this._patterns),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var pattern = _step2.value;
            var match = isElementMatching(singleElement, pattern);

            if (match) {
              results.push({
                element: singleElement,
                pattern: pattern,
                match: match
              });
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }

      return results.length > 0 ? results : null;
    }
    /**
     * Returns the name of the element to match if there is exactly one pattern added to the matcher instance
     * and it matches element name defined by `string` (not `RegExp`). Otherwise, returns `null`.
     *
     * @returns {String|null} Element name trying to match.
     */

  }, {
    key: "getElementName",
    value: function getElementName() {
      if (this._patterns.length !== 1) {
        return null;
      }

      var pattern = this._patterns[0];
      var name = pattern.name;
      return typeof pattern != 'function' && name && !(name instanceof RegExp) ? name : null;
    }
  }]);

  return Matcher;
}(); // Returns match information if {@link module:engine/view/element~Element element} is matching provided pattern.
// If element cannot be matched to provided pattern - returns `null`.
//
// @param {module:engine/view/element~Element} element
// @param {Object|String|RegExp|Function} pattern
// @returns {Object|null} Returns object with match information or null if element is not matching.




function isElementMatching(element, pattern) {
  // If pattern is provided as function - return result of that function;
  if (typeof pattern == 'function') {
    return pattern(element);
  }

  var match = {}; // Check element's name.

  if (pattern.name) {
    match.name = matchName(pattern.name, element.name);

    if (!match.name) {
      return null;
    }
  } // Check element's attributes.


  if (pattern.attributes) {
    match.attributes = matchAttributes(pattern.attributes, element);

    if (!match.attributes) {
      return null;
    }
  } // Check element's classes.


  if (pattern.classes) {
    match.classes = matchClasses(pattern.classes, element);

    if (!match.classes) {
      return false;
    }
  } // Check element's styles.


  if (pattern.styles) {
    match.styles = matchStyles(pattern.styles, element);

    if (!match.styles) {
      return false;
    }
  }

  return match;
} // Checks if name can be matched by provided pattern.
//
// @param {String|RegExp} pattern
// @param {String} name
// @returns {Boolean} Returns `true` if name can be matched, `false` otherwise.


function matchName(pattern, name) {
  // If pattern is provided as RegExp - test against this regexp.
  if (pattern instanceof RegExp) {
    return pattern.test(name);
  }

  return pattern === name;
} // Checks if attributes of provided element can be matched against provided patterns.
//
// @param {Object} patterns Object with information about attributes to match. Each key of the object will be
// used as attribute name. Value of each key can be a string or regular expression to match against attribute value.
// @param {module:engine/view/element~Element} element Element which attributes will be tested.
// @returns {Array|null} Returns array with matched attribute names or `null` if no attributes were matched.


function matchAttributes(patterns, element) {
  var match = [];

  for (var name in patterns) {
    var pattern = patterns[name];

    if (element.hasAttribute(name)) {
      var attribute = element.getAttribute(name);

      if (pattern === true) {
        match.push(name);
      } else if (pattern instanceof RegExp) {
        if (pattern.test(attribute)) {
          match.push(name);
        } else {
          return null;
        }
      } else if (attribute === pattern) {
        match.push(name);
      } else {
        return null;
      }
    } else {
      return null;
    }
  }

  return match;
} // Checks if classes of provided element can be matched against provided patterns.
//
// @param {Array.<String|RegExp>} patterns Array of strings or regular expressions to match against element's classes.
// @param {module:engine/view/element~Element} element Element which classes will be tested.
// @returns {Array|null} Returns array with matched class names or `null` if no classes were matched.


function matchClasses(patterns, element) {
  var match = [];

  var _iterator3 = _createForOfIteratorHelper(patterns),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var pattern = _step3.value;

      if (pattern instanceof RegExp) {
        var classes = element.getClassNames();

        var _iterator4 = _createForOfIteratorHelper(classes),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var name = _step4.value;

            if (pattern.test(name)) {
              match.push(name);
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        if (match.length === 0) {
          return null;
        }
      } else if (element.hasClass(pattern)) {
        match.push(pattern);
      } else {
        return null;
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return match;
} // Checks if styles of provided element can be matched against provided patterns.
//
// @param {Object} patterns Object with information about styles to match. Each key of the object will be
// used as style name. Value of each key can be a string or regular expression to match against style value.
// @param {module:engine/view/element~Element} element Element which styles will be tested.
// @returns {Array|null} Returns array with matched style names or `null` if no styles were matched.


function matchStyles(patterns, element) {
  var match = [];

  for (var name in patterns) {
    var pattern = patterns[name];

    if (element.hasStyle(name)) {
      var style = element.getStyle(name);

      if (pattern instanceof RegExp) {
        if (pattern.test(style)) {
          match.push(name);
        } else {
          return null;
        }
      } else if (style === pattern) {
        match.push(name);
      } else {
        return null;
      }
    } else {
      return null;
    }
  }

  return match;
}
/**
 * An entity that is a valid pattern recognized by a matcher. `MatcherPattern` is used by {@link ~Matcher} to recognize
 * if a view element fits in a group of view elements described by the pattern.
 *
 * `MatcherPattern` can be given as a `String`, a `RegExp`, an `Object` or a `Function`.
 *
 * If `MatcherPattern` is given as a `String` or `RegExp`, it will match any view element that has a matching name:
 *
 *		// Match any element with name equal to 'div'.
 *		const pattern = 'div';
 *
 *		// Match any element which name starts on 'p'.
 *		const pattern = /^p/;
 *
 * If `MatcherPattern` is given as an `Object`, all the object's properties will be matched with view element properties.
 *
 *		// Match view element's name.
 *		const pattern = { name: /^p/ };
 *
 *		// Match view element which has matching attributes.
 *		const pattern = {
 *			attributes: {
 *				title: 'foobar',	// Attribute title should equal 'foobar'.
 *				foo: /^\w+/,		// Attribute foo should match /^\w+/ regexp.
 *				bar: true			// Attribute bar should be set (can be empty).
 *			}
 *		};
 *
 *		// Match view element which has given class.
 *		const pattern = {
 *			classes: 'foobar'
 *		};
 *
 *		// Match view element class using regular expression.
 *		const pattern = {
 *			classes: /foo.../
 *		};
 *
 *		// Multiple classes to match.
 *		const pattern = {
 *			classes: [ 'baz', 'bar', /foo.../ ]
 *		};
 *
 *		// Match view element which has given styles.
 *		const pattern = {
 *			styles: {
 *				position: 'absolute',
 *				color: /^\w*blue$/
 *			}
 *		};
 *
 *		// Pattern with multiple properties.
 *		const pattern = {
 *			name: 'span',
 *			styles: {
 *				'font-weight': 'bold'
 *			},
 *			classes: 'highlighted'
 *		};
 *
 * If `MatcherPattern` is given as a `Function`, the function takes a view element as a first and only parameter and
 * the function should decide whether that element matches. If so, it should return what part of the view element has been matched.
 * Otherwise, the function should return `null`. The returned result will be included in `match` property of the object
 * returned by {@link ~Matcher#match} call.
 *
 *		// Match an empty <div> element.
 *		const pattern = element => {
 *			if ( element.name == 'div' && element.childCount > 0 ) {
 *				// Return which part of the element was matched.
 *				return { name: true };
 *			}
 *
 *			return null;
 *		};
 *
 *		// Match a <p> element with big font ("heading-like" element).
 *		const pattern = element => {
 *			if ( element.name == 'p' ) {
 *				const fontSize = element.getStyle( 'font-size' );
 *				const size = fontSize.match( /(\d+)/px );
 *
 *				if ( size && Number( size[ 1 ] ) > 26 ) {
 *					return { name: true, attribute: [ 'font-size' ] };
 *				}
 *			}
 *
 *			return null;
 *		};
 *
 * `MatcherPattern` is defined in a way that it is a superset of {@link module:engine/view/elementdefinition~ElementDefinition},
 * that is, every `ElementDefinition` also can be used as a `MatcherPattern`.
 *
 * @typedef {String|RegExp|Object|Function} module:engine/view/matcher~MatcherPattern
 *
 * @property {String|RegExp} [name] View element name to match.
 * @property {String|RegExp|Array.<String|RegExp>} [classes] View element's class name(s) to match.
 * @property {Object} [styles] Object with key-value pairs representing styles to match.
 * Each object key represents style name. Value can be given as `String` or `RegExp`.
 * @property {Object} [attributes] Object with key-value pairs representing attributes to match.
 * Each object key represents attribute name. Value can be given as `String` or `RegExp`.
 */
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.entries.js
var es_object_entries = __webpack_require__("4fad");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.trim.js
var es_string_trim = __webpack_require__("498a");

// CONCATENATED MODULE: ./node_modules/lodash-es/isSymbol.js



/** `Object#toString` result references. */
var isSymbol_symbolTag = '[object Symbol]';

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (lodash_es_isObjectLike(value) && _baseGetTag(value) == isSymbol_symbolTag);
}

/* harmony default export */ var lodash_es_isSymbol = (isSymbol);

// CONCATENATED MODULE: ./node_modules/lodash-es/_isKey.js



/** Used to match property names within property paths. */
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
    reIsPlainProp = /^\w*$/;

/**
 * Checks if `value` is a property name and not a property path.
 *
 * @private
 * @param {*} value The value to check.
 * @param {Object} [object] The object to query keys on.
 * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
 */
function isKey(value, object) {
  if (lodash_es_isArray(value)) {
    return false;
  }
  var type = typeof value;
  if (type == 'number' || type == 'symbol' || type == 'boolean' ||
      value == null || lodash_es_isSymbol(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
    (object != null && value in Object(object));
}

/* harmony default export */ var _isKey = (isKey);

// CONCATENATED MODULE: ./node_modules/lodash-es/memoize.js


/** Error message constants. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that memoizes the result of `func`. If `resolver` is
 * provided, it determines the cache key for storing the result based on the
 * arguments provided to the memoized function. By default, the first argument
 * provided to the memoized function is used as the map cache key. The `func`
 * is invoked with the `this` binding of the memoized function.
 *
 * **Note:** The cache is exposed as the `cache` property on the memoized
 * function. Its creation may be customized by replacing the `_.memoize.Cache`
 * constructor with one whose instances implement the
 * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
 * method interface of `clear`, `delete`, `get`, `has`, and `set`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to have its output memoized.
 * @param {Function} [resolver] The function to resolve the cache key.
 * @returns {Function} Returns the new memoized function.
 * @example
 *
 * var object = { 'a': 1, 'b': 2 };
 * var other = { 'c': 3, 'd': 4 };
 *
 * var values = _.memoize(_.values);
 * values(object);
 * // => [1, 2]
 *
 * values(other);
 * // => [3, 4]
 *
 * object.a = 2;
 * values(object);
 * // => [1, 2]
 *
 * // Modify the result cache.
 * values.cache.set(object, ['a', 'b']);
 * values(object);
 * // => ['a', 'b']
 *
 * // Replace `_.memoize.Cache`.
 * _.memoize.Cache = WeakMap;
 */
function memoize(func, resolver) {
  if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var memoized = function() {
    var args = arguments,
        key = resolver ? resolver.apply(this, args) : args[0],
        cache = memoized.cache;

    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize.Cache || _MapCache);
  return memoized;
}

// Expose `MapCache`.
memoize.Cache = _MapCache;

/* harmony default export */ var lodash_es_memoize = (memoize);

// CONCATENATED MODULE: ./node_modules/lodash-es/_memoizeCapped.js


/** Used as the maximum memoize cache size. */
var MAX_MEMOIZE_SIZE = 500;

/**
 * A specialized version of `_.memoize` which clears the memoized function's
 * cache when it exceeds `MAX_MEMOIZE_SIZE`.
 *
 * @private
 * @param {Function} func The function to have its output memoized.
 * @returns {Function} Returns the new memoized function.
 */
function memoizeCapped(func) {
  var result = lodash_es_memoize(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });

  var cache = result.cache;
  return result;
}

/* harmony default export */ var _memoizeCapped = (memoizeCapped);

// CONCATENATED MODULE: ./node_modules/lodash-es/_stringToPath.js


/** Used to match property names within property paths. */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

/** Used to match backslashes in property paths. */
var reEscapeChar = /\\(\\)?/g;

/**
 * Converts `string` to a property path array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the property path array.
 */
var stringToPath = _memoizeCapped(function(string) {
  var result = [];
  if (string.charCodeAt(0) === 46 /* . */) {
    result.push('');
  }
  string.replace(rePropName, function(match, number, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  });
  return result;
});

/* harmony default export */ var _stringToPath = (stringToPath);

// CONCATENATED MODULE: ./node_modules/lodash-es/_arrayMap.js
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */
function arrayMap(array, iteratee) {
  var index = -1,
      length = array == null ? 0 : array.length,
      result = Array(length);

  while (++index < length) {
    result[index] = iteratee(array[index], index, array);
  }
  return result;
}

/* harmony default export */ var _arrayMap = (arrayMap);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseToString.js





/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0;

/** Used to convert symbols to primitives and strings. */
var _baseToString_symbolProto = _Symbol ? _Symbol.prototype : undefined,
    symbolToString = _baseToString_symbolProto ? _baseToString_symbolProto.toString : undefined;

/**
 * The base implementation of `_.toString` which doesn't convert nullish
 * values to empty strings.
 *
 * @private
 * @param {*} value The value to process.
 * @returns {string} Returns the string.
 */
function baseToString(value) {
  // Exit early for strings to avoid a performance hit in some environments.
  if (typeof value == 'string') {
    return value;
  }
  if (lodash_es_isArray(value)) {
    // Recursively convert values (susceptible to call stack limits).
    return _arrayMap(value, baseToString) + '';
  }
  if (lodash_es_isSymbol(value)) {
    return symbolToString ? symbolToString.call(value) : '';
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
}

/* harmony default export */ var _baseToString = (baseToString);

// CONCATENATED MODULE: ./node_modules/lodash-es/toString.js


/**
 * Converts `value` to a string. An empty string is returned for `null`
 * and `undefined` values. The sign of `-0` is preserved.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.toString(null);
 * // => ''
 *
 * _.toString(-0);
 * // => '-0'
 *
 * _.toString([1, 2, 3]);
 * // => '1,2,3'
 */
function toString_toString(value) {
  return value == null ? '' : _baseToString(value);
}

/* harmony default export */ var lodash_es_toString = (toString_toString);

// CONCATENATED MODULE: ./node_modules/lodash-es/_castPath.js





/**
 * Casts `value` to a path array if it's not one.
 *
 * @private
 * @param {*} value The value to inspect.
 * @param {Object} [object] The object to query keys on.
 * @returns {Array} Returns the cast property path array.
 */
function castPath(value, object) {
  if (lodash_es_isArray(value)) {
    return value;
  }
  return _isKey(value, object) ? [value] : _stringToPath(lodash_es_toString(value));
}

/* harmony default export */ var _castPath = (castPath);

// CONCATENATED MODULE: ./node_modules/lodash-es/last.js
/**
 * Gets the last element of `array`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Array
 * @param {Array} array The array to query.
 * @returns {*} Returns the last element of `array`.
 * @example
 *
 * _.last([1, 2, 3]);
 * // => 3
 */
function last_last(array) {
  var length = array == null ? 0 : array.length;
  return length ? array[length - 1] : undefined;
}

/* harmony default export */ var lodash_es_last = (last_last);

// CONCATENATED MODULE: ./node_modules/lodash-es/_toKey.js


/** Used as references for various `Number` constants. */
var _toKey_INFINITY = 1 / 0;

/**
 * Converts `value` to a string key if it's not a string or symbol.
 *
 * @private
 * @param {*} value The value to inspect.
 * @returns {string|symbol} Returns the key.
 */
function toKey(value) {
  if (typeof value == 'string' || lodash_es_isSymbol(value)) {
    return value;
  }
  var result = (value + '');
  return (result == '0' && (1 / value) == -_toKey_INFINITY) ? '-0' : result;
}

/* harmony default export */ var _toKey = (toKey);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseGet.js



/**
 * The base implementation of `_.get` without support for default values.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @returns {*} Returns the resolved value.
 */
function baseGet(object, path) {
  path = _castPath(path, object);

  var index = 0,
      length = path.length;

  while (object != null && index < length) {
    object = object[_toKey(path[index++])];
  }
  return (index && index == length) ? object : undefined;
}

/* harmony default export */ var _baseGet = (baseGet);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseSlice.js
/**
 * The base implementation of `_.slice` without an iteratee call guard.
 *
 * @private
 * @param {Array} array The array to slice.
 * @param {number} [start=0] The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the slice of `array`.
 */
function baseSlice(array, start, end) {
  var index = -1,
      length = array.length;

  if (start < 0) {
    start = -start > length ? 0 : (length + start);
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : ((end - start) >>> 0);
  start >>>= 0;

  var result = Array(length);
  while (++index < length) {
    result[index] = array[index + start];
  }
  return result;
}

/* harmony default export */ var _baseSlice = (baseSlice);

// CONCATENATED MODULE: ./node_modules/lodash-es/_parent.js



/**
 * Gets the parent value at `path` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} path The path to get the parent value of.
 * @returns {*} Returns the parent value.
 */
function _parent_parent(object, path) {
  return path.length < 2 ? object : _baseGet(object, _baseSlice(path, 0, -1));
}

/* harmony default export */ var _parent = (_parent_parent);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseUnset.js





/**
 * The base implementation of `_.unset`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The property path to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 */
function baseUnset(object, path) {
  path = _castPath(path, object);
  object = _parent(object, path);
  return object == null || delete object[_toKey(lodash_es_last(path))];
}

/* harmony default export */ var _baseUnset = (baseUnset);

// CONCATENATED MODULE: ./node_modules/lodash-es/unset.js


/**
 * Removes the property at `path` of `object`.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to unset.
 * @returns {boolean} Returns `true` if the property is deleted, else `false`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 7 } }] };
 * _.unset(object, 'a[0].b.c');
 * // => true
 *
 * console.log(object);
 * // => { 'a': [{ 'b': {} }] };
 *
 * _.unset(object, ['a', '0', 'b', 'c']);
 * // => true
 *
 * console.log(object);
 * // => { 'a': [{ 'b': {} }] };
 */
function unset(object, path) {
  return object == null ? true : _baseUnset(object, path);
}

/* harmony default export */ var lodash_es_unset = (unset);

// CONCATENATED MODULE: ./node_modules/lodash-es/get.js


/**
 * Gets the value at `path` of `object`. If the resolved value is
 * `undefined`, the `defaultValue` is returned in its place.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to query.
 * @param {Array|string} path The path of the property to get.
 * @param {*} [defaultValue] The value returned for `undefined` resolved values.
 * @returns {*} Returns the resolved value.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.get(object, 'a[0].b.c');
 * // => 3
 *
 * _.get(object, ['a', '0', 'b', 'c']);
 * // => 3
 *
 * _.get(object, 'a.b.c', 'default');
 * // => 'default'
 */
function lodash_es_get_get(object, path, defaultValue) {
  var result = object == null ? undefined : _baseGet(object, path);
  return result === undefined ? defaultValue : result;
}

/* harmony default export */ var lodash_es_get = (lodash_es_get_get);

// CONCATENATED MODULE: ./node_modules/lodash-es/_assignMergeValue.js



/**
 * This function is like `assignValue` except that it doesn't assign
 * `undefined` values.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {string} key The key of the property to assign.
 * @param {*} value The value to assign.
 */
function assignMergeValue(object, key, value) {
  if ((value !== undefined && !lodash_es_eq(object[key], value)) ||
      (value === undefined && !(key in object))) {
    _baseAssignValue(object, key, value);
  }
}

/* harmony default export */ var _assignMergeValue = (assignMergeValue);

// CONCATENATED MODULE: ./node_modules/lodash-es/_createBaseFor.js
/**
 * Creates a base function for methods like `_.forIn` and `_.forOwn`.
 *
 * @private
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {Function} Returns the new base function.
 */
function createBaseFor(fromRight) {
  return function(object, iteratee, keysFunc) {
    var index = -1,
        iterable = Object(object),
        props = keysFunc(object),
        length = props.length;

    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  };
}

/* harmony default export */ var _createBaseFor = (createBaseFor);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseFor.js


/**
 * The base implementation of `baseForOwn` which iterates over `object`
 * properties returned by `keysFunc` and invokes `iteratee` for each property.
 * Iteratee functions may exit iteration early by explicitly returning `false`.
 *
 * @private
 * @param {Object} object The object to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @returns {Object} Returns `object`.
 */
var baseFor = _createBaseFor();

/* harmony default export */ var _baseFor = (baseFor);

// CONCATENATED MODULE: ./node_modules/lodash-es/isArrayLikeObject.js



/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */
function isArrayLikeObject(value) {
  return lodash_es_isObjectLike(value) && lodash_es_isArrayLike(value);
}

/* harmony default export */ var lodash_es_isArrayLikeObject = (isArrayLikeObject);

// CONCATENATED MODULE: ./node_modules/lodash-es/_safeGet.js
/**
 * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function safeGet(object, key) {
  if (key === 'constructor' && typeof object[key] === 'function') {
    return;
  }

  if (key == '__proto__') {
    return;
  }

  return object[key];
}

/* harmony default export */ var _safeGet = (safeGet);

// CONCATENATED MODULE: ./node_modules/lodash-es/toPlainObject.js



/**
 * Converts `value` to a plain object flattening inherited enumerable string
 * keyed properties of `value` to own properties of the plain object.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {Object} Returns the converted plain object.
 * @example
 *
 * function Foo() {
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.assign({ 'a': 1 }, new Foo);
 * // => { 'a': 1, 'b': 2 }
 *
 * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
 * // => { 'a': 1, 'b': 2, 'c': 3 }
 */
function toPlainObject(value) {
  return _copyObject(value, lodash_es_keysIn(value));
}

/* harmony default export */ var lodash_es_toPlainObject = (toPlainObject);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseMergeDeep.js
















/**
 * A specialized version of `baseMerge` for arrays and objects which performs
 * deep merges and tracks traversed objects enabling objects with circular
 * references to be merged.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {string} key The key of the value to merge.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} mergeFunc The function to merge values.
 * @param {Function} [customizer] The function to customize assigned values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  var objValue = _safeGet(object, key),
      srcValue = _safeGet(source, key),
      stacked = stack.get(srcValue);

  if (stacked) {
    _assignMergeValue(object, key, stacked);
    return;
  }
  var newValue = customizer
    ? customizer(objValue, srcValue, (key + ''), object, source, stack)
    : undefined;

  var isCommon = newValue === undefined;

  if (isCommon) {
    var isArr = lodash_es_isArray(srcValue),
        isBuff = !isArr && Object(isBuffer["a" /* default */])(srcValue),
        isTyped = !isArr && !isBuff && lodash_es_isTypedArray(srcValue);

    newValue = srcValue;
    if (isArr || isBuff || isTyped) {
      if (lodash_es_isArray(objValue)) {
        newValue = objValue;
      }
      else if (lodash_es_isArrayLikeObject(objValue)) {
        newValue = _copyArray(objValue);
      }
      else if (isBuff) {
        isCommon = false;
        newValue = Object(_cloneBuffer["a" /* default */])(srcValue, true);
      }
      else if (isTyped) {
        isCommon = false;
        newValue = _cloneTypedArray(srcValue, true);
      }
      else {
        newValue = [];
      }
    }
    else if (lodash_es_isPlainObject(srcValue) || lodash_es_isArguments(srcValue)) {
      newValue = objValue;
      if (lodash_es_isArguments(objValue)) {
        newValue = lodash_es_toPlainObject(objValue);
      }
      else if (!lodash_es_isObject(objValue) || lodash_es_isFunction(objValue)) {
        newValue = _initCloneObject(srcValue);
      }
    }
    else {
      isCommon = false;
    }
  }
  if (isCommon) {
    // Recursively merge objects and arrays (susceptible to call stack limits).
    stack.set(srcValue, newValue);
    mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
    stack['delete'](srcValue);
  }
  _assignMergeValue(object, key, newValue);
}

/* harmony default export */ var _baseMergeDeep = (baseMergeDeep);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseMerge.js








/**
 * The base implementation of `_.merge` without support for multiple sources.
 *
 * @private
 * @param {Object} object The destination object.
 * @param {Object} source The source object.
 * @param {number} srcIndex The index of `source`.
 * @param {Function} [customizer] The function to customize merged values.
 * @param {Object} [stack] Tracks traversed source values and their merged
 *  counterparts.
 */
function baseMerge(object, source, srcIndex, customizer, stack) {
  if (object === source) {
    return;
  }
  _baseFor(source, function(srcValue, key) {
    stack || (stack = new _Stack);
    if (lodash_es_isObject(srcValue)) {
      _baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
    }
    else {
      var newValue = customizer
        ? customizer(_safeGet(object, key), srcValue, (key + ''), object, source, stack)
        : undefined;

      if (newValue === undefined) {
        newValue = srcValue;
      }
      _assignMergeValue(object, key, newValue);
    }
  }, lodash_es_keysIn);
}

/* harmony default export */ var _baseMerge = (baseMerge);

// CONCATENATED MODULE: ./node_modules/lodash-es/identity.js
/**
 * This method returns the first argument it receives.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'a': 1 };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

/* harmony default export */ var lodash_es_identity = (identity);

// CONCATENATED MODULE: ./node_modules/lodash-es/_apply.js
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  switch (args.length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

/* harmony default export */ var _apply = (apply);

// CONCATENATED MODULE: ./node_modules/lodash-es/_overRest.js


/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * A specialized version of `baseRest` which transforms the rest array.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @param {Function} transform The rest array transform.
 * @returns {Function} Returns the new function.
 */
function overRest(func, start, transform) {
  start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
  return function() {
    var args = arguments,
        index = -1,
        length = nativeMax(args.length - start, 0),
        array = Array(length);

    while (++index < length) {
      array[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array);
    return _apply(func, this, otherArgs);
  };
}

/* harmony default export */ var _overRest = (overRest);

// CONCATENATED MODULE: ./node_modules/lodash-es/constant.js
/**
 * Creates a function that returns `value`.
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Util
 * @param {*} value The value to return from the new function.
 * @returns {Function} Returns the new constant function.
 * @example
 *
 * var objects = _.times(2, _.constant({ 'a': 1 }));
 *
 * console.log(objects);
 * // => [{ 'a': 1 }, { 'a': 1 }]
 *
 * console.log(objects[0] === objects[1]);
 * // => true
 */
function constant(value) {
  return function() {
    return value;
  };
}

/* harmony default export */ var lodash_es_constant = (constant);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseSetToString.js




/**
 * The base implementation of `setToString` without support for hot loop shorting.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var baseSetToString = !_defineProperty ? lodash_es_identity : function(func, string) {
  return _defineProperty(func, 'toString', {
    'configurable': true,
    'enumerable': false,
    'value': lodash_es_constant(string),
    'writable': true
  });
};

/* harmony default export */ var _baseSetToString = (baseSetToString);

// CONCATENATED MODULE: ./node_modules/lodash-es/_shortOut.js
/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 800,
    HOT_SPAN = 16;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeNow = Date.now;

/**
 * Creates a function that'll short out and invoke `identity` instead
 * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
 * milliseconds.
 *
 * @private
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new shortable function.
 */
function shortOut(func) {
  var count = 0,
      lastCalled = 0;

  return function() {
    var stamp = nativeNow(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(undefined, arguments);
  };
}

/* harmony default export */ var _shortOut = (shortOut);

// CONCATENATED MODULE: ./node_modules/lodash-es/_setToString.js



/**
 * Sets the `toString` method of `func` to return `string`.
 *
 * @private
 * @param {Function} func The function to modify.
 * @param {Function} string The `toString` result.
 * @returns {Function} Returns `func`.
 */
var setToString = _shortOut(_baseSetToString);

/* harmony default export */ var _setToString = (setToString);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseRest.js




/**
 * The base implementation of `_.rest` which doesn't validate or coerce arguments.
 *
 * @private
 * @param {Function} func The function to apply a rest parameter to.
 * @param {number} [start=func.length-1] The start position of the rest parameter.
 * @returns {Function} Returns the new function.
 */
function baseRest(func, start) {
  return _setToString(_overRest(func, start, lodash_es_identity), func + '');
}

/* harmony default export */ var _baseRest = (baseRest);

// CONCATENATED MODULE: ./node_modules/lodash-es/_isIterateeCall.js





/**
 * Checks if the given arguments are from an iteratee call.
 *
 * @private
 * @param {*} value The potential iteratee value argument.
 * @param {*} index The potential iteratee index or key argument.
 * @param {*} object The potential iteratee object argument.
 * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
 *  else `false`.
 */
function isIterateeCall(value, index, object) {
  if (!lodash_es_isObject(object)) {
    return false;
  }
  var type = typeof index;
  if (type == 'number'
        ? (lodash_es_isArrayLike(object) && _isIndex(index, object.length))
        : (type == 'string' && index in object)
      ) {
    return lodash_es_eq(object[index], value);
  }
  return false;
}

/* harmony default export */ var _isIterateeCall = (isIterateeCall);

// CONCATENATED MODULE: ./node_modules/lodash-es/_createAssigner.js



/**
 * Creates a function like `_.assign`.
 *
 * @private
 * @param {Function} assigner The function to assign values.
 * @returns {Function} Returns the new assigner function.
 */
function createAssigner(assigner) {
  return _baseRest(function(object, sources) {
    var index = -1,
        length = sources.length,
        customizer = length > 1 ? sources[length - 1] : undefined,
        guard = length > 2 ? sources[2] : undefined;

    customizer = (assigner.length > 3 && typeof customizer == 'function')
      ? (length--, customizer)
      : undefined;

    if (guard && _isIterateeCall(sources[0], sources[1], guard)) {
      customizer = length < 3 ? undefined : customizer;
      length = 1;
    }
    object = Object(object);
    while (++index < length) {
      var source = sources[index];
      if (source) {
        assigner(object, source, index, customizer);
      }
    }
    return object;
  });
}

/* harmony default export */ var _createAssigner = (createAssigner);

// CONCATENATED MODULE: ./node_modules/lodash-es/merge.js



/**
 * This method is like `_.assign` except that it recursively merges own and
 * inherited enumerable string keyed properties of source objects into the
 * destination object. Source properties that resolve to `undefined` are
 * skipped if a destination value exists. Array and plain object properties
 * are merged recursively. Other objects and value types are overridden by
 * assignment. Source objects are applied from left to right. Subsequent
 * sources overwrite property assignments of previous sources.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 0.5.0
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = {
 *   'a': [{ 'b': 2 }, { 'd': 4 }]
 * };
 *
 * var other = {
 *   'a': [{ 'c': 3 }, { 'e': 5 }]
 * };
 *
 * _.merge(object, other);
 * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
 */
var merge_merge = _createAssigner(function(object, source, srcIndex) {
  _baseMerge(object, source, srcIndex);
});

/* harmony default export */ var lodash_es_merge = (merge_merge);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseSet.js






/**
 * The base implementation of `_.set`.
 *
 * @private
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @param {Function} [customizer] The function to customize path creation.
 * @returns {Object} Returns `object`.
 */
function baseSet(object, path, value, customizer) {
  if (!lodash_es_isObject(object)) {
    return object;
  }
  path = _castPath(path, object);

  var index = -1,
      length = path.length,
      lastIndex = length - 1,
      nested = object;

  while (nested != null && ++index < length) {
    var key = _toKey(path[index]),
        newValue = value;

    if (index != lastIndex) {
      var objValue = nested[key];
      newValue = customizer ? customizer(objValue, key, nested) : undefined;
      if (newValue === undefined) {
        newValue = lodash_es_isObject(objValue)
          ? objValue
          : (_isIndex(path[index + 1]) ? [] : {});
      }
    }
    _assignValue(nested, key, newValue);
    nested = nested[key];
  }
  return object;
}

/* harmony default export */ var _baseSet = (baseSet);

// CONCATENATED MODULE: ./node_modules/lodash-es/set.js


/**
 * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
 * it's created. Arrays are created for missing index properties while objects
 * are created for all other missing properties. Use `_.setWith` to customize
 * `path` creation.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 3.7.0
 * @category Object
 * @param {Object} object The object to modify.
 * @param {Array|string} path The path of the property to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns `object`.
 * @example
 *
 * var object = { 'a': [{ 'b': { 'c': 3 } }] };
 *
 * _.set(object, 'a[0].b.c', 4);
 * console.log(object.a[0].b.c);
 * // => 4
 *
 * _.set(object, ['x', '0', 'y', 'z'], 5);
 * console.log(object.x[0].y.z);
 * // => 5
 */
function set_set(object, path, value) {
  return object == null ? object : _baseSet(object, path, value);
}

/* harmony default export */ var lodash_es_set = (set_set);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/stylesmap.js






















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/stylesmap
 */

/**
 * Styles map. Allows handling (adding, removing, retrieving) a set of style rules (usually, of an element).
 *
 * The styles map is capable of normalizing style names so e.g. the following operations are possible:
 */

var stylesmap_StylesMap = /*#__PURE__*/function () {
  /**
   * Creates Styles instance.
   *
   * @param {module:engine/view/stylesmap~StylesProcessor} styleProcessor
   */
  function StylesMap(styleProcessor) {
    Object(classCallCheck["a" /* default */])(this, StylesMap);

    /**
     * Keeps an internal representation of styles map. Normalized styles are kept as object tree to allow unified modification and
     * value access model using lodash's get, set, unset, etc methods.
     *
     * When no style processor rules are defined the it acts as simple key-value storage.
     *
     * @private
     * @type {Object}
     */
    this._styles = {};
    /**
     * An instance of the {@link module:engine/view/stylesmap~StylesProcessor}.
     *
     * @private
     * @member {module:engine/view/stylesmap~StylesProcessor}
     */

    this._styleProcessor = styleProcessor;
  }
  /**
   * Returns true if style map has no styles set.
   *
   * @returns {Boolean}
   */


  Object(createClass["a" /* default */])(StylesMap, [{
    key: "setTo",

    /**
     * Set styles map to a new value.
     *
     *		styles.setTo( 'border:1px solid blue;margin-top:1px;' );
     *
     * @param {String} inlineStyle
     */
    value: function setTo(inlineStyle) {
      this.clear();
      var parsedStyles = Array.from(parseInlineStyles(inlineStyle).entries());

      for (var _i = 0, _parsedStyles = parsedStyles; _i < _parsedStyles.length; _i++) {
        var _parsedStyles$_i = _slicedToArray(_parsedStyles[_i], 2),
            key = _parsedStyles$_i[0],
            value = _parsedStyles$_i[1];

        this._styleProcessor.toNormalizedForm(key, value, this._styles);
      }
    }
    /**
     * Checks if a given style is set.
     *
     *		styles.setTo( 'margin-left:1px;' );
     *
     *		styles.has( 'margin-left' );    // -> true
     *		styles.has( 'padding' );        // -> false
     *
     * **Note**: This check supports normalized style names.
     *
     *		// Enable 'margin' shorthand processing:
     *		editor.data.addStyleProcessorRules( addMarginRules );
     *
     *		styles.setTo( 'margin:2px;' );
     *
     *		styles.has( 'margin' );         // -> true
     *		styles.has( 'margin-top' );     // -> true
     *		styles.has( 'margin-left' );    // -> true
     *
     *		styles.remove( 'margin-top' );
     *
     *		styles.has( 'margin' );         // -> false
     *		styles.has( 'margin-top' );     // -> false
     *		styles.has( 'margin-left' );    // -> true
     *
     * @param {String} name Style name.
     * @returns {Boolean}
     */

  }, {
    key: "has",
    value: function has(name) {
      if (this.isEmpty) {
        return false;
      }

      var styles = this._styleProcessor.getReducedForm(name, this._styles);

      var propertyDescriptor = styles.find(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 1),
            property = _ref2[0];

        return property === name;
      }); // Only return a value if it is set;

      return Array.isArray(propertyDescriptor);
    }
    /**
     * Sets a given style.
     *
     * Can insert one by one:
     *
     *		styles.set( 'color', 'blue' );
     *		styles.set( 'margin-right', '1em' );
     *
     * or many styles at once:
     *
     *		styles.set( {
     *			color: 'blue',
     *			'margin-right': '1em'
     *		} );
     *
     * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules
     * enabled style processor rules} to normalize passed values.
     *
     *		// Enable 'margin' shorthand processing:
     *		editor.data.addStyleProcessorRules( addMarginRules );
     *
     *		styles.set( 'margin', '2px' );
     *
     * The above code will set margin to:
     *
     *		styles.getNormalized( 'margin' );
     *		// -> { top: '2px', right: '2px', bottom: '2px', left: '2px' }
     *
     * Which makes it possible to retrieve a "sub-value":
     *
     *		styles.get( 'margin-left' );       // -> '2px'
     *
     * Or modify it:
     *
     *		styles.remove( 'margin-left' );
     *
     *		styles.getNormalized( 'margin' );  // -> { top: '1px', bottom: '1px', right: '1px' }
     *		styles.toString();                 // -> 'margin-bottom:1px;margin-right:1px;margin-top:1px;'
     *
     * This method also allows to set normalized values directly (if a particular styles processor rule was enabled):
     *
     *		styles.set( 'border-color', { top: 'blue' } );
     *		styles.set( 'margin', { right: '2em' } );
     *
     *		styles.toString();                 // -> 'border-color-top:blue;margin-right:2em;'
     *
     * @param {String|Object} nameOrObject Style property name or object with multiple properties.
     * @param {String|Object} valueOrObject Value to set.
     */

  }, {
    key: "set",
    value: function set(nameOrObject, valueOrObject) {
      if (lodash_es_isObject(nameOrObject)) {
        for (var _i2 = 0, _Object$entries = Object.entries(nameOrObject); _i2 < _Object$entries.length; _i2++) {
          var _Object$entries$_i = _slicedToArray(_Object$entries[_i2], 2),
              key = _Object$entries$_i[0],
              value = _Object$entries$_i[1];

          this._styleProcessor.toNormalizedForm(key, value, this._styles);
        }
      } else {
        this._styleProcessor.toNormalizedForm(nameOrObject, valueOrObject, this._styles);
      }
    }
    /**
     * Removes given style.
     *
     *		styles.setTo( 'background:#f00;margin-right:2px;' );
     *
     *		styles.remove( 'background' );
     *
     *		styles.toString();   // -> 'margin-right:2px;'
     *
     * ***Note**:* This method uses {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules
     * enabled style processor rules} to normalize passed values.
     *
     *		// Enable 'margin' shorthand processing:
     *		editor.data.addStyleProcessorRules( addMarginRules );
     *
     *		styles.setTo( 'margin:1px' );
     *
     *		styles.remove( 'margin-top' );
     *		styles.remove( 'margin-right' );
     *
     *		styles.toString(); // -> 'margin-bottom:1px;margin-left:1px;'
     *
     * @param {String} name Style name.
     */

  }, {
    key: "remove",
    value: function remove(name) {
      var path = toPath(name);
      lodash_es_unset(this._styles, path);
      delete this._styles[name];

      this._cleanEmptyObjectsOnPath(path);
    }
    /**
     * Returns a normalized style object or a single value.
     *
     *		// Enable 'margin' shorthand processing:
     *		editor.data.addStyleProcessorRules( addMarginRules );
     *
     *		const styles = new Styles();
     *		styles.setTo( 'margin:1px 2px 3em;' );
     *
     *		styles.getNormalized( 'margin' );
     *		// will log:
     *		// {
     *		//     top: '1px',
     *		//     right: '2px',
     *		//     bottom: '3em',
     *		//     left: '2px'     // normalized value from margin shorthand
     *		// }
     *
     *		styles.getNormalized( 'margin-left' ); // -> '2px'
     *
     * **Note**: This method will only return normalized styles if a style processor was defined.
     *
     * @param {String} name Style name.
     * @returns {Object|String|undefined}
     */

  }, {
    key: "getNormalized",
    value: function getNormalized(name) {
      return this._styleProcessor.getNormalized(name, this._styles);
    }
    /**
     * Returns a normalized style string. Styles are sorted by name.
     *
     *		styles.set( 'margin' , '1px' );
     *		styles.set( 'background', '#f00' );
     *
     *		styles.toString(); // -> 'background:#f00;margin:1px;'
     *
     * **Note**: This method supports normalized styles if defined.
     *
     *		// Enable 'margin' shorthand processing:
     *		editor.data.addStyleProcessorRules( addMarginRules );
     *
     *		styles.set( 'margin' , '1px' );
     *		styles.set( 'background', '#f00' );
     *		styles.remove( 'margin-top' );
     *		styles.remove( 'margin-right' );
     *
     *		styles.toString(); // -> 'background:#f00;margin-bottom:1px;margin-left:1px;'
     *
     * @returns {String}
     */

  }, {
    key: "toString",
    value: function toString() {
      if (this.isEmpty) {
        return '';
      }

      return this._getStylesEntries().map(function (arr) {
        return arr.join(':');
      }).sort().join(';') + ';';
    }
    /**
     * Returns property as a value string or undefined if property is not set.
     *
     *		// Enable 'margin' shorthand processing:
     *		editor.data.addStyleProcessorRules( addMarginRules );
     *
     *		const styles = new Styles();
     *		styles.setTo( 'margin:1px;' );
     *		styles.set( 'margin-bottom', '3em' );
     *
     *		styles.getAsString( 'margin' ); // -> 'margin: 1px 1px 3em;'
     *
     * Note, however, that all sub-values must be set for the longhand property name to return a value:
     *
     *		const styles = new Styles();
     *		styles.setTo( 'margin:1px;' );
     *		styles.remove( 'margin-bottom' );
     *
     *		styles.getAsString( 'margin' ); // -> undefined
     *
     * In the above scenario, it is not possible to return a `margin` value, so `undefined` is returned.
     * Instead, you should use:
     *
     *		const styles = new Styles();
     *		styles.setTo( 'margin:1px;' );
     *		styles.remove( 'margin-bottom' );
     *
     *		for ( const styleName of styles.getStyleNames() ) {
     *			console.log( styleName, styles.getAsString( styleName ) );
     *		}
     *		// 'margin-top', '1px'
     *		// 'margin-right', '1px'
     *		// 'margin-left', '1px'
     *
     * In general, it is recommend to iterate over style names like in the example above. This way, you will always get all
     * the currently set style values. So, if all the 4 margin values would be set
     * the for-of loop above would yield only `'margin'`, `'1px'`:
     *
     *		const styles = new Styles();
     *		styles.setTo( 'margin:1px;' );
     *
     *		for ( const styleName of styles.getStyleNames() ) {
     *			console.log( styleName, styles.getAsString( styleName ) );
     *		}
     *		// 'margin', '1px'
     *
     * **Note**: To get a normalized version of a longhand property use the {@link #getNormalized `#getNormalized()`} method.
     *
     * @param {String} propertyName
     * @returns {String|undefined}
     */

  }, {
    key: "getAsString",
    value: function getAsString(propertyName) {
      if (this.isEmpty) {
        return;
      }

      if (this._styles[propertyName] && !lodash_es_isObject(this._styles[propertyName])) {
        // Try return styles set directly - values that are not parsed.
        return this._styles[propertyName];
      }

      var styles = this._styleProcessor.getReducedForm(propertyName, this._styles);

      var propertyDescriptor = styles.find(function (_ref3) {
        var _ref4 = _slicedToArray(_ref3, 1),
            property = _ref4[0];

        return property === propertyName;
      }); // Only return a value if it is set;

      if (Array.isArray(propertyDescriptor)) {
        return propertyDescriptor[1];
      }
    }
    /**
     * Returns style property names as they would appear when using {@link #toString `#toString()`}.
     *
     * @returns {Array.<String>}
     */

  }, {
    key: "getStyleNames",
    value: function getStyleNames() {
      if (this.isEmpty) {
        return [];
      }

      var entries = this._getStylesEntries();

      return entries.map(function (_ref5) {
        var _ref6 = _slicedToArray(_ref5, 1),
            key = _ref6[0];

        return key;
      });
    }
    /**
     * Removes all styles.
     */

  }, {
    key: "clear",
    value: function clear() {
      this._styles = {};
    }
    /**
     * Returns normalized styles entries for further processing.
     *
     * @private
     * @returns {Array.<module:engine/view/stylesmap~PropertyDescriptor>}
     */

  }, {
    key: "_getStylesEntries",
    value: function _getStylesEntries() {
      var parsed = [];
      var keys = Object.keys(this._styles);

      for (var _i3 = 0, _keys = keys; _i3 < _keys.length; _i3++) {
        var key = _keys[_i3];
        parsed.push.apply(parsed, _toConsumableArray(this._styleProcessor.getReducedForm(key, this._styles)));
      }

      return parsed;
    }
    /**
     * Removes empty objects upon removing an entry from internal object.
     *
     * @param {String} path
     * @private
     */

  }, {
    key: "_cleanEmptyObjectsOnPath",
    value: function _cleanEmptyObjectsOnPath(path) {
      var pathParts = path.split('.');
      var isChildPath = pathParts.length > 1;

      if (!isChildPath) {
        return;
      }

      var parentPath = pathParts.splice(0, pathParts.length - 1).join('.');
      var parentObject = lodash_es_get(this._styles, parentPath);

      if (!parentObject) {
        return;
      }

      var isParentEmpty = !Array.from(Object.keys(parentObject)).length;

      if (isParentEmpty) {
        this.remove(parentPath);
      }
    }
  }, {
    key: "isEmpty",
    get: function get() {
      var entries = Object.entries(this._styles);
      var from = Array.from(entries);
      return !from.length;
    }
    /**
     * Number of styles defined.
     *
     * @type {Number}
     */

  }, {
    key: "size",
    get: function get() {
      if (this.isEmpty) {
        return 0;
      }

      return this.getStyleNames().length;
    }
  }]);

  return StylesMap;
}();
/**
 * Style processor is responsible for writing and reading a normalized styles object.
 */



var stylesmap_StylesProcessor = /*#__PURE__*/function () {
  /**
   * Creates StylesProcessor instance.
   *
   * @private
   */
  function StylesProcessor() {
    Object(classCallCheck["a" /* default */])(this, StylesProcessor);

    this._normalizers = new Map();
    this._extractors = new Map();
    this._reducers = new Map();
    this._consumables = new Map();
  }
  /**
   * Parse style string value to a normalized object and appends it to styles object.
   *
   *		const styles = {};
   *
   *		stylesProcessor.toNormalizedForm( 'margin', '1px', styles );
   *
   *		// styles will consist: { margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; } }
   *
   * **Note**: To define normalizer callbacks use {@link #setNormalizer}.
   *
   * @param {String} name Name of style property.
   * @param {String} propertyValue Value of style property.
   * @param {Object} styles Object holding normalized styles.
   */


  Object(createClass["a" /* default */])(StylesProcessor, [{
    key: "toNormalizedForm",
    value: function toNormalizedForm(name, propertyValue, styles) {
      if (lodash_es_isObject(propertyValue)) {
        appendStyleValue(styles, toPath(name), propertyValue);
        return;
      }

      if (this._normalizers.has(name)) {
        var normalizer = this._normalizers.get(name);

        var _normalizer = normalizer(propertyValue),
            path = _normalizer.path,
            value = _normalizer.value;

        appendStyleValue(styles, path, value);
      } else {
        appendStyleValue(styles, name, propertyValue);
      }
    }
    /**
     * Returns a normalized version of a style property.
     *		const styles = {
     *			margin: { top: '1px', right: '1px', bottom: '1px', left: '1px; },
     *			background: { color: '#f00' }
     *		};
     *
     *		stylesProcessor.getNormalized( 'background' );
     *		// will return: { color: '#f00' }
     *
     *		stylesProcessor.getNormalized( 'margin-top' );
     *		// will return: '1px'
     *
     * **Note**: In some cases extracting single value requires defining an extractor callback {@link #setExtractor}.
     *
     * @param {String} name Name of style property.
     * @param {Object} styles Object holding normalized styles.
     * @returns {*}
     */

  }, {
    key: "getNormalized",
    value: function getNormalized(name, styles) {
      if (!name) {
        return lodash_es_merge({}, styles);
      } // Might be empty string.


      if (styles[name] !== undefined) {
        return styles[name];
      }

      if (this._extractors.has(name)) {
        var extractor = this._extractors.get(name);

        if (typeof extractor === 'string') {
          return lodash_es_get(styles, extractor);
        }

        var value = extractor(name, styles);

        if (value) {
          return value;
        }
      }

      return lodash_es_get(styles, toPath(name));
    }
    /**
     * Returns a reduced form of style property form normalized object.
     *
     * For default margin reducer, the below code:
     *
     *		stylesProcessor.getReducedForm( 'margin', {
     *			margin: { top: '1px', right: '1px', bottom: '2px', left: '1px; }
     *		} );
     *
     * will return:
     *
     *		[
     *			[ 'margin', '1px 1px 2px' ]
     *		]
     *
     * because it might be represented as a shorthand 'margin' value. However if one of margin long hand values is missing it should return:
     *
     *		[
     *			[ 'margin-top', '1px' ],
     *			[ 'margin-right', '1px' ],
     *			[ 'margin-bottom', '2px' ]
     *			// the 'left' value is missing - cannot use 'margin' shorthand.
     *		]
     *
     * **Note**: To define reducer callbacks use {@link #setReducer}.
     *
     * @param {String} name
     * @param {String} name Name of style property.
     * @param {Object} styles Object holding normalized styles.
     * @returns {Array.<module:engine/view/stylesmap~PropertyDescriptor>}
     */

  }, {
    key: "getReducedForm",
    value: function getReducedForm(name, styles) {
      var normalizedValue = this.getNormalized(name, styles); // Might be empty string.

      if (normalizedValue === undefined) {
        return [];
      }

      if (this._reducers.has(name)) {
        var reducer = this._reducers.get(name);

        return reducer(normalizedValue);
      }

      return [[name, normalizedValue]];
    }
    /**
     * Returns related style names.
     *
     *		stylesProcessor.getRelatedStyles( 'margin' );
     *		// will return: [ 'margin-top', 'margin-right', 'margin-bottom', 'margin-left' ];
     *
     *		stylesProcessor.getRelatedStyles( 'margin-top' );
     *		// will return: [ 'margin' ];
     *
     * **Note**: To define new style relations load an existing style processor or use
     * {@link module:engine/view/stylesmap~StylesProcessor#setStyleRelation `StylesProcessor.setStyleRelation()`}.
     *
     * @param {String} name
     * @returns {Array.<String>}
     */

  }, {
    key: "getRelatedStyles",
    value: function getRelatedStyles(name) {
      return this._consumables.get(name) || [];
    }
    /**
     * Adds a normalizer method for a style property.
     *
     * A normalizer returns describing how the value should be normalized.
     *
     * For instance 'margin' style is a shorthand for four margin values:
     *
     * - 'margin-top'
     * - 'margin-right'
     * - 'margin-bottom'
     * - 'margin-left'
     *
     * and can be written in various ways if some values are equal to others. For instance `'margin: 1px 2em;'` is a shorthand for
     * `'margin-top: 1px;margin-right: 2em;margin-bottom: 1px;margin-left: 2em'`.
     *
     * A normalizer should parse various margin notations as a single object:
     *
     *		const styles = {
     *			margin: {
     *				top: '1px',
     *				right: '2em',
     *				bottom: '1px',
     *				left: '2em'
     *			}
     *		};
     *
     * Thus a normalizer for 'margin' style should return an object defining style path and value to store:
     *
     *		const returnValue = {
     *			path: 'margin',
     *			value: {
     *				top: '1px',
     *				right: '2em',
     *				bottom: '1px',
     *				left: '2em'
     *			}
     *		};
     *
     * Additionally to fully support all margin notations there should be also defined 4 normalizers for longhand margin notations. Below
     * is an example for 'margin-top' style property normalizer:
     *
     *		stylesProcessor.setNormalizer( 'margin-top', valueString => {
     *			return {
     *				path: 'margin.top',
     *				value: valueString
     *			}
     *		} );
     *
     * @param {String} name
     * @param {Function} callback
     */

  }, {
    key: "setNormalizer",
    value: function setNormalizer(name, callback) {
      this._normalizers.set(name, callback);
    }
    /**
     * Adds a extractor callback for a style property.
     *
     * Most normalized style values are stored as one level objects. It is assumed that `'margin-top'` style will be stored as:
     *
     *		const styles = {
     *			margin: {
     *				top: 'value'
     *			}
     *		}
     *
     * However, some styles can have conflicting notations and thus it might be harder to extract a style value from shorthand. For instance
     * the 'border-top-style' can be defined using `'border-top:solid'`, `'border-style:solid none none none'` or by `'border:solid'`
     * shorthands. The default border styles processors stores styles as:
     *
     *		const styles = {
     *			border: {
     *				style: {
     *					top: 'solid'
     *				}
     *			}
     *		}
     *
     * as it is better to modify border style independently from other values. On the other part the output of the border might be
     * desired as `border-top`, `border-left`, etc notation.
     *
     * In the above example a reducer should return a side border value that combines style, color and width:
     *
     *		styleProcessor.setExtractor( 'border-top', styles => {
     *			return {
     *				color: styles.border.color.top,
     *				style: styles.border.style.top,
     *				width: styles.border.width.top
     *			}
     *		} );
     *
     * @param {String} name
     * @param {Function|String} callbackOrPath Callback that return a requested value or path string for single values.
     */

  }, {
    key: "setExtractor",
    value: function setExtractor(name, callbackOrPath) {
      this._extractors.set(name, callbackOrPath);
    }
    /**
     * Adds a reducer callback for a style property.
     *
     * Reducer returns a minimal notation for given style name. For longhand properties it is not required to write a reducer as
     * by default the direct value from style path is taken.
     *
     * For shorthand styles a reducer should return minimal style notation either by returning single name-value tuple or multiple tuples
     * if a shorthand cannot be used. For instance for a margin shorthand a reducer might return:
     *
     *		const marginShortHandTuple = [
     *			[ 'margin', '1px 1px 2px' ]
     *		];
     *
     * or a longhand tuples for defined values:
     *
     *		// Considering margin.bottom and margin.left are undefined.
     *		const marginLonghandsTuples = [
     *			[ 'margin-top', '1px' ],
     *			[ 'margin-right', '1px' ]
     *		];
     *
     * A reducer obtains a normalized style value:
     *
     *		// Simplified reducer that always outputs 4 values which are always present:
     *		stylesProcessor.setReducer( 'margin', margin => {
     *			return [
     *				[ 'margin', `${ margin.top } ${ margin.right } ${ margin.bottom } ${ margin.left }` ]
     *			]
     *		} );
     *
     * @param {String} name
     * @param {Function} callback
     */

  }, {
    key: "setReducer",
    value: function setReducer(name, callback) {
      this._reducers.set(name, callback);
    }
    /**
     * Defines a style shorthand relation to other style notations.
     *
     *		stylesProcessor.setStyleRelation( 'margin', [
     *			'margin-top',
     *			'margin-right',
     *			'margin-bottom',
     *			'margin-left'
     *		] );
     *
     * This enables expanding of style names for shorthands. For instance, if defined,
     * {@link module:engine/conversion/viewconsumable~ViewConsumable view consumable} items are automatically created
     * for long-hand margin style notation alongside the `'margin'` item.
     *
     * This means that when an element being converted has a style `margin`, a converter for `margin-left` will work just
     * fine since the view consumable will contain a consumable `margin-left` item (thanks to the relation) and
     * `element.getStyle( 'margin-left' )` will work as well assuming that the style processor was correctly configured.
     * However, once `margin-left` is consumed, `margin` will not be consumable anymore.
     *
     * @param {String} shorthandName
     * @param {Array.<String>} styleNames
     */

  }, {
    key: "setStyleRelation",
    value: function setStyleRelation(shorthandName, styleNames) {
      this._mapStyleNames(shorthandName, styleNames);

      var _iterator = _createForOfIteratorHelper(styleNames),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var alsoName = _step.value;

          this._mapStyleNames(alsoName, [shorthandName]);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Set two-way binding of style names.
     *
     * @param {String} name
     * @param {Array.<String>} styleNames
     * @private
     */

  }, {
    key: "_mapStyleNames",
    value: function _mapStyleNames(name, styleNames) {
      var _this$_consumables$ge;

      if (!this._consumables.has(name)) {
        this._consumables.set(name, []);
      }

      (_this$_consumables$ge = this._consumables.get(name)).push.apply(_this$_consumables$ge, _toConsumableArray(styleNames));
    }
  }]);

  return StylesProcessor;
}(); // Parses inline styles and puts property - value pairs into styles map.
//
// @param {String} stylesString Styles to parse.
// @returns {Map.<String, String>} stylesMap Map of parsed properties and values.

function parseInlineStyles(stylesString) {
  // `null` if no quote was found in input string or last found quote was a closing quote. See below.
  var quoteType = null;
  var propertyNameStart = 0;
  var propertyValueStart = 0;
  var propertyName = null;
  var stylesMap = new Map(); // Do not set anything if input string is empty.

  if (stylesString === '') {
    return stylesMap;
  } // Fix inline styles that do not end with `;` so they are compatible with algorithm below.


  if (stylesString.charAt(stylesString.length - 1) != ';') {
    stylesString = stylesString + ';';
  } // Seek the whole string for "special characters".


  for (var i = 0; i < stylesString.length; i++) {
    var char = stylesString.charAt(i);

    if (quoteType === null) {
      // No quote found yet or last found quote was a closing quote.
      switch (char) {
        case ':':
          // Most of time colon means that property name just ended.
          // Sometimes however `:` is found inside property value (for example in background image url).
          if (!propertyName) {
            // Treat this as end of property only if property name is not already saved.
            // Save property name.
            propertyName = stylesString.substr(propertyNameStart, i - propertyNameStart); // Save this point as the start of property value.

            propertyValueStart = i + 1;
          }

          break;

        case '"':
        case '\'':
          // Opening quote found (this is an opening quote, because `quoteType` is `null`).
          quoteType = char;
          break;

        case ';':
          {
            // Property value just ended.
            // Use previously stored property value start to obtain property value.
            var propertyValue = stylesString.substr(propertyValueStart, i - propertyValueStart);

            if (propertyName) {
              // Save parsed part.
              stylesMap.set(propertyName.trim(), propertyValue.trim());
            }

            propertyName = null; // Save this point as property name start. Property name starts immediately after previous property value ends.

            propertyNameStart = i + 1;
            break;
          }
      }
    } else if (char === quoteType) {
      // If a quote char is found and it is a closing quote, mark this fact by `null`-ing `quoteType`.
      quoteType = null;
    }
  }

  return stylesMap;
} // Return lodash compatible path from style name.


function toPath(name) {
  return name.replace('-', '.');
} // Appends style definition to the styles object.
//
// @param {String} nameOrPath
// @param {String|Object} valueOrObject
// @private


function appendStyleValue(stylesObject, nameOrPath, valueOrObject) {
  var valueToSet = valueOrObject;

  if (lodash_es_isObject(valueOrObject)) {
    valueToSet = lodash_es_merge({}, lodash_es_get(stylesObject, nameOrPath), valueOrObject);
  }

  lodash_es_set(stylesObject, nameOrPath, valueToSet);
}
/**
 * A CSS style property descriptor that contains tuplet of two strings:
 *
 * - first string describes property name
 * - second string describes property value
 *
 *		const marginDescriptor = [ 'margin', '2px 3em' ];
 *		const marginTopDescriptor = [ 'margin-top', '2px' ];
 *
 * @typedef {Array.<String, String>} module:engine/view/stylesmap~PropertyDescriptor
 */

/**
 * An object describing values associated with the sides of a box, for instance margins, paddings,
 * border widths, border colors, etc.
 *
 *		const margin = {
 *			top: '1px',
 *			right: '3px',
 *			bottom: '3px',
 *			left: '7px'
 *		};
 *
 *		const borderColor = {
 *			top: 'red',
 *			right: 'blue',
 *			bottom: 'blue',
 *			left: 'red'
 *		};
 *
 * @typedef {Object} module:engine/view/stylesmap~BoxSides
 *
 * @property {String} top Top side value.
 * @property {String} right Right side value.
 * @property {String} bottom Bottom side value.
 * @property {String} left Left side value.
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/element.js
































/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/element
 */






 // @if CK_DEBUG_ENGINE // const { convertMapToTags } = require( '../dev-utils/utils' );

/**
 * View element.
 *
 * The editing engine does not define a fixed semantics of its elements (it is "DTD-free").
 * This is why the type of the {@link module:engine/view/element~Element} need to
 * be defined by the feature developer. When creating an element you should use one of the following methods:
 *
 * * {@link module:engine/view/downcastwriter~DowncastWriter#createContainerElement `downcastWriter#createContainerElement()`}
 * in order to create a {@link module:engine/view/containerelement~ContainerElement},
 * * {@link module:engine/view/downcastwriter~DowncastWriter#createAttributeElement `downcastWriter#createAttributeElement()`}
 * in order to create a {@link module:engine/view/attributeelement~AttributeElement},
 * * {@link module:engine/view/downcastwriter~DowncastWriter#createEmptyElement `downcastWriter#createEmptyElement()`}
 * in order to create a {@link module:engine/view/emptyelement~EmptyElement}.
 * * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `downcastWriter#createUIElement()`}
 * in order to create a {@link module:engine/view/uielement~UIElement}.
 * * {@link module:engine/view/downcastwriter~DowncastWriter#createEditableElement `downcastWriter#createEditableElement()`}
 * in order to create a {@link module:engine/view/editableelement~EditableElement}.
 *
 * Note that for view elements which are not created from the model, like elements from mutations, paste or
 * {@link module:engine/controller/datacontroller~DataController#set data.set} it is not possible to define the type of the element.
 * In such cases the {@link module:engine/view/upcastwriter~UpcastWriter#createElement `UpcastWriter#createElement()`} method
 * should be used to create generic view elements.
 *
 * @extends module:engine/view/node~Node
 */

var element_Element = /*#__PURE__*/function (_Node) {
  Object(inherits["a" /* default */])(Element, _Node);

  var _super = Object(createSuper["a" /* default */])(Element);

  /**
   * Creates a view element.
   *
   * Attributes can be passed in various formats:
   *
   *		new Element( viewDocument, 'div', { class: 'editor', contentEditable: 'true' } ); // object
   *		new Element( viewDocument, 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
   *		new Element( viewDocument, 'div', mapOfAttributes ); // map
   *
   * @protected
   * @param {module:engine/view/document~Document} document The document instance to which this element belongs.
   * @param {String} name Node name.
   * @param {Object|Iterable} [attrs] Collection of attributes.
   * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]
   * A list of nodes to be inserted into created element.
   */
  function Element(document, name, attrs, children) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Element);

    _this = _super.call(this, document);
    /**
     * Name of the element.
     *
     * @readonly
     * @member {String}
     */

    _this.name = name;
    /**
     * Map of attributes, where attributes names are keys and attributes values are values.
     *
     * @protected
     * @member {Map} #_attrs
     */

    _this._attrs = parseAttributes(attrs);
    /**
     * Array of child nodes.
     *
     * @protected
     * @member {Array.<module:engine/view/node~Node>}
     */

    _this._children = [];

    if (children) {
      _this._insertChild(0, children);
    }
    /**
     * Set of classes associated with element instance.
     *
     * @protected
     * @member {Set}
     */


    _this._classes = new Set();

    if (_this._attrs.has('class')) {
      // Remove class attribute and handle it by class set.
      var classString = _this._attrs.get('class');

      parseClasses(_this._classes, classString);

      _this._attrs.delete('class');
    }
    /**
     * Normalized styles.
     *
     * @protected
     * @member {module:engine/view/stylesmap~StylesMap} module:engine/view/element~Element#_styles
     */


    _this._styles = new stylesmap_StylesMap(_this.document.stylesProcessor);

    if (_this._attrs.has('style')) {
      // Remove style attribute and handle it by styles map.
      _this._styles.setTo(_this._attrs.get('style'));

      _this._attrs.delete('style');
    }
    /**
     * Map of custom properties.
     * Custom properties can be added to element instance, will be cloned but not rendered into DOM.
     *
     * @protected
     * @member {Map}
     */


    _this._customProperties = new Map();
    return _this;
  }
  /**
   * Number of element's children.
   *
   * @readonly
   * @type {Number}
   */


  Object(createClass["a" /* default */])(Element, [{
    key: "is",

    /**
     * Checks whether this object is of the given.
     *
     *		element.is( 'element' ); // -> true
     *		element.is( 'node' ); // -> true
     *		element.is( 'view:element' ); // -> true
     *		element.is( 'view:node' ); // -> true
     *
     *		element.is( 'model:element' ); // -> false
     *		element.is( 'documentSelection' ); // -> false
     *
     * Assuming that the object being checked is an element, you can also check its
     * {@link module:engine/view/element~Element#name name}:
     *
     *		element.is( 'img' ); // -> true if this is an <img> element
     *		element.is( 'element', 'img' ); // -> same as above
     *		text.is( 'img' ); -> false
     *
     * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.
     *
     * @param {String} type Type to check when `name` parameter is present.
     * Otherwise, it acts like the `name` parameter.
     * @param {String} [name] Element name.
     * @returns {Boolean}
     */
    value: function is(type) {
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (!name) {
        return type === this.name || type === 'view:' + this.name || type === 'element' || type === 'view:element' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'node' || type === 'view:node';
      } else {
        return name === this.name && (type === 'element' || type === 'view:element');
      }
    }
    /**
     * Gets child at the given index.
     *
     * @param {Number} index Index of child.
     * @returns {module:engine/view/node~Node} Child node.
     */

  }, {
    key: "getChild",
    value: function getChild(index) {
      return this._children[index];
    }
    /**
     * Gets index of the given child node. Returns `-1` if child node is not found.
     *
     * @param {module:engine/view/node~Node} node Child node.
     * @returns {Number} Index of the child node.
     */

  }, {
    key: "getChildIndex",
    value: function getChildIndex(node) {
      return this._children.indexOf(node);
    }
    /**
     * Gets child nodes iterator.
     *
     * @returns {Iterable.<module:engine/view/node~Node>} Child nodes iterator.
     */

  }, {
    key: "getChildren",
    value: function getChildren() {
      return this._children[Symbol.iterator]();
    }
    /**
     * Returns an iterator that contains the keys for attributes. Order of inserting attributes is not preserved.
     *
     * @returns {Iterable.<String>} Keys for attributes.
     */

  }, {
    key: "getAttributeKeys",
    value: /*#__PURE__*/regeneratorRuntime.mark(function getAttributeKeys() {
      return regeneratorRuntime.wrap(function getAttributeKeys$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!(this._classes.size > 0)) {
                _context.next = 3;
                break;
              }

              _context.next = 3;
              return 'class';

            case 3:
              if (this._styles.isEmpty) {
                _context.next = 6;
                break;
              }

              _context.next = 6;
              return 'style';

            case 6:
              return _context.delegateYield(this._attrs.keys(), "t0", 7);

            case 7:
            case "end":
              return _context.stop();
          }
        }
      }, getAttributeKeys, this);
    })
    /**
     * Returns iterator that iterates over this element's attributes.
     *
     * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
     * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
     *
     * @returns {Iterable.<*>}
     */

  }, {
    key: "getAttributes",
    value: /*#__PURE__*/regeneratorRuntime.mark(function getAttributes() {
      return regeneratorRuntime.wrap(function getAttributes$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.delegateYield(this._attrs.entries(), "t0", 1);

            case 1:
              if (!(this._classes.size > 0)) {
                _context2.next = 4;
                break;
              }

              _context2.next = 4;
              return ['class', this.getAttribute('class')];

            case 4:
              if (this._styles.isEmpty) {
                _context2.next = 7;
                break;
              }

              _context2.next = 7;
              return ['style', this.getAttribute('style')];

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, getAttributes, this);
    })
    /**
     * Gets attribute by key. If attribute is not present - returns undefined.
     *
     * @param {String} key Attribute key.
     * @returns {String|undefined} Attribute value.
     */

  }, {
    key: "getAttribute",
    value: function getAttribute(key) {
      if (key == 'class') {
        if (this._classes.size > 0) {
          return _toConsumableArray(this._classes).join(' ');
        }

        return undefined;
      }

      if (key == 'style') {
        var inlineStyle = this._styles.toString();

        return inlineStyle == '' ? undefined : inlineStyle;
      }

      return this._attrs.get(key);
    }
    /**
     * Returns a boolean indicating whether an attribute with the specified key exists in the element.
     *
     * @param {String} key Attribute key.
     * @returns {Boolean} `true` if attribute with the specified key exists in the element, false otherwise.
     */

  }, {
    key: "hasAttribute",
    value: function hasAttribute(key) {
      if (key == 'class') {
        return this._classes.size > 0;
      }

      if (key == 'style') {
        return !this._styles.isEmpty;
      }

      return this._attrs.has(key);
    }
    /**
     * Checks if this element is similar to other element.
     * Both elements should have the same name and attributes to be considered as similar. Two similar elements
     * can contain different set of children nodes.
     *
     * @param {module:engine/view/element~Element} otherElement
     * @returns {Boolean}
     */

  }, {
    key: "isSimilar",
    value: function isSimilar(otherElement) {
      if (!(otherElement instanceof Element)) {
        return false;
      } // If exactly the same Element is provided - return true immediately.


      if (this === otherElement) {
        return true;
      } // Check element name.


      if (this.name != otherElement.name) {
        return false;
      } // Check number of attributes, classes and styles.


      if (this._attrs.size !== otherElement._attrs.size || this._classes.size !== otherElement._classes.size || this._styles.size !== otherElement._styles.size) {
        return false;
      } // Check if attributes are the same.


      var _iterator = _createForOfIteratorHelper(this._attrs),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _slicedToArray(_step.value, 2),
              key = _step$value[0],
              value = _step$value[1];

          if (!otherElement._attrs.has(key) || otherElement._attrs.get(key) !== value) {
            return false;
          }
        } // Check if classes are the same.

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var _iterator2 = _createForOfIteratorHelper(this._classes),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var className = _step2.value;

          if (!otherElement._classes.has(className)) {
            return false;
          }
        } // Check if styles are the same.

      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var _iterator3 = _createForOfIteratorHelper(this._styles.getStyleNames()),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var property = _step3.value;

          if (!otherElement._styles.has(property) || otherElement._styles.getAsString(property) !== this._styles.getAsString(property)) {
            return false;
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return true;
    }
    /**
     * Returns true if class is present.
     * If more then one class is provided - returns true only when all classes are present.
     *
     *		element.hasClass( 'foo' ); // Returns true if 'foo' class is present.
     *		element.hasClass( 'foo', 'bar' ); // Returns true if 'foo' and 'bar' classes are both present.
     *
     * @param {...String} className
     */

  }, {
    key: "hasClass",
    value: function hasClass() {
      for (var _len = arguments.length, className = new Array(_len), _key = 0; _key < _len; _key++) {
        className[_key] = arguments[_key];
      }

      for (var _i = 0, _className = className; _i < _className.length; _i++) {
        var name = _className[_i];

        if (!this._classes.has(name)) {
          return false;
        }
      }

      return true;
    }
    /**
     * Returns iterator that contains all class names.
     *
     * @returns {Iterable.<String>}
     */

  }, {
    key: "getClassNames",
    value: function getClassNames() {
      return this._classes.keys();
    }
    /**
     * Returns style value for the given property mae.
     * If the style does not exist `undefined` is returned.
     *
     * **Note**: This method can work with normalized style names if
     * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
     * See {@link module:engine/view/stylesmap~StylesMap#getAsString `StylesMap#getAsString()`} for details.
     *
     * For an element with style set to `'margin:1px'`:
     *
     *		// Enable 'margin' shorthand processing:
     *		editor.data.addStyleProcessorRules( addMarginRules );
     *
     *		const element = view.change( writer => {
     *			const element = writer.createElement();
     *			writer.setStyle( 'margin', '1px' );
     *			writer.setStyle( 'margin-bottom', '3em' );
     *
     *			return element;
     *		} );
     *
     *		element.getStyle( 'margin' ); // -> 'margin: 1px 1px 3em;'
     *
     * @param {String} property
     * @returns {String|undefined}
     */

  }, {
    key: "getStyle",
    value: function getStyle(property) {
      return this._styles.getAsString(property);
    }
    /**
     * Returns a normalized style object or single style value.
     *
     * For an element with style set to: margin:1px 2px 3em;
     *
     *		element.getNormalizedStyle( 'margin' ) );
     *
     * will return:
     *
     *		{
     *			top: '1px',
     *			right: '2px',
     *			bottom: '3em',
     *			left: '2px'    // a normalized value from margin shorthand
     *		}
     *
     * and reading for single style value:
     *
     *		styles.getNormalizedStyle( 'margin-left' );
     *
     * Will return a `2px` string.
     *
     * **Note**: This method will return normalized values only if
     * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
     * See {@link module:engine/view/stylesmap~StylesMap#getNormalized `StylesMap#getNormalized()`} for details.
     *
     *
     * @param {String} property Name of CSS property
     * @returns {Object|String|undefined}
     */

  }, {
    key: "getNormalizedStyle",
    value: function getNormalizedStyle(property) {
      return this._styles.getNormalized(property);
    }
    /**
     * Returns iterator that contains all style names.
     *
     * @returns {Iterable.<String>}
     */

  }, {
    key: "getStyleNames",
    value: function getStyleNames() {
      return this._styles.getStyleNames();
    }
    /**
     * Returns true if style keys are present.
     * If more then one style property is provided - returns true only when all properties are present.
     *
     *		element.hasStyle( 'color' ); // Returns true if 'border-top' style is present.
     *		element.hasStyle( 'color', 'border-top' ); // Returns true if 'color' and 'border-top' styles are both present.
     *
     * @param {...String} property
     */

  }, {
    key: "hasStyle",
    value: function hasStyle() {
      for (var _len2 = arguments.length, property = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        property[_key2] = arguments[_key2];
      }

      for (var _i2 = 0, _property = property; _i2 < _property.length; _i2++) {
        var name = _property[_i2];

        if (!this._styles.has(name)) {
          return false;
        }
      }

      return true;
    }
    /**
     * Returns ancestor element that match specified pattern.
     * Provided patterns should be compatible with {@link module:engine/view/matcher~Matcher Matcher} as it is used internally.
     *
     * @see module:engine/view/matcher~Matcher
     * @param {Object|String|RegExp|Function} patterns Patterns used to match correct ancestor.
     * See {@link module:engine/view/matcher~Matcher}.
     * @returns {module:engine/view/element~Element|null} Found element or `null` if no matching ancestor was found.
     */

  }, {
    key: "findAncestor",
    value: function findAncestor() {
      for (var _len3 = arguments.length, patterns = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        patterns[_key3] = arguments[_key3];
      }

      var matcher = Object(construct["a" /* default */])(matcher_Matcher, patterns);

      var parent = this.parent;

      while (parent) {
        if (matcher.match(parent)) {
          return parent;
        }

        parent = parent.parent;
      }

      return null;
    }
    /**
     * Returns the custom property value for the given key.
     *
     * @param {String|Symbol} key
     * @returns {*}
     */

  }, {
    key: "getCustomProperty",
    value: function getCustomProperty(key) {
      return this._customProperties.get(key);
    }
    /**
     * Returns an iterator which iterates over this element's custom properties.
     * Iterator provides `[ key, value ]` pairs for each stored property.
     *
     * @returns {Iterable.<*>}
     */

  }, {
    key: "getCustomProperties",
    value: /*#__PURE__*/regeneratorRuntime.mark(function getCustomProperties() {
      return regeneratorRuntime.wrap(function getCustomProperties$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              return _context3.delegateYield(this._customProperties.entries(), "t0", 1);

            case 1:
            case "end":
              return _context3.stop();
          }
        }
      }, getCustomProperties, this);
    })
    /**
     * Returns identity string based on element's name, styles, classes and other attributes.
     * Two elements that {@link #isSimilar are similar} will have same identity string.
     * It has the following format:
     *
     *		'name class="class1,class2" style="style1:value1;style2:value2" attr1="val1" attr2="val2"'
    	 *
     * For example:
     *
     *		const element = writer.createContainerElement( 'foo', {
     *			banana: '10',
     *			apple: '20',
     *			style: 'color: red; border-color: white;',
     *			class: 'baz'
     *		} );
     *
     *		// returns 'foo class="baz" style="border-color:white;color:red" apple="20" banana="10"'
     *		element.getIdentity();
     *
     * **Note**: Classes, styles and other attributes are sorted alphabetically.
     *
     * @returns {String}
     */

  }, {
    key: "getIdentity",
    value: function getIdentity() {
      var classes = Array.from(this._classes).sort().join(',');

      var styles = this._styles.toString();

      var attributes = Array.from(this._attrs).map(function (i) {
        return "".concat(i[0], "=\"").concat(i[1], "\"");
      }).sort().join(' ');
      return this.name + (classes == '' ? '' : " class=\"".concat(classes, "\"")) + (!styles ? '' : " style=\"".concat(styles, "\"")) + (attributes == '' ? '' : " ".concat(attributes));
    }
    /**
     * Clones provided element.
     *
     * @protected
     * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,
     * element will be cloned without any children.
     * @returns {module:engine/view/element~Element} Clone of this element.
     */

  }, {
    key: "_clone",
    value: function _clone() {
      var deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var childrenClone = [];

      if (deep) {
        var _iterator4 = _createForOfIteratorHelper(this.getChildren()),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var child = _step4.value;
            childrenClone.push(child._clone(deep));
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      } // ContainerElement and AttributeElement should be also cloned properly.


      var cloned = new this.constructor(this.document, this.name, this._attrs, childrenClone); // Classes and styles are cloned separately - this solution is faster than adding them back to attributes and
      // parse once again in constructor.

      cloned._classes = new Set(this._classes);

      cloned._styles.set(this._styles.getNormalized()); // Clone custom properties.


      cloned._customProperties = new Map(this._customProperties); // Clone filler offset method.
      // We can't define this method in a prototype because it's behavior which
      // is changed by e.g. toWidget() function from ckeditor5-widget. Perhaps this should be one of custom props.

      cloned.getFillerOffset = this.getFillerOffset;
      return cloned;
    }
    /**
     * {@link module:engine/view/element~Element#_insertChild Insert} a child node or a list of child nodes at the end of this node
     * and sets the parent of these nodes to this element.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#insert
     * @protected
     * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.
     * @fires module:engine/view/node~Node#change
     * @returns {Number} Number of appended nodes.
     */

  }, {
    key: "_appendChild",
    value: function _appendChild(items) {
      return this._insertChild(this.childCount, items);
    }
    /**
     * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
     * this element.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#insert
     * @protected
     * @param {Number} index Position where nodes should be inserted.
     * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.
     * @fires module:engine/view/node~Node#change
     * @returns {Number} Number of inserted nodes.
     */

  }, {
    key: "_insertChild",
    value: function _insertChild(index, items) {
      this._fireChange('children', this);

      var count = 0;
      var nodes = normalize(this.document, items);

      var _iterator5 = _createForOfIteratorHelper(nodes),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var node = _step5.value;

          // If node that is being added to this element is already inside another element, first remove it from the old parent.
          if (node.parent !== null) {
            node._remove();
          }

          node.parent = this;
          node.document = this.document;

          this._children.splice(index, 0, node);

          index++;
          count++;
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return count;
    }
    /**
     * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#remove
     * @protected
     * @param {Number} index Number of the first node to remove.
     * @param {Number} [howMany=1] Number of nodes to remove.
     * @fires module:engine/view/node~Node#change
     * @returns {Array.<module:engine/view/node~Node>} The array of removed nodes.
     */

  }, {
    key: "_removeChildren",
    value: function _removeChildren(index) {
      var howMany = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      this._fireChange('children', this);

      for (var i = index; i < index + howMany; i++) {
        this._children[i].parent = null;
      }

      return this._children.splice(index, howMany);
    }
    /**
     * Adds or overwrite attribute with a specified key and value.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#setAttribute
     * @protected
     * @param {String} key Attribute key.
     * @param {String} value Attribute value.
     * @fires module:engine/view/node~Node#change
     */

  }, {
    key: "_setAttribute",
    value: function _setAttribute(key, value) {
      value = String(value);

      this._fireChange('attributes', this);

      if (key == 'class') {
        parseClasses(this._classes, value);
      } else if (key == 'style') {
        this._styles.setTo(value);
      } else {
        this._attrs.set(key, value);
      }
    }
    /**
     * Removes attribute from the element.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#removeAttribute
     * @protected
     * @param {String} key Attribute key.
     * @returns {Boolean} Returns true if an attribute existed and has been removed.
     * @fires module:engine/view/node~Node#change
     */

  }, {
    key: "_removeAttribute",
    value: function _removeAttribute(key) {
      this._fireChange('attributes', this); // Remove class attribute.


      if (key == 'class') {
        if (this._classes.size > 0) {
          this._classes.clear();

          return true;
        }

        return false;
      } // Remove style attribute.


      if (key == 'style') {
        if (!this._styles.isEmpty) {
          this._styles.clear();

          return true;
        }

        return false;
      } // Remove other attributes.


      return this._attrs.delete(key);
    }
    /**
     * Adds specified class.
     *
     *		element._addClass( 'foo' ); // Adds 'foo' class.
     *		element._addClass( [ 'foo', 'bar' ] ); // Adds 'foo' and 'bar' classes.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#addClass
     * @protected
     * @param {Array.<String>|String} className
     * @fires module:engine/view/node~Node#change
     */

  }, {
    key: "_addClass",
    value: function _addClass(className) {
      var _this2 = this;

      this._fireChange('attributes', this);

      className = Array.isArray(className) ? className : [className];
      className.forEach(function (name) {
        return _this2._classes.add(name);
      });
    }
    /**
     * Removes specified class.
     *
     *		element._removeClass( 'foo' );  // Removes 'foo' class.
     *		element._removeClass( [ 'foo', 'bar' ] ); // Removes both 'foo' and 'bar' classes.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#removeClass
     * @protected
     * @param {Array.<String>|String} className
     * @fires module:engine/view/node~Node#change
     */

  }, {
    key: "_removeClass",
    value: function _removeClass(className) {
      var _this3 = this;

      this._fireChange('attributes', this);

      className = Array.isArray(className) ? className : [className];
      className.forEach(function (name) {
        return _this3._classes.delete(name);
      });
    }
    /**
     * Adds style to the element.
     *
     *		element._setStyle( 'color', 'red' );
     *		element._setStyle( {
     *			color: 'red',
     *			position: 'fixed'
     *		} );
     *
     * **Note**: This method can work with normalized style names if
     * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
     * See {@link module:engine/view/stylesmap~StylesMap#set `StylesMap#set()`} for details.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#setStyle
     * @protected
     * @param {String|Object} property Property name or object with key - value pairs.
     * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.
     * @fires module:engine/view/node~Node#change
     */

  }, {
    key: "_setStyle",
    value: function _setStyle(property, value) {
      this._fireChange('attributes', this);

      this._styles.set(property, value);
    }
    /**
     * Removes specified style.
     *
     *		element._removeStyle( 'color' );  // Removes 'color' style.
     *		element._removeStyle( [ 'color', 'border-top' ] ); // Removes both 'color' and 'border-top' styles.
     *
     * **Note**: This method can work with normalized style names if
     * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
     * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#removeStyle
     * @protected
     * @param {Array.<String>|String} property
     * @fires module:engine/view/node~Node#change
     */

  }, {
    key: "_removeStyle",
    value: function _removeStyle(property) {
      var _this4 = this;

      this._fireChange('attributes', this);

      property = Array.isArray(property) ? property : [property];
      property.forEach(function (name) {
        return _this4._styles.remove(name);
      });
    }
    /**
     * Sets a custom property. Unlike attributes, custom properties are not rendered to the DOM,
     * so they can be used to add special data to elements.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#setCustomProperty
     * @protected
     * @param {String|Symbol} key
     * @param {*} value
     */

  }, {
    key: "_setCustomProperty",
    value: function _setCustomProperty(key, value) {
      this._customProperties.set(key, value);
    }
    /**
     * Removes the custom property stored under the given key.
     *
     * @see module:engine/view/downcastwriter~DowncastWriter#removeCustomProperty
     * @protected
     * @param {String|Symbol} key
     * @returns {Boolean} Returns true if property was removed.
     */

  }, {
    key: "_removeCustomProperty",
    value: function _removeCustomProperty(key) {
      return this._customProperties.delete(key);
    }
    /**
     * Returns block {@link module:engine/view/filler filler} offset or `null` if block filler is not needed.
     *
     * @abstract
     * @method module:engine/view/element~Element#getFillerOffset
     */
    // @if CK_DEBUG_ENGINE // printTree( level = 0) {
    // @if CK_DEBUG_ENGINE // 	let string = '';
    // @if CK_DEBUG_ENGINE //	string += '\t'.repeat( level ) + `<${ this.name }${ convertMapToTags( this.getAttributes() ) }>`;
    // @if CK_DEBUG_ENGINE //	for ( const child of this.getChildren() ) {
    // @if CK_DEBUG_ENGINE //		if ( child.is( 'text' ) ) {
    // @if CK_DEBUG_ENGINE //			string += '\n' + '\t'.repeat( level + 1 ) + child.data;
    // @if CK_DEBUG_ENGINE //		} else {
    // @if CK_DEBUG_ENGINE //			string += '\n' + child.printTree( level + 1 );
    // @if CK_DEBUG_ENGINE //		}
    // @if CK_DEBUG_ENGINE //	}
    // @if CK_DEBUG_ENGINE //	if ( this.childCount ) {
    // @if CK_DEBUG_ENGINE //		string += '\n' + '\t'.repeat( level );
    // @if CK_DEBUG_ENGINE //	}
    // @if CK_DEBUG_ENGINE //	string += `</${ this.name }>`;
    // @if CK_DEBUG_ENGINE //	return string;
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // logTree() {
    // @if CK_DEBUG_ENGINE // 	console.log( this.printTree() );
    // @if CK_DEBUG_ENGINE // }

  }, {
    key: "childCount",
    get: function get() {
      return this._children.length;
    }
    /**
     * Is `true` if there are no nodes inside this element, `false` otherwise.
     *
     * @readonly
     * @type {Boolean}
     */

  }, {
    key: "isEmpty",
    get: function get() {
      return this._children.length === 0;
    }
  }]);

  return Element;
}(node_Node); // Parses attributes provided to the element constructor before they are applied to an element. If attributes are passed
// as an object (instead of `Iterable`), the object is transformed to the map. Attributes with `null` value are removed.
// Attributes with non-`String` value are converted to `String`.
//
// @param {Object|Iterable} attrs Attributes to parse.
// @returns {Map} Parsed attributes.




function parseAttributes(attrs) {
  attrs = toMap(attrs);

  var _iterator6 = _createForOfIteratorHelper(attrs),
      _step6;

  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var _step6$value = _slicedToArray(_step6.value, 2),
          key = _step6$value[0],
          value = _step6$value[1];

      if (value === null) {
        attrs.delete(key);
      } else if (typeof value != 'string') {
        attrs.set(key, String(value));
      }
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  return attrs;
} // Parses class attribute and puts all classes into classes set.
// Classes set s cleared before insertion.
//
// @param {Set.<String>} classesSet Set to insert parsed classes.
// @param {String} classesString String with classes to parse.


function parseClasses(classesSet, classesString) {
  var classArray = classesString.split(/\s+/);
  classesSet.clear();
  classArray.forEach(function (name) {
    return classesSet.add(name);
  });
} // Converts strings to Text and non-iterables to arrays.
//
// @param {String|module:engine/view/item~Item|Iterable.<String|module:engine/view/item~Item>}
// @returns {Iterable.<module:engine/view/node~Node>}


function normalize(document, nodes) {
  // Separate condition because string is iterable.
  if (typeof nodes == 'string') {
    return [new text_Text(document, nodes)];
  }

  if (!isIterable(nodes)) {
    nodes = [nodes];
  } // Array.from to enable .map() on non-arrays.


  return Array.from(nodes).map(function (node) {
    if (typeof node == 'string') {
      return new text_Text(document, node);
    }

    if (node instanceof textproxy_TextProxy) {
      return new text_Text(document, node.data);
    }

    return node;
  });
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/containerelement.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/containerelement
 */

/**
 * Containers are elements which define document structure. They define boundaries for
 * {@link module:engine/view/attributeelement~AttributeElement attributes}. They are mostly used for block elements like `<p>` or `<div>`.
 *
 * Editing engine does not define a fixed HTML DTD. This is why a feature developer needs to choose between various
 * types (container element, {@link module:engine/view/attributeelement~AttributeElement attribute element},
 * {@link module:engine/view/emptyelement~EmptyElement empty element}, etc) when developing a feature.
 *
 * The container element should be your default choice when writing a converter, unless:
 *
 * * this element represents a model text attribute (then use {@link module:engine/view/attributeelement~AttributeElement}),
 * * this is an empty element like `<img>` (then use {@link module:engine/view/emptyelement~EmptyElement}),
 * * this is a root element,
 * * this is a nested editable element (then use  {@link module:engine/view/editableelement~EditableElement}).
 *
 * To create a new container element instance use the
 * {@link module:engine/view/downcastwriter~DowncastWriter#createContainerElement `DowncastWriter#createContainerElement()`}
 * method.
 *
 * @extends module:engine/view/element~Element
 */

var containerelement_ContainerElement = /*#__PURE__*/function (_Element) {
  Object(inherits["a" /* default */])(ContainerElement, _Element);

  var _super = Object(createSuper["a" /* default */])(ContainerElement);

  /**
   * Creates a container element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createContainerElement
   * @see module:engine/view/element~Element
   * @protected
   * @param {module:engine/view/document~Document} document The document instance to which this element belongs.
   * @param {String} name Node name.
   * @param {Object|Iterable} [attrs] Collection of attributes.
   * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]
   * A list of nodes to be inserted into created element.
   */
  function ContainerElement(document, name, attrs, children) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, ContainerElement);

    _this = _super.call(this, document, name, attrs, children);
    /**
     * Returns block {@link module:engine/view/filler filler} offset or `null` if block filler is not needed.
     *
     * @method #getFillerOffset
     * @returns {Number|null} Block filler offset or `null` if block filler is not needed.
     */

    _this.getFillerOffset = getFillerOffset;
    return _this;
  }
  /**
   * Checks whether this object is of the given.
   *
   *		containerElement.is( 'containerElement' ); // -> true
   *		containerElement.is( 'element' ); // -> true
   *		containerElement.is( 'node' ); // -> true
   *		containerElement.is( 'view:containerElement' ); // -> true
   *		containerElement.is( 'view:element' ); // -> true
   *		containerElement.is( 'view:node' ); // -> true
   *
   *		containerElement.is( 'model:element' ); // -> false
   *		containerElement.is( 'documentFragment' ); // -> false
   *
   * Assuming that the object being checked is a container element, you can also check its
   * {@link module:engine/view/containerelement~ContainerElement#name name}:
   *
   *		containerElement.is( 'div' ); // -> true if this is a div container element
   *		containerElement.is( 'contaienrElement', 'div' ); // -> same as above
   *		text.is( 'div' ); -> false
   *
   * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.
   *
   * @param {String} type Type to check when `name` parameter is present.
   * Otherwise, it acts like the `name` parameter.
   * @param {String} [name] Element name.
   * @returns {Boolean}
   */


  Object(createClass["a" /* default */])(ContainerElement, [{
    key: "is",
    value: function is(type) {
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (!name) {
        return type === 'containerElement' || type === 'view:containerElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === this.name || type === 'view:' + this.name || type === 'element' || type === 'view:element' || type === 'node' || type === 'view:node';
      } else {
        return name === this.name && (type === 'containerElement' || type === 'view:containerElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'element' || type === 'view:element');
      }
    }
  }]);

  return ContainerElement;
}(element_Element);
/**
 * Returns block {@link module:engine/view/filler filler} offset or `null` if block filler is not needed.
 *
 * @returns {Number|null} Block filler offset or `null` if block filler is not needed.
 */



function getFillerOffset() {
  var children = _toConsumableArray(this.getChildren());

  var lastChild = children[this.childCount - 1]; // Block filler is required after a `<br>` if it's the last element in its container. See #1422.

  if (lastChild && lastChild.is('element', 'br')) {
    return this.childCount;
  }

  var _iterator = _createForOfIteratorHelper(children),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var child = _step.value;

      // If there's any non-UI element – don't render the bogus.
      if (!child.is('uiElement')) {
        return null;
      }
    } // If there are only UI elements – render the bogus at the end of the element.

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return this.childCount;
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.every.js
var es_array_every = __webpack_require__("a623");

// EXTERNAL MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/typeof.js
var esm_typeof = __webpack_require__("0122");

// CONCATENATED MODULE: ./node_modules/lodash-es/assignIn.js




/**
 * This method is like `_.assign` except that it iterates over own and
 * inherited source properties.
 *
 * **Note:** This method mutates `object`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @alias extend
 * @category Object
 * @param {Object} object The destination object.
 * @param {...Object} [sources] The source objects.
 * @returns {Object} Returns `object`.
 * @see _.assign
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * function Bar() {
 *   this.c = 3;
 * }
 *
 * Foo.prototype.b = 2;
 * Bar.prototype.d = 4;
 *
 * _.assignIn({ 'a': 0 }, new Foo, new Bar);
 * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
 */
var assignIn = _createAssigner(function(object, source) {
  _copyObject(source, lodash_es_keysIn(source), object);
});

/* harmony default export */ var lodash_es_assignIn = (assignIn);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/observablemixin.js



















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/observablemixin
 */



var observablePropertiesSymbol = Symbol('observableProperties');
var boundObservablesSymbol = Symbol('boundObservables');
var boundPropertiesSymbol = Symbol('boundProperties');
/**
 * Mixin that injects the "observable properties" and data binding functionality described in the
 * {@link ~Observable} interface.
 *
 * Read more about the concept of observables in the:
 * * {@glink framework/guides/architecture/core-editor-architecture#event-system-and-observables "Event system and observables"}
 * section of the {@glink framework/guides/architecture/core-editor-architecture "Core editor architecture"} guide,
 * * {@glink framework/guides/deep-dive/observables "Observables" deep dive} guide.
 *
 * @mixin ObservableMixin
 * @mixes module:utils/emittermixin~EmitterMixin
 * @implements module:utils/observablemixin~Observable
 */

var ObservableMixin = {
  /**
   * @inheritDoc
   */
  set: function set(name, value) {
    var _this = this;

    // If the first parameter is an Object, iterate over its properties.
    if (lodash_es_isObject(name)) {
      Object.keys(name).forEach(function (property) {
        _this.set(property, name[property]);
      }, this);
      return;
    }

    initObservable(this);
    var properties = this[observablePropertiesSymbol];

    if (name in this && !properties.has(name)) {
      /**
       * Cannot override an existing property.
       *
       * This error is thrown when trying to {@link ~Observable#set set} an property with
       * a name of an already existing property. For example:
       *
       *		let observable = new Model();
       *		observable.property = 1;
       *		observable.set( 'property', 2 );			// throws
       *
       *		observable.set( 'property', 1 );
       *		observable.set( 'property', 2 );			// ok, because this is an existing property.
       *
       * @error observable-set-cannot-override
       */
      throw new ckeditorerror["b" /* default */]('observable-set-cannot-override: Cannot override an existing property.', this);
    }

    Object.defineProperty(this, name, {
      enumerable: true,
      configurable: true,
      get: function get() {
        return properties.get(name);
      },
      set: function set(value) {
        var oldValue = properties.get(name); // Fire `set` event before the new value will be set to make it possible
        // to override observable property without affecting `change` event.
        // See https://github.com/ckeditor/ckeditor5-utils/issues/171.

        var newValue = this.fire('set:' + name, name, value, oldValue);

        if (newValue === undefined) {
          newValue = value;
        } // Allow undefined as an initial value like A.define( 'x', undefined ) (#132).
        // Note: When properties map has no such own property, then its value is undefined.


        if (oldValue !== newValue || !properties.has(name)) {
          properties.set(name, newValue);
          this.fire('change:' + name, name, newValue, oldValue);
        }
      }
    });
    this[name] = value;
  },

  /**
   * @inheritDoc
   */
  bind: function bind() {
    var _this2 = this;

    for (var _len = arguments.length, bindProperties = new Array(_len), _key = 0; _key < _len; _key++) {
      bindProperties[_key] = arguments[_key];
    }

    if (!bindProperties.length || !isStringArray(bindProperties)) {
      /**
       * All properties must be strings.
       *
       * @error observable-bind-wrong-properties
       */
      throw new ckeditorerror["b" /* default */]('observable-bind-wrong-properties: All properties must be strings.', this);
    }

    if (new Set(bindProperties).size !== bindProperties.length) {
      /**
       * Properties must be unique.
       *
       * @error observable-bind-duplicate-properties
       */
      throw new ckeditorerror["b" /* default */]('observable-bind-duplicate-properties: Properties must be unique.', this);
    }

    initObservable(this);
    var boundProperties = this[boundPropertiesSymbol];
    bindProperties.forEach(function (propertyName) {
      if (boundProperties.has(propertyName)) {
        /**
         * Cannot bind the same property more than once.
         *
         * @error observable-bind-rebind
         */
        throw new ckeditorerror["b" /* default */]('observable-bind-rebind: Cannot bind the same property more than once.', _this2);
      }
    });
    var bindings = new Map(); // @typedef {Object} Binding
    // @property {Array} property Property which is bound.
    // @property {Array} to Array of observable–property components of the binding (`{ observable: ..., property: .. }`).
    // @property {Array} callback A function which processes `to` components.

    bindProperties.forEach(function (a) {
      var binding = {
        property: a,
        to: []
      };
      boundProperties.set(a, binding);
      bindings.set(a, binding);
    }); // @typedef {Object} BindChain
    // @property {Function} to See {@link ~ObservableMixin#_bindTo}.
    // @property {Function} toMany See {@link ~ObservableMixin#_bindToMany}.
    // @property {module:utils/observablemixin~Observable} _observable The observable which initializes the binding.
    // @property {Array} _bindProperties Array of `_observable` properties to be bound.
    // @property {Array} _to Array of `to()` observable–properties (`{ observable: toObservable, properties: ...toProperties }`).
    // @property {Map} _bindings Stores bindings to be kept in
    // {@link ~ObservableMixin#_boundProperties}/{@link ~ObservableMixin#_boundObservables}
    // initiated in this binding chain.

    return {
      to: observablemixin_bindTo,
      toMany: bindToMany,
      _observable: this,
      _bindProperties: bindProperties,
      _to: [],
      _bindings: bindings
    };
  },

  /**
   * @inheritDoc
   */
  unbind: function unbind() {
    var _this3 = this;

    // Nothing to do here if not inited yet.
    if (!this[observablePropertiesSymbol]) {
      return;
    }

    var boundProperties = this[boundPropertiesSymbol];
    var boundObservables = this[boundObservablesSymbol];

    for (var _len2 = arguments.length, unbindProperties = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      unbindProperties[_key2] = arguments[_key2];
    }

    if (unbindProperties.length) {
      if (!isStringArray(unbindProperties)) {
        /**
         * Properties must be strings.
         *
         * @error observable-unbind-wrong-properties
         */
        throw new ckeditorerror["b" /* default */]('observable-unbind-wrong-properties: Properties must be strings.', this);
      }

      unbindProperties.forEach(function (propertyName) {
        var binding = boundProperties.get(propertyName); // Nothing to do if the binding is not defined

        if (!binding) {
          return;
        }

        var toObservable, toProperty, toProperties, toPropertyBindings;
        binding.to.forEach(function (to) {
          // TODO: ES6 destructuring.
          toObservable = to[0];
          toProperty = to[1];
          toProperties = boundObservables.get(toObservable);
          toPropertyBindings = toProperties[toProperty];
          toPropertyBindings.delete(binding);

          if (!toPropertyBindings.size) {
            delete toProperties[toProperty];
          }

          if (!Object.keys(toProperties).length) {
            boundObservables.delete(toObservable);

            _this3.stopListening(toObservable, 'change');
          }
        });
        boundProperties.delete(propertyName);
      });
    } else {
      boundObservables.forEach(function (bindings, boundObservable) {
        _this3.stopListening(boundObservable, 'change');
      });
      boundObservables.clear();
      boundProperties.clear();
    }
  },

  /**
   * @inheritDoc
   */
  decorate: function decorate(methodName) {
    var _this4 = this;

    var originalMethod = this[methodName];

    if (!originalMethod) {
      /**
       * Cannot decorate an undefined method.
       *
       * @error observablemixin-cannot-decorate-undefined
       * @param {Object} object The object which method should be decorated.
       * @param {String} methodName Name of the method which does not exist.
       */
      throw new ckeditorerror["b" /* default */]('observablemixin-cannot-decorate-undefined: Cannot decorate an undefined method.', this, {
        object: this,
        methodName: methodName
      });
    }

    this.on(methodName, function (evt, args) {
      evt.return = originalMethod.apply(_this4, args);
    });

    this[methodName] = function () {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      return this.fire(methodName, args);
    };
  }
};
lodash_es_assignIn(ObservableMixin, emittermixin);
/* harmony default export */ var observablemixin = (ObservableMixin); // Init symbol properties needed to for the observable mechanism to work.
//
// @private
// @param {module:utils/observablemixin~ObservableMixin} observable

function initObservable(observable) {
  // Do nothing if already inited.
  if (observable[observablePropertiesSymbol]) {
    return;
  } // The internal hash containing the observable's state.
  //
  // @private
  // @type {Map}


  Object.defineProperty(observable, observablePropertiesSymbol, {
    value: new Map()
  }); // Map containing bindings to external observables. It shares the binding objects
  // (`{ observable: A, property: 'a', to: ... }`) with {@link module:utils/observablemixin~ObservableMixin#_boundProperties} and
  // it is used to observe external observables to update own properties accordingly.
  // See {@link module:utils/observablemixin~ObservableMixin#bind}.
  //
  //		A.bind( 'a', 'b', 'c' ).to( B, 'x', 'y', 'x' );
  //		console.log( A._boundObservables );
  //
  //			Map( {
  //				B: {
  //					x: Set( [
  //						{ observable: A, property: 'a', to: [ [ B, 'x' ] ] },
  //						{ observable: A, property: 'c', to: [ [ B, 'x' ] ] }
  //					] ),
  //					y: Set( [
  //						{ observable: A, property: 'b', to: [ [ B, 'y' ] ] },
  //					] )
  //				}
  //			} )
  //
  //		A.bind( 'd' ).to( B, 'z' ).to( C, 'w' ).as( callback );
  //		console.log( A._boundObservables );
  //
  //			Map( {
  //				B: {
  //					x: Set( [
  //						{ observable: A, property: 'a', to: [ [ B, 'x' ] ] },
  //						{ observable: A, property: 'c', to: [ [ B, 'x' ] ] }
  //					] ),
  //					y: Set( [
  //						{ observable: A, property: 'b', to: [ [ B, 'y' ] ] },
  //					] ),
  //					z: Set( [
  //						{ observable: A, property: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }
  //					] )
  //				},
  //				C: {
  //					w: Set( [
  //						{ observable: A, property: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }
  //					] )
  //				}
  //			} )
  //
  // @private
  // @type {Map}

  Object.defineProperty(observable, boundObservablesSymbol, {
    value: new Map()
  }); // Object that stores which properties of this observable are bound and how. It shares
  // the binding objects (`{ observable: A, property: 'a', to: ... }`) with
  // {@link module:utils/observablemixin~ObservableMixin#_boundObservables}. This data structure is
  // a reverse of {@link module:utils/observablemixin~ObservableMixin#_boundObservables} and it is helpful for
  // {@link module:utils/observablemixin~ObservableMixin#unbind}.
  //
  // See {@link module:utils/observablemixin~ObservableMixin#bind}.
  //
  //		A.bind( 'a', 'b', 'c' ).to( B, 'x', 'y', 'x' );
  //		console.log( A._boundProperties );
  //
  //			Map( {
  //				a: { observable: A, property: 'a', to: [ [ B, 'x' ] ] },
  //				b: { observable: A, property: 'b', to: [ [ B, 'y' ] ] },
  //				c: { observable: A, property: 'c', to: [ [ B, 'x' ] ] }
  //			} )
  //
  //		A.bind( 'd' ).to( B, 'z' ).to( C, 'w' ).as( callback );
  //		console.log( A._boundProperties );
  //
  //			Map( {
  //				a: { observable: A, property: 'a', to: [ [ B, 'x' ] ] },
  //				b: { observable: A, property: 'b', to: [ [ B, 'y' ] ] },
  //				c: { observable: A, property: 'c', to: [ [ B, 'x' ] ] },
  //				d: { observable: A, property: 'd', to: [ [ B, 'z' ], [ C, 'w' ] ], callback: callback }
  //			} )
  //
  // @private
  // @type {Map}

  Object.defineProperty(observable, boundPropertiesSymbol, {
    value: new Map()
  });
} // A chaining for {@link module:utils/observablemixin~ObservableMixin#bind} providing `.to()` interface.
//
// @private
// @param {...[Observable|String|Function]} args Arguments of the `.to( args )` binding.


function observablemixin_bindTo() {
  var _this5 = this;

  var parsedArgs = parseBindToArgs.apply(void 0, arguments);
  var bindingsKeys = Array.from(this._bindings.keys());
  var numberOfBindings = bindingsKeys.length; // Eliminate A.bind( 'x' ).to( B, C )

  if (!parsedArgs.callback && parsedArgs.to.length > 1) {
    /**
     * Binding multiple observables only possible with callback.
     *
     * @error observable-bind-no-callback
     */
    throw new ckeditorerror["b" /* default */]('observable-bind-to-no-callback: Binding multiple observables only possible with callback.', this);
  } // Eliminate A.bind( 'x', 'y' ).to( B, callback )


  if (numberOfBindings > 1 && parsedArgs.callback) {
    /**
     * Cannot bind multiple properties and use a callback in one binding.
     *
     * @error observable-bind-to-extra-callback
     */
    throw new ckeditorerror["b" /* default */]('observable-bind-to-extra-callback: Cannot bind multiple properties and use a callback in one binding.', this);
  }

  parsedArgs.to.forEach(function (to) {
    // Eliminate A.bind( 'x', 'y' ).to( B, 'a' )
    if (to.properties.length && to.properties.length !== numberOfBindings) {
      /**
       * The number of properties must match.
       *
       * @error observable-bind-to-properties-length
       */
      throw new ckeditorerror["b" /* default */]('observable-bind-to-properties-length: The number of properties must match.', _this5);
    } // When no to.properties specified, observing source properties instead i.e.
    // A.bind( 'x', 'y' ).to( B ) -> Observe B.x and B.y


    if (!to.properties.length) {
      to.properties = _this5._bindProperties;
    }
  });
  this._to = parsedArgs.to; // Fill {@link BindChain#_bindings} with callback. When the callback is set there's only one binding.

  if (parsedArgs.callback) {
    this._bindings.get(bindingsKeys[0]).callback = parsedArgs.callback;
  }

  attachBindToListeners(this._observable, this._to); // Update observable._boundProperties and observable._boundObservables.

  updateBindToBound(this); // Set initial values of bound properties.

  this._bindProperties.forEach(function (propertyName) {
    updateBoundObservableProperty(_this5._observable, propertyName);
  });
} // Binds to an attribute in a set of iterable observables.
//
// @private
// @param {Array.<Observable>} observables
// @param {String} attribute
// @param {Function} callback


function bindToMany(observables, attribute, callback) {
  if (this._bindings.size > 1) {
    /**
     * Binding one attribute to many observables only possible with one attribute.
     *
     * @error observable-bind-to-many-not-one-binding
     */
    throw new ckeditorerror["b" /* default */]('observable-bind-to-many-not-one-binding: Cannot bind multiple properties with toMany().', this);
  }

  this.to.apply(this, _toConsumableArray(getBindingTargets(observables, attribute)).concat([// ...using given callback to parse attribute values.
  callback]));
} // Returns an array of binding components for
// {@link Observable#bind} from a set of iterable observables.
//
// @param {Array.<Observable>} observables
// @param {String} attribute
// @returns {Array.<String|Observable>}


function getBindingTargets(observables, attribute) {
  var observableAndAttributePairs = observables.map(function (observable) {
    return [observable, attribute];
  }); // Merge pairs to one-dimension array of observables and attributes.

  return Array.prototype.concat.apply([], observableAndAttributePairs);
} // Check if all entries of the array are of `String` type.
//
// @private
// @param {Array} arr An array to be checked.
// @returns {Boolean}


function isStringArray(arr) {
  return arr.every(function (a) {
    return typeof a == 'string';
  });
} // Parses and validates {@link Observable#bind}`.to( args )` arguments and returns
// an object with a parsed structure. For example
//
//		A.bind( 'x' ).to( B, 'a', C, 'b', call );
//
// becomes
//
//		{
//			to: [
//				{ observable: B, properties: [ 'a' ] },
//				{ observable: C, properties: [ 'b' ] },
//			],
//			callback: call
// 		}
//
// @private
// @param {...*} args Arguments of {@link Observable#bind}`.to( args )`.
// @returns {Object}


function parseBindToArgs() {
  for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
    args[_key4] = arguments[_key4];
  }

  // Eliminate A.bind( 'x' ).to()
  if (!args.length) {
    /**
     * Invalid argument syntax in `to()`.
     *
     * @error observable-bind-to-parse-error
     */
    throw new ckeditorerror["b" /* default */]('observable-bind-to-parse-error: Invalid argument syntax in `to()`.', null);
  }

  var parsed = {
    to: []
  };
  var lastObservable;

  if (typeof args[args.length - 1] == 'function') {
    parsed.callback = args.pop();
  }

  args.forEach(function (a) {
    if (typeof a == 'string') {
      lastObservable.properties.push(a);
    } else if (Object(esm_typeof["a" /* default */])(a) == 'object') {
      lastObservable = {
        observable: a,
        properties: []
      };
      parsed.to.push(lastObservable);
    } else {
      throw new ckeditorerror["b" /* default */]('observable-bind-to-parse-error: Invalid argument syntax in `to()`.', null);
    }
  });
  return parsed;
} // Synchronizes {@link module:utils/observablemixin#_boundObservables} with {@link Binding}.
//
// @private
// @param {Binding} binding A binding to store in {@link Observable#_boundObservables}.
// @param {Observable} toObservable A observable, which is a new component of `binding`.
// @param {String} toPropertyName A name of `toObservable`'s property, a new component of the `binding`.


function updateBoundObservables(observable, binding, toObservable, toPropertyName) {
  var boundObservables = observable[boundObservablesSymbol];
  var bindingsToObservable = boundObservables.get(toObservable);
  var bindings = bindingsToObservable || {};

  if (!bindings[toPropertyName]) {
    bindings[toPropertyName] = new Set();
  } // Pass the binding to a corresponding Set in `observable._boundObservables`.


  bindings[toPropertyName].add(binding);

  if (!bindingsToObservable) {
    boundObservables.set(toObservable, bindings);
  }
} // Synchronizes {@link Observable#_boundProperties} and {@link Observable#_boundObservables}
// with {@link BindChain}.
//
// Assuming the following binding being created
//
// 		A.bind( 'a', 'b' ).to( B, 'x', 'y' );
//
// the following bindings were initialized by {@link Observable#bind} in {@link BindChain#_bindings}:
//
// 		{
// 			a: { observable: A, property: 'a', to: [] },
// 			b: { observable: A, property: 'b', to: [] },
// 		}
//
// Iterate over all bindings in this chain and fill their `to` properties with
// corresponding to( ... ) arguments (components of the binding), so
//
// 		{
// 			a: { observable: A, property: 'a', to: [ B, 'x' ] },
// 			b: { observable: A, property: 'b', to: [ B, 'y' ] },
// 		}
//
// Then update the structure of {@link Observable#_boundObservables} with updated
// binding, so it becomes:
//
// 		Map( {
// 			B: {
// 				x: Set( [
// 					{ observable: A, property: 'a', to: [ [ B, 'x' ] ] }
// 				] ),
// 				y: Set( [
// 					{ observable: A, property: 'b', to: [ [ B, 'y' ] ] },
// 				] )
//			}
// 		} )
//
// @private
// @param {BindChain} chain The binding initialized by {@link Observable#bind}.


function updateBindToBound(chain) {
  var toProperty;

  chain._bindings.forEach(function (binding, propertyName) {
    // Note: For a binding without a callback, this will run only once
    // like in A.bind( 'x', 'y' ).to( B, 'a', 'b' )
    // TODO: ES6 destructuring.
    chain._to.forEach(function (to) {
      toProperty = to.properties[binding.callback ? 0 : chain._bindProperties.indexOf(propertyName)];
      binding.to.push([to.observable, toProperty]);
      updateBoundObservables(chain._observable, binding, to.observable, toProperty);
    });
  });
} // Updates an property of a {@link Observable} with a value
// determined by an entry in {@link Observable#_boundProperties}.
//
// @private
// @param {Observable} observable A observable which property is to be updated.
// @param {String} propertyName An property to be updated.


function updateBoundObservableProperty(observable, propertyName) {
  var boundProperties = observable[boundPropertiesSymbol];
  var binding = boundProperties.get(propertyName);
  var propertyValue; // When a binding with callback is created like
  //
  // 		A.bind( 'a' ).to( B, 'b', C, 'c', callback );
  //
  // collect B.b and C.c, then pass them to callback to set A.a.

  if (binding.callback) {
    propertyValue = binding.callback.apply(observable, binding.to.map(function (to) {
      return to[0][to[1]];
    }));
  } else {
    propertyValue = binding.to[0];
    propertyValue = propertyValue[0][propertyValue[1]];
  }

  if (Object.prototype.hasOwnProperty.call(observable, propertyName)) {
    observable[propertyName] = propertyValue;
  } else {
    observable.set(propertyName, propertyValue);
  }
} // Starts listening to changes in {@link BindChain._to} observables to update
// {@link BindChain._observable} {@link BindChain._bindProperties}. Also sets the
// initial state of {@link BindChain._observable}.
//
// @private
// @param {BindChain} chain The chain initialized by {@link Observable#bind}.


function attachBindToListeners(observable, toBindings) {
  toBindings.forEach(function (to) {
    var boundObservables = observable[boundObservablesSymbol];
    var bindings; // If there's already a chain between the observables (`observable` listens to
    // `to.observable`), there's no need to create another `change` event listener.

    if (!boundObservables.get(to.observable)) {
      observable.listenTo(to.observable, 'change', function (evt, propertyName) {
        bindings = boundObservables.get(to.observable)[propertyName]; // Note: to.observable will fire for any property change, react
        // to changes of properties which are bound only.

        if (bindings) {
          bindings.forEach(function (binding) {
            updateBoundObservableProperty(observable, binding.property);
          });
        }
      });
    }
  });
}
/**
 * Interface which adds "observable properties" and data binding functionality.
 *
 * Can be easily implemented by a class by mixing the {@link module:utils/observablemixin~ObservableMixin} mixin.
 *
 * Read more about the usage of this interface in the:
 * * {@glink framework/guides/architecture/core-editor-architecture#event-system-and-observables "Event system and observables"}
 * section of the {@glink framework/guides/architecture/core-editor-architecture "Core editor architecture"} guide,
 * * {@glink framework/guides/deep-dive/observables "Observables" deep dive} guide.
 *
 * @interface Observable
 * @extends module:utils/emittermixin~Emitter
 */

/**
 * Fired when a property changed value.
 *
 *		observable.set( 'prop', 1 );
 *
 *		observable.on( 'change:prop', ( evt, propertyName, newValue, oldValue ) => {
 *			console.log( `${ propertyName } has changed from ${ oldValue } to ${ newValue }` );
 *		} );
 *
 *		observable.prop = 2; // -> 'prop has changed from 1 to 2'
 *
 * @event change:{property}
 * @param {String} name The property name.
 * @param {*} value The new property value.
 * @param {*} oldValue The previous property value.
 */

/**
 * Fired when a property value is going to be set but is not set yet (before the `change` event is fired).
 *
 * You can control the final value of the property by using
 * the {@link module:utils/eventinfo~EventInfo#return event's `return` property}.
 *
 *		observable.set( 'prop', 1 );
 *
 *		observable.on( 'set:prop', ( evt, propertyName, newValue, oldValue ) => {
 *			console.log( `Value is going to be changed from ${ oldValue } to ${ newValue }` );
 *			console.log( `Current property value is ${ observable[ propertyName ] }` );
 *
 *			// Let's override the value.
 *			evt.return = 3;
 *		} );
 *
 *		observable.on( 'change:prop', ( evt, propertyName, newValue, oldValue ) => {
 *			console.log( `Value has changed from ${ oldValue } to ${ newValue }` );
 *		} );
 *
 *		observable.prop = 2; // -> 'Value is going to be changed from 1 to 2'
 *		                     // -> 'Current property value is 1'
 *		                     // -> 'Value has changed from 1 to 3'
 *
 * **Note:** Event is fired even when the new value is the same as the old value.
 *
 * @event set:{property}
 * @param {String} name The property name.
 * @param {*} value The new property value.
 * @param {*} oldValue The previous property value.
 */

/**
 * Creates and sets the value of an observable property of this object. Such an property becomes a part
 * of the state and is be observable.
 *
 * It accepts also a single object literal containing key/value pairs with properties to be set.
 *
 * This method throws the `observable-set-cannot-override` error if the observable instance already
 * have a property with the given property name. This prevents from mistakenly overriding existing
 * properties and methods, but means that `foo.set( 'bar', 1 )` may be slightly slower than `foo.bar = 1`.
 *
 * @method #set
 * @param {String|Object} name The property's name or object with `name=>value` pairs.
 * @param {*} [value] The property's value (if `name` was passed in the first parameter).
 */

/**
 * Binds {@link #set observable properties} to other objects implementing the
 * {@link module:utils/observablemixin~Observable} interface.
 *
 * Read more in the {@glink framework/guides/deep-dive/observables#property-bindings dedicated guide}
 * covering the topic of property bindings with some additional examples.
 *
 * Consider two objects: a `button` and an associated `command` (both `Observable`).
 *
 * A simple property binding could be as follows:
 *
 *		button.bind( 'isEnabled' ).to( command, 'isEnabled' );
 *
 * or even shorter:
 *
 *		button.bind( 'isEnabled' ).to( command );
 *
 * which works in the following way:
 *
 * * `button.isEnabled` **instantly equals** `command.isEnabled`,
 * * whenever `command.isEnabled` changes, `button.isEnabled` will immediately reflect its value.
 *
 * **Note**: To release the binding, use {@link module:utils/observablemixin~Observable#unbind}.
 *
 * You can also "rename" the property in the binding by specifying the new name in the `to()` chain:
 *
 *		button.bind( 'isEnabled' ).to( command, 'isWorking' );
 *
 * It is possible to bind more than one property at a time to shorten the code:
 *
 *		button.bind( 'isEnabled', 'value' ).to( command );
 *
 * which corresponds to:
 *
 *		button.bind( 'isEnabled' ).to( command );
 *		button.bind( 'value' ).to( command );
 *
 * The binding can include more than one observable, combining multiple data sources in a custom callback:
 *
 *		button.bind( 'isEnabled' ).to( command, 'isEnabled', ui, 'isVisible',
 *			( isCommandEnabled, isUIVisible ) => isCommandEnabled && isUIVisible );
 *
 * It is also possible to bind to the same property in an array of observables.
 * To bind a `button` to multiple commands (also `Observables`) so that each and every one of them
 * must be enabled for the button to become enabled, use the following code:
 *
 *		button.bind( 'isEnabled' ).toMany( [ commandA, commandB, commandC ], 'isEnabled',
 *			( isAEnabled, isBEnabled, isCEnabled ) => isAEnabled && isBEnabled && isCEnabled );
 *
 * @method #bind
 * @param {...String} bindProperties Observable properties that will be bound to other observable(s).
 * @returns {Object} The bind chain with the `to()` and `toMany()` methods.
 */

/**
 * Removes the binding created with {@link #bind}.
 *
 *		// Removes the binding for the 'a' property.
 *		A.unbind( 'a' );
 *
 *		// Removes bindings for all properties.
 *		A.unbind();
 *
 * @method #unbind
 * @param {...String} [unbindProperties] Observable properties to be unbound. All the bindings will
 * be released if no properties are provided.
 */

/**
 * Turns the given methods of this object into event-based ones. This means that the new method will fire an event
 * (named after the method) and the original action will be plugged as a listener to that event.
 *
 * Read more in the {@glink framework/guides/deep-dive/observables#decorating-object-methods dedicated guide}
 * covering the topic of decorating methods with some additional examples.
 *
 * Decorating the method does not change its behavior (it only adds an event),
 * but it allows to modify it later on by listening to the method's event.
 *
 * For example, to cancel the method execution the event can be {@link module:utils/eventinfo~EventInfo#stop stopped}:
 *
 *		class Foo {
 *			constructor() {
 *				this.decorate( 'method' );
 *			}
 *
 *			method() {
 *				console.log( 'called!' );
 *			}
 *		}
 *
 *		const foo = new Foo();
 *		foo.on( 'method', ( evt ) => {
 *			evt.stop();
 *		}, { priority: 'high' } );
 *
 *		foo.method(); // Nothing is logged.
 *
 *
 * **Note**: The high {@link module:utils/priorities~PriorityString priority} listener
 * has been used to execute this particular callback before the one which calls the original method
 * (which uses the "normal" priority).
 *
 * It is also possible to change the returned value:
 *
 *		foo.on( 'method', ( evt ) => {
 *			evt.return = 'Foo!';
 *		} );
 *
 *		foo.method(); // -> 'Foo'
 *
 * Finally, it is possible to access and modify the arguments the method is called with:
 *
 *		method( a, b ) {
 *			console.log( `${ a }, ${ b }`  );
 *		}
 *
 *		// ...
 *
 *		foo.on( 'method', ( evt, args ) => {
 *			args[ 0 ] = 3;
 *
 *			console.log( args[ 1 ] ); // -> 2
 *		}, { priority: 'high' } );
 *
 *		foo.method( 1, 2 ); // -> '3, 2'
 *
 * @method #decorate
 * @param {String} methodName Name of the method to decorate.
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/editableelement.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/editableelement
 */



/**
 * Editable element which can be a {@link module:engine/view/rooteditableelement~RootEditableElement root}
 * or nested editable area in the editor.
 *
 * Editable is automatically read-only when its {@link module:engine/view/document~Document Document} is read-only.
 *
 * The constructor of this class shouldn't be used directly. To create new `EditableElement` use the
 * {@link module:engine/view/downcastwriter~DowncastWriter#createEditableElement `downcastWriter#createEditableElement()`} method.
 *
 * @extends module:engine/view/containerelement~ContainerElement
 * @mixes module:utils/observablemixin~ObservableMixin
 */

var editableelement_EditableElement = /*#__PURE__*/function (_ContainerElement) {
  Object(inherits["a" /* default */])(EditableElement, _ContainerElement);

  var _super = Object(createSuper["a" /* default */])(EditableElement);

  /**
   * Creates an editable element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createEditableElement
   * @protected
   */
  function EditableElement(document, name, attrs, children) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, EditableElement);

    _this = _super.call(this, document, name, attrs, children);
    /**
     * Whether the editable is in read-write or read-only mode.
     *
     * @observable
     * @member {Boolean} module:engine/view/editableelement~EditableElement#isReadOnly
     */

    _this.set('isReadOnly', false);
    /**
     * Whether the editable is focused.
     *
     * This property updates when {@link module:engine/view/document~Document#isFocused document.isFocused} or view
     * selection is changed.
     *
     * @readonly
     * @observable
     * @member {Boolean} module:engine/view/editableelement~EditableElement#isFocused
     */


    _this.set('isFocused', false);

    _this.bind('isReadOnly').to(document);

    _this.bind('isFocused').to(document, 'isFocused', function (isFocused) {
      return isFocused && document.selection.editableElement == Object(assertThisInitialized["a" /* default */])(_this);
    }); // Update focus state based on selection changes.


    _this.listenTo(document.selection, 'change', function () {
      _this.isFocused = document.isFocused && document.selection.editableElement == Object(assertThisInitialized["a" /* default */])(_this);
    });

    return _this;
  }
  /**
   * Checks whether this object is of the given.
   *
   *		editableElement.is( 'editableElement' ); // -> true
   *		editableElement.is( 'element' ); // -> true
   *		editableElement.is( 'node' ); // -> true
   *		editableElement.is( 'view:editableElement' ); // -> true
   *		editableElement.is( 'view:element' ); // -> true
   *		editableElement.is( 'view:node' ); // -> true
   *
   *		editableElement.is( 'model:element' ); // -> false
   *		editableElement.is( 'documentFragment' ); // -> false
   *
   * Assuming that the object being checked is an editbale element, you can also check its
   * {@link module:engine/view/editableelement~EditableElement#name name}:
   *
   *		editableElement.is( 'div' ); // -> true if this is a div element
   *		editableElement.is( 'editableElement', 'div' ); // -> same as above
   *		text.is( 'div' ); -> false
   *
   * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.
   *
   * @param {String} type Type to check when `name` parameter is present.
   * Otherwise, it acts like the `name` parameter.
   * @param {String} [name] Element name.
   * @returns {Boolean}
   */


  Object(createClass["a" /* default */])(EditableElement, [{
    key: "is",
    value: function is(type) {
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (!name) {
        return type === 'editableElement' || type === 'view:editableElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'containerElement' || type === 'view:containerElement' || type === this.name || type === 'view:' + this.name || type === 'element' || type === 'view:element' || type === 'node' || type === 'view:node';
      } else {
        return name === this.name && (type === 'editableElement' || type === 'view:editableElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'containerElement' || type === 'view:containerElement' || type === 'element' || type === 'view:element');
      }
    }
  }, {
    key: "destroy",
    value: function destroy() {
      this.stopListening();
    }
  }]);

  return EditableElement;
}(containerelement_ContainerElement);


mix(editableelement_EditableElement, observablemixin);
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/rooteditableelement.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/rooteditableelement
 */

var rootNameSymbol = Symbol('rootName');
/**
 * Class representing a single root in the data view. A root can be either {@link ~RootEditableElement#isReadOnly editable or read-only},
 * but in both cases it is called "an editable". Roots can contain other {@link module:engine/view/editableelement~EditableElement
 * editable elements} making them "nested editables".
 *
 * @extends module:engine/view/editableelement~EditableElement
 */

var rooteditableelement_RootEditableElement = /*#__PURE__*/function (_EditableElement) {
  Object(inherits["a" /* default */])(RootEditableElement, _EditableElement);

  var _super = Object(createSuper["a" /* default */])(RootEditableElement);

  /**
   * Creates root editable element.
   *
   * @param {module:engine/view/document~Document} document The document instance to which this element belongs.
   * @param {String} name Node name.
   */
  function RootEditableElement(document, name) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, RootEditableElement);

    _this = _super.call(this, document, name);
    /**
     * Name of this root inside {@link module:engine/view/document~Document} that is an owner of this root. If no
     * other name is set, `main` name is used.
     *
     * @readonly
     * @member {String}
     */

    _this.rootName = 'main';
    return _this;
  }
  /**
   * Checks whether this object is of the given.
   *
   *		rootEditableElement.is( 'rootElement' ); // -> true
   *		rootEditableElement.is( 'editableElement' ); // -> true
   *		rootEditableElement.is( 'element' ); // -> true
   *		rootEditableElement.is( 'node' ); // -> true
   *		rootEditableElement.is( 'view:editableElement' ); // -> true
   *		rootEditableElement.is( 'view:element' ); // -> true
   *		rootEditableElement.is( 'view:node' ); // -> true
   *
   *		rootEditableElement.is( 'model:element' ); // -> false
   *		rootEditableElement.is( 'documentFragment' ); // -> false
   *
   * Assuming that the object being checked is a root editable element, you can also check its
   * {@link module:engine/view/rooteditableelement~RootEditableElement#name name}:
   *
   *		rootEditableElement.is( 'div' ); // -> true if this is a div root editable element
   *		rootEditableElement.is( 'rootElement', 'div' ); // -> same as above
   *		text.is( 'div' ); -> false
   *
   * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.
   *
   * @param {String} type Type to check when `name` parameter is present.
   * Otherwise, it acts like the `name` parameter.
   * @param {String} [name] Element name.
   * @returns {Boolean}
   */


  Object(createClass["a" /* default */])(RootEditableElement, [{
    key: "is",
    value: function is(type) {
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (!name) {
        return type === 'rootElement' || type === 'view:rootElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'editableElement' || type === 'view:editableElement' || type === 'containerElement' || type === 'view:containerElement' || type === this.name || type === 'view:' + this.name || type === 'element' || type === 'view:element' || type === 'node' || type === 'view:node';
      } else {
        return name === this.name && (type === 'rootElement' || type === 'view:rootElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'editableElement' || type === 'view:editableElement' || type === 'containerElement' || type === 'view:containerElement' || type === 'element' || type === 'view:element');
      }
    }
  }, {
    key: "rootName",
    get: function get() {
      return this.getCustomProperty(rootNameSymbol);
    },
    set: function set(rootName) {
      this._setCustomProperty(rootNameSymbol, rootName);
    }
    /**
     * Overrides old element name and sets new one.
     * This is needed because view roots are created before they are attached to the DOM.
     * The name of the root element is temporary at this stage. It has to be changed when the
     * view root element is attached to the DOM element.
     *
     * @protected
     * @param {String} name The new name of element.
     */

  }, {
    key: "_name",
    set: function set(name) {
      this.name = name;
    }
  }]);

  return RootEditableElement;
}(editableelement_EditableElement);


// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.anchor.js
var es_string_anchor = __webpack_require__("18a5");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/treewalker.js










/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/treewalker
 */





/**
 * Position iterator class. It allows to iterate forward and backward over the document.
 */

var treewalker_TreeWalker = /*#__PURE__*/function () {
  /**
   * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
   *
   * @constructor
   * @param {Object} options Object with configuration.
   * @param {module:engine/view/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.
   * @param {module:engine/view/position~Position} [options.startPosition] Starting position.
   * @param {'forward'|'backward'} [options.direction='forward'] Walking direction.
   * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all characters from
   * {@link module:engine/view/text~Text} should be returned as one {@link module:engine/view/text~Text} (`false`) ore one by one as
   * {@link module:engine/view/textproxy~TextProxy} (`true`).
   * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the
   * iterator is shallow child nodes of any iterated node will not be returned along with `elementEnd` tag.
   * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `elementEnd`
   * tags. If the option is true walker will not return a parent node of start position. If this option is `true`
   * each {@link module:engine/view/element~Element} will be returned once, while if the option is `false` they might be returned
   * twice: for `'elementStart'` and `'elementEnd'`.
   */
  function TreeWalker() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    Object(classCallCheck["a" /* default */])(this, TreeWalker);

    if (!options.boundaries && !options.startPosition) {
      /**
       * Neither boundaries nor starting position have been defined.
       *
       * @error view-tree-walker-no-start-position
       */
      throw new ckeditorerror["b" /* default */]('view-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.', null);
    }

    if (options.direction && options.direction != 'forward' && options.direction != 'backward') {
      throw new ckeditorerror["b" /* default */]('view-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.', options.startPosition, {
        direction: options.direction
      });
    }
    /**
     * Iterator boundaries.
     *
     * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`
     * on the start of boundary, then `{ done: true }` is returned.
     *
     * If boundaries are not defined they are set before first and after last child of the root node.
     *
     * @readonly
     * @member {module:engine/view/range~Range} module:engine/view/treewalker~TreeWalker#boundaries
     */


    this.boundaries = options.boundaries || null;
    /**
     * Iterator position. If start position is not defined then position depends on {@link #direction}. If direction is
     * `'forward'` position starts form the beginning, when direction is `'backward'` position starts from the end.
     *
     * @readonly
     * @member {module:engine/view/position~Position} module:engine/view/treewalker~TreeWalker#position
     */

    if (options.startPosition) {
      this.position = position_Position._createAt(options.startPosition);
    } else {
      this.position = position_Position._createAt(options.boundaries[options.direction == 'backward' ? 'end' : 'start']);
    }
    /**
     * Walking direction. Defaults `'forward'`.
     *
     * @readonly
     * @member {'backward'|'forward'} module:engine/view/treewalker~TreeWalker#direction
     */


    this.direction = options.direction || 'forward';
    /**
     * Flag indicating whether all characters from {@link module:engine/view/text~Text} should be returned as one
     * {@link module:engine/view/text~Text} or one by one as {@link module:engine/view/textproxy~TextProxy}.
     *
     * @readonly
     * @member {Boolean} module:engine/view/treewalker~TreeWalker#singleCharacters
     */

    this.singleCharacters = !!options.singleCharacters;
    /**
     * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any
     * iterated node will not be returned along with `elementEnd` tag.
     *
     * @readonly
     * @member {Boolean} module:engine/view/treewalker~TreeWalker#shallow
     */

    this.shallow = !!options.shallow;
    /**
     * Flag indicating whether iterator should ignore `elementEnd` tags. If set to `true`, walker will not
     * return a parent node of the start position. Each {@link module:engine/view/element~Element} will be returned once.
     * When set to `false` each element might be returned twice: for `'elementStart'` and `'elementEnd'`.
     *
     * @readonly
     * @member {Boolean} module:engine/view/treewalker~TreeWalker#ignoreElementEnd
     */

    this.ignoreElementEnd = !!options.ignoreElementEnd;
    /**
     * Start boundary parent.
     *
     * @private
     * @member {module:engine/view/node~Node} module:engine/view/treewalker~TreeWalker#_boundaryStartParent
     */

    this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
    /**
     * End boundary parent.
     *
     * @private
     * @member {module:engine/view/node~Node} module:engine/view/treewalker~TreeWalker#_boundaryEndParent
     */

    this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
  }
  /**
   * Iterable interface.
   *
   * @returns {Iterable.<module:engine/view/treewalker~TreeWalkerValue>}
   */


  Object(createClass["a" /* default */])(TreeWalker, [{
    key: Symbol.iterator,
    value: function value() {
      return this;
    }
    /**
     * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
     *
     * For example:
     *
     * 		walker.skip( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
     * 		walker.skip( value => true ); // Move the position to the end: <p>{}foo</p> -> <p>foo</p>[]
     * 		walker.skip( value => false ); // Do not move the position.
     *
     * @param {Function} skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should
     * return `true` if the value should be skipped or `false` if not.
     */

  }, {
    key: "skip",
    value: function skip(_skip) {
      var done, value, prevPosition;

      do {
        prevPosition = this.position;

        var _this$next = this.next();

        done = _this$next.done;
        value = _this$next.value;
      } while (!done && _skip(value));

      if (!done) {
        this.position = prevPosition;
      }
    }
    /**
     * Gets the next tree walker's value.
     *
     * @returns {module:engine/view/treewalker~TreeWalkerValue} Object implementing iterator interface, returning
     * information about taken step.
     */

  }, {
    key: "next",
    value: function next() {
      if (this.direction == 'forward') {
        return this._next();
      } else {
        return this._previous();
      }
    }
    /**
     * Makes a step forward in view. Moves the {@link #position} to the next position and returns the encountered value.
     *
     * @private
     * @returns {Object}
     * @returns {Boolean} return.done `true` if iterator is done, `false` otherwise.
     * @returns {module:engine/view/treewalker~TreeWalkerValue} return.value Information about taken step.
     */

  }, {
    key: "_next",
    value: function _next() {
      var position = this.position.clone();
      var previousPosition = this.position;
      var parent = position.parent; // We are at the end of the root.

      if (parent.parent === null && position.offset === parent.childCount) {
        return {
          done: true
        };
      } // We reached the walker boundary.


      if (parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {
        return {
          done: true
        };
      } // Get node just after current position.


      var node; // Text is a specific parent because it contains string instead of child nodes.

      if (parent instanceof text_Text) {
        if (position.isAtEnd) {
          // Prevent returning "elementEnd" for Text node. Skip that value and return the next walker step.
          this.position = position_Position._createAfter(parent);
          return this._next();
        }

        node = parent.data[position.offset];
      } else {
        node = parent.getChild(position.offset);
      }

      if (node instanceof element_Element) {
        if (!this.shallow) {
          position = new position_Position(node, 0);
        } else {
          position.offset++;
        }

        this.position = position;
        return this._formatReturnValue('elementStart', node, previousPosition, position, 1);
      } else if (node instanceof text_Text) {
        if (this.singleCharacters) {
          position = new position_Position(node, 0);
          this.position = position;
          return this._next();
        } else {
          var charactersCount = node.data.length;
          var item; // If text stick out of walker range, we need to cut it and wrap in TextProxy.

          if (node == this._boundaryEndParent) {
            charactersCount = this.boundaries.end.offset;
            item = new textproxy_TextProxy(node, 0, charactersCount);
            position = position_Position._createAfter(item);
          } else {
            item = new textproxy_TextProxy(node, 0, node.data.length); // If not just keep moving forward.

            position.offset++;
          }

          this.position = position;
          return this._formatReturnValue('text', item, previousPosition, position, charactersCount);
        }
      } else if (typeof node == 'string') {
        var textLength;

        if (this.singleCharacters) {
          textLength = 1;
        } else {
          // Check if text stick out of walker range.
          var endOffset = parent === this._boundaryEndParent ? this.boundaries.end.offset : parent.data.length;
          textLength = endOffset - position.offset;
        }

        var textProxy = new textproxy_TextProxy(parent, position.offset, textLength);
        position.offset += textLength;
        this.position = position;
        return this._formatReturnValue('text', textProxy, previousPosition, position, textLength);
      } else {
        // `node` is not set, we reached the end of current `parent`.
        position = position_Position._createAfter(parent);
        this.position = position;

        if (this.ignoreElementEnd) {
          return this._next();
        } else {
          return this._formatReturnValue('elementEnd', parent, previousPosition, position);
        }
      }
    }
    /**
     * Makes a step backward in view. Moves the {@link #position} to the previous position and returns the encountered value.
     *
     * @private
     * @returns {Object}
     * @returns {Boolean} return.done True if iterator is done.
     * @returns {module:engine/view/treewalker~TreeWalkerValue} return.value Information about taken step.
     */

  }, {
    key: "_previous",
    value: function _previous() {
      var position = this.position.clone();
      var previousPosition = this.position;
      var parent = position.parent; // We are at the beginning of the root.

      if (parent.parent === null && position.offset === 0) {
        return {
          done: true
        };
      } // We reached the walker boundary.


      if (parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {
        return {
          done: true
        };
      } // Get node just before current position.


      var node; // Text {@link module:engine/view/text~Text} element is a specific parent because contains string instead of child nodes.

      if (parent instanceof text_Text) {
        if (position.isAtStart) {
          // Prevent returning "elementStart" for Text node. Skip that value and return the next walker step.
          this.position = position_Position._createBefore(parent);
          return this._previous();
        }

        node = parent.data[position.offset - 1];
      } else {
        node = parent.getChild(position.offset - 1);
      }

      if (node instanceof element_Element) {
        if (!this.shallow) {
          position = new position_Position(node, node.childCount);
          this.position = position;

          if (this.ignoreElementEnd) {
            return this._previous();
          } else {
            return this._formatReturnValue('elementEnd', node, previousPosition, position);
          }
        } else {
          position.offset--;
          this.position = position;
          return this._formatReturnValue('elementStart', node, previousPosition, position, 1);
        }
      } else if (node instanceof text_Text) {
        if (this.singleCharacters) {
          position = new position_Position(node, node.data.length);
          this.position = position;
          return this._previous();
        } else {
          var charactersCount = node.data.length;
          var item; // If text stick out of walker range, we need to cut it and wrap in TextProxy.

          if (node == this._boundaryStartParent) {
            var offset = this.boundaries.start.offset;
            item = new textproxy_TextProxy(node, offset, node.data.length - offset);
            charactersCount = item.data.length;
            position = position_Position._createBefore(item);
          } else {
            item = new textproxy_TextProxy(node, 0, node.data.length); // If not just keep moving backward.

            position.offset--;
          }

          this.position = position;
          return this._formatReturnValue('text', item, previousPosition, position, charactersCount);
        }
      } else if (typeof node == 'string') {
        var textLength;

        if (!this.singleCharacters) {
          // Check if text stick out of walker range.
          var startOffset = parent === this._boundaryStartParent ? this.boundaries.start.offset : 0;
          textLength = position.offset - startOffset;
        } else {
          textLength = 1;
        }

        position.offset -= textLength;
        var textProxy = new textproxy_TextProxy(parent, position.offset, textLength);
        this.position = position;
        return this._formatReturnValue('text', textProxy, previousPosition, position, textLength);
      } else {
        // `node` is not set, we reached the beginning of current `parent`.
        position = position_Position._createBefore(parent);
        this.position = position;
        return this._formatReturnValue('elementStart', parent, previousPosition, position, 1);
      }
    }
    /**
     * Format returned data and adjust `previousPosition` and `nextPosition` if reach the bound of the {@link module:engine/view/text~Text}.
     *
     * @private
     * @param {module:engine/view/treewalker~TreeWalkerValueType} type Type of step.
     * @param {module:engine/view/item~Item} item Item between old and new position.
     * @param {module:engine/view/position~Position} previousPosition Previous position of iterator.
     * @param {module:engine/view/position~Position} nextPosition Next position of iterator.
     * @param {Number} [length] Length of the item.
     * @returns {module:engine/view/treewalker~TreeWalkerValue}
     */

  }, {
    key: "_formatReturnValue",
    value: function _formatReturnValue(type, item, previousPosition, nextPosition, length) {
      // Text is a specific parent, because contains string instead of children.
      // Walker doesn't enter to the Text except situations when walker is iterating over every single character,
      // or the bound starts/ends inside the Text. So when the position is at the beginning or at the end of the Text
      // we move it just before or just after Text.
      if (item instanceof textproxy_TextProxy) {
        // Position is at the end of Text.
        if (item.offsetInText + item.data.length == item.textNode.data.length) {
          if (this.direction == 'forward' && !(this.boundaries && this.boundaries.end.isEqual(this.position))) {
            nextPosition = position_Position._createAfter(item.textNode); // When we change nextPosition of returned value we need also update walker current position.

            this.position = nextPosition;
          } else {
            previousPosition = position_Position._createAfter(item.textNode);
          }
        } // Position is at the begining ot the text.


        if (item.offsetInText === 0) {
          if (this.direction == 'backward' && !(this.boundaries && this.boundaries.start.isEqual(this.position))) {
            nextPosition = position_Position._createBefore(item.textNode); // When we change nextPosition of returned value we need also update walker current position.

            this.position = nextPosition;
          } else {
            previousPosition = position_Position._createBefore(item.textNode);
          }
        }
      }

      return {
        done: false,
        value: {
          type: type,
          item: item,
          previousPosition: previousPosition,
          nextPosition: nextPosition,
          length: length
        }
      };
    }
  }]);

  return TreeWalker;
}();
/**
 * Type of the step made by {@link module:engine/view/treewalker~TreeWalker}.
 * Possible values: `'elementStart'` if walker is at the beginning of a node, `'elementEnd'` if walker is at the end
 * of node, or `'text'` if walker traversed over single and multiple characters.
 * For {@link module:engine/view/text~Text} `elementStart` and `elementEnd` is not returned.
 *
 * @typedef {String} module:engine/view/treewalker~TreeWalkerValueType
 */

/**
 * Object returned by {@link module:engine/view/treewalker~TreeWalker} when traversing tree view.
 *
 * @typedef {Object} module:engine/view/treewalker~TreeWalkerValue
 * @property {module:engine/view/treewalker~TreeWalkerValueType} type
 * @property {module:engine/view/item~Item} item Item between the old and the new positions
 * of the tree walker.
 * @property {module:engine/view/position~Position} previousPosition Previous position of the iterator.
 * * Forward iteration: For `'elementEnd'` it is the last position inside the element. For all other types it is the
 * position before the item.
 * * Backward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is
 * the position after item.
 * * If the position is at the beginning or at the end of the {@link module:engine/view/text~Text} it is always moved from the
 * inside of the text to its parent just before or just after that text.
 * @property {module:engine/view/position~Position} nextPosition Next position of the iterator.
 * * Forward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is
 * the position after the item.
 * * Backward iteration: For `'elementEnd'` it is last position inside element. For all other types it is the position
 * before the item.
 * * If the position is at the beginning or at the end of the {@link module:engine/view/text~Text} it is always moved from the
 * inside of the text to its parent just before or just after that text.
 * @property {Number} [length] Length of the item. For `'elementStart'` it is `1`. For `'text'` it is
 * the length of that text. For `'elementEnd'` it is `undefined`.
 */

/**
 * Tree walking directions.
 *
 * @typedef {'forward'|'backward'} module:engine/view/treewalker~TreeWalkerDirection
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/position.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/position
 */



 // To check if component is loaded more than once.


/**
 * Position in the view tree. Position is represented by its parent node and an offset in this parent.
 *
 * In order to create a new position instance use the `createPosition*()` factory methods available in:
 *
 * * {@link module:engine/view/view~View}
 * * {@link module:engine/view/downcastwriter~DowncastWriter}
 * * {@link module:engine/view/upcastwriter~UpcastWriter}
 */

var position_Position = /*#__PURE__*/function () {
  /**
   * Creates a position.
   *
   * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} parent Position parent.
   * @param {Number} offset Position offset.
   */
  function Position(parent, offset) {
    Object(classCallCheck["a" /* default */])(this, Position);

    /**
     * Position parent.
     *
     * @readonly
     * @member {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}
     * module:engine/view/position~Position#parent
     */
    this.parent = parent;
    /**
     * Position offset.
     *
     * @readonly
     * @member {Number} module:engine/view/position~Position#offset
     */

    this.offset = offset;
  }
  /**
   * Node directly after the position. Equals `null` when there is no node after position or position is located
   * inside text node.
   *
   * @readonly
   * @type {module:engine/view/node~Node|null}
   */


  Object(createClass["a" /* default */])(Position, [{
    key: "getShiftedBy",

    /**
     * Returns a new instance of Position with offset incremented by `shift` value.
     *
     * @param {Number} shift How position offset should get changed. Accepts negative values.
     * @returns {module:engine/view/position~Position} Shifted position.
     */
    value: function getShiftedBy(shift) {
      var shifted = Position._createAt(this);

      var offset = shifted.offset + shift;
      shifted.offset = offset < 0 ? 0 : offset;
      return shifted;
    }
    /**
     * Gets the farthest position which matches the callback using
     * {@link module:engine/view/treewalker~TreeWalker TreeWalker}.
     *
     * For example:
     *
     * 		getLastMatchingPosition( value => value.type == 'text' ); // <p>{}foo</p> -> <p>foo[]</p>
     * 		getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } ); // <p>foo[]</p> -> <p>{}foo</p>
     * 		getLastMatchingPosition( value => false ); // Do not move the position.
     *
     * @param {Function} skip Callback function. Gets {@link module:engine/view/treewalker~TreeWalkerValue} and should
     * return `true` if the value should be skipped or `false` if not.
     * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
     *
     * @returns {module:engine/view/position~Position} The position after the last item which matches the `skip` callback test.
     */

  }, {
    key: "getLastMatchingPosition",
    value: function getLastMatchingPosition(skip) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      options.startPosition = this;
      var treeWalker = new treewalker_TreeWalker(options);
      treeWalker.skip(skip);
      return treeWalker.position;
    }
    /**
     * Returns ancestors array of this position, that is this position's parent and it's ancestors.
     *
     * @returns {Array} Array with ancestors.
     */

  }, {
    key: "getAncestors",
    value: function getAncestors() {
      if (this.parent.is('documentFragment')) {
        return [this.parent];
      } else {
        return this.parent.getAncestors({
          includeSelf: true
        });
      }
    }
    /**
     * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}
     * which is a common ancestor of both positions.
     *
     * @param {module:engine/view/position~Position} position
     * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null}
     */

  }, {
    key: "getCommonAncestor",
    value: function getCommonAncestor(position) {
      var ancestorsA = this.getAncestors();
      var ancestorsB = position.getAncestors();
      var i = 0;

      while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
        i++;
      }

      return i === 0 ? null : ancestorsA[i - 1];
    }
    /**
     * Checks whether this object is of the given type.
     *
     *		position.is( 'position' ); // -> true
     *		position.is( 'view:position' ); // -> true
     *
     *		position.is( 'model:position' ); // -> false
     *		position.is( 'element' ); // -> false
     *		position.is( 'range' ); // -> false
     *
     * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.
     *
     * @param {String} type
     * @returns {Boolean}
     */

  }, {
    key: "is",
    value: function is(type) {
      return type === 'position' || type === 'view:position';
    }
    /**
     * Checks whether this position equals given position.
     *
     * @param {module:engine/view/position~Position} otherPosition Position to compare with.
     * @returns {Boolean} True if positions are same.
     */

  }, {
    key: "isEqual",
    value: function isEqual(otherPosition) {
      return this.parent == otherPosition.parent && this.offset == otherPosition.offset;
    }
    /**
     * Checks whether this position is located before given position. When method returns `false` it does not mean that
     * this position is after give one. Two positions may be located inside separate roots and in that situation this
     * method will still return `false`.
     *
     * @see module:engine/view/position~Position#isAfter
     * @see module:engine/view/position~Position#compareWith
     * @param {module:engine/view/position~Position} otherPosition Position to compare with.
     * @returns {Boolean} Returns `true` if this position is before given position.
     */

  }, {
    key: "isBefore",
    value: function isBefore(otherPosition) {
      return this.compareWith(otherPosition) == 'before';
    }
    /**
     * Checks whether this position is located after given position. When method returns `false` it does not mean that
     * this position is before give one. Two positions may be located inside separate roots and in that situation this
     * method will still return `false`.
     *
     * @see module:engine/view/position~Position#isBefore
     * @see module:engine/view/position~Position#compareWith
     * @param {module:engine/view/position~Position} otherPosition Position to compare with.
     * @returns {Boolean} Returns `true` if this position is after given position.
     */

  }, {
    key: "isAfter",
    value: function isAfter(otherPosition) {
      return this.compareWith(otherPosition) == 'after';
    }
    /**
     * Checks whether this position is before, after or in same position that other position. Two positions may be also
     * different when they are located in separate roots.
     *
     * @param {module:engine/view/position~Position} otherPosition Position to compare with.
     * @returns {module:engine/view/position~PositionRelation}
     */

  }, {
    key: "compareWith",
    value: function compareWith(otherPosition) {
      if (this.root !== otherPosition.root) {
        return 'different';
      }

      if (this.isEqual(otherPosition)) {
        return 'same';
      } // Get path from root to position's parent element.


      var thisPath = this.parent.is('node') ? this.parent.getPath() : [];
      var otherPath = otherPosition.parent.is('node') ? otherPosition.parent.getPath() : []; // Add the positions' offsets to the parents offsets.

      thisPath.push(this.offset);
      otherPath.push(otherPosition.offset); // Compare both path arrays to find common ancestor.

      var result = compareArrays(thisPath, otherPath);

      switch (result) {
        case 'prefix':
          return 'before';

        case 'extension':
          return 'after';

        default:
          return thisPath[result] < otherPath[result] ? 'before' : 'after';
      }
    }
    /**
     * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this positions as a start position.
     *
     * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}
     * @param {module:engine/view/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.
     * @param {Boolean} [options.singleCharacters=false]
     * @param {Boolean} [options.shallow=false]
     * @param {Boolean} [options.ignoreElementEnd=false]
     */

  }, {
    key: "getWalker",
    value: function getWalker() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      options.startPosition = this;
      return new treewalker_TreeWalker(options);
    }
  }, {
    key: "clone",
    value: function clone() {
      return new Position(this.parent, this.offset);
    }
    /**
     * Creates position at the given location. The location can be specified as:
     *
     * * a {@link module:engine/view/position~Position position},
     * * parent element and offset (offset defaults to `0`),
     * * parent element and `'end'` (sets position at the end of that element),
     * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
     *
     * This method is a shortcut to other constructors such as:
     *
     * * {@link module:engine/view/position~Position._createBefore},
     * * {@link module:engine/view/position~Position._createAfter}.
     *
     * @protected
     * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition
     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when
     * first parameter is a {@link module:engine/view/item~Item view item}.
     */

  }, {
    key: "nodeAfter",
    get: function get() {
      if (this.parent.is('text')) {
        return null;
      }

      return this.parent.getChild(this.offset) || null;
    }
    /**
     * Node directly before the position. Equals `null` when there is no node before position or position is located
     * inside text node.
     *
     * @readonly
     * @type {module:engine/view/node~Node|null}
     */

  }, {
    key: "nodeBefore",
    get: function get() {
      if (this.parent.is('text')) {
        return null;
      }

      return this.parent.getChild(this.offset - 1) || null;
    }
    /**
     * Is `true` if position is at the beginning of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.
     *
     * @readonly
     * @type {Boolean}
     */

  }, {
    key: "isAtStart",
    get: function get() {
      return this.offset === 0;
    }
    /**
     * Is `true` if position is at the end of its {@link module:engine/view/position~Position#parent parent}, `false` otherwise.
     *
     * @readonly
     * @type {Boolean}
     */

  }, {
    key: "isAtEnd",
    get: function get() {
      var endOffset = this.parent.is('text') ? this.parent.data.length : this.parent.childCount;
      return this.offset === endOffset;
    }
    /**
     * Position's root, that is the root of the position's parent element.
     *
     * @readonly
     * @type {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}
     */

  }, {
    key: "root",
    get: function get() {
      return this.parent.root;
    }
    /**
     * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this position, or `null` if
     * position is not inside an editable element.
     *
     * @type {module:engine/view/editableelement~EditableElement|null}
     */

  }, {
    key: "editableElement",
    get: function get() {
      var editable = this.parent;

      while (!(editable instanceof editableelement_EditableElement)) {
        if (editable.parent) {
          editable = editable.parent;
        } else {
          return null;
        }
      }

      return editable;
    }
  }], [{
    key: "_createAt",
    value: function _createAt(itemOrPosition, offset) {
      if (itemOrPosition instanceof Position) {
        return new this(itemOrPosition.parent, itemOrPosition.offset);
      } else {
        var node = itemOrPosition;

        if (offset == 'end') {
          offset = node.is('text') ? node.data.length : node.childCount;
        } else if (offset == 'before') {
          return this._createBefore(node);
        } else if (offset == 'after') {
          return this._createAfter(node);
        } else if (offset !== 0 && !offset) {
          /**
           * {@link module:engine/view/view~View#createPositionAt `View#createPositionAt()`}
           * requires the offset to be specified when the first parameter is a view item.
           *
           * @error view-createPositionAt-offset-required
           */
          throw new ckeditorerror["b" /* default */]('view-createPositionAt-offset-required: ' + 'View#createPositionAt() requires the offset when the first parameter is a view item.', node);
        }

        return new Position(node, offset);
      }
    }
    /**
     * Creates a new position after given view item.
     *
     * @protected
     * @param {module:engine/view/item~Item} item View item after which the position should be located.
     * @returns {module:engine/view/position~Position}
     */

  }, {
    key: "_createAfter",
    value: function _createAfter(item) {
      // TextProxy is not a instance of Node so we need do handle it in specific way.
      if (item.is('textProxy')) {
        return new Position(item.textNode, item.offsetInText + item.data.length);
      }

      if (!item.parent) {
        /**
         * You can not make a position after a root.
         *
         * @error view-position-after-root
         * @param {module:engine/view/node~Node} root
         */
        throw new ckeditorerror["b" /* default */]('view-position-after-root: You can not make position after root.', item, {
          root: item
        });
      }

      return new Position(item.parent, item.index + 1);
    }
    /**
     * Creates a new position before given view item.
     *
     * @protected
     * @param {module:engine/view/item~Item} item View item before which the position should be located.
     * @returns {module:engine/view/position~Position}
     */

  }, {
    key: "_createBefore",
    value: function _createBefore(item) {
      // TextProxy is not a instance of Node so we need do handle it in specific way.
      if (item.is('textProxy')) {
        return new Position(item.textNode, item.offsetInText);
      }

      if (!item.parent) {
        /**
         * You cannot make a position before a root.
         *
         * @error view-position-before-root
         * @param {module:engine/view/node~Node} root
         */
        throw new ckeditorerror["b" /* default */]('view-position-before-root: You can not make position before root.', item, {
          root: item
        });
      }

      return new Position(item.parent, item.index);
    }
  }]);

  return Position;
}();
/**
 * A flag indicating whether this position is `'before'` or `'after'` or `'same'` as given position.
 * If positions are in different roots `'different'` flag is returned.
 *
 * @typedef {String} module:engine/view/position~PositionRelation
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/range.js












/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/range
 */


/**
 * Range in the view tree. A range is represented by its start and end {@link module:engine/view/position~Position positions}.
 *
 * In order to create a new position instance use the `createPosition*()` factory methods available in:
 *
 * * {@link module:engine/view/view~View}
 * * {@link module:engine/view/downcastwriter~DowncastWriter}
 * * {@link module:engine/view/upcastwriter~UpcastWriter}
 */

var range_Range = /*#__PURE__*/function () {
  /**
   * Creates a range spanning from `start` position to `end` position.
   *
   * **Note:** Constructor creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
   *
   * @param {module:engine/view/position~Position} start Start position.
   * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at the `start` position.
   */
  function Range(start) {
    var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    Object(classCallCheck["a" /* default */])(this, Range);

    /**
     * Start position.
     *
     * @readonly
     * @member {module:engine/view/position~Position}
     */
    this.start = start.clone();
    /**
     * End position.
     *
     * @readonly
     * @member {module:engine/view/position~Position}
     */

    this.end = end ? end.clone() : start.clone();
  }
  /**
   * Iterable interface.
   *
   * Iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns
   * them together with additional information like length or {@link module:engine/view/position~Position positions},
   * grouped as {@link module:engine/view/treewalker~TreeWalkerValue}.
   *
   * This iterator uses {@link module:engine/view/treewalker~TreeWalker TreeWalker} with `boundaries` set to this range and
   * `ignoreElementEnd` option
   * set to `true`.
   *
   * @returns {Iterable.<module:engine/view/treewalker~TreeWalkerValue>}
   */


  Object(createClass["a" /* default */])(Range, [{
    key: Symbol.iterator,
    value: /*#__PURE__*/regeneratorRuntime.mark(function value() {
      return regeneratorRuntime.wrap(function value$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.delegateYield(new treewalker_TreeWalker({
                boundaries: this,
                ignoreElementEnd: true
              }), "t0", 1);

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, value, this);
    })
    /**
     * Returns whether the range is collapsed, that is it start and end positions are equal.
     *
     * @type {Boolean}
     */

  }, {
    key: "getEnlarged",

    /**
     * Creates a maximal range that has the same content as this range but is expanded in both ways (at the beginning
     * and at the end).
     *
     * For example:
     *
     *		<p>Foo</p><p><b>{Bar}</b></p> -> <p>Foo</p>[<p><b>Bar</b>]</p>
     *		<p><b>foo</b>{bar}<span></span></p> -> <p><b>foo[</b>bar<span></span>]</p>
     *
     * Note that in the sample above:
     *
     * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},
     * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},
     * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.
     *
     * @returns {module:engine/view/range~Range} Enlarged range.
     */
    value: function getEnlarged() {
      var start = this.start.getLastMatchingPosition(enlargeTrimSkip, {
        direction: 'backward'
      });
      var end = this.end.getLastMatchingPosition(enlargeTrimSkip); // Fix positions, in case if they are in Text node.

      if (start.parent.is('text') && start.isAtStart) {
        start = position_Position._createBefore(start.parent);
      }

      if (end.parent.is('text') && end.isAtEnd) {
        end = position_Position._createAfter(end.parent);
      }

      return new Range(start, end);
    }
    /**
     * Creates a minimum range that has the same content as this range but is trimmed in both ways (at the beginning
     * and at the end).
     *
     * For example:
     *
     *		<p>Foo</p>[<p><b>Bar</b>]</p> -> <p>Foo</p><p><b>{Bar}</b></p>
     *		<p><b>foo[</b>bar<span></span>]</p> -> <p><b>foo</b>{bar}<span></span></p>
     *
     * Note that in the sample above:
     *
     * - `<p>` have type of {@link module:engine/view/containerelement~ContainerElement},
     * - `<b>` have type of {@link module:engine/view/attributeelement~AttributeElement},
     * - `<span>` have type of {@link module:engine/view/uielement~UIElement}.
     *
     * @returns {module:engine/view/range~Range} Shrink range.
     */

  }, {
    key: "getTrimmed",
    value: function getTrimmed() {
      var start = this.start.getLastMatchingPosition(enlargeTrimSkip);

      if (start.isAfter(this.end) || start.isEqual(this.end)) {
        return new Range(start, start);
      }

      var end = this.end.getLastMatchingPosition(enlargeTrimSkip, {
        direction: 'backward'
      });
      var nodeAfterStart = start.nodeAfter;
      var nodeBeforeEnd = end.nodeBefore; // Because TreeWalker prefers positions next to text node, we need to move them manually into these text nodes.

      if (nodeAfterStart && nodeAfterStart.is('text')) {
        start = new position_Position(nodeAfterStart, 0);
      }

      if (nodeBeforeEnd && nodeBeforeEnd.is('text')) {
        end = new position_Position(nodeBeforeEnd, nodeBeforeEnd.data.length);
      }

      return new Range(start, end);
    }
    /**
     * Two ranges are equal if their start and end positions are equal.
     *
     * @param {module:engine/view/range~Range} otherRange Range to compare with.
     * @returns {Boolean} `true` if ranges are equal, `false` otherwise
     */

  }, {
    key: "isEqual",
    value: function isEqual(otherRange) {
      return this == otherRange || this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);
    }
    /**
     * Checks whether this range contains given {@link module:engine/view/position~Position position}.
     *
     * @param {module:engine/view/position~Position} position Position to check.
     * @returns {Boolean} `true` if given {@link module:engine/view/position~Position position} is contained in this range,
     * `false` otherwise.
     */

  }, {
    key: "containsPosition",
    value: function containsPosition(position) {
      return position.isAfter(this.start) && position.isBefore(this.end);
    }
    /**
     * Checks whether this range contains given {@link module:engine/view/range~Range range}.
     *
     * @param {module:engine/view/range~Range} otherRange Range to check.
     * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
     * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
     * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
     * @returns {Boolean} `true` if given {@link module:engine/view/range~Range range} boundaries are contained by this range, `false`
     * otherwise.
     */

  }, {
    key: "containsRange",
    value: function containsRange(otherRange) {
      var loose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (otherRange.isCollapsed) {
        loose = false;
      }

      var containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);
      var containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);
      return containsStart && containsEnd;
    }
    /**
     * Computes which part(s) of this {@link module:engine/view/range~Range range} is not a part of given
     * {@link module:engine/view/range~Range range}.
     * Returned array contains zero, one or two {@link module:engine/view/range~Range ranges}.
     *
     * Examples:
     *
     *		let foo = downcastWriter.createText( 'foo' );
     *		let img = downcastWriter.createContainerElement( 'img' );
     *		let bar = downcastWriter.createText( 'bar' );
     *		let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
     *
     *		let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
     *		let otherRange = view.createRange( // "oo", img, "ba" are in range.
     *			view.createPositionAt( foo, 1 ),
     *			view.createPositionAt( bar, 2 )
     *		);
     *		let transformed = range.getDifference( otherRange );
     *		// transformed array has no ranges because `otherRange` contains `range`
     *
     *		otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
     *		transformed = range.getDifference( otherRange );
     *		// transformed array has one range: from ( p, 2 ) to ( bar, 1 )
     *
     *		otherRange = view.createRange( view.createPositionAt( p, 1 ), view.createPositionAt( p, 2 ) ); // img is in range.
     *		transformed = range.getDifference( otherRange );
     *		// transformed array has two ranges: from ( foo, 1 ) to ( p, 1 ) and from ( p, 2 ) to ( bar, 1 )
     *
     * @param {module:engine/view/range~Range} otherRange Range to differentiate against.
     * @returns {Array.<module:engine/view/range~Range>} The difference between ranges.
     */

  }, {
    key: "getDifference",
    value: function getDifference(otherRange) {
      var ranges = [];

      if (this.isIntersecting(otherRange)) {
        // Ranges intersect.
        if (this.containsPosition(otherRange.start)) {
          // Given range start is inside this range. This means that we have to
          // add shrunken range - from the start to the middle of this range.
          ranges.push(new Range(this.start, otherRange.start));
        }

        if (this.containsPosition(otherRange.end)) {
          // Given range end is inside this range. This means that we have to
          // add shrunken range - from the middle of this range to the end.
          ranges.push(new Range(otherRange.end, this.end));
        }
      } else {
        // Ranges do not intersect, return the original range.
        ranges.push(this.clone());
      }

      return ranges;
    }
    /**
     * Returns an intersection of this {@link module:engine/view/range~Range range} and given {@link module:engine/view/range~Range range}.
     * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
     *
     * Examples:
     *
     *		let foo = downcastWriter.createText( 'foo' );
     *		let img = downcastWriter.createContainerElement( 'img' );
     *		let bar = downcastWriter.createText( 'bar' );
     *		let p = downcastWriter.createContainerElement( 'p', null, [ foo, img, bar ] );
     *
     *		let range = view.createRange( view.createPositionAt( foo, 2 ), view.createPositionAt( bar, 1 ); // "o", img, "b" are in range.
     *		let otherRange = view.createRange( view.createPositionAt( foo, 1 ), view.createPositionAt( p, 2 ); // "oo", img are in range.
     *		let transformed = range.getIntersection( otherRange ); // range from ( foo, 1 ) to ( p, 2 ).
     *
     *		otherRange = view.createRange( view.createPositionAt( bar, 1 ), view.createPositionAt( bar, 3 ); "ar" is in range.
     *		transformed = range.getIntersection( otherRange ); // null - no common part.
     *
     * @param {module:engine/view/range~Range} otherRange Range to check for intersection.
     * @returns {module:engine/view/range~Range|null} A common part of given ranges or `null` if ranges have no common part.
     */

  }, {
    key: "getIntersection",
    value: function getIntersection(otherRange) {
      if (this.isIntersecting(otherRange)) {
        // Ranges intersect, so a common range will be returned.
        // At most, it will be same as this range.
        var commonRangeStart = this.start;
        var commonRangeEnd = this.end;

        if (this.containsPosition(otherRange.start)) {
          // Given range start is inside this range. This means thaNt we have to
          // shrink common range to the given range start.
          commonRangeStart = otherRange.start;
        }

        if (this.containsPosition(otherRange.end)) {
          // Given range end is inside this range. This means that we have to
          // shrink common range to the given range end.
          commonRangeEnd = otherRange.end;
        }

        return new Range(commonRangeStart, commonRangeEnd);
      } // Ranges do not intersect, so they do not have common part.


      return null;
    }
    /**
     * Creates a {@link module:engine/view/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.
     *
     * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
     * @param {module:engine/view/position~Position} [options.startPosition]
     * @param {Boolean} [options.singleCharacters=false]
     * @param {Boolean} [options.shallow=false]
     * @param {Boolean} [options.ignoreElementEnd=false]
     * @returns {module:engine/view/treewalker~TreeWalker}
     */

  }, {
    key: "getWalker",
    value: function getWalker() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      options.boundaries = this;
      return new treewalker_TreeWalker(options);
    }
    /**
     * Returns a {@link module:engine/view/node~Node} or {@link module:engine/view/documentfragment~DocumentFragment}
     * which is a common ancestor of range's both ends (in which the entire range is contained).
     *
     * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null}
     */

  }, {
    key: "getCommonAncestor",
    value: function getCommonAncestor() {
      return this.start.getCommonAncestor(this.end);
    }
    /**
     * Returns an {@link module:engine/view/element~Element Element} contained by the range.
     * The element will be returned when it is the **only** node within the range and **fully–contained**
     * at the same time.
     *
     * @returns {module:engine/view/element~Element|null}
     */

  }, {
    key: "getContainedElement",
    value: function getContainedElement() {
      if (this.isCollapsed) {
        return null;
      }

      var nodeAfterStart = this.start.nodeAfter;
      var nodeBeforeEnd = this.end.nodeBefore; // Handle the situation when the range position is at the beginning / at the end of a text node.
      // In such situation `.nodeAfter` and `.nodeBefore` are `null` but the range still might be spanning
      // over one element.
      //
      // <p>Foo{<span class="widget"></span>}bar</p> vs <p>Foo[<span class="widget"></span>]bar</p>
      //
      // These are basically the same range, only the difference is if the range position is at
      // at the end/at the beginning of a text node or just before/just after the text node.
      //

      if (this.start.parent.is('text') && this.start.isAtEnd && this.start.parent.nextSibling) {
        nodeAfterStart = this.start.parent.nextSibling;
      }

      if (this.end.parent.is('text') && this.end.isAtStart && this.end.parent.previousSibling) {
        nodeBeforeEnd = this.end.parent.previousSibling;
      }

      if (nodeAfterStart && nodeAfterStart.is('element') && nodeAfterStart === nodeBeforeEnd) {
        return nodeAfterStart;
      }

      return null;
    }
    /**
     * Clones this range.
     *
     * @returns {module:engine/view/range~Range}
     */

  }, {
    key: "clone",
    value: function clone() {
      return new Range(this.start, this.end);
    }
    /**
     * Returns an iterator that iterates over all {@link module:engine/view/item~Item view items} that are in this range and returns
     * them.
     *
     * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
     * set to `true`. However it returns only {@link module:engine/view/item~Item items},
     * not {@link module:engine/view/treewalker~TreeWalkerValue}.
     *
     * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for
     * a full list of available options.
     *
     * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
     * @returns {Iterable.<module:engine/view/item~Item>}
     */

  }, {
    key: "getItems",
    value: /*#__PURE__*/regeneratorRuntime.mark(function getItems() {
      var options,
          treeWalker,
          _iterator,
          _step,
          _value,
          _args2 = arguments;

      return regeneratorRuntime.wrap(function getItems$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
              options.boundaries = this;
              options.ignoreElementEnd = true;
              treeWalker = new treewalker_TreeWalker(options);
              _iterator = _createForOfIteratorHelper(treeWalker);
              _context2.prev = 5;

              _iterator.s();

            case 7:
              if ((_step = _iterator.n()).done) {
                _context2.next = 13;
                break;
              }

              _value = _step.value;
              _context2.next = 11;
              return _value.item;

            case 11:
              _context2.next = 7;
              break;

            case 13:
              _context2.next = 18;
              break;

            case 15:
              _context2.prev = 15;
              _context2.t0 = _context2["catch"](5);

              _iterator.e(_context2.t0);

            case 18:
              _context2.prev = 18;

              _iterator.f();

              return _context2.finish(18);

            case 21:
            case "end":
              return _context2.stop();
          }
        }
      }, getItems, this, [[5, 15, 18, 21]]);
    })
    /**
     * Returns an iterator that iterates over all {@link module:engine/view/position~Position positions} that are boundaries or
     * contained in this range.
     *
     * This method uses {@link module:engine/view/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only
     * {@link module:engine/view/position~Position positions}, not {@link module:engine/view/treewalker~TreeWalkerValue}.
     *
     * You may specify additional options for the tree walker. See {@link module:engine/view/treewalker~TreeWalker} for
     * a full list of available options.
     *
     * @param {Object} options Object with configuration options. See {@link module:engine/view/treewalker~TreeWalker}.
     * @returns {Iterable.<module:engine/view/position~Position>}
     */

  }, {
    key: "getPositions",
    value: /*#__PURE__*/regeneratorRuntime.mark(function getPositions() {
      var options,
          treeWalker,
          _iterator2,
          _step2,
          _value2,
          _args3 = arguments;

      return regeneratorRuntime.wrap(function getPositions$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};
              options.boundaries = this;
              treeWalker = new treewalker_TreeWalker(options);
              _context3.next = 5;
              return treeWalker.position;

            case 5:
              _iterator2 = _createForOfIteratorHelper(treeWalker);
              _context3.prev = 6;

              _iterator2.s();

            case 8:
              if ((_step2 = _iterator2.n()).done) {
                _context3.next = 14;
                break;
              }

              _value2 = _step2.value;
              _context3.next = 12;
              return _value2.nextPosition;

            case 12:
              _context3.next = 8;
              break;

            case 14:
              _context3.next = 19;
              break;

            case 16:
              _context3.prev = 16;
              _context3.t0 = _context3["catch"](6);

              _iterator2.e(_context3.t0);

            case 19:
              _context3.prev = 19;

              _iterator2.f();

              return _context3.finish(19);

            case 22:
            case "end":
              return _context3.stop();
          }
        }
      }, getPositions, this, [[6, 16, 19, 22]]);
    })
    /**
     * Checks whether this object is of the given type.
     *
     *		range.is( 'range' ); // -> true
     *		range.is( 'view:range' ); // -> true
     *
     *		range.is( 'model:range' ); // -> false
     *		range.is( 'element' ); // -> false
     *		range.is( 'selection' ); // -> false
     *
     * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.
     *
     * @param {String} type
     * @returns {Boolean}
     */

  }, {
    key: "is",
    value: function is(type) {
      return type === 'range' || type === 'view:range';
    }
    /**
     * Checks and returns whether this range intersects with the given range.
     *
     * @param {module:engine/view/range~Range} otherRange Range to compare with.
     * @returns {Boolean} True if ranges intersect.
     */

  }, {
    key: "isIntersecting",
    value: function isIntersecting(otherRange) {
      return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);
    }
    /**
     * Creates a range from the given parents and offsets.
     *
     * @protected
     * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} startElement Start position
     * parent element.
     * @param {Number} startOffset Start position offset.
     * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} endElement End position
     * parent element.
     * @param {Number} endOffset End position offset.
     * @returns {module:engine/view/range~Range} Created range.
     */

  }, {
    key: "isCollapsed",
    get: function get() {
      return this.start.isEqual(this.end);
    }
    /**
     * Returns whether this range is flat, that is if {@link module:engine/view/range~Range#start start} position and
     * {@link module:engine/view/range~Range#end end} position are in the same {@link module:engine/view/position~Position#parent parent}.
     *
     * @type {Boolean}
     */

  }, {
    key: "isFlat",
    get: function get() {
      return this.start.parent === this.end.parent;
    }
    /**
     * Range root element.
     *
     * @type {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment}
     */

  }, {
    key: "root",
    get: function get() {
      return this.start.root;
    }
  }], [{
    key: "_createFromParentsAndOffsets",
    value: function _createFromParentsAndOffsets(startElement, startOffset, endElement, endOffset) {
      return new this(new position_Position(startElement, startOffset), new position_Position(endElement, endOffset));
    }
    /**
     * Creates a new range, spreading from specified {@link module:engine/view/position~Position position} to a position moved by
     * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
     *
     * @protected
     * @param {module:engine/view/position~Position} position Beginning of the range.
     * @param {Number} shift How long the range should be.
     * @returns {module:engine/view/range~Range}
     */

  }, {
    key: "_createFromPositionAndShift",
    value: function _createFromPositionAndShift(position, shift) {
      var start = position;
      var end = position.getShiftedBy(shift);
      return shift > 0 ? new this(start, end) : new this(end, start);
    }
    /**
     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
     * that element and ends after the last child of that element.
     *
     * @protected
     * @param {module:engine/view/element~Element} element Element which is a parent for the range.
     * @returns {module:engine/view/range~Range}
     */

  }, {
    key: "_createIn",
    value: function _createIn(element) {
      return this._createFromParentsAndOffsets(element, 0, element, element.childCount);
    }
    /**
     * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
     *
     * @protected
     * @param {module:engine/view/item~Item} item
     * @returns {module:engine/view/range~Range}
     */

  }, {
    key: "_createOn",
    value: function _createOn(item) {
      var size = item.is('textProxy') ? item.offsetSize : 1;
      return this._createFromPositionAndShift(position_Position._createBefore(item), size);
    }
  }]);

  return Range;
}(); // Function used by getEnlarged and getTrimmed methods.




function enlargeTrimSkip(value) {
  if (value.item.is('attributeElement') || value.item.is('uiElement')) {
    return true;
  }

  return false;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/count.js


/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/count
 */

/**
 * Returns the number of items return by the iterator.
 *
 *		count( [ 1, 2, 3, 4, 5 ] ); // 5;
 *
 * @param {Iterable.<*>} iterator Any iterator.
 * @returns {Number} Number of items returned by that iterator.
 */
function count_count(iterator) {
  var count = 0;

  var _iterator = _createForOfIteratorHelper(iterator),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ = _step.value;
      // eslint-disable-line no-unused-vars
      count++;
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return count;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/selection.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/selection
 */









/**
 * Class representing an arbirtary selection in the view.
 * See also {@link module:engine/view/documentselection~DocumentSelection}.
 *
 * New selection instances can be created via the constructor or one these methods:
 *
 * * {@link module:engine/view/view~View#createSelection `View#createSelection()`},
 * * {@link module:engine/view/upcastwriter~UpcastWriter#createSelection `UpcastWriter#createSelection()`}.
 *
 * A selection can consist of {@link module:engine/view/range~Range ranges} that can be set by using
 * the {@link module:engine/view/selection~Selection#setTo `Selection#setTo()`} method.
 */

var selection_Selection = /*#__PURE__*/function () {
  /**
   * Creates new selection instance.
   *
   * **Note**: The selection constructor is available as a factory method:
   *
   * * {@link module:engine/view/view~View#createSelection `View#createSelection()`},
   * * {@link module:engine/view/upcastwriter~UpcastWriter#createSelection `UpcastWriter#createSelection()`}.
   *
   * 		// Creates empty selection without ranges.
   *		const selection = writer.createSelection();
   *
   *		// Creates selection at the given range.
   *		const range = writer.createRange( start, end );
   *		const selection = writer.createSelection( range );
   *
   *		// Creates selection at the given ranges
   * 		const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
   *		const selection = writer.createSelection( ranges );
   *
   *		// Creates selection from the other selection.
   *		const otherSelection = writer.createSelection();
   *		const selection = writer.createSelection( otherSelection );
   *
   *		// Creates selection from the document selection.
   *		const selection = writer.createSelection( editor.editing.view.document.selection );
   *
   * 		// Creates selection at the given position.
   *		const position = writer.createPositionFromPath( root, path );
   *		const selection = writer.createSelection( position );
   *
   *		// Creates collapsed selection at the position of given item and offset.
   *		const paragraph = writer.createContainerElement( 'paragraph' );
   *		const selection = writer.createSelection( paragraph, offset );
   *
   *		// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the
   *		// first child of that element and ends after the last child of that element.
   *		const selection = writer.createSelection( paragraph, 'in' );
   *
   *		// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends
   *		// just after the item.
   *		const selection = writer.createSelection( paragraph, 'on' );
   *
   * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.
   *
   *		// Creates backward selection.
   *		const selection = writer.createSelection( range, { backward: true } );
   *
   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
   * represented in other way, for example by applying proper CSS class.
   *
   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
   * (and be  properly handled by screen readers).
   *
   *		// Creates fake selection with label.
   *		const selection = writer.createSelection( range, { fake: true, label: 'foo' } );
   *
   * @param {module:engine/view/selection~Selectable} [selectable=null]
   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.
   * @param {Object} [options]
   * @param {Boolean} [options.backward] Sets this selection instance to be backward.
   * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.
   * @param {String} [options.label] Label for the fake selection.
   */
  function Selection() {
    var selectable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var placeOrOffset = arguments.length > 1 ? arguments[1] : undefined;
    var options = arguments.length > 2 ? arguments[2] : undefined;

    Object(classCallCheck["a" /* default */])(this, Selection);

    /**
     * Stores all ranges that are selected.
     *
     * @protected
     * @member {Array.<module:engine/view/range~Range>}
     */
    this._ranges = [];
    /**
     * Specifies whether the last added range was added as a backward or forward range.
     *
     * @protected
     * @member {Boolean}
     */

    this._lastRangeBackward = false;
    /**
     * Specifies whether selection instance is fake.
     *
     * @private
     * @member {Boolean}
     */

    this._isFake = false;
    /**
     * Fake selection's label.
     *
     * @private
     * @member {String}
     */

    this._fakeSelectionLabel = '';
    this.setTo(selectable, placeOrOffset, options);
  }
  /**
   * Returns true if selection instance is marked as `fake`.
   *
   * @see #setTo
   * @returns {Boolean}
   */


  Object(createClass["a" /* default */])(Selection, [{
    key: "getRanges",

    /**
     * Returns an iterable that contains copies of all ranges added to the selection.
     *
     * @returns {Iterable.<module:engine/view/range~Range>}
     */
    value: /*#__PURE__*/regeneratorRuntime.mark(function getRanges() {
      var _iterator, _step, range;

      return regeneratorRuntime.wrap(function getRanges$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _iterator = _createForOfIteratorHelper(this._ranges);
              _context.prev = 1;

              _iterator.s();

            case 3:
              if ((_step = _iterator.n()).done) {
                _context.next = 9;
                break;
              }

              range = _step.value;
              _context.next = 7;
              return range.clone();

            case 7:
              _context.next = 3;
              break;

            case 9:
              _context.next = 14;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](1);

              _iterator.e(_context.t0);

            case 14:
              _context.prev = 14;

              _iterator.f();

              return _context.finish(14);

            case 17:
            case "end":
              return _context.stop();
          }
        }
      }, getRanges, this, [[1, 11, 14, 17]]);
    })
    /**
     * Returns copy of the first range in the selection. First range is the one which
     * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start
     * position of all other ranges (not to confuse with the first range added to the selection).
     * Returns `null` if no ranges are added to selection.
     *
     * @returns {module:engine/view/range~Range|null}
     */

  }, {
    key: "getFirstRange",
    value: function getFirstRange() {
      var first = null;

      var _iterator2 = _createForOfIteratorHelper(this._ranges),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var range = _step2.value;

          if (!first || range.start.isBefore(first.start)) {
            first = range;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return first ? first.clone() : null;
    }
    /**
     * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}
     * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse
     * with the last range added to the selection). Returns `null` if no ranges are added to selection.
     *
     * @returns {module:engine/view/range~Range|null}
     */

  }, {
    key: "getLastRange",
    value: function getLastRange() {
      var last = null;

      var _iterator3 = _createForOfIteratorHelper(this._ranges),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var range = _step3.value;

          if (!last || range.end.isAfter(last.end)) {
            last = range;
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return last ? last.clone() : null;
    }
    /**
     * Returns copy of the first position in the selection. First position is the position that
     * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.
     * Returns `null` if no ranges are added to selection.
     *
     * @returns {module:engine/view/position~Position|null}
     */

  }, {
    key: "getFirstPosition",
    value: function getFirstPosition() {
      var firstRange = this.getFirstRange();
      return firstRange ? firstRange.start.clone() : null;
    }
    /**
     * Returns copy of the last position in the selection. Last position is the position that
     * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.
     * Returns `null` if no ranges are added to selection.
     *
     * @returns {module:engine/view/position~Position|null}
     */

  }, {
    key: "getLastPosition",
    value: function getLastPosition() {
      var lastRange = this.getLastRange();
      return lastRange ? lastRange.end.clone() : null;
    }
    /**
     * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
     * same number of ranges and all ranges from one selection equal to a range from other selection.
     *
     * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection
     * Selection to compare with.
     * @returns {Boolean} `true` if selections are equal, `false` otherwise.
     */

  }, {
    key: "isEqual",
    value: function isEqual(otherSelection) {
      if (this.isFake != otherSelection.isFake) {
        return false;
      }

      if (this.isFake && this.fakeSelectionLabel != otherSelection.fakeSelectionLabel) {
        return false;
      }

      if (this.rangeCount != otherSelection.rangeCount) {
        return false;
      } else if (this.rangeCount === 0) {
        return true;
      }

      if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {
        return false;
      }

      var _iterator4 = _createForOfIteratorHelper(this._ranges),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var thisRange = _step4.value;
          var found = false;

          var _iterator5 = _createForOfIteratorHelper(otherSelection._ranges),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var otherRange = _step5.value;

              if (thisRange.isEqual(otherRange)) {
                found = true;
                break;
              }
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }

          if (!found) {
            return false;
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      return true;
    }
    /**
     * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
     * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are
     * equal to any trimmed range from other selection.
     *
     * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection
     * Selection to compare with.
     * @returns {Boolean} `true` if selections are similar, `false` otherwise.
     */

  }, {
    key: "isSimilar",
    value: function isSimilar(otherSelection) {
      if (this.isBackward != otherSelection.isBackward) {
        return false;
      }

      var numOfRangesA = count_count(this.getRanges());
      var numOfRangesB = count_count(otherSelection.getRanges()); // If selections have different number of ranges, they cannot be similar.

      if (numOfRangesA != numOfRangesB) {
        return false;
      } // If both selections have no ranges, they are similar.


      if (numOfRangesA == 0) {
        return true;
      } // Check if each range in one selection has a similar range in other selection.


      var _iterator6 = _createForOfIteratorHelper(this.getRanges()),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var rangeA = _step6.value;
          rangeA = rangeA.getTrimmed();
          var found = false;

          var _iterator7 = _createForOfIteratorHelper(otherSelection.getRanges()),
              _step7;

          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var rangeB = _step7.value;
              rangeB = rangeB.getTrimmed();

              if (rangeA.start.isEqual(rangeB.start) && rangeA.end.isEqual(rangeB.end)) {
                found = true;
                break;
              }
            } // For `rangeA`, neither range in `otherSelection` was similar. So selections are not similar.

          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }

          if (!found) {
            return false;
          }
        } // There were no ranges that weren't matched. Selections are similar.

      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      return true;
    }
    /**
     * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only
     * one range in the selection, and that range contains exactly one element.
     * Returns `null` if there is no selected element.
     *
     * @returns {module:engine/view/element~Element|null}
     */

  }, {
    key: "getSelectedElement",
    value: function getSelectedElement() {
      if (this.rangeCount !== 1) {
        return null;
      }

      return this.getFirstRange().getContainedElement();
    }
    /**
     * Sets this selection's ranges and direction to the specified location based on the given
     * {@link module:engine/view/selection~Selectable selectable}.
     *
     *		// Sets selection to the given range.
     *		const range = writer.createRange( start, end );
     *		selection.setTo( range );
     *
     *		// Sets selection to given ranges.
     * 		const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
     *		selection.setTo( range );
     *
     *		// Sets selection to the other selection.
     *		const otherSelection = writer.createSelection();
     *		selection.setTo( otherSelection );
     *
     *	 	// Sets selection to contents of DocumentSelection.
     *		selection.setTo( editor.editing.view.document.selection );
     *
     * 		// Sets collapsed selection at the given position.
     *		const position = writer.createPositionAt( root, path );
     *		selection.setTo( position );
     *
     * 		// Sets collapsed selection at the position of given item and offset.
     *		selection.setTo( paragraph, offset );
     *
     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
     * that element and ends after the last child of that element.
     *
     *		selection.setTo( paragraph, 'in' );
     *
     * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.
     *
     *		selection.setTo( paragraph, 'on' );
     *
     * 		// Clears selection. Removes all ranges.
     *		selection.setTo( null );
     *
     * `Selection#setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
     *
     *		// Sets selection as backward.
     *		selection.setTo( range, { backward: true } );
     *
     * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
     * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
     * represented in other way, for example by applying proper CSS class.
     *
     * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
     * (and be  properly handled by screen readers).
     *
     *		// Creates fake selection with label.
     *		selection.setTo( range, { fake: true, label: 'foo' } );
     *
     * @fires change
     * @param {module:engine/view/selection~Selectable} selectable
     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.
     * @param {Object} [options]
     * @param {Boolean} [options.backward] Sets this selection instance to be backward.
     * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.
     * @param {String} [options.label] Label for the fake selection.
     */

  }, {
    key: "setTo",
    value: function setTo(selectable, placeOrOffset, options) {
      if (selectable === null) {
        this._setRanges([]);

        this._setFakeOptions(placeOrOffset);
      } else if (selectable instanceof Selection || selectable instanceof documentselection_DocumentSelection) {
        this._setRanges(selectable.getRanges(), selectable.isBackward);

        this._setFakeOptions({
          fake: selectable.isFake,
          label: selectable.fakeSelectionLabel
        });
      } else if (selectable instanceof range_Range) {
        this._setRanges([selectable], placeOrOffset && placeOrOffset.backward);

        this._setFakeOptions(placeOrOffset);
      } else if (selectable instanceof position_Position) {
        this._setRanges([new range_Range(selectable)]);

        this._setFakeOptions(placeOrOffset);
      } else if (selectable instanceof node_Node) {
        var backward = !!options && !!options.backward;
        var range;

        if (placeOrOffset === undefined) {
          /**
           * selection.setTo requires the second parameter when the first parameter is a node.
           *
           * @error view-selection-setTo-required-second-parameter
           */
          throw new ckeditorerror["b" /* default */]('view-selection-setTo-required-second-parameter: ' + 'selection.setTo requires the second parameter when the first parameter is a node.', this);
        } else if (placeOrOffset == 'in') {
          range = range_Range._createIn(selectable);
        } else if (placeOrOffset == 'on') {
          range = range_Range._createOn(selectable);
        } else {
          range = new range_Range(position_Position._createAt(selectable, placeOrOffset));
        }

        this._setRanges([range], backward);

        this._setFakeOptions(options);
      } else if (isIterable(selectable)) {
        // We assume that the selectable is an iterable of ranges.
        // Array.from() is used to prevent setting ranges to the old iterable
        this._setRanges(selectable, placeOrOffset && placeOrOffset.backward);

        this._setFakeOptions(placeOrOffset);
      } else {
        /**
         * Cannot set selection to given place.
         *
         * @error view-selection-setTo-not-selectable
         */
        throw new ckeditorerror["b" /* default */]('view-selection-setTo-not-selectable: Cannot set selection to given place.', this);
      }

      this.fire('change');
    }
    /**
     * Moves {@link #focus} to the specified location.
     *
     * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
     * parameters.
     *
     * @fires change
     * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition
     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when
     * first parameter is a {@link module:engine/view/item~Item view item}.
     */

  }, {
    key: "setFocus",
    value: function setFocus(itemOrPosition, offset) {
      if (this.anchor === null) {
        /**
         * Cannot set selection focus if there are no ranges in selection.
         *
         * @error view-selection-setFocus-no-ranges
         */
        throw new ckeditorerror["b" /* default */]('view-selection-setFocus-no-ranges: Cannot set selection focus if there are no ranges in selection.', this);
      }

      var newFocus = position_Position._createAt(itemOrPosition, offset);

      if (newFocus.compareWith(this.focus) == 'same') {
        return;
      }

      var anchor = this.anchor;

      this._ranges.pop();

      if (newFocus.compareWith(anchor) == 'before') {
        this._addRange(new range_Range(newFocus, anchor), true);
      } else {
        this._addRange(new range_Range(anchor, newFocus));
      }

      this.fire('change');
    }
    /**
     * Checks whether this object is of the given type.
     *
     *		selection.is( 'selection' ); // -> true
     *		selection.is( 'view:selection' ); // -> true
     *
     *		selection.is( 'model:selection' ); // -> false
     *		selection.is( 'element' ); // -> false
     *		selection.is( 'range' ); // -> false
     *
     * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.
     *
     * @param {String} type
     * @returns {Boolean}
     */

  }, {
    key: "is",
    value: function is(type) {
      return type === 'selection' || type === 'view:selection';
    }
    /**
     * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
     * is treated like the last added range and is used to set {@link #anchor anchor} and {@link #focus focus}.
     * Accepts a flag describing in which way the selection is made.
     *
     * @private
     * @param {Iterable.<module:engine/view/range~Range>} newRanges Iterable object of ranges to set.
     * @param {Boolean} [isLastBackward=false] Flag describing if last added range was selected forward - from start to end
     * (`false`) or backward - from end to start (`true`). Defaults to `false`.
     */

  }, {
    key: "_setRanges",
    value: function _setRanges(newRanges) {
      var isLastBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      // New ranges should be copied to prevent removing them by setting them to `[]` first.
      // Only applies to situations when selection is set to the same selection or same selection's ranges.
      newRanges = Array.from(newRanges);
      this._ranges = [];

      var _iterator8 = _createForOfIteratorHelper(newRanges),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var range = _step8.value;

          this._addRange(range);
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }

      this._lastRangeBackward = !!isLastBackward;
    }
    /**
     * Sets this selection instance to be marked as `fake`. A fake selection does not render as browser native selection
     * over selected elements and is hidden to the user. This way, no native selection UI artifacts are displayed to
     * the user and selection over elements can be represented in other way, for example by applying proper CSS class.
     *
     * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM (and be
     * properly handled by screen readers).
     *
     * @private
     * @param {Object} [options] Options.
     * @param {Boolean} [options.fake] If set to true selection will be marked as `fake`.
     * @param {String} [options.label=''] Fake selection label.
     */

  }, {
    key: "_setFakeOptions",
    value: function _setFakeOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      this._isFake = !!options.fake;
      this._fakeSelectionLabel = options.fake ? options.label || '' : '';
    }
    /**
     * Adds a range to the selection. Added range is copied. This means that passed range is not saved in the
     * selection instance and you can safely operate on it.
     *
     * Accepts a flag describing in which way the selection is made - passed range might be selected from
     * {@link module:engine/view/range~Range#start start} to {@link module:engine/view/range~Range#end end}
     * or from {@link module:engine/view/range~Range#end end} to {@link module:engine/view/range~Range#start start}.
     * The flag is used to set {@link #anchor anchor} and {@link #focus focus} properties.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
     * with ranges already stored in Selection instance.
     *
     * @private
     * @fires change
     * @param {module:engine/view/range~Range} range
     * @param {Boolean} [isBackward]
     */

  }, {
    key: "_addRange",
    value: function _addRange(range) {
      var isBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (!(range instanceof range_Range)) {
        /**
         * Selection range set to an object that is not an instance of {@link module:engine/view/range~Range}.
         *
         * @error view-selection-add-range-not-range
         */
        throw new ckeditorerror["b" /* default */]('view-selection-add-range-not-range: ' + 'Selection range set to an object that is not an instance of view.Range', this);
      }

      this._pushRange(range);

      this._lastRangeBackward = !!isBackward;
    }
    /**
     * Adds range to selection - creates copy of given range so it can be safely used and modified.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-selection-range-intersects` if added range intersects
     * with ranges already stored in selection instance.
     *
     * @private
     * @param {module:engine/view/range~Range} range
     */

  }, {
    key: "_pushRange",
    value: function _pushRange(range) {
      var _iterator9 = _createForOfIteratorHelper(this._ranges),
          _step9;

      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var storedRange = _step9.value;

          if (range.isIntersecting(storedRange)) {
            /**
             * Trying to add a range that intersects with another range from selection.
             *
             * @error view-selection-range-intersects
             * @param {module:engine/view/range~Range} addedRange Range that was added to the selection.
             * @param {module:engine/view/range~Range} intersectingRange Range from selection that intersects with `addedRange`.
             */
            throw new ckeditorerror["b" /* default */]('view-selection-range-intersects: Trying to add a range that intersects with another range from selection.', this, {
              addedRange: range,
              intersectingRange: storedRange
            });
          }
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }

      this._ranges.push(new range_Range(range.start, range.end));
    }
    /**
     * Fired whenever selection ranges are changed through {@link ~Selection Selection API}.
     *
     * @event change
     */

  }, {
    key: "isFake",
    get: function get() {
      return this._isFake;
    }
    /**
     * Returns fake selection label.
     *
     * @see #setTo
     * @returns {String}
     */

  }, {
    key: "fakeSelectionLabel",
    get: function get() {
      return this._fakeSelectionLabel;
    }
    /**
     * Selection anchor. Anchor may be described as a position where the selection starts. Together with
     * {@link #focus focus} they define the direction of selection, which is important
     * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
     * It may be a bit unintuitive when there are multiple ranges in selection.
     *
     * @see #focus
     * @type {module:engine/view/position~Position}
     */

  }, {
    key: "anchor",
    get: function get() {
      if (!this._ranges.length) {
        return null;
      }

      var range = this._ranges[this._ranges.length - 1];
      var anchor = this._lastRangeBackward ? range.end : range.start;
      return anchor.clone();
    }
    /**
     * Selection focus. Focus is a position where the selection ends.
     *
     * @see #anchor
     * @type {module:engine/view/position~Position}
     */

  }, {
    key: "focus",
    get: function get() {
      if (!this._ranges.length) {
        return null;
      }

      var range = this._ranges[this._ranges.length - 1];
      var focus = this._lastRangeBackward ? range.start : range.end;
      return focus.clone();
    }
    /**
     * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
     * collapsed.
     *
     * @type {Boolean}
     */

  }, {
    key: "isCollapsed",
    get: function get() {
      return this.rangeCount === 1 && this._ranges[0].isCollapsed;
    }
    /**
     * Returns number of ranges in selection.
     *
     * @type {Number}
     */

  }, {
    key: "rangeCount",
    get: function get() {
      return this._ranges.length;
    }
    /**
     * Specifies whether the {@link #focus} precedes {@link #anchor}.
     *
     * @type {Boolean}
     */

  }, {
    key: "isBackward",
    get: function get() {
      return !this.isCollapsed && this._lastRangeBackward;
    }
    /**
     * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`
     * if the selection is not inside an editable element.
     *
     * @type {module:engine/view/editableelement~EditableElement|null}
     */

  }, {
    key: "editableElement",
    get: function get() {
      if (this.anchor) {
        return this.anchor.editableElement;
      }

      return null;
    }
  }]);

  return Selection;
}();


mix(selection_Selection, emittermixin);
/**
 * An entity that is used to set selection.
 *
 * See also {@link module:engine/view/selection~Selection#setTo}
 *
 * @typedef {
 *    module:engine/view/selection~Selection|
 *    module:engine/view/documentselection~DocumentSelection|
 *    module:engine/view/position~Position|
 *    Iterable.<module:engine/view/range~Range>|
 *    module:engine/view/range~Range|
 *    module:engine/view/item~Item|
 *    null
 * } module:engine/view/selection~Selectable
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/documentselection.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/documentselection
 */



/**
 * Class representing the document selection in the view.
 *
 * Its instance is available in {@link module:engine/view/document~Document#selection `Document#selection`}.
 *
 * It is similar to {@link module:engine/view/selection~Selection} but
 * it has a read-only API and can be modified only by the writer available in
 * the {@link module:engine/view/view~View#change `View#change()`} block
 * (so via {@link module:engine/view/downcastwriter~DowncastWriter#setSelection `DowncastWriter#setSelection()`}).
 */

var documentselection_DocumentSelection = /*#__PURE__*/function () {
  /**
   * Creates new DocumentSelection instance.
   *
   * 		// Creates empty selection without ranges.
   *		const selection = new DocumentSelection();
   *
   *		// Creates selection at the given range.
   *		const range = writer.createRange( start, end );
   *		const selection = new DocumentSelection( range );
   *
   *		// Creates selection at the given ranges
   * 		const ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];
   *		const selection = new DocumentSelection( ranges );
   *
   *		// Creates selection from the other selection.
   *		const otherSelection = writer.createSelection();
   *		const selection = new DocumentSelection( otherSelection );
   *
   * 		// Creates selection at the given position.
   *		const position = writer.createPositionAt( root, offset );
   *		const selection = new DocumentSelection( position );
   *
   *		// Creates collapsed selection at the position of given item and offset.
   *		const paragraph = writer.createContainerElement( 'paragraph' );
   *		const selection = new DocumentSelection( paragraph, offset );
   *
   *		// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the
   *		// first child of that element and ends after the last child of that element.
   *		const selection = new DocumentSelection( paragraph, 'in' );
   *
   *		// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends
   *		// just after the item.
   *		const selection = new DocumentSelection( paragraph, 'on' );
   *
   * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.
   *
   *		// Creates backward selection.
   *		const selection = new DocumentSelection( range, { backward: true } );
   *
   * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
   * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
   * represented in other way, for example by applying proper CSS class.
   *
   * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
   * (and be  properly handled by screen readers).
   *
   *		// Creates fake selection with label.
   *		const selection = new DocumentSelection( range, { fake: true, label: 'foo' } );
   *
   * @param {module:engine/view/selection~Selectable} [selectable=null]
   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.
   * @param {Object} [options]
   * @param {Boolean} [options.backward] Sets this selection instance to be backward.
   * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.
   * @param {String} [options.label] Label for the fake selection.
   */
  function DocumentSelection() {
    var selectable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
    var placeOrOffset = arguments.length > 1 ? arguments[1] : undefined;
    var options = arguments.length > 2 ? arguments[2] : undefined;

    Object(classCallCheck["a" /* default */])(this, DocumentSelection);

    /**
     * Selection is used internally (`DocumentSelection` is a proxy to that selection).
     *
     * @private
     * @member {module:engine/view/selection~Selection}
     */
    this._selection = new selection_Selection(); // Delegate change event to be fired on DocumentSelection instance.

    this._selection.delegate('change').to(this); // Set selection data.


    this._selection.setTo(selectable, placeOrOffset, options);
  }
  /**
   * Returns true if selection instance is marked as `fake`.
   *
   * @see #_setTo
   * @returns {Boolean}
   */


  Object(createClass["a" /* default */])(DocumentSelection, [{
    key: "getRanges",

    /**
     * Returns an iterable that contains copies of all ranges added to the selection.
     *
     * @returns {Iterable.<module:engine/view/range~Range>}
     */
    value: /*#__PURE__*/regeneratorRuntime.mark(function getRanges() {
      return regeneratorRuntime.wrap(function getRanges$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.delegateYield(this._selection.getRanges(), "t0", 1);

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, getRanges, this);
    })
    /**
     * Returns copy of the first range in the selection. First range is the one which
     * {@link module:engine/view/range~Range#start start} position {@link module:engine/view/position~Position#isBefore is before} start
     * position of all other ranges (not to confuse with the first range added to the selection).
     * Returns `null` if no ranges are added to selection.
     *
     * @returns {module:engine/view/range~Range|null}
     */

  }, {
    key: "getFirstRange",
    value: function getFirstRange() {
      return this._selection.getFirstRange();
    }
    /**
     * Returns copy of the last range in the selection. Last range is the one which {@link module:engine/view/range~Range#end end}
     * position {@link module:engine/view/position~Position#isAfter is after} end position of all other ranges (not to confuse
     * with the last range added to the selection). Returns `null` if no ranges are added to selection.
     *
     * @returns {module:engine/view/range~Range|null}
     */

  }, {
    key: "getLastRange",
    value: function getLastRange() {
      return this._selection.getLastRange();
    }
    /**
     * Returns copy of the first position in the selection. First position is the position that
     * {@link module:engine/view/position~Position#isBefore is before} any other position in the selection ranges.
     * Returns `null` if no ranges are added to selection.
     *
     * @returns {module:engine/view/position~Position|null}
     */

  }, {
    key: "getFirstPosition",
    value: function getFirstPosition() {
      return this._selection.getFirstPosition();
    }
    /**
     * Returns copy of the last position in the selection. Last position is the position that
     * {@link module:engine/view/position~Position#isAfter is after} any other position in the selection ranges.
     * Returns `null` if no ranges are added to selection.
     *
     * @returns {module:engine/view/position~Position|null}
     */

  }, {
    key: "getLastPosition",
    value: function getLastPosition() {
      return this._selection.getLastPosition();
    }
    /**
     * Returns the selected element. {@link module:engine/view/element~Element Element} is considered as selected if there is only
     * one range in the selection, and that range contains exactly one element.
     * Returns `null` if there is no selected element.
     *
     * @returns {module:engine/view/element~Element|null}
     */

  }, {
    key: "getSelectedElement",
    value: function getSelectedElement() {
      return this._selection.getSelectedElement();
    }
    /**
     * Checks whether, this selection is equal to given selection. Selections are equal if they have same directions,
     * same number of ranges and all ranges from one selection equal to a range from other selection.
     *
     * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection
     * Selection to compare with.
     * @returns {Boolean} `true` if selections are equal, `false` otherwise.
     */

  }, {
    key: "isEqual",
    value: function isEqual(otherSelection) {
      return this._selection.isEqual(otherSelection);
    }
    /**
     * Checks whether this selection is similar to given selection. Selections are similar if they have same directions, same
     * number of ranges, and all {@link module:engine/view/range~Range#getTrimmed trimmed} ranges from one selection are
     * equal to any trimmed range from other selection.
     *
     * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} otherSelection
     * Selection to compare with.
     * @returns {Boolean} `true` if selections are similar, `false` otherwise.
     */

  }, {
    key: "isSimilar",
    value: function isSimilar(otherSelection) {
      return this._selection.isSimilar(otherSelection);
    }
    /**
     * Checks whether this object is of the given type.
     *
     *		docSelection.is( 'selection' ); // -> true
     *		docSelection.is( 'documentSelection' ); // -> true
     *		docSelection.is( 'view:selection' ); // -> true
     *		docSelection.is( 'view:documentSelection' ); // -> true
     *
     *		docSelection.is( 'model:documentSelection' ); // -> false
     *		docSelection.is( 'element' ); // -> false
     *		docSelection.is( 'node' ); // -> false
     *
     * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.
     *
     * @param {String} type
     * @returns {Boolean}
     */

  }, {
    key: "is",
    value: function is(type) {
      return type === 'selection' || type == 'documentSelection' || type == 'view:selection' || type == 'view:documentSelection';
    }
    /**
     * Sets this selection's ranges and direction to the specified location based on the given
     * {@link module:engine/view/selection~Selectable selectable}.
     *
     *		// Sets selection to the given range.
     *		const range = writer.createRange( start, end );
     *		documentSelection._setTo( range );
     *
     *		// Sets selection to given ranges.
     * 		const ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];
     *		documentSelection._setTo( range );
     *
     *		// Sets selection to the other selection.
     *		const otherSelection = writer.createSelection();
     *		documentSelection._setTo( otherSelection );
     *
     * 		// Sets collapsed selection at the given position.
     *		const position = writer.createPositionAt( root, offset );
     *		documentSelection._setTo( position );
     *
     * 		// Sets collapsed selection at the position of given item and offset.
     *		documentSelection._setTo( paragraph, offset );
     *
     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
     * that element and ends after the last child of that element.
     *
     *		documentSelection._setTo( paragraph, 'in' );
     *
     * Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.
     *
     *		documentSelection._setTo( paragraph, 'on' );
     *
     * 		// Clears selection. Removes all ranges.
     *		documentSelection._setTo( null );
     *
     * `Selection#_setTo()` method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
     *
     *		// Sets selection as backward.
     *		documentSelection._setTo( range, { backward: true } );
     *
     * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
     * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
     * represented in other way, for example by applying proper CSS class.
     *
     * Additionally fake's selection label can be provided. It will be used to des cribe fake selection in DOM
     * (and be  properly handled by screen readers).
     *
     *		// Creates fake selection with label.
     *		documentSelection._setTo( range, { fake: true, label: 'foo' } );
     *
     * @protected
     * @fires change
     * @param {module:engine/view/selection~Selectable} selectable
     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.
     * @param {Object} [options]
     * @param {Boolean} [options.backward] Sets this selection instance to be backward.
     * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.
     * @param {String} [options.label] Label for the fake selection.
     */

  }, {
    key: "_setTo",
    value: function _setTo(selectable, placeOrOffset, options) {
      this._selection.setTo(selectable, placeOrOffset, options);
    }
    /**
     * Moves {@link #focus} to the specified location.
     *
     * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
     * parameters.
     *
     * @protected
     * @fires change
     * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition
     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when
     * first parameter is a {@link module:engine/view/item~Item view item}.
     */

  }, {
    key: "_setFocus",
    value: function _setFocus(itemOrPosition, offset) {
      this._selection.setFocus(itemOrPosition, offset);
    }
    /**
     * Fired whenever selection ranges are changed through {@link ~DocumentSelection Selection API}.
     *
     * @event change
     */

  }, {
    key: "isFake",
    get: function get() {
      return this._selection.isFake;
    }
    /**
     * Returns fake selection label.
     *
     * @see #_setTo
     * @returns {String}
     */

  }, {
    key: "fakeSelectionLabel",
    get: function get() {
      return this._selection.fakeSelectionLabel;
    }
    /**
     * Selection anchor. Anchor may be described as a position where the selection starts. Together with
     * {@link #focus focus} they define the direction of selection, which is important
     * when expanding/shrinking selection. Anchor is always the start or end of the most recent added range.
     * It may be a bit unintuitive when there are multiple ranges in selection.
     *
     * @see #focus
     * @type {module:engine/view/position~Position}
     */

  }, {
    key: "anchor",
    get: function get() {
      return this._selection.anchor;
    }
    /**
     * Selection focus. Focus is a position where the selection ends.
     *
     * @see #anchor
     * @type {module:engine/view/position~Position}
     */

  }, {
    key: "focus",
    get: function get() {
      return this._selection.focus;
    }
    /**
     * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
     * collapsed.
     *
     * @type {Boolean}
     */

  }, {
    key: "isCollapsed",
    get: function get() {
      return this._selection.isCollapsed;
    }
    /**
     * Returns number of ranges in selection.
     *
     * @type {Number}
     */

  }, {
    key: "rangeCount",
    get: function get() {
      return this._selection.rangeCount;
    }
    /**
     * Specifies whether the {@link #focus} precedes {@link #anchor}.
     *
     * @type {Boolean}
     */

  }, {
    key: "isBackward",
    get: function get() {
      return this._selection.isBackward;
    }
    /**
     * {@link module:engine/view/editableelement~EditableElement EditableElement} instance that contains this selection, or `null`
     * if the selection is not inside an editable element.
     *
     * @type {module:engine/view/editableelement~EditableElement|null}
     */

  }, {
    key: "editableElement",
    get: function get() {
      return this._selection.editableElement;
    }
    /**
     * Used for the compatibility with the {@link module:engine/view/selection~Selection#isEqual} method.
     *
     * @protected
     */

  }, {
    key: "_ranges",
    get: function get() {
      return this._selection._ranges;
    }
  }]);

  return DocumentSelection;
}();


mix(documentselection_DocumentSelection, emittermixin);
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/document.js










/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/document
 */



 // @if CK_DEBUG_ENGINE // const { logDocument } = require( '../dev-utils/utils' );

/**
 * Document class creates an abstract layer over the content editable area, contains a tree of view elements and
 * {@link module:engine/view/documentselection~DocumentSelection view selection} associated with this document.
 *
 * @mixes module:utils/observablemixin~ObservableMixin
 */

var document_Document = /*#__PURE__*/function () {
  /**
   * Creates a Document instance.
   *
   * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.
   */
  function Document(stylesProcessor) {
    Object(classCallCheck["a" /* default */])(this, Document);

    /**
     * Selection done on this document.
     *
     * @readonly
     * @member {module:engine/view/documentselection~DocumentSelection} module:engine/view/document~Document#selection
     */
    this.selection = new documentselection_DocumentSelection();
    /**
     * Roots of the view tree. Collection of the {@link module:engine/view/element~Element view elements}.
     *
     * View roots are created as a result of binding between {@link module:engine/view/document~Document#roots} and
     * {@link module:engine/model/document~Document#roots} and this is handled by
     * {@link module:engine/controller/editingcontroller~EditingController}, so to create view root we need to create
     * model root using {@link module:engine/model/document~Document#createRoot}.
     *
     * @readonly
     * @member {module:utils/collection~Collection} module:engine/view/document~Document#roots
     */

    this.roots = new collection_Collection({
      idProperty: 'rootName'
    });
    /**
     * The styles processor instance used by this document when normalizing styles.
     *
     * @readonly
     * @member {module:engine/view/stylesmap~StylesProcessor}
     */

    this.stylesProcessor = stylesProcessor;
    /**
     * Defines whether document is in read-only mode.
     *
     * When document is read-ony then all roots are read-only as well and caret placed inside this root is hidden.
     *
     * @observable
     * @member {Boolean} #isReadOnly
     */

    this.set('isReadOnly', false);
    /**
     * True if document is focused.
     *
     * This property is updated by the {@link module:engine/view/observer/focusobserver~FocusObserver}.
     * If the {@link module:engine/view/observer/focusobserver~FocusObserver} is disabled this property will not change.
     *
     * @readonly
     * @observable
     * @member {Boolean} module:engine/view/document~Document#isFocused
     */

    this.set('isFocused', false);
    /**
     * True if composition is in progress inside the document.
     *
     * This property is updated by the {@link module:engine/view/observer/compositionobserver~CompositionObserver}.
     * If the {@link module:engine/view/observer/compositionobserver~CompositionObserver} is disabled this property will not change.
     *
     * @readonly
     * @observable
     * @member {Boolean} module:engine/view/document~Document#isComposing
     */

    this.set('isComposing', false);
    /**
     * Post-fixer callbacks registered to the view document.
     *
     * @private
     * @member {Set}
     */

    this._postFixers = new Set();
  }
  /**
   * Gets a {@link module:engine/view/document~Document#roots view root element} with the specified name. If the name is not
   * specific "main" root is returned.
   *
   * @param {String} [name='main'] Name of the root.
   * @returns {module:engine/view/rooteditableelement~RootEditableElement|null} The view root element with the specified name
   * or null when there is no root of given name.
   */


  Object(createClass["a" /* default */])(Document, [{
    key: "getRoot",
    value: function getRoot() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';
      return this.roots.get(name);
    }
    /**
     * Allows registering post-fixer callbacks. A post-fixers mechanism allows to update the view tree just before it is rendered
     * to the DOM.
     *
     * Post-fixers are executed right after all changes from the outermost change block were applied but
     * before the {@link module:engine/view/view~View#event:render render event} is fired. If a post-fixer callback made
     * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should
     * not be fixed in the new document tree state.
     *
     * View post-fixers are useful when you want to apply some fixes whenever the view structure changes. Keep in mind that
     * changes executed in a view post-fixer should not break model-view mapping.
     *
     * The types of changes which should be safe:
     *
     * * adding or removing attribute from elements,
     * * changes inside of {@link module:engine/view/uielement~UIElement UI elements},
     * * {@link module:engine/model/differ~Differ#refreshItem marking some of the model elements to be re-converted}.
     *
     * Try to avoid changes which touch view structure:
     *
     * * you should not add or remove nor wrap or unwrap any view elements,
     * * you should not change the editor data model in a view post-fixer.
     *
     * As a parameter, a post-fixer callback receives a {@link module:engine/view/downcastwriter~DowncastWriter downcast writer}.
     *
     * Typically, a post-fixer will look like this:
     *
     *		editor.editing.view.document.registerPostFixer( writer => {
     *			if ( checkSomeCondition() ) {
     *				writer.doSomething();
     *
     *				// Let other post-fixers know that something changed.
     *				return true;
     *			}
     *		} );
     *
     * Note that nothing happens right after you register a post-fixer (e.g. execute such a code in the console).
     * That is because adding a post-fixer does not execute it.
     * The post-fixer will be executed as soon as any change in the document needs to cause its rendering.
     * If you want to re-render the editor's view after registering the post-fixer then you should do it manually by calling
     * {@link module:engine/view/view~View#forceRender `view.forceRender()`}.
     *
     * If you need to register a callback which is executed when DOM elements are already updated,
     * use {@link module:engine/view/view~View#event:render render event}.
     *
     * @param {Function} postFixer
     */

  }, {
    key: "registerPostFixer",
    value: function registerPostFixer(postFixer) {
      this._postFixers.add(postFixer);
    }
    /**
     * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.roots.map(function (root) {
        return root.destroy();
      });
      this.stopListening();
    }
    /**
     * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.
     *
     * @protected
     * @param {module:engine/view/downcastwriter~DowncastWriter} writer
     */

  }, {
    key: "_callPostFixers",
    value: function _callPostFixers(writer) {
      var wasFixed = false;

      do {
        var _iterator = _createForOfIteratorHelper(this._postFixers),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var callback = _step.value;
            wasFixed = callback(writer);

            if (wasFixed) {
              break;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      } while (wasFixed);
    }
    /**
     * Event fired whenever document content layout changes. It is fired whenever content is
     * {@link module:engine/view/view~View#event:render rendered}, but should be also fired by observers in case of
     * other actions which may change layout, for instance when image loads.
     *
     * @event layoutChanged
     */
    // @if CK_DEBUG_ENGINE // log( version ) {
    // @if CK_DEBUG_ENGINE //	logDocument( this, version );
    // @if CK_DEBUG_ENGINE // }

  }]);

  return Document;
}();


mix(document_Document, observablemixin);
/**
 * Enum representing type of the change.
 *
 * Possible values:
 *
 * * `children` - for child list changes,
 * * `attributes` - for element attributes changes,
 * * `text` - for text nodes changes.
 *
 * @typedef {String} module:engine/view/document~ChangeType
 */
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.some.js
var es_array_some = __webpack_require__("45fc");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/attributeelement.js















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/attributeelement
 */

 // Default attribute priority.

var DEFAULT_PRIORITY = 10;
/**
 * Attribute elements are used to represent formatting elements in the view (think – `<b>`, `<span style="font-size: 2em">`, etc.).
 * Most often they are created when downcasting model text attributes.
 *
 * Editing engine does not define a fixed HTML DTD. This is why a feature developer needs to choose between various
 * types (container element, {@link module:engine/view/attributeelement~AttributeElement attribute element},
 * {@link module:engine/view/emptyelement~EmptyElement empty element}, etc) when developing a feature.
 *
 * To create a new attribute element instance use the
 * {@link module:engine/view/downcastwriter~DowncastWriter#createAttributeElement `DowncastWriter#createAttributeElement()`} method.
 *
 * @extends module:engine/view/element~Element
 */

var attributeelement_AttributeElement = /*#__PURE__*/function (_Element) {
  Object(inherits["a" /* default */])(AttributeElement, _Element);

  var _super = Object(createSuper["a" /* default */])(AttributeElement);

  /**
   * Creates an attribute element.
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createAttributeElement
   * @see module:engine/view/element~Element
   * @protected
   * @param {module:engine/view/document~Document} document The document instance to which this element belongs.
   * @param {String} name Node name.
   * @param {Object|Iterable} [attrs] Collection of attributes.
   * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]
   * A list of nodes to be inserted into created element.
   */
  function AttributeElement(document, name, attrs, children) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, AttributeElement);

    _this = _super.call(this, document, name, attrs, children);
    /**
     * Returns block {@link module:engine/view/filler filler} offset or `null` if block filler is not needed.
     *
     * @method #getFillerOffset
     * @returns {Number|null} Block filler offset or `null` if block filler is not needed.
     */

    _this.getFillerOffset = attributeelement_getFillerOffset;
    /**
     * Element priority. Decides in what order elements are wrapped by {@link module:engine/view/downcastwriter~DowncastWriter}.
     *
     * @protected
     * @member {Number}
     */

    _this._priority = DEFAULT_PRIORITY;
    /**
     * Element identifier. If set, it is used by {@link module:engine/view/element~Element#isSimilar},
     * and then two elements are considered similar if, and only if they have the same `_id`.
     *
     * @protected
     * @member {String|Number}
     */

    _this._id = null;
    /**
     * Keeps all the attribute elements that have the same {@link module:engine/view/attributeelement~AttributeElement#id ids}
     * and still exist in the view tree.
     *
     * This property is managed by {@link module:engine/view/downcastwriter~DowncastWriter}.
     *
     * @protected
     * @member {Set.<module:engine/view/attributeelement~AttributeElement>|null}
     */

    _this._clonesGroup = null;
    return _this;
  }
  /**
   * Element priority. Decides in what order elements are wrapped by {@link module:engine/view/downcastwriter~DowncastWriter}.
   *
   * @readonly
   * @type {Number}
   */


  Object(createClass["a" /* default */])(AttributeElement, [{
    key: "getElementsWithSameId",

    /**
     * Returns all {@link module:engine/view/attributeelement~AttributeElement attribute elements} that has the
     * same {@link module:engine/view/attributeelement~AttributeElement#id id} and are in the view tree (were not removed).
     *
     * Note: If this element has been removed from the tree, returned set will not include it.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError attribute-element-get-elements-with-same-id-no-id}
     * if this element has no `id`.
     *
     * @returns {Set.<module:engine/view/attributeelement~AttributeElement>} Set containing all the attribute elements
     * with the same `id` that were added and not removed from the view tree.
     */
    value: function getElementsWithSameId() {
      if (this.id === null) {
        /**
         * Cannot get elements with the same id for an attribute element without id.
         *
         * @error attribute-element-get-elements-with-same-id-no-id
         */
        throw new ckeditorerror["b" /* default */]('attribute-element-get-elements-with-same-id-no-id: ' + 'Cannot get elements with the same id for an attribute element without id.', this);
      }

      return new Set(this._clonesGroup);
    }
    /**
     * Checks whether this object is of the given.
     *
     *		attributeElement.is( 'attributeElement' ); // -> true
     *		attributeElement.is( 'element' ); // -> true
     *		attributeElement.is( 'node' ); // -> true
     *		attributeElement.is( 'view:attributeElement' ); // -> true
     *		attributeElement.is( 'view:element' ); // -> true
     *		attributeElement.is( 'view:node' ); // -> true
     *
     *		attributeElement.is( 'model:element' ); // -> false
     *		attributeElement.is( 'documentFragment' ); // -> false
     *
     * Assuming that the object being checked is an attribute element, you can also check its
     * {@link module:engine/view/attributeelement~AttributeElement#name name}:
     *
     *		attributeElement.is( 'b' ); // -> true if this is a bold element
     *		attributeElement.is( 'attributeElement', 'b' ); // -> same as above
     *		text.is( 'b' ); -> false
     *
     * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.
     *
     * @param {String} type Type to check when `name` parameter is present.
     * Otherwise, it acts like the `name` parameter.
     * @param {String} [name] Element name.
     * @returns {Boolean}
     */

  }, {
    key: "is",
    value: function is(type) {
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (!name) {
        return type === 'attributeElement' || type === 'view:attributeElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === this.name || type === 'view:' + this.name || type === 'element' || type === 'view:element' || type === 'node' || type === 'view:node';
      } else {
        return name === this.name && (type === 'attributeElement' || type === 'view:attributeElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'element' || type === 'view:element');
      }
    }
    /**
     * Checks if this element is similar to other element.
     *
     * If none of elements has set {@link module:engine/view/attributeelement~AttributeElement#id}, then both elements
     * should have the same name, attributes and priority to be considered as similar. Two similar elements can contain
     * different set of children nodes.
     *
     * If at least one element has {@link module:engine/view/attributeelement~AttributeElement#id} set, then both
     * elements have to have the same {@link module:engine/view/attributeelement~AttributeElement#id} value to be
     * considered similar.
     *
     * Similarity is important for {@link module:engine/view/downcastwriter~DowncastWriter}. For example:
     *
     * * two following similar elements can be merged together into one, longer element,
     * * {@link module:engine/view/downcastwriter~DowncastWriter#unwrap} checks similarity of passed element and processed element to
     * decide whether processed element should be unwrapped,
     * * etc.
     *
     * @param {module:engine/view/element~Element} otherElement
     * @returns {Boolean}
     */

  }, {
    key: "isSimilar",
    value: function isSimilar(otherElement) {
      // If any element has an `id` set, just compare the ids.
      if (this.id !== null || otherElement.id !== null) {
        return this.id === otherElement.id;
      }

      return get_get(Object(getPrototypeOf["a" /* default */])(AttributeElement.prototype), "isSimilar", this).call(this, otherElement) && this.priority == otherElement.priority;
    }
    /**
     * Clones provided element with priority.
     *
     * @protected
     * @param {Boolean} deep If set to `true` clones element and all its children recursively. When set to `false`,
     * element will be cloned without any children.
     * @returns {module:engine/view/attributeelement~AttributeElement} Clone of this element.
     */

  }, {
    key: "_clone",
    value: function _clone(deep) {
      var cloned = get_get(Object(getPrototypeOf["a" /* default */])(AttributeElement.prototype), "_clone", this).call(this, deep); // Clone priority too.


      cloned._priority = this._priority; // And id too.

      cloned._id = this._id;
      return cloned;
    }
  }, {
    key: "priority",
    get: function get() {
      return this._priority;
    }
    /**
     * Element identifier. If set, it is used by {@link module:engine/view/element~Element#isSimilar},
     * and then two elements are considered similar if, and only if they have the same `id`.
     *
     * @readonly
     * @type {String|Number}
     */

  }, {
    key: "id",
    get: function get() {
      return this._id;
    }
  }]);

  return AttributeElement;
}(element_Element);
/**
 * Default attribute priority.
 *
 * @member {Number} module:engine/view/attributeelement~AttributeElement.DEFAULT_PRIORITY
 */



attributeelement_AttributeElement.DEFAULT_PRIORITY = DEFAULT_PRIORITY; // Returns block {@link module:engine/view/filler~Filler filler} offset or `null` if block filler is not needed.
//
// @returns {Number|null} Block filler offset or `null` if block filler is not needed.

function attributeelement_getFillerOffset() {
  // <b>foo</b> does not need filler.
  if (nonUiChildrenCount(this)) {
    return null;
  }

  var element = this.parent; // <p><b></b></p> needs filler -> <p><b><br></b></p>

  while (element && element.is('attributeElement')) {
    if (nonUiChildrenCount(element) > 1) {
      return null;
    }

    element = element.parent;
  }

  if (!element || nonUiChildrenCount(element) > 1) {
    return null;
  } // Render block filler at the end of element (after all ui elements).


  return this.childCount;
} // Returns total count of children that are not {@link module:engine/view/uielement~UIElement UIElements}.
//
// @param {module:engine/view/element~Element} element
// @returns {Number}


function nonUiChildrenCount(element) {
  return Array.from(element.getChildren()).filter(function (element) {
    return !element.is('uiElement');
  }).length;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/emptyelement.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/emptyelement
 */



/**
 * Empty element class. It is used to represent elements that cannot contain any child nodes (for example `<img>` elements).
 *
 * To create a new empty element use the
 * {@link module:engine/view/downcastwriter~DowncastWriter#createEmptyElement `downcastWriter#createEmptyElement()`} method.
 *
 * @extends module:engine/view/element~Element
 */

var emptyelement_EmptyElement = /*#__PURE__*/function (_Element) {
  Object(inherits["a" /* default */])(EmptyElement, _Element);

  var _super = Object(createSuper["a" /* default */])(EmptyElement);

  /**
   * Creates new instance of EmptyElement.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` when third parameter is passed,
   * to inform that usage of EmptyElement is incorrect (adding child nodes to EmptyElement is forbidden).
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createEmptyElement
   * @protected
   * @param {module:engine/view/document~Document} document The document instance to which this element belongs.
   * @param {String} name Node name.
   * @param {Object|Iterable} [attrs] Collection of attributes.
   * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]
   * A list of nodes to be inserted into created element.
   */
  function EmptyElement(document, name, attrs, children) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, EmptyElement);

    _this = _super.call(this, document, name, attrs, children);
    /**
     * Returns `null` because filler is not needed for EmptyElements.
     *
     * @method #getFillerOffset
     * @returns {null} Always returns null.
     */

    _this.getFillerOffset = emptyelement_getFillerOffset;
    return _this;
  }
  /**
   * Checks whether this object is of the given.
   *
   *		emptyElement.is( 'emptyElement' ); // -> true
   *		emptyElement.is( 'element' ); // -> true
   *		emptyElement.is( 'node' ); // -> true
   *		emptyElement.is( 'view:emptyElement' ); // -> true
   *		emptyElement.is( 'view:element' ); // -> true
   *		emptyElement.is( 'view:node' ); // -> true
   *
   *		emptyElement.is( 'model:element' ); // -> false
   *		emptyElement.is( 'documentFragment' ); // -> false
   *
   * Assuming that the object being checked is an empty element, you can also check its
   * {@link module:engine/view/emptyelement~EmptyElement#name name}:
   *
   *		emptyElement.is( 'img' ); // -> true if this is a img element
   *		emptyElement.is( 'emptyElement', 'img' ); // -> same as above
   *		text.is( 'img' ); -> false
   *
   * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.
   *
   * @param {String} type Type to check when `name` parameter is present.
   * Otherwise, it acts like the `name` parameter.
   * @param {String} [name] Element name.
   * @returns {Boolean}
   */


  Object(createClass["a" /* default */])(EmptyElement, [{
    key: "is",
    value: function is(type) {
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (!name) {
        return type === 'emptyElement' || type === 'view:emptyElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === this.name || type === 'view:' + this.name || type === 'element' || type === 'view:element' || type === 'node' || type === 'view:node';
      } else {
        return name === this.name && (type === 'emptyElement' || type === 'view:emptyElement' || type === 'element' || type === 'view:element');
      }
    }
    /**
     * Overrides {@link module:engine/view/element~Element#_insertChild} method.
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-emptyelement-cannot-add` to prevent
     * adding any child nodes to EmptyElement.
     *
     * @protected
     */

  }, {
    key: "_insertChild",
    value: function _insertChild(index, nodes) {
      if (nodes && (nodes instanceof node_Node || Array.from(nodes).length > 0)) {
        /**
         * Cannot add children to {@link module:engine/view/emptyelement~EmptyElement}.
         *
         * @error view-emptyelement-cannot-add
         */
        throw new ckeditorerror["b" /* default */]('view-emptyelement-cannot-add: Cannot add child nodes to EmptyElement instance.', [this, nodes]);
      }
    }
  }]);

  return EmptyElement;
}(element_Element); // Returns `null` because block filler is not needed for EmptyElements.
//
// @returns {null}




function emptyelement_getFillerOffset() {
  return null;
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.search.js
var es_string_search = __webpack_require__("841c");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/env.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* globals navigator:false */

/**
 * @module utils/env
 */
var userAgent = navigator.userAgent.toLowerCase();
/**
 * A namespace containing environment and browser information.
 *
 * @namespace
 */

var env = {
  /**
   * Indicates that the application is running on Macintosh.
   *
   * @static
   * @type {Boolean}
   */
  isMac: isMac(userAgent),

  /**
   * Indicates that the application is running in Firefox (Gecko).
   *
   * @static
   * @type {Boolean}
   */
  isGecko: isGecko(userAgent),

  /**
   * Indicates that the application is running in Safari.
   *
   * @static
   * @type {Boolean}
   */
  isSafari: isSafari(userAgent),

  /**
   * Indicates that the application is running on Android mobile device.
   *
   * @static
   * @type {Boolean}
   */
  isAndroid: isAndroid(userAgent),

  /**
   * Environment features information.
   *
   * @memberOf module:utils/env~env
   * @namespace
   */
  features: {
    /**
     * Indicates that the environment supports ES2018 Unicode property escapes — like `\p{P}` or `\p{L}`.
     * More information about unicode properties might be found
     * [in Unicode Standard Annex #44](https://www.unicode.org/reports/tr44/#GC_Values_Table).
     *
     * @type {Boolean}
     */
    isRegExpUnicodePropertySupported: isRegExpUnicodePropertySupported()
  }
};
/* harmony default export */ var src_env = (env);
/**
 * Checks if User Agent represented by the string is running on Macintosh.
 *
 * @param {String} userAgent **Lowercase** `navigator.userAgent` string.
 * @returns {Boolean} Whether User Agent is running on Macintosh or not.
 */

function isMac(userAgent) {
  return userAgent.indexOf('macintosh') > -1;
}
/**
 * Checks if User Agent represented by the string is Firefox (Gecko).
 *
 * @param {String} userAgent **Lowercase** `navigator.userAgent` string.
 * @returns {Boolean} Whether User Agent is Firefox or not.
 */

function isGecko(userAgent) {
  return !!userAgent.match(/gecko\/\d+/);
}
/**
 * Checks if User Agent represented by the string is Safari.
 *
 * @param {String} userAgent **Lowercase** `navigator.userAgent` string.
 * @returns {Boolean} Whether User Agent is Safari or not.
 */

function isSafari(userAgent) {
  return userAgent.indexOf(' applewebkit/') > -1 && userAgent.indexOf('chrome') === -1;
}
/**
 * Checks if User Agent represented by the string is Android mobile device.
 *
 * @param {String} userAgent **Lowercase** `navigator.userAgent` string.
 * @returns {Boolean} Whether User Agent is Safari or not.
 */

function isAndroid(userAgent) {
  return userAgent.indexOf('android') > -1;
}
/**
 * Checks if the current environment supports ES2018 Unicode properties like `\p{P}` or `\p{L}`.
 * More information about unicode properties might be found
 * [in Unicode Standard Annex #44](https://www.unicode.org/reports/tr44/#GC_Values_Table).
 *
 * @returns {Boolean}
 */

function isRegExpUnicodePropertySupported() {
  var isSupported = false; // Feature detection for Unicode properties. Added in ES2018. Currently Firefox does not support it.
  // See https://github.com/ckeditor/ckeditor5-mention/issues/44#issuecomment-487002174.

  try {
    // Usage of regular expression literal cause error during build (ckeditor/ckeditor5-dev#534).
    isSupported = 'ć'.search(new RegExp('[\\p{L}]', 'u')) === 0;
  } catch (error) {// Firefox throws a SyntaxError when the group is unsupported.
  }

  return isSupported;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/keyboard.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Set of utils related to keyboard support.
 *
 * @module utils/keyboard
 */


var macGlyphsToModifiers = {
  '⌘': 'ctrl',
  '⇧': 'shift',
  '⌥': 'alt'
};
var modifiersToMacGlyphs = {
  'ctrl': '⌘',
  'shift': '⇧',
  'alt': '⌥'
};
/**
 * Object with `keyName => keyCode` pairs for a set of known keys.
 *
 * Contains:
 *
 * * `a-z`,
 * * `0-9`,
 * * `f1-f12`,
 * * `arrow(left|up|right|bottom)`,
 * * `backspace`, `delete`, `enter`, `esc`, `tab`,
 * * `ctrl`, `cmd`, `shift`, `alt`.
 */

var keyCodes = generateKnownKeyCodes();
/**
 * Converts a key name or a {@link module:utils/keyboard~KeystrokeInfo keystroke info} into a key code.
 *
 * Note: Key names are matched with {@link module:utils/keyboard~keyCodes} in a case-insensitive way.
 *
 * @param {String|module:utils/keyboard~KeystrokeInfo} Key name (see {@link module:utils/keyboard~keyCodes})
 * or a keystroke data object.
 * @returns {Number} Key or keystroke code.
 */

function getCode(key) {
  var keyCode;

  if (typeof key == 'string') {
    keyCode = keyCodes[key.toLowerCase()];

    if (!keyCode) {
      /**
       * Unknown key name. Only key names contained by the {@link module:utils/keyboard~keyCodes} can be used.
       *
       * @errror keyboard-unknown-key
       * @param {String} key
       */
      throw new ckeditorerror["b" /* default */]('keyboard-unknown-key: Unknown key name.', null, {
        key: key
      });
    }
  } else {
    keyCode = key.keyCode + (key.altKey ? keyCodes.alt : 0) + (key.ctrlKey ? keyCodes.ctrl : 0) + (key.shiftKey ? keyCodes.shift : 0);
  }

  return keyCode;
}
/**
 * Parses keystroke and returns a keystroke code that will match the code returned by
 * link {@link module:utils/keyboard.getCode} for a corresponding {@link module:utils/keyboard~KeystrokeInfo keystroke info}.
 *
 * The keystroke can be passed in two formats:
 *
 * * as a single string – e.g. `ctrl + A`,
 * * as an array of {@link module:utils/keyboard~keyCodes known key names} and key codes – e.g.:
 *   * `[ 'ctrl', 32 ]` (ctrl + space),
 *   * `[ 'ctrl', 'a' ]` (ctrl + A).
 *
 * Note: Key names are matched with {@link module:utils/keyboard~keyCodes} in a case-insensitive way.
 *
 * Note: Only keystrokes with a single non-modifier key are supported (e.g. `ctrl+A` is OK, but `ctrl+A+B` is not).
 *
 * @param {String|Array.<Number|String>} keystroke Keystroke definition.
 * @returns {Number} Keystroke code.
 */

function parseKeystroke(keystroke) {
  if (typeof keystroke == 'string') {
    keystroke = splitKeystrokeText(keystroke);
  }

  return keystroke.map(function (key) {
    return typeof key == 'string' ? getCode(key) : key;
  }).reduce(function (key, sum) {
    return sum + key;
  }, 0);
}
/**
 * It translates any keystroke string text like `"CTRL+A"` to an
 * environment–specific keystroke, i.e. `"⌘A"` on Mac OSX.
 *
 * @param {String} keystroke Keystroke text.
 * @returns {String} Keystroke text specific for the environment.
 */

function getEnvKeystrokeText(keystroke) {
  if (!src_env.isMac) {
    return keystroke;
  }

  return splitKeystrokeText(keystroke) // Replace modifiers (e.g. "ctrl") with Mac glyphs (e.g. "⌘") first.
  .map(function (key) {
    return modifiersToMacGlyphs[key.toLowerCase()] || key;
  }) // Decide whether to put "+" between keys in the keystroke or not.
  .reduce(function (value, key) {
    if (value.slice(-1) in macGlyphsToModifiers) {
      return value + key;
    } else {
      return value + '+' + key;
    }
  });
}
/**
 * Returns `true` if the provided key code represents one of the arrow keys.
 *
 * @param {Number} keyCode A key code as in {@link module:utils/keyboard~KeystrokeInfo#keyCode}.
 * @returns {Boolean}
 */

function isArrowKeyCode(keyCode) {
  return keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup || keyCode == keyCodes.arrowdown;
}
/**
 * Returns the direction in which the {@link module:engine/model/documentselection~DocumentSelection selection}
 * will move when a provided arrow key code is pressed considering the language direction of the editor content.
 *
 * For instance, in right–to–left (RTL) content languages, pressing the left arrow means moving selection right (forward)
 * in the model structure. Similarly, pressing the right arrow moves the selection left (backward).
 *
 * @param {Number} keyCode A key code as in {@link module:utils/keyboard~KeystrokeInfo#keyCode}.
 * @param {'ltr'|'rtl'} contentLanguageDirection The content language direction, corresponding to
 * {@link module:utils/locale~Locale#contentLanguageDirection}.
 * @returns {'left'|'up'|'right'|'down'} Localized arrow direction.
 */

function getLocalizedArrowKeyCodeDirection(keyCode, contentLanguageDirection) {
  var isLtrContent = contentLanguageDirection === 'ltr';

  switch (keyCode) {
    case keyCodes.arrowleft:
      return isLtrContent ? 'left' : 'right';

    case keyCodes.arrowright:
      return isLtrContent ? 'right' : 'left';

    case keyCodes.arrowup:
      return 'up';

    case keyCodes.arrowdown:
      return 'down';
  }
}
/**
 * Determines if the provided key code moves the {@link module:engine/model/documentselection~DocumentSelection selection}
 * forward or backward considering the language direction of the editor content.
 *
 * For instance, in right–to–left (RTL) languages, pressing the left arrow means moving forward
 * in the model structure. Similarly, pressing the right arrow moves the selection backward.
 *
 * @param {Number} keyCode A key code as in {@link module:utils/keyboard~KeystrokeInfo#keyCode}.
 * @param {'ltr'|'rtl'} contentLanguageDirection The content language direction, corresponding to
 * {@link module:utils/locale~Locale#contentLanguageDirection}.
 * @returns {Boolean}
 */

function isForwardArrowKeyCode(keyCode, contentLanguageDirection) {
  var localizedKeyCodeDirection = getLocalizedArrowKeyCodeDirection(keyCode, contentLanguageDirection);
  return localizedKeyCodeDirection === 'down' || localizedKeyCodeDirection === 'right';
}

function generateKnownKeyCodes() {
  var keyCodes = {
    arrowleft: 37,
    arrowup: 38,
    arrowright: 39,
    arrowdown: 40,
    backspace: 8,
    delete: 46,
    enter: 13,
    space: 32,
    esc: 27,
    tab: 9,
    // The idea about these numbers is that they do not collide with any real key codes, so we can use them
    // like bit masks.
    ctrl: 0x110000,
    // Has the same code as ctrl, because their behaviour should be unified across the editor.
    // See http://ckeditor.github.io/editor-recommendations/general-policies#ctrl-vs-cmd
    cmd: 0x110000,
    shift: 0x220000,
    alt: 0x440000
  }; // a-z

  for (var code = 65; code <= 90; code++) {
    var letter = String.fromCharCode(code);
    keyCodes[letter.toLowerCase()] = code;
  } // 0-9


  for (var _code = 48; _code <= 57; _code++) {
    keyCodes[_code - 48] = _code;
  } // F1-F12


  for (var _code2 = 112; _code2 <= 123; _code2++) {
    keyCodes['f' + (_code2 - 111)] = _code2;
  }

  return keyCodes;
}

function splitKeystrokeText(keystroke) {
  return keystroke.split(/\s*\+\s*/);
}
/**
 * Information about a keystroke.
 *
 * @interface module:utils/keyboard~KeystrokeInfo
 */

/**
 * The [key code](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/keyCode).
 *
 * @member {Number} module:utils/keyboard~KeystrokeInfo#keyCode
 */

/**
 * Whether the <kbd>Alt</kbd> modifier was pressed.
 *
 * @member {Bolean} module:utils/keyboard~KeystrokeInfo#altKey
 */

/**
 * Whether the <kbd>Ctrl</kbd> or <kbd>Cmd</kbd> modifier was pressed.
 *
 * @member {Bolean} module:utils/keyboard~KeystrokeInfo#ctrlKey
 */

/**
 * Whether the <kbd>Shift</kbd> modifier was pressed.
 *
 * @member {Bolean} module:utils/keyboard~KeystrokeInfo#shiftKey
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/uielement.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/uielement
 */




/**
 * UI element class. It should be used to represent editing UI which needs to be injected into the editing view
 * If possible, you should keep your UI outside the editing view. However, if that is not possible,
 * UI elements can be used.
 *
 * How a UI element is rendered is in your control (you pass a callback to
 * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `downcastWriter#createUIElement()`}).
 * The editor will ignore your UI element – the selection cannot be placed in it, it is skipped (invisible) when
 * the user modifies the selection by using arrow keys and the editor does not listen to any mutations which
 * happen inside your UI elements.
 *
 * The limitation is that you cannot convert a model element to a UI element. UI elements need to be
 * created for {@link module:engine/model/markercollection~Marker markers} or as additinal elements
 * inside normal {@link module:engine/view/containerelement~ContainerElement container elements}.
 *
 * To create a new UI element use the
 * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `downcastWriter#createUIElement()`} method.
 *
 * @extends module:engine/view/element~Element
 */

var uielement_UIElement = /*#__PURE__*/function (_Element) {
  Object(inherits["a" /* default */])(UIElement, _Element);

  var _super = Object(createSuper["a" /* default */])(UIElement);

  /**
   * Creates new instance of UIElement.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` when third parameter is passed,
   * to inform that usage of UIElement is incorrect (adding child nodes to UIElement is forbidden).
   *
   * @see module:engine/view/downcastwriter~DowncastWriter#createUIElement
   * @protected
   * @param {module:engine/view/document~Document} document The document instance to which this element belongs.
   * @param {String} name Node name.
   * @param {Object|Iterable} [attributes] Collection of attributes.
   * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]
   * A list of nodes to be inserted into created element.
   */
  function UIElement(document, name, attributes, children) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, UIElement);

    _this = _super.call(this, document, name, attributes, children);
    /**
     * Returns `null` because filler is not needed for UIElements.
     *
     * @method #getFillerOffset
     * @returns {null} Always returns null.
     */

    _this.getFillerOffset = uielement_getFillerOffset;
    return _this;
  }
  /**
   * Checks whether this object is of the given.
   *
   *		uiElement.is( 'uiElement' ); // -> true
   *		uiElement.is( 'element' ); // -> true
   *		uiElement.is( 'node' ); // -> true
   *		uiElement.is( 'view:uiElement' ); // -> true
   *		uiElement.is( 'view:element' ); // -> true
   *		uiElement.is( 'view:node' ); // -> true
   *
   *		uiElement.is( 'model:element' ); // -> false
   *		uiElement.is( 'documentFragment' ); // -> false
   *
   * Assuming that the object being checked is an ui element, you can also check its
   * {@link module:engine/view/uielement~UIElement#name name}:
   *
   *		uiElement.is( 'span' ); // -> true if this is a span ui element
   *		uiElement.is( 'uiElement', 'span' ); // -> same as above
   *		text.is( 'span' ); -> false
   *
   * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.
   *
   * @param {String} type Type to check when `name` parameter is present.
   * Otherwise, it acts like the `name` parameter.
   * @param {String} [name] Element name.
   * @returns {Boolean}
   */


  Object(createClass["a" /* default */])(UIElement, [{
    key: "is",
    value: function is(type) {
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (!name) {
        return type === 'uiElement' || type === 'view:uiElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === this.name || type === 'view:' + this.name || type === 'element' || type === 'view:element' || type === 'node' || type === 'view:node';
      } else {
        return name === this.name && (type === 'uiElement' || type === 'view:uiElement' || type === 'element' || type === 'view:element');
      }
    }
    /**
     * Overrides {@link module:engine/view/element~Element#_insertChild} method.
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-uielement-cannot-add` to prevent adding any child nodes
     * to UIElement.
     *
     * @protected
     */

  }, {
    key: "_insertChild",
    value: function _insertChild(index, nodes) {
      if (nodes && (nodes instanceof node_Node || Array.from(nodes).length > 0)) {
        /**
         * Cannot add children to {@link module:engine/view/uielement~UIElement}.
         *
         * @error view-uielement-cannot-add
         */
        throw new ckeditorerror["b" /* default */]('view-uielement-cannot-add: Cannot add child nodes to UIElement instance.', this);
      }
    }
    /**
     * Renders this {@link module:engine/view/uielement~UIElement} to DOM. This method is called by
     * {@link module:engine/view/domconverter~DomConverter}.
     * Do not use inheritance to create custom rendering method, replace `render()` method instead:
     *
     *		const myUIElement = downcastWriter.createUIElement( 'span' );
     *		myUIElement.render = function( domDocument ) {
     *			const domElement = this.toDomElement( domDocument );
     *			domElement.innerHTML = '<b>this is ui element</b>';
     *
     *			return domElement;
     *		};
     *
     * If changes in your UI element should trigger some editor UI update you should call
     * the {@link module:core/editor/editorui~EditorUI#update `editor.ui.update()`} method
     * after rendering your UI element.
     *
     * @param {Document} domDocument
     * @returns {HTMLElement}
     */

  }, {
    key: "render",
    value: function render(domDocument) {
      return this.toDomElement(domDocument);
    }
    /**
     * Creates DOM element based on this view UIElement.
     * Note that each time this method is called new DOM element is created.
     *
     * @param {Document} domDocument
     * @returns {HTMLElement}
     */

  }, {
    key: "toDomElement",
    value: function toDomElement(domDocument) {
      var domElement = domDocument.createElement(this.name);

      var _iterator = _createForOfIteratorHelper(this.getAttributeKeys()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var key = _step.value;
          domElement.setAttribute(key, this.getAttribute(key));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return domElement;
    }
  }]);

  return UIElement;
}(element_Element);
/**
 * This function injects UI element handling to the given {@link module:engine/view/document~Document document}.
 *
 * A callback is added to {@link module:engine/view/document~Document#event:keydown document keydown event}.
 * The callback handles the situation when right arrow key is pressed and selection is collapsed before a UI element.
 * Without this handler, it would be impossible to "jump over" UI element using right arrow key.
 *
 * @param {module:engine/view/view~View} view View controller to which the quirks handling will be injected.
 */



function injectUiElementHandling(view) {
  view.document.on('keydown', function (evt, data) {
    return jumpOverUiElement(evt, data, view.domConverter);
  });
} // Returns `null` because block filler is not needed for UIElements.
//
// @returns {null}

function uielement_getFillerOffset() {
  return null;
} // Selection cannot be placed in a `UIElement`. Whenever it is placed there, it is moved before it. This
// causes a situation when it is impossible to jump over `UIElement` using right arrow key, because the selection
// ends up in ui element (in DOM) and is moved back to the left. This handler fixes this situation.


function jumpOverUiElement(evt, data, domConverter) {
  if (data.keyCode == keyCodes.arrowright) {
    var domSelection = data.domTarget.ownerDocument.defaultView.getSelection();
    var domSelectionCollapsed = domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed; // Jump over UI element if selection is collapsed or shift key is pressed. These are the cases when selection would extend.

    if (domSelectionCollapsed || data.shiftKey) {
      var domParent = domSelection.focusNode;
      var domOffset = domSelection.focusOffset;
      var viewPosition = domConverter.domPositionToView(domParent, domOffset); // In case if dom element is not converted to view or is not mapped or something. Happens for example in some tests.

      if (viewPosition === null) {
        return;
      } // Skip all following ui elements.


      var jumpedOverAnyUiElement = false;
      var nextViewPosition = viewPosition.getLastMatchingPosition(function (value) {
        if (value.item.is('uiElement')) {
          // Remember that there was at least one ui element.
          jumpedOverAnyUiElement = true;
        } // Jump over ui elements, jump over empty attribute elements, move up from inside of attribute element.


        if (value.item.is('uiElement') || value.item.is('attributeElement')) {
          return true;
        } // Don't jump over text or don't get out of container element.


        return false;
      }); // If anything has been skipped, fix position.
      // This `if` could be possibly omitted but maybe it is better not to mess with DOM selection if not needed.

      if (jumpedOverAnyUiElement) {
        var newDomPosition = domConverter.viewPositionToDom(nextViewPosition);

        if (domSelectionCollapsed) {
          // Selection was collapsed, so collapse it at further position.
          domSelection.collapse(newDomPosition.parent, newDomPosition.offset);
        } else {
          // Selection was not collapse, so extend it instead of collapsing.
          domSelection.extend(newDomPosition.parent, newDomPosition.offset);
        }
      }
    }
  }
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/documentfragment.js















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/documentfragment
 */





/**
 * Document fragment.
 *
 * To create a new document fragment instance use the
 * {@link module:engine/view/upcastwriter~UpcastWriter#createDocumentFragment `UpcastWriter#createDocumentFragment()`}
 * method.
 */

var documentfragment_DocumentFragment = /*#__PURE__*/function () {
  /**
   * Creates new DocumentFragment instance.
   *
   * @protected
   * @param {module:engine/view/document~Document} document The document to which this document fragment belongs.
   * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]
   * A list of nodes to be inserted into the created document fragment.
   */
  function DocumentFragment(document, children) {
    Object(classCallCheck["a" /* default */])(this, DocumentFragment);

    /**
     * The document to which this document fragment belongs.
     *
     * @readonly
     * @member {module:engine/view/document~Document}
     */
    this.document = document;
    /**
     * Array of child nodes.
     *
     * @protected
     * @member {Array.<module:engine/view/element~Element>} module:engine/view/documentfragment~DocumentFragment#_children
     */

    this._children = [];

    if (children) {
      this._insertChild(0, children);
    }
  }
  /**
   * Iterable interface.
   *
   * Iterates over nodes added to this document fragment.
   *
   * @returns {Iterable.<module:engine/view/node~Node>}
   */


  Object(createClass["a" /* default */])(DocumentFragment, [{
    key: Symbol.iterator,
    value: function value() {
      return this._children[Symbol.iterator]();
    }
    /**
     * Number of child nodes in this document fragment.
     *
     * @readonly
     * @type {Number}
     */

  }, {
    key: "is",

    /**
     * Checks whether this object is of the given type.
     *
     *		docFrag.is( 'documentFragment' ); // -> true
     *		docFrag.is( 'view:documentFragment' ); // -> true
     *
     *		docFrag.is( 'model:documentFragment' ); // -> false
     *		docFrag.is( 'element' ); // -> false
     *		docFrag.is( 'node' ); // -> false
     *
     * {@link module:engine/view/node~Node#is Check the entire list of view objects} which implement the `is()` method.
     *
     * @param {String} type
     * @returns {Boolean}
     */
    value: function is(type) {
      return type === 'documentFragment' || type === 'view:documentFragment';
    }
    /**
     * {@link module:engine/view/documentfragment~DocumentFragment#_insertChild Insert} a child node or a list of child nodes at the end
     * and sets the parent of these nodes to this fragment.
     *
     * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.
     * @returns {Number} Number of appended nodes.
     */

  }, {
    key: "_appendChild",
    value: function _appendChild(items) {
      return this._insertChild(this.childCount, items);
    }
    /**
     * Gets child at the given index.
     *
     * @param {Number} index Index of child.
     * @returns {module:engine/view/node~Node} Child node.
     */

  }, {
    key: "getChild",
    value: function getChild(index) {
      return this._children[index];
    }
    /**
     * Gets index of the given child node. Returns `-1` if child node is not found.
     *
     * @param {module:engine/view/node~Node} node Child node.
     * @returns {Number} Index of the child node.
     */

  }, {
    key: "getChildIndex",
    value: function getChildIndex(node) {
      return this._children.indexOf(node);
    }
    /**
     * Gets child nodes iterator.
     *
     * @returns {Iterable.<module:engine/view/node~Node>} Child nodes iterator.
     */

  }, {
    key: "getChildren",
    value: function getChildren() {
      return this._children[Symbol.iterator]();
    }
    /**
     * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
     * this fragment.
     *
     * @param {Number} index Position where nodes should be inserted.
     * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.
     * @returns {Number} Number of inserted nodes.
     */

  }, {
    key: "_insertChild",
    value: function _insertChild(index, items) {
      this._fireChange('children', this);

      var count = 0;
      var nodes = documentfragment_normalize(this.document, items);

      var _iterator = _createForOfIteratorHelper(nodes),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var node = _step.value;

          // If node that is being added to this element is already inside another element, first remove it from the old parent.
          if (node.parent !== null) {
            node._remove();
          }

          node.parent = this;

          this._children.splice(index, 0, node);

          index++;
          count++;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return count;
    }
    /**
     * Removes number of child nodes starting at the given index and set the parent of these nodes to `null`.
     *
     * @param {Number} index Number of the first node to remove.
     * @param {Number} [howMany=1] Number of nodes to remove.
     * @returns {Array.<module:engine/view/node~Node>} The array of removed nodes.
     */

  }, {
    key: "_removeChildren",
    value: function _removeChildren(index) {
      var howMany = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      this._fireChange('children', this);

      for (var i = index; i < index + howMany; i++) {
        this._children[i].parent = null;
      }

      return this._children.splice(index, howMany);
    }
    /**
     * Fires `change` event with given type of the change.
     *
     * @private
     * @param {module:engine/view/document~ChangeType} type Type of the change.
     * @param {module:engine/view/node~Node} node Changed node.
     * @fires module:engine/view/node~Node#change
     */

  }, {
    key: "_fireChange",
    value: function _fireChange(type, node) {
      this.fire('change:' + type, node);
    } // @if CK_DEBUG_ENGINE // printTree() {
    // @if CK_DEBUG_ENGINE //	let string = 'ViewDocumentFragment: [';
    // @if CK_DEBUG_ENGINE //	for ( const child of this.getChildren() ) {
    // @if CK_DEBUG_ENGINE //		if ( child.is( 'text' ) ) {
    // @if CK_DEBUG_ENGINE //			string += '\n' + '\t'.repeat( 1 ) + child.data;
    // @if CK_DEBUG_ENGINE //		} else {
    // @if CK_DEBUG_ENGINE //			string += '\n' + child.printTree( 1 );
    // @if CK_DEBUG_ENGINE //		}
    // @if CK_DEBUG_ENGINE //	}
    // @if CK_DEBUG_ENGINE //	string += '\n]';
    // @if CK_DEBUG_ENGINE //	return string;
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // logTree() {
    // @if CK_DEBUG_ENGINE // 	console.log( this.printTree() );
    // @if CK_DEBUG_ENGINE // }

  }, {
    key: "childCount",
    get: function get() {
      return this._children.length;
    }
    /**
     * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
     *
     * @readonly
     * @type {Boolean}
     */

  }, {
    key: "isEmpty",
    get: function get() {
      return this.childCount === 0;
    }
    /**
     * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
     *
     * @readonly
     * @type {module:engine/model/documentfragment~DocumentFragment}
     */

  }, {
    key: "root",
    get: function get() {
      return this;
    }
    /**
     * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
     *
     * @readonly
     * @type {null}
     */

  }, {
    key: "parent",
    get: function get() {
      return null;
    }
  }]);

  return DocumentFragment;
}();


mix(documentfragment_DocumentFragment, emittermixin); // Converts strings to Text and non-iterables to arrays.
//
// @param {String|module:engine/view/item~Item|Iterable.<String|module:engine/view/item~Item>}
// @returns {Iterable.<module:engine/view/node~Node>}

function documentfragment_normalize(document, nodes) {
  // Separate condition because string is iterable.
  if (typeof nodes == 'string') {
    return [new text_Text(document, nodes)];
  }

  if (!isIterable(nodes)) {
    nodes = [nodes];
  } // Array.from to enable .map() on non-arrays.


  return Array.from(nodes).map(function (node) {
    if (typeof node == 'string') {
      return new text_Text(document, node);
    }

    if (node instanceof textproxy_TextProxy) {
      return new text_Text(document, node.data);
    }

    return node;
  });
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/downcastwriter.js

















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module module:engine/view/downcastwriter
 */













/**
 * View downcast writer.
 *
 * It provides a set of methods used to manipulate view nodes.
 *
 * Do not create an instance of this writer manually. To modify a view structure, use
 * the {@link module:engine/view/view~View#change `View#change()`} block.
 *
 * The `DowncastWriter` is designed to work with semantic views which are the views that were/are being downcasted from the model.
 * To work with ordinary views (e.g. parsed from a pasted content) use the
 * {@link module:engine/view/upcastwriter~UpcastWriter upcast writer}.
 *
 * Read more about changing the view in the {@glink framework/guides/architecture/editing-engine#changing-the-view Changing the view}
 * section of the {@glink framework/guides/architecture/editing-engine Editing engine architecture} guide.
 */

var downcastwriter_DowncastWriter = /*#__PURE__*/function () {
  /**
   * @param {module:engine/view/document~Document} document The view document instance.
   */
  function DowncastWriter(document) {
    Object(classCallCheck["a" /* default */])(this, DowncastWriter);

    /**
     * The view document instance in which this writer operates.
     *
     * @readonly
     * @type {module:engine/view/document~Document}
     */
    this.document = document;
    /**
     * Holds references to the attribute groups that share the same {@link module:engine/view/attributeelement~AttributeElement#id id}.
     * The keys are `id`s, the values are `Set`s holding {@link module:engine/view/attributeelement~AttributeElement}s.
     *
     * @private
     * @type {Map.<String,Set>}
     */

    this._cloneGroups = new Map();
  }
  /**
   * Sets {@link module:engine/view/documentselection~DocumentSelection selection's} ranges and direction to the
   * specified location based on the given {@link module:engine/view/selection~Selectable selectable}.
   *
   * Usage:
   *
   *		// Sets selection to the given range.
   *		const range = writer.createRange( start, end );
   *		writer.setSelection( range );
   *
   *		// Sets backward selection to the given range.
   *		const range = writer.createRange( start, end );
   *		writer.setSelection( range );
   *
   *		// Sets selection to given ranges.
   * 		const ranges = [ writer.createRange( start1, end2 ), writer.createRange( start2, end2 ) ];
   *		writer.setSelection( range );
   *
   *		// Sets selection to the other selection.
   *		const otherSelection = writer.createSelection();
   *		writer.setSelection( otherSelection );
   *
   * 		// Sets collapsed selection at the given position.
   *		const position = writer.createPositionFromPath( root, path );
   *		writer.setSelection( position );
   *
   * 		// Sets collapsed selection at the position of given item and offset.
   *		const paragraph = writer.createContainerElement( 'p' );
   *		writer.setSelection( paragraph, offset );
   *
   * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
  	 * that element and ends after the last child of that element.
   *
   * 		writer.setSelection( paragraph, 'in' );
   *
   * Creates a range on the {@link module:engine/view/item~Item item} which starts before the item and ends just after the item.
   *
   *		writer.setSelection( paragraph, 'on' );
   *
   * 		// Removes all ranges.
   *		writer.setSelection( null );
   *
   * `DowncastWriter#setSelection()` allow passing additional options (`backward`, `fake` and `label`) as the last argument.
   *
   *		// Sets selection as backward.
   *		writer.setSelection( range, { backward: true } );
   *
   *		// Sets selection as fake.
   *		// Fake selection does not render as browser native selection over selected elements and is hidden to the user.
   * 		// This way, no native selection UI artifacts are displayed to the user and selection over elements can be
   * 		// represented in other way, for example by applying proper CSS class.
   *		writer.setSelection( range, { fake: true } );
   *
   * 		// Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
   * 		// (and be  properly handled by screen readers).
   *		writer.setSelection( range, { fake: true, label: 'foo' } );
   *
   * @param {module:engine/view/selection~Selectable} selectable
   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.
   * @param {Object} [options]
   * @param {Boolean} [options.backward] Sets this selection instance to be backward.
   * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.
   * @param {String} [options.label] Label for the fake selection.
   */


  Object(createClass["a" /* default */])(DowncastWriter, [{
    key: "setSelection",
    value: function setSelection(selectable, placeOrOffset, options) {
      this.document.selection._setTo(selectable, placeOrOffset, options);
    }
    /**
     * Moves {@link module:engine/view/documentselection~DocumentSelection#focus selection's focus} to the specified location.
     *
     * The location can be specified in the same form as {@link module:engine/view/view~View#createPositionAt view.createPositionAt()}
     * parameters.
     *
     * @param {module:engine/view/item~Item|module:engine/view/position~Position} itemOrPosition
     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when
     * first parameter is a {@link module:engine/view/item~Item view item}.
     */

  }, {
    key: "setSelectionFocus",
    value: function setSelectionFocus(itemOrPosition, offset) {
      this.document.selection._setFocus(itemOrPosition, offset);
    }
    /**
     * Creates a new {@link module:engine/view/text~Text text node}.
     *
     *		writer.createText( 'foo' );
     *
     * @param {String} data The text's data.
     * @returns {module:engine/view/text~Text} The created text node.
     */

  }, {
    key: "createText",
    value: function createText(data) {
      return new text_Text(this.document, data);
    }
    /**
     * Creates new {@link module:engine/view/attributeelement~AttributeElement}.
     *
     *		writer.createAttributeElement( 'strong' );
     *		writer.createAttributeElement( 'a', { href: 'foo.bar' } );
     *
     *		// Make `<a>` element contain other attributes element so the `<a>` element is not broken.
     *		writer.createAttributeElement( 'a', { href: 'foo.bar' }, { priority: 5 } );
     *
     *		// Set `id` of a marker element so it is not joined or merged with "normal" elements.
     *		writer.createAttributeElement( 'span', { class: 'my-marker' }, { id: 'marker:my' } );
     *
     * @param {String} name Name of the element.
     * @param {Object} [attributes] Element's attributes.
     * @param {Object} [options] Element's options.
     * @param {Number} [options.priority] Element's {@link module:engine/view/attributeelement~AttributeElement#priority priority}.
     * @param {Number|String} [options.id] Element's {@link module:engine/view/attributeelement~AttributeElement#id id}.
     * @returns {module:engine/view/attributeelement~AttributeElement} Created element.
     */

  }, {
    key: "createAttributeElement",
    value: function createAttributeElement(name, attributes) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var attributeElement = new attributeelement_AttributeElement(this.document, name, attributes);

      if (options.priority) {
        attributeElement._priority = options.priority;
      }

      if (options.id) {
        attributeElement._id = options.id;
      }

      return attributeElement;
    }
    /**
     * Creates new {@link module:engine/view/containerelement~ContainerElement}.
     *
     *		writer.createContainerElement( 'p' );
     *
     *		// Create element with custom attributes.
     *		writer.createContainerElement( 'div', { id: 'foo-bar', 'data-baz': '123' } );
     *
     *		// Create element with custom styles.
     *		writer.createContainerElement( 'p', { style: 'font-weight: bold; padding-bottom: 10px' } );
     *
     *		// Create element with custom classes.
     *		writer.createContainerElement( 'p', { class: 'foo bar baz' } );
     *
     * @param {String} name Name of the element.
     * @param {Object} [attributes] Elements attributes.
     * @returns {module:engine/view/containerelement~ContainerElement} Created element.
     */

  }, {
    key: "createContainerElement",
    value: function createContainerElement(name, attributes) {
      return new containerelement_ContainerElement(this.document, name, attributes);
    }
    /**
     * Creates new {@link module:engine/view/editableelement~EditableElement}.
     *
     *		writer.createEditableElement( 'div' );
     *		writer.createEditableElement( 'div', { id: 'foo-1234' } );
     *
     * @param {String} name Name of the element.
     * @param {Object} [attributes] Elements attributes.
     * @returns {module:engine/view/editableelement~EditableElement} Created element.
     */

  }, {
    key: "createEditableElement",
    value: function createEditableElement(name, attributes) {
      var editableElement = new editableelement_EditableElement(this.document, name, attributes);
      editableElement._document = this.document;
      return editableElement;
    }
    /**
     * Creates new {@link module:engine/view/emptyelement~EmptyElement}.
     *
     *		writer.createEmptyElement( 'img' );
     *		writer.createEmptyElement( 'img', { id: 'foo-1234' } );
     *
     * @param {String} name Name of the element.
     * @param {Object} [attributes] Elements attributes.
     * @returns {module:engine/view/emptyelement~EmptyElement} Created element.
     */

  }, {
    key: "createEmptyElement",
    value: function createEmptyElement(name, attributes) {
      return new emptyelement_EmptyElement(this.document, name, attributes);
    }
    /**
     * Creates new {@link module:engine/view/uielement~UIElement}.
     *
     *		writer.createUIElement( 'span' );
     *		writer.createUIElement( 'span', { id: 'foo-1234' } );
     *
     * Custom render function can be provided as third parameter:
     *
     *		writer.createUIElement( 'span', null, function( domDocument ) {
     *			const domElement = this.toDomElement( domDocument );
     *			domElement.innerHTML = '<b>this is ui element</b>';
     *
     *			return domElement;
     *		} );
     *
     * @param {String} name Name of the element.
     * @param {Object} [attributes] Elements attributes.
     * @param {Function} [renderFunction] Custom render function.
     * @returns {module:engine/view/uielement~UIElement} Created element.
     */

  }, {
    key: "createUIElement",
    value: function createUIElement(name, attributes, renderFunction) {
      var uiElement = new uielement_UIElement(this.document, name, attributes);

      if (renderFunction) {
        uiElement.render = renderFunction;
      }

      return uiElement;
    }
    /**
     * Adds or overwrite element's attribute with a specified key and value.
     *
     *		writer.setAttribute( 'href', 'http://ckeditor.com', linkElement );
     *
     * @param {String} key Attribute key.
     * @param {String} value Attribute value.
     * @param {module:engine/view/element~Element} element
     */

  }, {
    key: "setAttribute",
    value: function setAttribute(key, value, element) {
      element._setAttribute(key, value);
    }
    /**
     * Removes attribute from the element.
     *
     *		writer.removeAttribute( 'href', linkElement );
     *
     * @param {String} key Attribute key.
     * @param {module:engine/view/element~Element} element
     */

  }, {
    key: "removeAttribute",
    value: function removeAttribute(key, element) {
      element._removeAttribute(key);
    }
    /**
     * Adds specified class to the element.
     *
     *		writer.addClass( 'foo', linkElement );
     *		writer.addClass( [ 'foo', 'bar' ], linkElement );
     *
     * @param {Array.<String>|String} className
     * @param {module:engine/view/element~Element} element
     */

  }, {
    key: "addClass",
    value: function addClass(className, element) {
      element._addClass(className);
    }
    /**
     * Removes specified class from the element.
     *
     *		writer.removeClass( 'foo', linkElement );
     *		writer.removeClass( [ 'foo', 'bar' ], linkElement );
     *
     * @param {Array.<String>|String} className
     * @param {module:engine/view/element~Element} element
     */

  }, {
    key: "removeClass",
    value: function removeClass(className, element) {
      element._removeClass(className);
    }
    /**
     * Adds style to the element.
     *
     *		writer.setStyle( 'color', 'red', element );
     *		writer.setStyle( {
     *			color: 'red',
     *			position: 'fixed'
     *		}, element );
     *
     * **Note**: The passed style can be normalized if
     * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
     * See {@link module:engine/view/stylesmap~StylesMap#set `StylesMap#set()`} for details.
     *
     * @param {String|Object} property Property name or object with key - value pairs.
     * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.
     * @param {module:engine/view/element~Element} element Element to set styles on.
     */

  }, {
    key: "setStyle",
    value: function setStyle(property, value, element) {
      if (lodash_es_isPlainObject(property) && element === undefined) {
        element = value;
      }

      element._setStyle(property, value);
    }
    /**
     * Removes specified style from the element.
     *
     *		writer.removeStyle( 'color', element ); // Removes 'color' style.
     *		writer.removeStyle( [ 'color', 'border-top' ], element ); // Removes both 'color' and 'border-top' styles.
     *
     * **Note**: This method can work with normalized style names if
     * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
     * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
     *
     * @param {Array.<String>|String} property
     * @param {module:engine/view/element~Element} element
     */

  }, {
    key: "removeStyle",
    value: function removeStyle(property, element) {
      element._removeStyle(property);
    }
    /**
     * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,
     * so they can be used to add special data to elements.
     *
     * @param {String|Symbol} key
     * @param {*} value
     * @param {module:engine/view/element~Element} element
     */

  }, {
    key: "setCustomProperty",
    value: function setCustomProperty(key, value, element) {
      element._setCustomProperty(key, value);
    }
    /**
     * Removes a custom property stored under the given key.
     *
     * @param {String|Symbol} key
     * @param {module:engine/view/element~Element} element
     * @returns {Boolean} Returns true if property was removed.
     */

  }, {
    key: "removeCustomProperty",
    value: function removeCustomProperty(key, element) {
      return element._removeCustomProperty(key);
    }
    /**
     * Breaks attribute nodes at provided position or at boundaries of provided range. It breaks attribute elements inside
     * up to a container element.
     *
     * In following examples `<p>` is a container, `<b>` and `<u>` are attribute nodes:
     *
     *		<p>foo<b><u>bar{}</u></b></p> -> <p>foo<b><u>bar</u></b>[]</p>
     *		<p>foo<b><u>{}bar</u></b></p> -> <p>foo{}<b><u>bar</u></b></p>
     *		<p>foo<b><u>b{}ar</u></b></p> -> <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>
     *		<p><b>fo{o</b><u>ba}r</u></p> -> <p><b>fo</b><b>o</b><u>ba</u><u>r</u></b></p>
     *
     * **Note:** {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.
     *
     * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes} and
     * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer} is that `breakAttributes` breaks all
     * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of given `position`,
     * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.
     * `breakContainer` assumes that given `position` is directly in container element and breaks that container element.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container`
     * when {@link module:engine/view/range~Range#start start}
     * and {@link module:engine/view/range~Range#end end} positions of a passed range are not placed inside same parent container.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element`
     * when trying to break attributes
     * inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element`
     * when trying to break attributes
     * inside {@link module:engine/view/uielement~UIElement UIElement}.
     *
     * @see module:engine/view/attributeelement~AttributeElement
     * @see module:engine/view/containerelement~ContainerElement
     * @see module:engine/view/downcastwriter~DowncastWriter#breakContainer
     * @param {module:engine/view/position~Position|module:engine/view/range~Range} positionOrRange Position where
     * to break attribute elements.
     * @returns {module:engine/view/position~Position|module:engine/view/range~Range} New position or range, after breaking the attribute
     * elements.
     */

  }, {
    key: "breakAttributes",
    value: function breakAttributes(positionOrRange) {
      if (positionOrRange instanceof position_Position) {
        return this._breakAttributes(positionOrRange);
      } else {
        return this._breakAttributesRange(positionOrRange);
      }
    }
    /**
     * Breaks {@link module:engine/view/containerelement~ContainerElement container view element} into two, at the given position. Position
     * has to be directly inside container element and cannot be in root. Does not break if position is at the beginning
     * or at the end of it's parent element.
     *
     *		<p>foo^bar</p> -> <p>foo</p><p>bar</p>
     *		<div><p>foo</p>^<p>bar</p></div> -> <div><p>foo</p></div><div><p>bar</p></div>
     *		<p>^foobar</p> -> ^<p>foobar</p>
     *		<p>foobar^</p> -> <p>foobar</p>^
     *
     * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#breakAttributes breakAttributes} and
     * {@link module:engine/view/downcastwriter~DowncastWriter#breakContainer breakContainer} is that `breakAttributes` breaks all
     * {@link module:engine/view/attributeelement~AttributeElement attribute elements} that are ancestors of given `position`,
     * up to the first encountered {@link module:engine/view/containerelement~ContainerElement container element}.
     * `breakContainer` assumes that given `position` is directly in container element and breaks that container element.
     *
     * @see module:engine/view/attributeelement~AttributeElement
     * @see module:engine/view/containerelement~ContainerElement
     * @see module:engine/view/downcastwriter~DowncastWriter#breakAttributes
     * @param {module:engine/view/position~Position} position Position where to break element.
     * @returns {module:engine/view/position~Position} Position between broken elements. If element has not been broken,
     * the returned position is placed either before it or after it.
     */

  }, {
    key: "breakContainer",
    value: function breakContainer(position) {
      var element = position.parent;

      if (!element.is('containerElement')) {
        /**
         * Trying to break an element which is not a container element.
         *
         * @error view-writer-break-non-container-element
         */
        throw new ckeditorerror["b" /* default */]('view-writer-break-non-container-element: Trying to break an element which is not a container element.', this.document);
      }

      if (!element.parent) {
        /**
         * Trying to break root element.
         *
         * @error view-writer-break-root
         */
        throw new ckeditorerror["b" /* default */]('view-writer-break-root: Trying to break root element.', this.document);
      }

      if (position.isAtStart) {
        return position_Position._createBefore(element);
      } else if (!position.isAtEnd) {
        var newElement = element._clone(false);

        this.insert(position_Position._createAfter(element), newElement);
        var sourceRange = new range_Range(position, position_Position._createAt(element, 'end'));
        var targetPosition = new position_Position(newElement, 0);
        this.move(sourceRange, targetPosition);
      }

      return position_Position._createAfter(element);
    }
    /**
     * Merges {@link module:engine/view/attributeelement~AttributeElement attribute elements}. It also merges text nodes if needed.
     * Only {@link module:engine/view/attributeelement~AttributeElement#isSimilar similar} attribute elements can be merged.
     *
     * In following examples `<p>` is a container and `<b>` is an attribute element:
     *
     *		<p>foo[]bar</p> -> <p>foo{}bar</p>
     *		<p><b>foo</b>[]<b>bar</b></p> -> <p><b>foo{}bar</b></p>
     *		<p><b foo="bar">a</b>[]<b foo="baz">b</b></p> -> <p><b foo="bar">a</b>[]<b foo="baz">b</b></p>
     *
     * It will also take care about empty attributes when merging:
     *
     *		<p><b>[]</b></p> -> <p>[]</p>
     *		<p><b>foo</b><i>[]</i><b>bar</b></p> -> <p><b>foo{}bar</b></p>
     *
     * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and
     * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two
     * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}
     * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.
     *
     * @see module:engine/view/attributeelement~AttributeElement
     * @see module:engine/view/containerelement~ContainerElement
     * @see module:engine/view/downcastwriter~DowncastWriter#mergeContainers
     * @param {module:engine/view/position~Position} position Merge position.
     * @returns {module:engine/view/position~Position} Position after merge.
     */

  }, {
    key: "mergeAttributes",
    value: function mergeAttributes(position) {
      var positionOffset = position.offset;
      var positionParent = position.parent; // When inside text node - nothing to merge.

      if (positionParent.is('text')) {
        return position;
      } // When inside empty attribute - remove it.


      if (positionParent.is('attributeElement') && positionParent.childCount === 0) {
        var parent = positionParent.parent;
        var offset = positionParent.index;

        positionParent._remove();

        this._removeFromClonedElementsGroup(positionParent);

        return this.mergeAttributes(new position_Position(parent, offset));
      }

      var nodeBefore = positionParent.getChild(positionOffset - 1);
      var nodeAfter = positionParent.getChild(positionOffset); // Position should be placed between two nodes.

      if (!nodeBefore || !nodeAfter) {
        return position;
      } // When position is between two text nodes.


      if (nodeBefore.is('text') && nodeAfter.is('text')) {
        return mergeTextNodes(nodeBefore, nodeAfter);
      } // When position is between two same attribute elements.
      else if (nodeBefore.is('attributeElement') && nodeAfter.is('attributeElement') && nodeBefore.isSimilar(nodeAfter)) {
          // Move all children nodes from node placed after selection and remove that node.
          var count = nodeBefore.childCount;

          nodeBefore._appendChild(nodeAfter.getChildren());

          nodeAfter._remove();

          this._removeFromClonedElementsGroup(nodeAfter); // New position is located inside the first node, before new nodes.
          // Call this method recursively to merge again if needed.


          return this.mergeAttributes(new position_Position(nodeBefore, count));
        }

      return position;
    }
    /**
     * Merges two {@link module:engine/view/containerelement~ContainerElement container elements} that are before and after given position.
     * Precisely, the element after the position is removed and it's contents are moved to element before the position.
     *
     *		<p>foo</p>^<p>bar</p> -> <p>foo^bar</p>
     *		<div>foo</div>^<p>bar</p> -> <div>foo^bar</div>
     *
     * **Note:** Difference between {@link module:engine/view/downcastwriter~DowncastWriter#mergeAttributes mergeAttributes} and
     * {@link module:engine/view/downcastwriter~DowncastWriter#mergeContainers mergeContainers} is that `mergeAttributes` merges two
     * {@link module:engine/view/attributeelement~AttributeElement attribute elements} or {@link module:engine/view/text~Text text nodes}
     * while `mergeContainer` merges two {@link module:engine/view/containerelement~ContainerElement container elements}.
     *
     * @see module:engine/view/attributeelement~AttributeElement
     * @see module:engine/view/containerelement~ContainerElement
     * @see module:engine/view/downcastwriter~DowncastWriter#mergeAttributes
     * @param {module:engine/view/position~Position} position Merge position.
     * @returns {module:engine/view/position~Position} Position after merge.
     */

  }, {
    key: "mergeContainers",
    value: function mergeContainers(position) {
      var prev = position.nodeBefore;
      var next = position.nodeAfter;

      if (!prev || !next || !prev.is('containerElement') || !next.is('containerElement')) {
        /**
         * Element before and after given position cannot be merged.
         *
         * @error view-writer-merge-containers-invalid-position
         */
        throw new ckeditorerror["b" /* default */]('view-writer-merge-containers-invalid-position: ' + 'Element before and after given position cannot be merged.', this.document);
      }

      var lastChild = prev.getChild(prev.childCount - 1);
      var newPosition = lastChild instanceof text_Text ? position_Position._createAt(lastChild, 'end') : position_Position._createAt(prev, 'end');
      this.move(range_Range._createIn(next), position_Position._createAt(prev, 'end'));
      this.remove(range_Range._createOn(next));
      return newPosition;
    }
    /**
     * Insert node or nodes at specified position. Takes care about breaking attributes before insertion
     * and merging them afterwards.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert
     * contains instances that are not {@link module:engine/view/text~Text Texts},
     * {@link module:engine/view/attributeelement~AttributeElement AttributeElements},
     * {@link module:engine/view/containerelement~ContainerElement ContainerElements},
     * {@link module:engine/view/emptyelement~EmptyElement EmptyElements} or
     * {@link module:engine/view/uielement~UIElement UIElements}.
     *
     * @param {module:engine/view/position~Position} position Insertion position.
     * @param {module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement|
     * module:engine/view/containerelement~ContainerElement|module:engine/view/emptyelement~EmptyElement|
     * module:engine/view/uielement~UIElement|Iterable.<module:engine/view/text~Text|
     * module:engine/view/attributeelement~AttributeElement|module:engine/view/containerelement~ContainerElement|
     * module:engine/view/emptyelement~EmptyElement|module:engine/view/uielement~UIElement>} nodes Node or nodes to insert.
     * @returns {module:engine/view/range~Range} Range around inserted nodes.
     */

  }, {
    key: "insert",
    value: function insert(position, nodes) {
      nodes = isIterable(nodes) ? _toConsumableArray(nodes) : [nodes]; // Check if nodes to insert are instances of AttributeElements, ContainerElements, EmptyElements, UIElements or Text.

      validateNodesToInsert(nodes, this.document);
      var container = getParentContainer(position);

      if (!container) {
        /**
         * Position's parent container cannot be found.
         *
         * @error view-writer-invalid-position-container
         */
        throw new ckeditorerror["b" /* default */]('view-writer-invalid-position-container', this.document);
      }

      var insertionPosition = this._breakAttributes(position, true);

      var length = container._insertChild(insertionPosition.offset, nodes);

      var _iterator = _createForOfIteratorHelper(nodes),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var node = _step.value;

          this._addToClonedElementsGroup(node);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var endPosition = insertionPosition.getShiftedBy(length);
      var start = this.mergeAttributes(insertionPosition); // When no nodes were inserted - return collapsed range.

      if (length === 0) {
        return new range_Range(start, start);
      } else {
        // If start position was merged - move end position.
        if (!start.isEqual(insertionPosition)) {
          endPosition.offset--;
        }

        var end = this.mergeAttributes(endPosition);
        return new range_Range(start, end);
      }
    }
    /**
     * Removes provided range from the container.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
     * same parent container.
     *
     * @param {module:engine/view/range~Range|module:engine/view/item~Item} rangeOrItem Range to remove from container
     * or an {@link module:engine/view/item~Item item} to remove. If range is provided, after removing, it will be updated
     * to a collapsed range showing the new position.
     * @returns {module:engine/view/documentfragment~DocumentFragment} Document fragment containing removed nodes.
     */

  }, {
    key: "remove",
    value: function remove(rangeOrItem) {
      var range = rangeOrItem instanceof range_Range ? rangeOrItem : range_Range._createOn(rangeOrItem);
      validateRangeContainer(range, this.document); // If range is collapsed - nothing to remove.

      if (range.isCollapsed) {
        return new documentfragment_DocumentFragment(this.document);
      } // Break attributes at range start and end.


      var _this$_breakAttribute = this._breakAttributesRange(range, true),
          breakStart = _this$_breakAttribute.start,
          breakEnd = _this$_breakAttribute.end;

      var parentContainer = breakStart.parent;
      var count = breakEnd.offset - breakStart.offset; // Remove nodes in range.

      var removed = parentContainer._removeChildren(breakStart.offset, count);

      var _iterator2 = _createForOfIteratorHelper(removed),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var node = _step2.value;

          this._removeFromClonedElementsGroup(node);
        } // Merge after removing.

      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var mergePosition = this.mergeAttributes(breakStart);
      range.start = mergePosition;
      range.end = mergePosition.clone(); // Return removed nodes.

      return new documentfragment_DocumentFragment(this.document, removed);
    }
    /**
     * Removes matching elements from given range.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
     * same parent container.
     *
     * @param {module:engine/view/range~Range} range Range to clear.
     * @param {module:engine/view/element~Element} element Element to remove.
     */

  }, {
    key: "clear",
    value: function clear(range, element) {
      validateRangeContainer(range, this.document); // Create walker on given range.
      // We walk backward because when we remove element during walk it modifies range end position.

      var walker = range.getWalker({
        direction: 'backward',
        ignoreElementEnd: true
      }); // Let's walk.

      var _iterator3 = _createForOfIteratorHelper(walker),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var current = _step3.value;
          var item = current.item;
          var rangeToRemove = void 0; // When current item matches to the given element.

          if (item.is('element') && element.isSimilar(item)) {
            // Create range on this element.
            rangeToRemove = range_Range._createOn(item); // When range starts inside Text or TextProxy element.
          } else if (!current.nextPosition.isAfter(range.start) && item.is('textProxy')) {
            // We need to check if parent of this text matches to given element.
            var parentElement = item.getAncestors().find(function (ancestor) {
              return ancestor.is('element') && element.isSimilar(ancestor);
            }); // If it is then create range inside this element.

            if (parentElement) {
              rangeToRemove = range_Range._createIn(parentElement);
            }
          } // If we have found element to remove.


          if (rangeToRemove) {
            // We need to check if element range stick out of the given range and truncate if it is.
            if (rangeToRemove.end.isAfter(range.end)) {
              rangeToRemove.end = range.end;
            }

            if (rangeToRemove.start.isBefore(range.start)) {
              rangeToRemove.start = range.start;
            } // At the end we remove range with found element.


            this.remove(rangeToRemove);
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
    /**
     * Moves nodes from provided range to target position.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
     * same parent container.
     *
     * @param {module:engine/view/range~Range} sourceRange Range containing nodes to move.
     * @param {module:engine/view/position~Position} targetPosition Position to insert.
     * @returns {module:engine/view/range~Range} Range in target container. Inserted nodes are placed between
     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions.
     */

  }, {
    key: "move",
    value: function move(sourceRange, targetPosition) {
      var nodes;

      if (targetPosition.isAfter(sourceRange.end)) {
        targetPosition = this._breakAttributes(targetPosition, true);
        var parent = targetPosition.parent;
        var countBefore = parent.childCount;
        sourceRange = this._breakAttributesRange(sourceRange, true);
        nodes = this.remove(sourceRange);
        targetPosition.offset += parent.childCount - countBefore;
      } else {
        nodes = this.remove(sourceRange);
      }

      return this.insert(targetPosition, nodes);
    }
    /**
     * Wraps elements within range with provided {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
     * If a collapsed range is provided, it will be wrapped only if it is equal to view selection.
     *
     * If a collapsed range was passed and is same as selection, the selection
     * will be moved to the inside of the wrapped attribute element.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-invalid-range-container`
     * when {@link module:engine/view/range~Range#start}
     * and {@link module:engine/view/range~Range#end} positions are not placed inside same parent container.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
     * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-nonselection-collapsed-range` when passed range
     * is collapsed and different than view selection.
     *
     * @param {module:engine/view/range~Range} range Range to wrap.
     * @param {module:engine/view/attributeelement~AttributeElement} attribute Attribute element to use as wrapper.
     * @returns {module:engine/view/range~Range} range Range after wrapping, spanning over wrapping attribute element.
    */

  }, {
    key: "wrap",
    value: function wrap(range, attribute) {
      if (!(attribute instanceof attributeelement_AttributeElement)) {
        throw new ckeditorerror["b" /* default */]('view-writer-wrap-invalid-attribute', this.document);
      }

      validateRangeContainer(range, this.document);

      if (!range.isCollapsed) {
        // Non-collapsed range. Wrap it with the attribute element.
        return this._wrapRange(range, attribute);
      } else {
        // Collapsed range. Wrap position.
        var position = range.start;

        if (position.parent.is('element') && !_hasNonUiChildren(position.parent)) {
          position = position.getLastMatchingPosition(function (value) {
            return value.item.is('uiElement');
          });
        }

        position = this._wrapPosition(position, attribute);
        var viewSelection = this.document.selection; // If wrapping position is equal to view selection, move view selection inside wrapping attribute element.

        if (viewSelection.isCollapsed && viewSelection.getFirstPosition().isEqual(range.start)) {
          this.setSelection(position);
        }

        return new range_Range(position);
      }
    }
    /**
     * Unwraps nodes within provided range from attribute element.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when
     * {@link module:engine/view/range~Range#start start} and {@link module:engine/view/range~Range#end end} positions are not placed inside
     * same parent container.
     *
     * @param {module:engine/view/range~Range} range
     * @param {module:engine/view/attributeelement~AttributeElement} attribute
     */

  }, {
    key: "unwrap",
    value: function unwrap(range, attribute) {
      if (!(attribute instanceof attributeelement_AttributeElement)) {
        /**
         * Attribute element need to be instance of attribute element.
         *
         * @error view-writer-unwrap-invalid-attribute
         */
        throw new ckeditorerror["b" /* default */]('view-writer-unwrap-invalid-attribute', this.document);
      }

      validateRangeContainer(range, this.document); // If range is collapsed - nothing to unwrap.

      if (range.isCollapsed) {
        return range;
      } // Break attributes at range start and end.


      var _this$_breakAttribute2 = this._breakAttributesRange(range, true),
          breakStart = _this$_breakAttribute2.start,
          breakEnd = _this$_breakAttribute2.end;

      var parentContainer = breakStart.parent; // Unwrap children located between break points.

      var newRange = this._unwrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute); // Merge attributes at the both ends and return a new range.


      var start = this.mergeAttributes(newRange.start); // If start position was merged - move end position back.

      if (!start.isEqual(newRange.start)) {
        newRange.end.offset--;
      }

      var end = this.mergeAttributes(newRange.end);
      return new range_Range(start, end);
    }
    /**
     * Renames element by creating a copy of renamed element but with changed name and then moving contents of the
     * old element to the new one. Keep in mind that this will invalidate all {@link module:engine/view/position~Position positions} which
     * has renamed element as {@link module:engine/view/position~Position#parent a parent}.
     *
     * New element has to be created because `Element#tagName` property in DOM is readonly.
     *
     * Since this function creates a new element and removes the given one, the new element is returned to keep reference.
     *
     * @param {String} newName New name for element.
     * @param {module:engine/view/containerelement~ContainerElement} viewElement Element to be renamed.
     */

  }, {
    key: "rename",
    value: function rename(newName, viewElement) {
      var newElement = new containerelement_ContainerElement(this.document, newName, viewElement.getAttributes());
      this.insert(position_Position._createAfter(viewElement), newElement);
      this.move(range_Range._createIn(viewElement), position_Position._createAt(newElement, 0));
      this.remove(range_Range._createOn(viewElement));
      return newElement;
    }
    /**
     * Cleans up memory by removing obsolete cloned elements group from the writer.
     *
     * Should be used whenever all {@link module:engine/view/attributeelement~AttributeElement attribute elements}
     * with the same {@link module:engine/view/attributeelement~AttributeElement#id id} are going to be removed from the view and
     * the group will no longer be needed.
     *
     * Cloned elements group are not removed automatically in case if the group is still needed after all its elements
     * were removed from the view.
     *
     * Keep in mind that group names are equal to the `id` property of the attribute element.
     *
     * @param {String} groupName Name of the group to clear.
     */

  }, {
    key: "clearClonedElementsGroup",
    value: function clearClonedElementsGroup(groupName) {
      this._cloneGroups.delete(groupName);
    }
    /**
     * Creates position at the given location. The location can be specified as:
     *
     * * a {@link module:engine/view/position~Position position},
     * * parent element and offset (offset defaults to `0`),
     * * parent element and `'end'` (sets position at the end of that element),
     * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
     *
     * This method is a shortcut to other constructors such as:
     *
     * * {@link #createPositionBefore},
     * * {@link #createPositionAfter},
     *
     * @param {module:engine/view/item~Item|module:engine/model/position~Position} itemOrPosition
     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when
     * first parameter is a {@link module:engine/view/item~Item view item}.
     */

  }, {
    key: "createPositionAt",
    value: function createPositionAt(itemOrPosition, offset) {
      return position_Position._createAt(itemOrPosition, offset);
    }
    /**
     * Creates a new position after given view item.
     *
     * @param {module:engine/view/item~Item} item View item after which the position should be located.
     * @returns {module:engine/view/position~Position}
     */

  }, {
    key: "createPositionAfter",
    value: function createPositionAfter(item) {
      return position_Position._createAfter(item);
    }
    /**
     * Creates a new position before given view item.
     *
     * @param {module:engine/view/item~Item} item View item before which the position should be located.
     * @returns {module:engine/view/position~Position}
     */

  }, {
    key: "createPositionBefore",
    value: function createPositionBefore(item) {
      return position_Position._createBefore(item);
    }
    /**
     * Creates a range spanning from `start` position to `end` position.
     *
     * **Note:** This factory method creates its own {@link module:engine/view/position~Position} instances basing on passed values.
     *
     * @param {module:engine/view/position~Position} start Start position.
     * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at `start` position.
     * @returns {module:engine/view/range~Range}
     */

  }, {
    key: "createRange",
    value: function createRange(start, end) {
      return new range_Range(start, end);
    }
    /**
     * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
     *
     * @param {module:engine/view/item~Item} item
     * @returns {module:engine/view/range~Range}
     */

  }, {
    key: "createRangeOn",
    value: function createRangeOn(item) {
      return range_Range._createOn(item);
    }
    /**
     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
     * that element and ends after the last child of that element.
     *
     * @param {module:engine/view/element~Element} element Element which is a parent for the range.
     * @returns {module:engine/view/range~Range}
     */

  }, {
    key: "createRangeIn",
    value: function createRangeIn(element) {
      return range_Range._createIn(element);
    }
    /**
     Creates new {@link module:engine/view/selection~Selection} instance.
     *
     * 		// Creates empty selection without ranges.
     *		const selection = writer.createSelection();
     *
     *		// Creates selection at the given range.
     *		const range = writer.createRange( start, end );
     *		const selection = writer.createSelection( range );
     *
     *		// Creates selection at the given ranges
     * 		const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
     *		const selection = writer.createSelection( ranges );
     *
     *		// Creates selection from the other selection.
     *		const otherSelection = writer.createSelection();
     *		const selection = writer.createSelection( otherSelection );
     *
     *		// Creates selection from the document selection.
     *		const selection = writer.createSelection( editor.editing.view.document.selection );
     *
     * 		// Creates selection at the given position.
     *		const position = writer.createPositionFromPath( root, path );
     *		const selection = writer.createSelection( position );
     *
     *		// Creates collapsed selection at the position of given item and offset.
     *		const paragraph = writer.createContainerElement( 'p' );
     *		const selection = writer.createSelection( paragraph, offset );
     *
     *		// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the
     *		// first child of that element and ends after the last child of that element.
     *		const selection = writer.createSelection( paragraph, 'in' );
     *
     *		// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends
     *		// just after the item.
     *		const selection = writer.createSelection( paragraph, 'on' );
     *
     * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.
     *
     *		// Creates backward selection.
     *		const selection = writer.createSelection( range, { backward: true } );
     *
     * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
     * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
     * represented in other way, for example by applying proper CSS class.
     *
     * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
     * (and be  properly handled by screen readers).
     *
     *		// Creates fake selection with label.
     *		const selection = writer.createSelection( range, { fake: true, label: 'foo' } );
     *
     * @param {module:engine/view/selection~Selectable} [selectable=null]
     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.
     * @param {Object} [options]
     * @param {Boolean} [options.backward] Sets this selection instance to be backward.
     * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.
     * @param {String} [options.label] Label for the fake selection.
     * @returns {module:engine/view/selection~Selection}
     */

  }, {
    key: "createSelection",
    value: function createSelection(selectable, placeOrOffset, options) {
      return new selection_Selection(selectable, placeOrOffset, options);
    }
    /**
     * Wraps children with provided `wrapElement`. Only children contained in `parent` element between
     * `startOffset` and `endOffset` will be wrapped.
     *
     * @private
     * @param {module:engine/view/element~Element} parent
     * @param {Number} startOffset
     * @param {Number} endOffset
     * @param {module:engine/view/element~Element} wrapElement
     */

  }, {
    key: "_wrapChildren",
    value: function _wrapChildren(parent, startOffset, endOffset, wrapElement) {
      var i = startOffset;
      var wrapPositions = [];

      while (i < endOffset) {
        var child = parent.getChild(i);
        var isText = child.is('text');
        var isAttribute = child.is('attributeElement');
        var isEmpty = child.is('emptyElement');
        var isUI = child.is('uiElement'); //
        // (In all examples, assume that `wrapElement` is `<span class="foo">` element.)
        //
        // Check if `wrapElement` can be joined with the wrapped element. One of requirements is having same name.
        // If possible, join elements.
        //
        // <p><span class="bar">abc</span></p>  -->  <p><span class="foo bar">abc</span></p>
        //

        if (isAttribute && this._wrapAttributeElement(wrapElement, child)) {
          wrapPositions.push(new position_Position(parent, i));
        } //
        // Wrap the child if it is not an attribute element or if it is an attribute element that should be inside
        // `wrapElement` (due to priority).
        //
        // <p>abc</p>                   -->  <p><span class="foo">abc</span></p>
        // <p><strong>abc</strong></p>  -->  <p><span class="foo"><strong>abc</strong></span></p>
        //
        else if (isText || isEmpty || isUI || isAttribute && shouldABeOutsideB(wrapElement, child)) {
            // Clone attribute.
            var newAttribute = wrapElement._clone(); // Wrap current node with new attribute.


            child._remove();

            newAttribute._appendChild(child);

            parent._insertChild(i, newAttribute);

            this._addToClonedElementsGroup(newAttribute);

            wrapPositions.push(new position_Position(parent, i));
          } //
          // If other nested attribute is found and it wasn't wrapped (see above), continue wrapping inside it.
          //
          // <p><a href="foo.html">abc</a></p>  -->  <p><a href="foo.html"><span class="foo">abc</span></a></p>
          //
          else if (isAttribute) {
              this._wrapChildren(child, 0, child.childCount, wrapElement);
            }

        i++;
      } // Merge at each wrap.


      var offsetChange = 0;

      for (var _i = 0, _wrapPositions = wrapPositions; _i < _wrapPositions.length; _i++) {
        var position = _wrapPositions[_i];
        position.offset -= offsetChange; // Do not merge with elements outside selected children.

        if (position.offset == startOffset) {
          continue;
        }

        var newPosition = this.mergeAttributes(position); // If nodes were merged - other merge offsets will change.

        if (!newPosition.isEqual(position)) {
          offsetChange++;
          endOffset--;
        }
      }

      return range_Range._createFromParentsAndOffsets(parent, startOffset, parent, endOffset);
    }
    /**
     * Unwraps children from provided `unwrapElement`. Only children contained in `parent` element between
     * `startOffset` and `endOffset` will be unwrapped.
     *
     * @private
     * @param {module:engine/view/element~Element} parent
     * @param {Number} startOffset
     * @param {Number} endOffset
     * @param {module:engine/view/element~Element} unwrapElement
     */

  }, {
    key: "_unwrapChildren",
    value: function _unwrapChildren(parent, startOffset, endOffset, unwrapElement) {
      var i = startOffset;
      var unwrapPositions = []; // Iterate over each element between provided offsets inside parent.
      // We don't use tree walker or range iterator because we will be removing and merging potentially multiple nodes,
      // so it could get messy. It is safer to it manually in this case.

      while (i < endOffset) {
        var child = parent.getChild(i); // Skip all text nodes. There should be no container element's here either.

        if (!child.is('attributeElement')) {
          i++;
          continue;
        } //
        // (In all examples, assume that `unwrapElement` is `<span class="foo">` element.)
        //
        // If the child is similar to the given attribute element, unwrap it - it will be completely removed.
        //
        // <p><span class="foo">abc</span>xyz</p>  -->  <p>abcxyz</p>
        //


        if (child.isSimilar(unwrapElement)) {
          var unwrapped = child.getChildren();
          var count = child.childCount; // Replace wrapper element with its children

          child._remove();

          parent._insertChild(i, unwrapped);

          this._removeFromClonedElementsGroup(child); // Save start and end position of moved items.


          unwrapPositions.push(new position_Position(parent, i), new position_Position(parent, i + count)); // Skip elements that were unwrapped. Assuming there won't be another element to unwrap in child elements.

          i += count;
          endOffset += count - 1;
          continue;
        } //
        // If the child is not similar but is an attribute element, try partial unwrapping - remove the same attributes/styles/classes.
        // Partial unwrapping will happen only if the elements have the same name.
        //
        // <p><span class="foo bar">abc</span>xyz</p>  -->  <p><span class="bar">abc</span>xyz</p>
        // <p><i class="foo">abc</i>xyz</p>            -->  <p><i class="foo">abc</i>xyz</p>
        //


        if (this._unwrapAttributeElement(unwrapElement, child)) {
          unwrapPositions.push(new position_Position(parent, i), new position_Position(parent, i + 1));
          i++;
          continue;
        } //
        // If other nested attribute is found, look through it's children for elements to unwrap.
        //
        // <p><i><span class="foo">abc</span></i><p>  -->  <p><i>abc</i><p>
        //


        this._unwrapChildren(child, 0, child.childCount, unwrapElement);

        i++;
      } // Merge at each unwrap.


      var offsetChange = 0;

      for (var _i2 = 0, _unwrapPositions = unwrapPositions; _i2 < _unwrapPositions.length; _i2++) {
        var position = _unwrapPositions[_i2];
        position.offset -= offsetChange; // Do not merge with elements outside selected children.

        if (position.offset == startOffset || position.offset == endOffset) {
          continue;
        }

        var newPosition = this.mergeAttributes(position); // If nodes were merged - other merge offsets will change.

        if (!newPosition.isEqual(position)) {
          offsetChange++;
          endOffset--;
        }
      }

      return range_Range._createFromParentsAndOffsets(parent, startOffset, parent, endOffset);
    }
    /**
     * Helper function for `view.writer.wrap`. Wraps range with provided attribute element.
     * This method will also merge newly added attribute element with its siblings whenever possible.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
     * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
     *
     * @private
     * @param {module:engine/view/range~Range} range
     * @param {module:engine/view/attributeelement~AttributeElement} attribute
     * @returns {module:engine/view/range~Range} New range after wrapping, spanning over wrapping attribute element.
     */

  }, {
    key: "_wrapRange",
    value: function _wrapRange(range, attribute) {
      // Break attributes at range start and end.
      var _this$_breakAttribute3 = this._breakAttributesRange(range, true),
          breakStart = _this$_breakAttribute3.start,
          breakEnd = _this$_breakAttribute3.end;

      var parentContainer = breakStart.parent; // Wrap all children with attribute.

      var newRange = this._wrapChildren(parentContainer, breakStart.offset, breakEnd.offset, attribute); // Merge attributes at the both ends and return a new range.


      var start = this.mergeAttributes(newRange.start); // If start position was merged - move end position back.

      if (!start.isEqual(newRange.start)) {
        newRange.end.offset--;
      }

      var end = this.mergeAttributes(newRange.end);
      return new range_Range(start, end);
    }
    /**
     * Helper function for {@link #wrap}. Wraps position with provided attribute element.
     * This method will also merge newly added attribute element with its siblings whenever possible.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError} `view-writer-wrap-invalid-attribute` when passed attribute element is not
     * an instance of {@link module:engine/view/attributeelement~AttributeElement AttributeElement}.
     *
     * @private
     * @param {module:engine/view/position~Position} position
     * @param {module:engine/view/attributeelement~AttributeElement} attribute
     * @returns {module:engine/view/position~Position} New position after wrapping.
     */

  }, {
    key: "_wrapPosition",
    value: function _wrapPosition(position, attribute) {
      // Return same position when trying to wrap with attribute similar to position parent.
      if (attribute.isSimilar(position.parent)) {
        return movePositionToTextNode(position.clone());
      } // When position is inside text node - break it and place new position between two text nodes.


      if (position.parent.is('text')) {
        position = breakTextNode(position);
      } // Create fake element that will represent position, and will not be merged with other attributes.


      var fakePosition = this.createAttributeElement();
      fakePosition._priority = Number.POSITIVE_INFINITY;

      fakePosition.isSimilar = function () {
        return false;
      }; // Insert fake element in position location.


      position.parent._insertChild(position.offset, fakePosition); // Range around inserted fake attribute element.


      var wrapRange = new range_Range(position, position.getShiftedBy(1)); // Wrap fake element with attribute (it will also merge if possible).

      this.wrap(wrapRange, attribute); // Remove fake element and place new position there.

      var newPosition = new position_Position(fakePosition.parent, fakePosition.index);

      fakePosition._remove(); // If position is placed between text nodes - merge them and return position inside.


      var nodeBefore = newPosition.nodeBefore;
      var nodeAfter = newPosition.nodeAfter;

      if (nodeBefore instanceof text_Text && nodeAfter instanceof text_Text) {
        return mergeTextNodes(nodeBefore, nodeAfter);
      } // If position is next to text node - move position inside.


      return movePositionToTextNode(newPosition);
    }
    /**
     * 	Wraps one {@link module:engine/view/attributeelement~AttributeElement AttributeElement} into another by
     * 	merging them if possible. When merging is possible - all attributes, styles and classes are moved from wrapper
     * 	element to element being wrapped.
     *
     * 	@private
     * 	@param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.
     * 	@param {module:engine/view/attributeelement~AttributeElement} toWrap AttributeElement to wrap using wrapper element.
     * 	@returns {Boolean} Returns `true` if elements are merged.
     */

  }, {
    key: "_wrapAttributeElement",
    value: function _wrapAttributeElement(wrapper, toWrap) {
      if (!canBeJoined(wrapper, toWrap)) {
        return false;
      } // Can't merge if name or priority differs.


      if (wrapper.name !== toWrap.name || wrapper.priority !== toWrap.priority) {
        return false;
      } // Check if attributes can be merged.


      var _iterator4 = _createForOfIteratorHelper(wrapper.getAttributeKeys()),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var key = _step4.value;

          // Classes and styles should be checked separately.
          if (key === 'class' || key === 'style') {
            continue;
          } // If some attributes are different we cannot wrap.


          if (toWrap.hasAttribute(key) && toWrap.getAttribute(key) !== wrapper.getAttribute(key)) {
            return false;
          }
        } // Check if styles can be merged.

      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      var _iterator5 = _createForOfIteratorHelper(wrapper.getStyleNames()),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _key = _step5.value;

          if (toWrap.hasStyle(_key) && toWrap.getStyle(_key) !== wrapper.getStyle(_key)) {
            return false;
          }
        } // Move all attributes/classes/styles from wrapper to wrapped AttributeElement.

      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      var _iterator6 = _createForOfIteratorHelper(wrapper.getAttributeKeys()),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var _key2 = _step6.value;

          // Classes and styles should be checked separately.
          if (_key2 === 'class' || _key2 === 'style') {
            continue;
          } // Move only these attributes that are not present - other are similar.


          if (!toWrap.hasAttribute(_key2)) {
            this.setAttribute(_key2, wrapper.getAttribute(_key2), toWrap);
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      var _iterator7 = _createForOfIteratorHelper(wrapper.getStyleNames()),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var _key3 = _step7.value;

          if (!toWrap.hasStyle(_key3)) {
            this.setStyle(_key3, wrapper.getStyle(_key3), toWrap);
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }

      var _iterator8 = _createForOfIteratorHelper(wrapper.getClassNames()),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var _key4 = _step8.value;

          if (!toWrap.hasClass(_key4)) {
            this.addClass(_key4, toWrap);
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }

      return true;
    }
    /**
     * Unwraps {@link module:engine/view/attributeelement~AttributeElement AttributeElement} from another by removing
     * corresponding attributes, classes and styles. All attributes, classes and styles from wrapper should be present
     * inside element being unwrapped.
     *
     * @private
     * @param {module:engine/view/attributeelement~AttributeElement} wrapper Wrapper AttributeElement.
     * @param {module:engine/view/attributeelement~AttributeElement} toUnwrap AttributeElement to unwrap using wrapper element.
     * @returns {Boolean} Returns `true` if elements are unwrapped.
     **/

  }, {
    key: "_unwrapAttributeElement",
    value: function _unwrapAttributeElement(wrapper, toUnwrap) {
      if (!canBeJoined(wrapper, toUnwrap)) {
        return false;
      } // Can't unwrap if name or priority differs.


      if (wrapper.name !== toUnwrap.name || wrapper.priority !== toUnwrap.priority) {
        return false;
      } // Check if AttributeElement has all wrapper attributes.


      var _iterator9 = _createForOfIteratorHelper(wrapper.getAttributeKeys()),
          _step9;

      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var key = _step9.value;

          // Classes and styles should be checked separately.
          if (key === 'class' || key === 'style') {
            continue;
          } // If some attributes are missing or different we cannot unwrap.


          if (!toUnwrap.hasAttribute(key) || toUnwrap.getAttribute(key) !== wrapper.getAttribute(key)) {
            return false;
          }
        } // Check if AttributeElement has all wrapper classes.

      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }

      if (!toUnwrap.hasClass.apply(toUnwrap, _toConsumableArray(wrapper.getClassNames()))) {
        return false;
      } // Check if AttributeElement has all wrapper styles.


      var _iterator10 = _createForOfIteratorHelper(wrapper.getStyleNames()),
          _step10;

      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var _key5 = _step10.value;

          // If some styles are missing or different we cannot unwrap.
          if (!toUnwrap.hasStyle(_key5) || toUnwrap.getStyle(_key5) !== wrapper.getStyle(_key5)) {
            return false;
          }
        } // Remove all wrapper's attributes from unwrapped element.

      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }

      var _iterator11 = _createForOfIteratorHelper(wrapper.getAttributeKeys()),
          _step11;

      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var _key6 = _step11.value;

          // Classes and styles should be checked separately.
          if (_key6 === 'class' || _key6 === 'style') {
            continue;
          }

          this.removeAttribute(_key6, toUnwrap);
        } // Remove all wrapper's classes from unwrapped element.

      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }

      this.removeClass(Array.from(wrapper.getClassNames()), toUnwrap); // Remove all wrapper's styles from unwrapped element.

      this.removeStyle(Array.from(wrapper.getStyleNames()), toUnwrap);
      return true;
    }
    /**
     * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at the boundaries of given range.
     *
     * @private
     * @param {module:engine/view/range~Range} range Range which `start` and `end` positions will be used to break attributes.
     * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.
     * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.
     * @returns {module:engine/view/range~Range} New range with located at break positions.
     */

  }, {
    key: "_breakAttributesRange",
    value: function _breakAttributesRange(range) {
      var forceSplitText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var rangeStart = range.start;
      var rangeEnd = range.end;
      validateRangeContainer(range, this.document); // Break at the collapsed position. Return new collapsed range.

      if (range.isCollapsed) {
        var position = this._breakAttributes(range.start, forceSplitText);

        return new range_Range(position, position);
      }

      var breakEnd = this._breakAttributes(rangeEnd, forceSplitText);

      var count = breakEnd.parent.childCount;

      var breakStart = this._breakAttributes(rangeStart, forceSplitText); // Calculate new break end offset.


      breakEnd.offset += breakEnd.parent.childCount - count;
      return new range_Range(breakStart, breakEnd);
    }
    /**
     * Helper function used by other `DowncastWriter` methods. Breaks attribute elements at given position.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-empty-element` when break position
     * is placed inside {@link module:engine/view/emptyelement~EmptyElement EmptyElement}.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-cannot-break-ui-element` when break position
     * is placed inside {@link module:engine/view/uielement~UIElement UIElement}.
     *
     * @private
     * @param {module:engine/view/position~Position} position Position where to break attributes.
     * @param {Boolean} [forceSplitText=false] If set to `true`, will break text nodes even if they are directly in container element.
     * This behavior will result in incorrect view state, but is needed by other view writing methods which then fixes view state.
     * @returns {module:engine/view/position~Position} New position after breaking the attributes.
     */

  }, {
    key: "_breakAttributes",
    value: function _breakAttributes(position) {
      var forceSplitText = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var positionOffset = position.offset;
      var positionParent = position.parent; // If position is placed inside EmptyElement - throw an exception as we cannot break inside.

      if (position.parent.is('emptyElement')) {
        /**
         * Cannot break inside EmptyElement instance.
         *
         * @error view-writer-cannot-break-empty-element
         */
        throw new ckeditorerror["b" /* default */]('view-writer-cannot-break-empty-element', this.document);
      } // If position is placed inside UIElement - throw an exception as we cannot break inside.


      if (position.parent.is('uiElement')) {
        /**
         * Cannot break inside UIElement instance.
         *
         * @error view-writer-cannot-break-ui-element
         */
        throw new ckeditorerror["b" /* default */]('view-writer-cannot-break-ui-element', this.document);
      } // There are no attributes to break and text nodes breaking is not forced.


      if (!forceSplitText && positionParent.is('text') && isContainerOrFragment(positionParent.parent)) {
        return position.clone();
      } // Position's parent is container, so no attributes to break.


      if (isContainerOrFragment(positionParent)) {
        return position.clone();
      } // Break text and start again in new position.


      if (positionParent.is('text')) {
        return this._breakAttributes(breakTextNode(position), forceSplitText);
      }

      var length = positionParent.childCount; // <p>foo<b><u>bar{}</u></b></p>
      // <p>foo<b><u>bar</u>[]</b></p>
      // <p>foo<b><u>bar</u></b>[]</p>

      if (positionOffset == length) {
        var newPosition = new position_Position(positionParent.parent, positionParent.index + 1);
        return this._breakAttributes(newPosition, forceSplitText);
      } else {
        // <p>foo<b><u>{}bar</u></b></p>
        // <p>foo<b>[]<u>bar</u></b></p>
        // <p>foo{}<b><u>bar</u></b></p>
        if (positionOffset === 0) {
          var _newPosition = new position_Position(positionParent.parent, positionParent.index);

          return this._breakAttributes(_newPosition, forceSplitText);
        } // <p>foo<b><u>b{}ar</u></b></p>
        // <p>foo<b><u>b[]ar</u></b></p>
        // <p>foo<b><u>b</u>[]<u>ar</u></b></p>
        // <p>foo<b><u>b</u></b>[]<b><u>ar</u></b></p>
        else {
            var offsetAfter = positionParent.index + 1; // Break element.

            var clonedNode = positionParent._clone(); // Insert cloned node to position's parent node.


            positionParent.parent._insertChild(offsetAfter, clonedNode);

            this._addToClonedElementsGroup(clonedNode); // Get nodes to move.


            var count = positionParent.childCount - positionOffset;

            var nodesToMove = positionParent._removeChildren(positionOffset, count); // Move nodes to cloned node.


            clonedNode._appendChild(nodesToMove); // Create new position to work on.


            var _newPosition2 = new position_Position(positionParent.parent, offsetAfter);

            return this._breakAttributes(_newPosition2, forceSplitText);
          }
      }
    }
    /**
     * Stores the information that an {@link module:engine/view/attributeelement~AttributeElement attribute element} was
     * added to the tree. Saves the reference to the group in the given element and updates the group, so other elements
     * from the group now keep a reference to the given attribute element.
     *
     * The clones group can be obtained using {@link module:engine/view/attributeelement~AttributeElement#getElementsWithSameId}.
     *
     * Does nothing if added element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.
     *
     * @private
     * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to save.
     */

  }, {
    key: "_addToClonedElementsGroup",
    value: function _addToClonedElementsGroup(element) {
      // Add only if the element is in document tree.
      if (!element.root.is('rootElement')) {
        return;
      } // Traverse the element's children recursively to find other attribute elements that also might got inserted.
      // The loop is at the beginning so we can make fast returns later in the code.


      if (element.is('element')) {
        var _iterator12 = _createForOfIteratorHelper(element.getChildren()),
            _step12;

        try {
          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var child = _step12.value;

            this._addToClonedElementsGroup(child);
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }
      }

      var id = element.id;

      if (!id) {
        return;
      }

      var group = this._cloneGroups.get(id);

      if (!group) {
        group = new Set();

        this._cloneGroups.set(id, group);
      }

      group.add(element);
      element._clonesGroup = group;
    }
    /**
     * Removes all the information about the given {@link module:engine/view/attributeelement~AttributeElement attribute element}
     * from its clones group.
     *
     * Keep in mind, that the element will still keep a reference to the group (but the group will not keep a reference to it).
     * This allows to reference the whole group even if the element was already removed from the tree.
     *
     * Does nothing if the element has no {@link module:engine/view/attributeelement~AttributeElement#id id}.
     *
     * @private
     * @param {module:engine/view/attributeelement~AttributeElement} element Attribute element to remove.
     */

  }, {
    key: "_removeFromClonedElementsGroup",
    value: function _removeFromClonedElementsGroup(element) {
      // Traverse the element's children recursively to find other attribute elements that also got removed.
      // The loop is at the beginning so we can make fast returns later in the code.
      if (element.is('element')) {
        var _iterator13 = _createForOfIteratorHelper(element.getChildren()),
            _step13;

        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
            var child = _step13.value;

            this._removeFromClonedElementsGroup(child);
          }
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }
      }

      var id = element.id;

      if (!id) {
        return;
      }

      var group = this._cloneGroups.get(id);

      if (!group) {
        return;
      }

      group.delete(element); // Not removing group from element on purpose!
      // If other parts of code have reference to this element, they will be able to get references to other elements from the group.
    }
  }]);

  return DowncastWriter;
}(); // Helper function for `view.writer.wrap`. Checks if given element has any children that are not ui elements.




function _hasNonUiChildren(parent) {
  return Array.from(parent.getChildren()).some(function (child) {
    return !child.is('uiElement');
  });
}
/**
 * Attribute element need to be instance of attribute element.
 *
 * @error view-writer-wrap-invalid-attribute
 */
// Returns first parent container of specified {@link module:engine/view/position~Position Position}.
// Position's parent node is checked as first, then next parents are checked.
// Note that {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment} is treated like a container.
//
// @param {module:engine/view/position~Position} position Position used as a start point to locate parent container.
// @returns {module:engine/view/containerelement~ContainerElement|module:engine/view/documentfragment~DocumentFragment|undefined}
// Parent container element or `undefined` if container is not found.


function getParentContainer(position) {
  var parent = position.parent;

  while (!isContainerOrFragment(parent)) {
    if (!parent) {
      return undefined;
    }

    parent = parent.parent;
  }

  return parent;
} // Checks if first {@link module:engine/view/attributeelement~AttributeElement AttributeElement} provided to the function
// can be wrapped otuside second element. It is done by comparing elements'
// {@link module:engine/view/attributeelement~AttributeElement#priority priorities}, if both have same priority
// {@link module:engine/view/element~Element#getIdentity identities} are compared.
//
// @param {module:engine/view/attributeelement~AttributeElement} a
// @param {module:engine/view/attributeelement~AttributeElement} b
// @returns {Boolean}


function shouldABeOutsideB(a, b) {
  if (a.priority < b.priority) {
    return true;
  } else if (a.priority > b.priority) {
    return false;
  } // When priorities are equal and names are different - use identities.


  return a.getIdentity() < b.getIdentity();
} // Returns new position that is moved to near text node. Returns same position if there is no text node before of after
// specified position.
//
//		<p>foo[]</p>  ->  <p>foo{}</p>
//		<p>[]foo</p>  ->  <p>{}foo</p>
//
// @param {module:engine/view/position~Position} position
// @returns {module:engine/view/position~Position} Position located inside text node or same position if there is no text nodes
// before or after position location.


function movePositionToTextNode(position) {
  var nodeBefore = position.nodeBefore;

  if (nodeBefore && nodeBefore.is('text')) {
    return new position_Position(nodeBefore, nodeBefore.data.length);
  }

  var nodeAfter = position.nodeAfter;

  if (nodeAfter && nodeAfter.is('text')) {
    return new position_Position(nodeAfter, 0);
  }

  return position;
} // Breaks text node into two text nodes when possible.
//
//		<p>foo{}bar</p> -> <p>foo[]bar</p>
//		<p>{}foobar</p> -> <p>[]foobar</p>
//		<p>foobar{}</p> -> <p>foobar[]</p>
//
// @param {module:engine/view/position~Position} position Position that need to be placed inside text node.
// @returns {module:engine/view/position~Position} New position after breaking text node.


function breakTextNode(position) {
  if (position.offset == position.parent.data.length) {
    return new position_Position(position.parent.parent, position.parent.index + 1);
  }

  if (position.offset === 0) {
    return new position_Position(position.parent.parent, position.parent.index);
  } // Get part of the text that need to be moved.


  var textToMove = position.parent.data.slice(position.offset); // Leave rest of the text in position's parent.

  position.parent._data = position.parent.data.slice(0, position.offset); // Insert new text node after position's parent text node.

  position.parent.parent._insertChild(position.parent.index + 1, new text_Text(position.root.document, textToMove)); // Return new position between two newly created text nodes.


  return new position_Position(position.parent.parent, position.parent.index + 1);
} // Merges two text nodes into first node. Removes second node and returns merge position.
//
// @param {module:engine/view/text~Text} t1 First text node to merge. Data from second text node will be moved at the end of
// this text node.
// @param {module:engine/view/text~Text} t2 Second text node to merge. This node will be removed after merging.
// @returns {module:engine/view/position~Position} Position after merging text nodes.


function mergeTextNodes(t1, t2) {
  // Merge text data into first text node and remove second one.
  var nodeBeforeLength = t1.data.length;
  t1._data += t2.data;

  t2._remove();

  return new position_Position(t1, nodeBeforeLength);
} // Checks if provided nodes are valid to insert. Checks if each node is an instance of
// {@link module:engine/view/text~Text Text} or {@link module:engine/view/attributeelement~AttributeElement AttributeElement},
// {@link module:engine/view/containerelement~ContainerElement ContainerElement},
// {@link module:engine/view/emptyelement~EmptyElement EmptyElement} or
// {@link module:engine/view/uielement~UIElement UIElement}.
//
// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-insert-invalid-node` when nodes to insert
// contains instances that are not {@link module:engine/view/text~Text Texts},
// {@link module:engine/view/emptyelement~EmptyElement EmptyElements},
// {@link module:engine/view/uielement~UIElement UIElements},
// {@link module:engine/view/attributeelement~AttributeElement AttributeElements} or
// {@link module:engine/view/containerelement~ContainerElement ContainerElements}.
//
// @param Iterable.<module:engine/view/text~Text|module:engine/view/attributeelement~AttributeElement
// |module:engine/view/containerelement~ContainerElement> nodes
// @param {Object} errorContext


function validateNodesToInsert(nodes, errorContext) {
  var _iterator14 = _createForOfIteratorHelper(nodes),
      _step14;

  try {
    var _loop = function _loop() {
      var node = _step14.value;

      if (!validNodesToInsert.some(function (validNode) {
        return node instanceof validNode;
      })) {
        // eslint-disable-line no-use-before-define

        /**
         * Inserted nodes should be valid to insert. of {@link module:engine/view/attributeelement~AttributeElement AttributeElement},
         * {@link module:engine/view/containerelement~ContainerElement ContainerElement},
         * {@link module:engine/view/emptyelement~EmptyElement EmptyElement},
         * {@link module:engine/view/uielement~UIElement UIElement}, {@link module:engine/view/text~Text Text}.
         *
         * @error view-writer-insert-invalid-node
         */
        throw new ckeditorerror["b" /* default */]('view-writer-insert-invalid-node', errorContext);
      }

      if (!node.is('text')) {
        validateNodesToInsert(node.getChildren(), errorContext);
      }
    };

    for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator14.e(err);
  } finally {
    _iterator14.f();
  }
}

var validNodesToInsert = [text_Text, attributeelement_AttributeElement, containerelement_ContainerElement, emptyelement_EmptyElement, uielement_UIElement]; // Checks if node is ContainerElement or DocumentFragment, because in most cases they should be treated the same way.
//
// @param {module:engine/view/node~Node} node
// @returns {Boolean} Returns `true` if node is instance of ContainerElement or DocumentFragment.

function isContainerOrFragment(node) {
  return node && (node.is('containerElement') || node.is('documentFragment'));
} // Checks if {@link module:engine/view/range~Range#start range start} and {@link module:engine/view/range~Range#end range end} are placed
// inside same {@link module:engine/view/containerelement~ContainerElement container element}.
// Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `view-writer-invalid-range-container` when validation fails.
//
// @param {module:engine/view/range~Range} range
// @param {Object} errorContext


function validateRangeContainer(range, errorContext) {
  var startContainer = getParentContainer(range.start);
  var endContainer = getParentContainer(range.end);

  if (!startContainer || !endContainer || startContainer !== endContainer) {
    /**
     * Range container is invalid. This can happen if {@link module:engine/view/range~Range#start range start} and
     * {@link module:engine/view/range~Range#end range end} positions are not placed inside same container or
     * parent container for these positions cannot be found.
     *
     * @error view-writer-invalid-range-container
     */
    throw new ckeditorerror["b" /* default */]('view-writer-invalid-range-container', errorContext);
  }
} // Checks if two attribute elements can be joined together. Elements can be joined together if, and only if
// they do not have ids specified.
//
// @private
// @param {module:engine/view/element~Element} a
// @param {module:engine/view/element~Element} b
// @returns {Boolean}


function canBeJoined(a, b) {
  return a.id === null && b.id === null;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/istext.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/dom/istext
 */

/**
 * Checks if the object is a native DOM Text node.
 *
 * @param {*} obj
 * @returns {Boolean}
 */
function istext_isText(obj) {
  return Object.prototype.toString.call(obj) == '[object Text]';
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/filler.js


/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */


/**
 * Set of utils related to block and inline fillers handling.
 *
 * Browsers do not allow to put caret in elements which does not have height. Because of it, we need to fill all
 * empty elements which should be selectable with elements or characters called "fillers". Unfortunately there is no one
 * universal filler, this is why two types are uses:
 *
 * * Block filler is an element which fill block elements, like `<p>`. CKEditor uses `<br>` as a block filler during the editing,
 * as browsers do natively. So instead of an empty `<p>` there will be `<p><br></p>`. The advantage of block filler is that
 * it is transparent for the selection, so when the caret is before the `<br>` and user presses right arrow he will be
 * moved to the next paragraph, not after the `<br>`. The disadvantage is that it breaks a block, so it can not be used
 * in the middle of a line of text. The {@link module:engine/view/filler~BR_FILLER `<br>` filler} can be replaced with any other
 * character in the data output, for instance {@link module:engine/view/filler~NBSP_FILLER non-breaking space}.
 *
 * * Inline filler is a filler which does not break a line of text, so it can be used inside the text, for instance in the empty
 * `<b>` surrendered by text: `foo<b></b>bar`, if we want to put the caret there. CKEditor uses a sequence of the zero-width
 * spaces as an {@link module:engine/view/filler~INLINE_FILLER inline filler} having the predetermined
 * {@link module:engine/view/filler~INLINE_FILLER_LENGTH length}. A sequence is used, instead of a single character to
 * avoid treating random zero-width spaces as the inline filler. Disadvantage of the inline filler is that it is not
 * transparent for the selection. The arrow key moves the caret between zero-width spaces characters, so the additional
 * code is needed to handle the caret.
 *
 * Both inline and block fillers are handled by the {@link module:engine/view/renderer~Renderer renderer} and are not present in the
 * view.
 *
 * @module engine/view/filler
 */

/**
 * Non-breaking space filler creator. This is a function which creates `&nbsp;` text node.
 * It defines how the filler is created.
 *
 * @see module:engine/view/filler~BR_FILLER
 * @function
 */

var NBSP_FILLER = function NBSP_FILLER(domDocument) {
  return domDocument.createTextNode("\xA0");
};
/**
 * `<br>` filler creator. This is a function which creates `<br data-cke-filler="true">` element.
 * It defines how the filler is created.
 *
 * @see module:engine/view/filler~NBSP_FILLER
 * @function
 */

var BR_FILLER = function BR_FILLER(domDocument) {
  var fillerBr = domDocument.createElement('br');
  fillerBr.dataset.ckeFiller = true;
  return fillerBr;
};
/**
 * Length of the {@link module:engine/view/filler~INLINE_FILLER INLINE_FILLER}.
 */

var INLINE_FILLER_LENGTH = 7;
/**
 * Inline filler which is a sequence of the zero width spaces.
 */

var INLINE_FILLER = function () {
  var inlineFiller = '';

  for (var i = 0; i < INLINE_FILLER_LENGTH; i++) {
    inlineFiller += "\u200B";
  }

  return inlineFiller;
}(); // Usu IIF so the INLINE_FILLER appears as a constant in the docs.

/**
 * Checks if the node is a text node which starts with the {@link module:engine/view/filler~INLINE_FILLER inline filler}.
 *
 *		startsWithFiller( document.createTextNode( INLINE_FILLER ) ); // true
 *		startsWithFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ); // true
 *		startsWithFiller( document.createTextNode( 'foo' ) ); // false
 *		startsWithFiller( document.createElement( 'p' ) ); // false
 *
 * @param {Node} domNode DOM node.
 * @returns {Boolean} True if the text node starts with the {@link module:engine/view/filler~INLINE_FILLER inline filler}.
 */

function startsWithFiller(domNode) {
  return istext_isText(domNode) && domNode.data.substr(0, INLINE_FILLER_LENGTH) === INLINE_FILLER;
}
/**
 * Checks if the text node contains only the {@link module:engine/view/filler~INLINE_FILLER inline filler}.
 *
 *		isInlineFiller( document.createTextNode( INLINE_FILLER ) ); // true
 *		isInlineFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ); // false
 *
 * @param {Text} domText DOM text node.
 * @returns {Boolean} True if the text node contains only the {@link module:engine/view/filler~INLINE_FILLER inline filler}.
 */

function isInlineFiller(domText) {
  return domText.data.length == INLINE_FILLER_LENGTH && startsWithFiller(domText);
}
/**
 * Get string data from the text node, removing an {@link module:engine/view/filler~INLINE_FILLER inline filler} from it,
 * if text node contains it.
 *
 *		getDataWithoutFiller( document.createTextNode( INLINE_FILLER + 'foo' ) ) == 'foo' // true
 *		getDataWithoutFiller( document.createTextNode( 'foo' ) ) == 'foo' // true
 *
 * @param {Text} domText DOM text node, possible with inline filler.
 * @returns {String} Data without filler.
 */

function getDataWithoutFiller(domText) {
  if (startsWithFiller(domText)) {
    return domText.data.slice(INLINE_FILLER_LENGTH);
  } else {
    return domText.data;
  }
}
/**
 * Assign key observer which move cursor from the end of the inline filler to the beginning of it when
 * the left arrow is pressed, so the filler does not break navigation.
 *
 * @param {module:engine/view/view~View} view View controller instance we should inject quirks handling on.
 */

function injectQuirksHandling(view) {
  view.document.on('keydown', jumpOverInlineFiller);
} // Move cursor from the end of the inline filler to the beginning of it when, so the filler does not break navigation.

function jumpOverInlineFiller(evt, data) {
  if (data.keyCode == keyCodes.arrowleft) {
    var domSelection = data.domTarget.ownerDocument.defaultView.getSelection();

    if (domSelection.rangeCount == 1 && domSelection.getRangeAt(0).collapsed) {
      var domParent = domSelection.getRangeAt(0).startContainer;
      var domOffset = domSelection.getRangeAt(0).startOffset;

      if (startsWithFiller(domParent) && domOffset <= INLINE_FILLER_LENGTH) {
        domSelection.collapse(domParent, 0);
      }
    }
  }
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/fastdiff.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/fastdiff
 */

/**
 * Finds positions of the first and last change in the given string/array and generates a set of changes:
 *
 *		fastDiff( '12a', '12xyza' );
 *		// [ { index: 2, type: 'insert', values: [ 'x', 'y', 'z' ] } ]
 *
 *		fastDiff( '12a', '12aa' );
 *		// [ { index: 3, type: 'insert', values: [ 'a' ] } ]
 *
 *		fastDiff( '12xyza', '12a' );
 *		// [ { index: 2, type: 'delete', howMany: 3 } ]
 *
 *		fastDiff( [ '1', '2', 'a', 'a' ], [ '1', '2', 'a' ] );
 *		// [ { index: 3, type: 'delete', howMany: 1 } ]
 *
 *		fastDiff( [ '1', '2', 'a', 'b', 'c', '3' ], [ '2', 'a', 'b' ] );
 *		// [ { index: 0, type: 'insert', values: [ '2', 'a', 'b' ] }, { index: 3, type: 'delete', howMany: 6 } ]
 *
 * Passed arrays can contain any type of data, however to compare them correctly custom comparator function
 * should be passed as a third parameter:
 *
 *		fastDiff( [ { value: 1 }, { value: 2 } ], [ { value: 1 }, { value: 3 } ], ( a, b ) => {
 *			return a.value === b.value;
 *		} );
 *		// [ { index: 1, type: 'insert', values: [ { value: 3 } ] }, { index: 2, type: 'delete', howMany: 1 } ]
 *
 * The resulted set of changes can be applied to the input in order to transform it into the output, for example:
 *
 *		let input = '12abc3';
 *		const output = '2ab';
 *		const changes = fastDiff( input, output );
 *
 *		changes.forEach( change => {
 *			if ( change.type == 'insert' ) {
 *				input = input.substring( 0, change.index ) + change.values.join( '' ) + input.substring( change.index );
 *			} else if ( change.type == 'delete' ) {
 *				input = input.substring( 0, change.index ) + input.substring( change.index + change.howMany );
 *			}
 *		} );
 *
 *		// input equals output now
 *
 * or in case of arrays:
 *
 *		let input = [ '1', '2', 'a', 'b', 'c', '3' ];
 *		const output = [ '2', 'a', 'b' ];
 *		const changes = fastDiff( input, output );
 *
 *		changes.forEach( change => {
 *			if ( change.type == 'insert' ) {
 *				input = input.slice( 0, change.index ).concat( change.values, input.slice( change.index ) );
 *			} else if ( change.type == 'delete' ) {
 *				input = input.slice( 0, change.index ).concat( input.slice( change.index + change.howMany ) );
 *			}
 *		} );
 *
 *		// input equals output now
 *
 * By passing `true` as the fourth parameter (`atomicChanges`) the output of this function will become compatible with
 * the {@link module:utils/diff~diff `diff()`} function:
 *
 *		fastDiff( '12a', '12xyza' );
 *		// [ 'equal', 'equal', 'insert', 'insert', 'insert', 'equal' ]
 *
 * The default output format of this function is compatible with the output format of
 * {@link module:utils/difftochanges~diffToChanges `diffToChanges()`}. The `diffToChanges()` input format is, in turn,
 * compatible with the output of {@link module:utils/diff~diff `diff()`}:
 *
 *		const a = '1234';
 *		const b = '12xyz34';
 *
 *		// Both calls will return the same results (grouped changes format).
 *		fastDiff( a, b );
 *		diffToChanges( diff( a, b ) );
 *
 *		// Again, both calls will return the same results (atomic changes format).
 *		fastDiff( a, b, null, true );
 *		diff( a, b );
 *
 *
 * @param {Array|String} a Input array or string.
 * @param {Array|String} b Input array or string.
 * @param {Function} [cmp] Optional function used to compare array values, by default `===` (strict equal operator) is used.
 * @param {Boolean} [atomicChanges=false] Whether an array of `inset|delete|equal` operations should
 * be returned instead of changes set. This makes this function compatible with {@link module:utils/diff~diff `diff()`}.
 * @returns {Array} Array of changes.
 */
function fastDiff(a, b, cmp) {
  var atomicChanges = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  // Set the comparator function.
  cmp = cmp || function (a, b) {
    return a === b;
  }; // Convert the string (or any array-like object - eg. NodeList) to an array by using the slice() method because,
  // unlike Array.from(), it returns array of UTF-16 code units instead of the code points of a string.
  // One code point might be a surrogate pair of two code units. All text offsets are expected to be in code units.
  // See ckeditor/ckeditor5#3147.
  //
  // We need to make sure here that fastDiff() works identical to diff().


  if (!Array.isArray(a)) {
    a = Array.prototype.slice.call(a);
  }

  if (!Array.isArray(b)) {
    b = Array.prototype.slice.call(b);
  } // Find first and last change.


  var changeIndexes = findChangeBoundaryIndexes(a, b, cmp); // Transform into changes array.

  return atomicChanges ? changeIndexesToAtomicChanges(changeIndexes, b.length) : changeIndexesToChanges(b, changeIndexes);
} // Finds position of the first and last change in the given arrays. For example:
//
//		const indexes = findChangeBoundaryIndexes( [ '1', '2', '3', '4' ], [ '1', '3', '4', '2', '4' ] );
//		console.log( indexes ); // { firstIndex: 1, lastIndexOld: 3, lastIndexNew: 4 }
//
// The above indexes means that in the first array the modified part is `1[23]4` and in the second array it is `1[342]4`.
// Based on such indexes, array with `insert`/`delete` operations which allows transforming first value into the second one
// can be generated.
//
// @param {Array} arr1
// @param {Array} arr2
// @param {Function} cmp Comparator function.
// @returns {Object}
// @returns {Number} return.firstIndex Index of the first change in both values (always the same for both).
// @returns {Number} result.lastIndexOld Index of the last common value in `arr1`.
// @returns {Number} result.lastIndexNew Index of the last common value in `arr2`.

function findChangeBoundaryIndexes(arr1, arr2, cmp) {
  // Find the first difference between passed values.
  var firstIndex = findFirstDifferenceIndex(arr1, arr2, cmp); // If arrays are equal return -1 indexes object.

  if (firstIndex === -1) {
    return {
      firstIndex: -1,
      lastIndexOld: -1,
      lastIndexNew: -1
    };
  } // Remove the common part of each value and reverse them to make it simpler to find the last difference between them.


  var oldArrayReversed = cutAndReverse(arr1, firstIndex);
  var newArrayReversed = cutAndReverse(arr2, firstIndex); // Find the first difference between reversed values.
  // It should be treated as "how many elements from the end the last difference occurred".
  //
  // For example:
  //
  // 				initial	->	after cut	-> reversed:
  // oldValue:	'321ba'	->	'21ba'		-> 'ab12'
  // newValue:	'31xba'	->	'1xba'		-> 'abx1'
  // lastIndex:							-> 2
  //
  // So the last change occurred two characters from the end of the arrays.

  var lastIndex = findFirstDifferenceIndex(oldArrayReversed, newArrayReversed, cmp); // Use `lastIndex` to calculate proper offset, starting from the beginning (`lastIndex` kind of starts from the end).

  var lastIndexOld = arr1.length - lastIndex;
  var lastIndexNew = arr2.length - lastIndex;
  return {
    firstIndex: firstIndex,
    lastIndexOld: lastIndexOld,
    lastIndexNew: lastIndexNew
  };
} // Returns a first index on which given arrays differ. If both arrays are the same, -1 is returned.
//
// @param {Array} arr1
// @param {Array} arr2
// @param {Function} cmp Comparator function.
// @returns {Number}


function findFirstDifferenceIndex(arr1, arr2, cmp) {
  for (var i = 0; i < Math.max(arr1.length, arr2.length); i++) {
    if (arr1[i] === undefined || arr2[i] === undefined || !cmp(arr1[i], arr2[i])) {
      return i;
    }
  }

  return -1; // Return -1 if arrays are equal.
} // Returns a copy of the given array with `howMany` elements removed starting from the beginning and in reversed order.
//
// @param {Array} arr Array to be processed.
// @param {Number} howMany How many elements from array beginning to remove.
// @returns {Array} Shortened and reversed array.


function cutAndReverse(arr, howMany) {
  return arr.slice(howMany).reverse();
} // Generates changes array based on change indexes from `findChangeBoundaryIndexes` function. This function will
// generate array with 0 (no changes), 1 (deletion or insertion) or 2 records (insertion and deletion).
//
// @param {Array} newArray New array for which change indexes were calculated.
// @param {Object} changeIndexes Change indexes object from `findChangeBoundaryIndexes` function.
// @returns {Array.<Object>} Array of changes compatible with {@link module:utils/difftochanges~diffToChanges} format.


function changeIndexesToChanges(newArray, changeIndexes) {
  var result = [];
  var firstIndex = changeIndexes.firstIndex,
      lastIndexOld = changeIndexes.lastIndexOld,
      lastIndexNew = changeIndexes.lastIndexNew; // Order operations as 'insert', 'delete' array to keep compatibility with {@link module:utils/difftochanges~diffToChanges}
  // in most cases. However, 'diffToChanges' does not stick to any order so in some cases
  // (for example replacing '12345' with 'abcd') it will generate 'delete', 'insert' order.

  if (lastIndexNew - firstIndex > 0) {
    result.push({
      index: firstIndex,
      type: 'insert',
      values: newArray.slice(firstIndex, lastIndexNew)
    });
  }

  if (lastIndexOld - firstIndex > 0) {
    result.push({
      index: firstIndex + (lastIndexNew - firstIndex),
      // Increase index of what was inserted.
      type: 'delete',
      howMany: lastIndexOld - firstIndex
    });
  }

  return result;
} // Generates array with set `equal|insert|delete` operations based on change indexes from `findChangeBoundaryIndexes` function.
//
// @param {Object} changeIndexes Change indexes object from `findChangeBoundaryIndexes` function.
// @param {Number} newLength Length of the new array on which `findChangeBoundaryIndexes` calculated change indexes.
// @returns {Array.<String>} Array of changes compatible with {@link module:utils/diff~diff} format.


function changeIndexesToAtomicChanges(changeIndexes, newLength) {
  var firstIndex = changeIndexes.firstIndex,
      lastIndexOld = changeIndexes.lastIndexOld,
      lastIndexNew = changeIndexes.lastIndexNew; // No changes.

  if (firstIndex === -1) {
    return Array(newLength).fill('equal');
  }

  var result = [];

  if (firstIndex > 0) {
    result = result.concat(Array(firstIndex).fill('equal'));
  }

  if (lastIndexNew - firstIndex > 0) {
    result = result.concat(Array(lastIndexNew - firstIndex).fill('insert'));
  }

  if (lastIndexOld - firstIndex > 0) {
    result = result.concat(Array(lastIndexOld - firstIndex).fill('delete'));
  }

  if (lastIndexNew < newLength) {
    result = result.concat(Array(newLength - lastIndexNew).fill('equal'));
  }

  return result;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/diff.js


/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/diff
 */
 // The following code is based on the "O(NP) Sequence Comparison Algorithm"
// by Sun Wu, Udi Manber, Gene Myers, Webb Miller.

/**
 * Calculates the difference between two arrays or strings producing an array containing a list of changes
 * necessary to transform input into output.
 *
 *		diff( 'aba', 'acca' ); // [ 'equal', 'insert', 'insert', 'delete', 'equal' ]
 *
 * This function is based on the "O(NP) Sequence Comparison Algorithm" by Sun Wu, Udi Manber, Gene Myers, Webb Miller.
 * Unfortunately, while it gives the most precise results, its to complex for longer strings/arrow (above 200 items).
 * Therefore, `diff()` automatically switches to {@link module:utils/fastdiff~fastDiff `fastDiff()`} when detecting
 * such a scenario. The return formats of both functions are identical.
 *
 * @param {Array|String} a Input array or string.
 * @param {Array|String} b Output array or string.
 * @param {Function} [cmp] Optional function used to compare array values, by default === is used.
 * @returns {Array} Array of changes.
 */

function diff_diff(a, b, cmp) {
  // Set the comparator function.
  cmp = cmp || function (a, b) {
    return a === b;
  };

  var aLength = a.length;
  var bLength = b.length; // Perform `fastDiff` for longer strings/arrays (see #269).

  if (aLength > 200 || bLength > 200 || aLength + bLength > 300) {
    return diff_diff.fastDiff(a, b, cmp, true);
  } // Temporary action type statics.


  var _insert, _delete; // Swapped the arrays to use the shorter one as the first one.


  if (bLength < aLength) {
    var tmp = a;
    a = b;
    b = tmp; // We swap the action types as well.

    _insert = 'delete';
    _delete = 'insert';
  } else {
    _insert = 'insert';
    _delete = 'delete';
  }

  var m = a.length;
  var n = b.length;
  var delta = n - m; // Edit scripts, for each diagonal.

  var es = {}; // Furthest points, the furthest y we can get on each diagonal.

  var fp = {};

  function snake(k) {
    // We use -1 as an alternative below to handle initial values ( instead of filling the fp with -1 first ).
    // Furthest points (y) on the diagonal below k.
    var y1 = (fp[k - 1] !== undefined ? fp[k - 1] : -1) + 1; // Furthest points (y) on the diagonal above k.

    var y2 = fp[k + 1] !== undefined ? fp[k + 1] : -1; // The way we should go to get further.

    var dir = y1 > y2 ? -1 : 1; // Clone previous changes array (if any).

    if (es[k + dir]) {
      es[k] = es[k + dir].slice(0);
    } // Create changes array.


    if (!es[k]) {
      es[k] = [];
    } // Push the action.


    es[k].push(y1 > y2 ? _insert : _delete); // Set the beginning coordinates.

    var y = Math.max(y1, y2);
    var x = y - k; // Traverse the diagonal as long as the values match.

    while (x < m && y < n && cmp(a[x], b[y])) {
      x++;
      y++; // Push no change action.

      es[k].push('equal');
    }

    return y;
  }

  var p = 0;
  var k; // Traverse the graph until we reach the end of the longer string.

  do {
    // Updates furthest points and edit scripts for diagonals below delta.
    for (k = -p; k < delta; k++) {
      fp[k] = snake(k);
    } // Updates furthest points and edit scripts for diagonals above delta.


    for (k = delta + p; k > delta; k--) {
      fp[k] = snake(k);
    } // Updates furthest point and edit script for the delta diagonal.
    // note that the delta diagonal is the one which goes through the sink (m, n).


    fp[delta] = snake(delta);
    p++;
  } while (fp[delta] !== n); // Return the final list of edit changes.
  // We remove the first item that represents the action for the injected nulls.


  return es[delta].slice(1);
} // Store the API in static property to easily overwrite it in tests.
// Too bad dependency injection does not work in Webpack + ES 6 (const) + Babel.

diff_diff.fastDiff = fastDiff;
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/insertat.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/dom/insertat
 */

/**
 * Inserts node to the parent at given index.
 *
 * @param {Element} parentElement Parent element.
 * @param {Number} index Insertions index.
 * @param {Node} nodeToInsert Node to insert.
 */
function insertat_insertAt(parentElement, index, nodeToInsert) {
  parentElement.insertBefore(nodeToInsert, parentElement.childNodes[index] || null);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/remove.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/dom/remove
 */

/**
 * Removes given node from parent.
 *
 * @param {Node} node Node to remove.
 */
function remove_remove(node) {
  var parent = node.parentNode;

  if (parent) {
    parent.removeChild(node);
  }
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/isnode.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/dom/isnode
 */

/**
 * Checks if the object is a native DOM Node.
 *
 * @param {*} obj
 * @returns {Boolean}
 */
function isNode(obj) {
  if (obj) {
    if (obj.defaultView) {
      return obj instanceof obj.defaultView.Document;
    } else if (obj.ownerDocument && obj.ownerDocument.defaultView) {
      return obj instanceof obj.ownerDocument.defaultView.Node;
    }
  }

  return false;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/renderer.js


















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* globals Node */

/**
 * @module engine/view/renderer
 */













/**
 * Renderer is responsible for updating the DOM structure and the DOM selection based on
 * the {@link module:engine/view/renderer~Renderer#markToSync information about updated view nodes}.
 * In other words, it renders the view to the DOM.
 *
 * Its main responsibility is to make only the necessary, minimal changes to the DOM. However, unlike in many
 * virtual DOM implementations, the primary reason for doing minimal changes is not the performance but ensuring
 * that native editing features such as text composition, autocompletion, spell checking, selection's x-index are
 * affected as little as possible.
 *
 * Renderer uses {@link module:engine/view/domconverter~DomConverter} to transform view nodes and positions
 * to and from the DOM.
 */

var renderer_Renderer = /*#__PURE__*/function () {
  /**
   * Creates a renderer instance.
   *
   * @param {module:engine/view/domconverter~DomConverter} domConverter Converter instance.
   * @param {module:engine/view/documentselection~DocumentSelection} selection View selection.
   */
  function Renderer(domConverter, selection) {
    Object(classCallCheck["a" /* default */])(this, Renderer);

    /**
     * Set of DOM Documents instances.
     *
     * @readonly
     * @member {Set.<Document>}
     */
    this.domDocuments = new Set();
    /**
     * Converter instance.
     *
     * @readonly
     * @member {module:engine/view/domconverter~DomConverter}
     */

    this.domConverter = domConverter;
    /**
     * Set of nodes which attributes changed and may need to be rendered.
     *
     * @readonly
     * @member {Set.<module:engine/view/node~Node>}
     */

    this.markedAttributes = new Set();
    /**
     * Set of elements which child lists changed and may need to be rendered.
     *
     * @readonly
     * @member {Set.<module:engine/view/node~Node>}
     */

    this.markedChildren = new Set();
    /**
     * Set of text nodes which text data changed and may need to be rendered.
     *
     * @readonly
     * @member {Set.<module:engine/view/node~Node>}
     */

    this.markedTexts = new Set();
    /**
     * View selection. Renderer updates DOM selection based on the view selection.
     *
     * @readonly
     * @member {module:engine/view/documentselection~DocumentSelection}
     */

    this.selection = selection;
    /**
     * Indicates if the view document is focused and selection can be rendered. Selection will not be rendered if
     * this is set to `false`.
     *
     * @member {Boolean}
     */

    this.isFocused = false;
    /**
     * The text node in which the inline filler was rendered.
     *
     * @private
     * @member {Text}
     */

    this._inlineFiller = null;
    /**
     * DOM element containing fake selection.
     *
     * @private
     * @type {null|HTMLElement}
     */

    this._fakeSelectionContainer = null;
  }
  /**
   * Marks a view node to be updated in the DOM by {@link #render `render()`}.
   *
   * Note that only view nodes whose parents have corresponding DOM elements need to be marked to be synchronized.
   *
   * @see #markedAttributes
   * @see #markedChildren
   * @see #markedTexts
   *
   * @param {module:engine/view/document~ChangeType} type Type of the change.
   * @param {module:engine/view/node~Node} node Node to be marked.
   */


  Object(createClass["a" /* default */])(Renderer, [{
    key: "markToSync",
    value: function markToSync(type, node) {
      if (type === 'text') {
        if (this.domConverter.mapViewToDom(node.parent)) {
          this.markedTexts.add(node);
        }
      } else {
        // If the node has no DOM element it is not rendered yet,
        // its children/attributes do not need to be marked to be sync.
        if (!this.domConverter.mapViewToDom(node)) {
          return;
        }

        if (type === 'attributes') {
          this.markedAttributes.add(node);
        } else if (type === 'children') {
          this.markedChildren.add(node);
        } else {
          /**
           * Unknown type passed to Renderer.markToSync.
           *
           * @error renderer-unknown-type
           */
          throw new ckeditorerror["b" /* default */]('view-renderer-unknown-type: Unknown type passed to Renderer.markToSync.', this);
        }
      }
    }
    /**
     * Renders all buffered changes ({@link #markedAttributes}, {@link #markedChildren} and {@link #markedTexts}) and
     * the current view selection (if needed) to the DOM by applying a minimal set of changes to it.
     *
     * Renderer tries not to break the text composition (e.g. IME) and x-index of the selection,
     * so it does as little as it is needed to update the DOM.
     *
     * Renderer also handles {@link module:engine/view/filler fillers}. Especially, it checks if the inline filler is needed
     * at the selection position and adds or removes it. To prevent breaking text composition inline filler will not be
     * removed as long as the selection is in the text node which needed it at first.
     */

  }, {
    key: "render",
    value: function render() {
      var inlineFillerPosition; // Refresh mappings.

      var _iterator = _createForOfIteratorHelper(this.markedChildren),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var element = _step.value;

          this._updateChildrenMappings(element);
        } // There was inline filler rendered in the DOM but it's not
        // at the selection position any more, so we can remove it
        // (cause even if it's needed, it must be placed in another location).

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if (this._inlineFiller && !this._isSelectionInInlineFiller()) {
        this._removeInlineFiller();
      } // If we've got the filler, let's try to guess its position in the view.


      if (this._inlineFiller) {
        inlineFillerPosition = this._getInlineFillerPosition();
      } // Otherwise, if it's needed, create it at the selection position.
      else if (this._needsInlineFillerAtSelection()) {
          inlineFillerPosition = this.selection.getFirstPosition(); // Do not use `markToSync` so it will be added even if the parent is already added.

          this.markedChildren.add(inlineFillerPosition.parent);
        }

      var _iterator2 = _createForOfIteratorHelper(this.markedAttributes),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _element = _step2.value;

          this._updateAttrs(_element);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var _iterator3 = _createForOfIteratorHelper(this.markedChildren),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _element2 = _step3.value;

          this._updateChildren(_element2, {
            inlineFillerPosition: inlineFillerPosition
          });
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      var _iterator4 = _createForOfIteratorHelper(this.markedTexts),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var node = _step4.value;

          if (!this.markedChildren.has(node.parent) && this.domConverter.mapViewToDom(node.parent)) {
            this._updateText(node, {
              inlineFillerPosition: inlineFillerPosition
            });
          }
        } // Check whether the inline filler is required and where it really is in the DOM.
        // At this point in most cases it will be in the DOM, but there are exceptions.
        // For example, if the inline filler was deep in the created DOM structure, it will not be created.
        // Similarly, if it was removed at the beginning of this function and then neither text nor children were updated,
        // it will not be present.
        // Fix those and similar scenarios.

      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      if (inlineFillerPosition) {
        var fillerDomPosition = this.domConverter.viewPositionToDom(inlineFillerPosition);
        var domDocument = fillerDomPosition.parent.ownerDocument;

        if (!startsWithFiller(fillerDomPosition.parent)) {
          // Filler has not been created at filler position. Create it now.
          this._inlineFiller = addInlineFiller(domDocument, fillerDomPosition.parent, fillerDomPosition.offset);
        } else {
          // Filler has been found, save it.
          this._inlineFiller = fillerDomPosition.parent;
        }
      } else {
        // There is no filler needed.
        this._inlineFiller = null;
      }

      this._updateSelection();

      this._updateFocus();

      this.markedTexts.clear();
      this.markedAttributes.clear();
      this.markedChildren.clear();
    }
    /**
     * Updates mappings of view element's children.
     *
     * Children that were replaced in the view structure by similar elements (same tag name) are treated as 'replaced'.
     * This means that their mappings can be updated so the new view elements are mapped to the existing DOM elements.
     * Thanks to that these elements do not need to be re-rendered completely.
     *
     * @private
     * @param {module:engine/view/node~Node} viewElement The view element whose children mappings will be updated.
     */

  }, {
    key: "_updateChildrenMappings",
    value: function _updateChildrenMappings(viewElement) {
      var domElement = this.domConverter.mapViewToDom(viewElement);

      if (!domElement) {
        // If there is no `domElement` it means that it was already removed from DOM and there is no need to process it.
        return;
      }

      var actualDomChildren = this.domConverter.mapViewToDom(viewElement).childNodes;
      var expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, domElement.ownerDocument, {
        withChildren: false
      }));

      var diff = this._diffNodeLists(actualDomChildren, expectedDomChildren);

      var actions = this._findReplaceActions(diff, actualDomChildren, expectedDomChildren);

      if (actions.indexOf('replace') !== -1) {
        var counter = {
          equal: 0,
          insert: 0,
          delete: 0
        };

        var _iterator5 = _createForOfIteratorHelper(actions),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var action = _step5.value;

            if (action === 'replace') {
              var insertIndex = counter.equal + counter.insert;
              var deleteIndex = counter.equal + counter.delete;
              var viewChild = viewElement.getChild(insertIndex); // The 'uiElement' is a special one and its children are not stored in a view (#799),
              // so we cannot use it with replacing flow (since it uses view children during rendering
              // which will always result in rendering empty element).

              if (viewChild && !viewChild.is('uiElement')) {
                this._updateElementMappings(viewChild, actualDomChildren[deleteIndex]);
              }

              remove_remove(expectedDomChildren[insertIndex]);
              counter.equal++;
            } else {
              counter[action]++;
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      }
    }
    /**
     * Updates mappings of a given view element.
     *
     * @private
     * @param {module:engine/view/node~Node} viewElement The view element whose mappings will be updated.
     * @param {Node} domElement The DOM element representing the given view element.
     */

  }, {
    key: "_updateElementMappings",
    value: function _updateElementMappings(viewElement, domElement) {
      // Remap 'DomConverter' bindings.
      this.domConverter.unbindDomElement(domElement);
      this.domConverter.bindElements(domElement, viewElement); // View element may have children which needs to be updated, but are not marked, mark them to update.

      this.markedChildren.add(viewElement); // Because we replace new view element mapping with the existing one, the corresponding DOM element
      // will not be rerendered. The new view element may have different attributes than the previous one.
      // Since its corresponding DOM element will not be rerendered, new attributes will not be added
      // to the DOM, so we need to mark it here to make sure its attributes gets updated. See #1427 for more
      // detailed case study.
      // Also there are cases where replaced element is removed from the view structure and then has
      // its attributes changed or removed. In such cases the element will not be present in `markedAttributes`
      // and also may be the same (`element.isSimilar()`) as the reused element not having its attributes updated.
      // To prevent such situations we always mark reused element to have its attributes rerenderd (#1560).

      this.markedAttributes.add(viewElement);
    }
    /**
     * Gets the position of the inline filler based on the current selection.
     * Here, we assume that we know that the filler is needed and
     * {@link #_isSelectionInInlineFiller is at the selection position}, and, since it is needed,
     * it is somewhere at the selection position.
     *
     * Note: The filler position cannot be restored based on the filler's DOM text node, because
     * when this method is called (before rendering), the bindings will often be broken. View-to-DOM
     * bindings are only dependable after rendering.
     *
     * @private
     * @returns {module:engine/view/position~Position}
     */

  }, {
    key: "_getInlineFillerPosition",
    value: function _getInlineFillerPosition() {
      var firstPos = this.selection.getFirstPosition();

      if (firstPos.parent.is('text')) {
        return position_Position._createBefore(this.selection.getFirstPosition().parent);
      } else {
        return firstPos;
      }
    }
    /**
     * Returns `true` if the selection has not left the inline filler's text node.
     * If it is `true`, it means that the filler had been added for a reason and the selection did not
     * leave the filler's text node. For example, the user can be in the middle of a composition so it should not be touched.
     *
     * @private
     * @returns {Boolean} `true` if the inline filler and selection are in the same place.
     */

  }, {
    key: "_isSelectionInInlineFiller",
    value: function _isSelectionInInlineFiller() {
      if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
        return false;
      } // Note, we can't check if selection's position equals position of the
      // this._inlineFiller node, because of #663. We may not be able to calculate
      // the filler's position in the view at this stage.
      // Instead, we check it the other way – whether selection is anchored in
      // that text node or next to it.
      // Possible options are:
      // "FILLER{}"
      // "FILLERadded-text{}"


      var selectionPosition = this.selection.getFirstPosition();
      var position = this.domConverter.viewPositionToDom(selectionPosition);

      if (position && istext_isText(position.parent) && startsWithFiller(position.parent)) {
        return true;
      }

      return false;
    }
    /**
     * Removes the inline filler.
     *
     * @private
     */

  }, {
    key: "_removeInlineFiller",
    value: function _removeInlineFiller() {
      var domFillerNode = this._inlineFiller; // Something weird happened and the stored node doesn't contain the filler's text.

      if (!startsWithFiller(domFillerNode)) {
        /**
         * The inline filler node was lost. Most likely, something overwrote the filler text node
         * in the DOM.
         *
         * @error view-renderer-filler-was-lost
         */
        throw new ckeditorerror["b" /* default */]('view-renderer-filler-was-lost: The inline filler node was lost.', this);
      }

      if (isInlineFiller(domFillerNode)) {
        domFillerNode.parentNode.removeChild(domFillerNode);
      } else {
        domFillerNode.data = domFillerNode.data.substr(INLINE_FILLER_LENGTH);
      }

      this._inlineFiller = null;
    }
    /**
     * Checks if the inline {@link module:engine/view/filler filler} should be added.
     *
     * @private
     * @returns {Boolean} `true` if the inline filler should be added.
     */

  }, {
    key: "_needsInlineFillerAtSelection",
    value: function _needsInlineFillerAtSelection() {
      if (this.selection.rangeCount != 1 || !this.selection.isCollapsed) {
        return false;
      }

      var selectionPosition = this.selection.getFirstPosition();
      var selectionParent = selectionPosition.parent;
      var selectionOffset = selectionPosition.offset; // If there is no DOM root we do not care about fillers.

      if (!this.domConverter.mapViewToDom(selectionParent.root)) {
        return false;
      }

      if (!selectionParent.is('element')) {
        return false;
      } // Prevent adding inline filler inside elements with contenteditable=false.
      // https://github.com/ckeditor/ckeditor5-engine/issues/1170


      if (!isEditable(selectionParent)) {
        return false;
      } // We have block filler, we do not need inline one.


      if (selectionOffset === selectionParent.getFillerOffset()) {
        return false;
      }

      var nodeBefore = selectionPosition.nodeBefore;
      var nodeAfter = selectionPosition.nodeAfter;

      if (nodeBefore instanceof text_Text || nodeAfter instanceof text_Text) {
        return false;
      }

      return true;
    }
    /**
     * Checks if text needs to be updated and possibly updates it.
     *
     * @private
     * @param {module:engine/view/text~Text} viewText View text to update.
     * @param {Object} options
     * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline
     * filler should be rendered.
     */

  }, {
    key: "_updateText",
    value: function _updateText(viewText, options) {
      var domText = this.domConverter.findCorrespondingDomText(viewText);
      var newDomText = this.domConverter.viewToDom(viewText, domText.ownerDocument);
      var actualText = domText.data;
      var expectedText = newDomText.data;
      var filler = options.inlineFillerPosition;

      if (filler && filler.parent == viewText.parent && filler.offset == viewText.index) {
        expectedText = INLINE_FILLER + expectedText;
      }

      if (actualText != expectedText) {
        var actions = fastDiff(actualText, expectedText);

        var _iterator6 = _createForOfIteratorHelper(actions),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var action = _step6.value;

            if (action.type === 'insert') {
              domText.insertData(action.index, action.values.join(''));
            } else {
              // 'delete'
              domText.deleteData(action.index, action.howMany);
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
      }
    }
    /**
     * Checks if attribute list needs to be updated and possibly updates it.
     *
     * @private
     * @param {module:engine/view/element~Element} viewElement The view element to update.
     */

  }, {
    key: "_updateAttrs",
    value: function _updateAttrs(viewElement) {
      var domElement = this.domConverter.mapViewToDom(viewElement);

      if (!domElement) {
        // If there is no `domElement` it means that 'viewElement' is outdated as its mapping was updated
        // in 'this._updateChildrenMappings()'. There is no need to process it as new view element which
        // replaced old 'viewElement' mapping was also added to 'this.markedAttributes'
        // in 'this._updateChildrenMappings()' so it will be processed separately.
        return;
      }

      var domAttrKeys = Array.from(domElement.attributes).map(function (attr) {
        return attr.name;
      });
      var viewAttrKeys = viewElement.getAttributeKeys(); // Add or overwrite attributes.

      var _iterator7 = _createForOfIteratorHelper(viewAttrKeys),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var key = _step7.value;
          domElement.setAttribute(key, viewElement.getAttribute(key));
        } // Remove from DOM attributes which do not exists in the view.

      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }

      var _iterator8 = _createForOfIteratorHelper(domAttrKeys),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var _key = _step8.value;

          if (!viewElement.hasAttribute(_key)) {
            domElement.removeAttribute(_key);
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
    }
    /**
     * Checks if elements child list needs to be updated and possibly updates it.
     *
     * @private
     * @param {module:engine/view/element~Element} viewElement View element to update.
     * @param {Object} options
     * @param {module:engine/view/position~Position} options.inlineFillerPosition The position where the inline
     * filler should be rendered.
     */

  }, {
    key: "_updateChildren",
    value: function _updateChildren(viewElement, options) {
      var domElement = this.domConverter.mapViewToDom(viewElement);

      if (!domElement) {
        // If there is no `domElement` it means that it was already removed from DOM.
        // There is no need to process it. It will be processed when re-inserted.
        return;
      }

      var inlineFillerPosition = options.inlineFillerPosition;
      var actualDomChildren = this.domConverter.mapViewToDom(viewElement).childNodes;
      var expectedDomChildren = Array.from(this.domConverter.viewChildrenToDom(viewElement, domElement.ownerDocument, {
        bind: true,
        inlineFillerPosition: inlineFillerPosition
      })); // Inline filler element has to be created as it is present in the DOM, but not in the view. It is required
      // during diffing so text nodes could be compared correctly and also during rendering to maintain
      // proper order and indexes while updating the DOM.

      if (inlineFillerPosition && inlineFillerPosition.parent === viewElement) {
        addInlineFiller(domElement.ownerDocument, expectedDomChildren, inlineFillerPosition.offset);
      }

      var diff = this._diffNodeLists(actualDomChildren, expectedDomChildren);

      var i = 0;
      var nodesToUnbind = new Set(); // Handle deletions first.
      // This is to prevent a situation where an element that already exists in `actualDomChildren` is inserted at a different
      // index in `actualDomChildren`. Since `actualDomChildren` is a `NodeList`, this works like move, not like an insert,
      // and it disrupts the whole algorithm. See https://github.com/ckeditor/ckeditor5/issues/6367.
      //
      // It doesn't matter in what order we remove or add nodes, as long as we remove and add correct nodes at correct indexes.

      var _iterator9 = _createForOfIteratorHelper(diff),
          _step9;

      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var action = _step9.value;

          if (action === 'delete') {
            nodesToUnbind.add(actualDomChildren[i]);
            remove_remove(actualDomChildren[i]);
          } else if (action === 'equal') {
            i++;
          }
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }

      i = 0;

      var _iterator10 = _createForOfIteratorHelper(diff),
          _step10;

      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var _action = _step10.value;

          if (_action === 'insert') {
            insertat_insertAt(domElement, i, expectedDomChildren[i]);
            i++;
          } else if (_action === 'equal') {
            // Force updating text nodes inside elements which did not change and do not need to be re-rendered (#1125).
            // Do it here (not in the loop above) because only after insertions the `i` index is correct.
            this._markDescendantTextToSync(this.domConverter.domToView(expectedDomChildren[i]));

            i++;
          }
        } // Unbind removed nodes. When node does not have a parent it means that it was removed from DOM tree during
        // comparison with the expected DOM. We don't need to check child nodes, because if child node was reinserted,
        // it was moved to DOM tree out of the removed node.

      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }

      var _iterator11 = _createForOfIteratorHelper(nodesToUnbind),
          _step11;

      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var node = _step11.value;

          if (!node.parentNode) {
            this.domConverter.unbindDomElement(node);
          }
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }
    }
    /**
     * Shorthand for diffing two arrays or node lists of DOM nodes.
     *
     * @private
     * @param {Array.<Node>|NodeList} actualDomChildren Actual DOM children
     * @param {Array.<Node>|NodeList} expectedDomChildren Expected DOM children.
     * @returns {Array.<String>} The list of actions based on the {@link module:utils/diff~diff} function.
     */

  }, {
    key: "_diffNodeLists",
    value: function _diffNodeLists(actualDomChildren, expectedDomChildren) {
      actualDomChildren = filterOutFakeSelectionContainer(actualDomChildren, this._fakeSelectionContainer);
      return diff_diff(actualDomChildren, expectedDomChildren, renderer_sameNodes.bind(null, this.domConverter));
    }
    /**
     * Finds DOM nodes that were replaced with the similar nodes (same tag name) in the view. All nodes are compared
     * within one `insert`/`delete` action group, for example:
     *
     * 		Actual DOM:		<p><b>Foo</b>Bar<i>Baz</i><b>Bax</b></p>
     * 		Expected DOM:	<p>Bar<b>123</b><i>Baz</i><b>456</b></p>
     * 		Input actions:	[ insert, insert, delete, delete, equal, insert, delete ]
     * 		Output actions:	[ insert, replace, delete, equal, replace ]
     *
     * @private
     * @param {Array.<String>} actions Actions array which is a result of the {@link module:utils/diff~diff} function.
     * @param {Array.<Node>|NodeList} actualDom Actual DOM children
     * @param {Array.<Node>} expectedDom Expected DOM children.
     * @returns {Array.<String>} Actions array modified with the `replace` actions.
     */

  }, {
    key: "_findReplaceActions",
    value: function _findReplaceActions(actions, actualDom, expectedDom) {
      // If there is no both 'insert' and 'delete' actions, no need to check for replaced elements.
      if (actions.indexOf('insert') === -1 || actions.indexOf('delete') === -1) {
        return actions;
      }

      var newActions = [];
      var actualSlice = [];
      var expectedSlice = [];
      var counter = {
        equal: 0,
        insert: 0,
        delete: 0
      };

      var _iterator12 = _createForOfIteratorHelper(actions),
          _step12;

      try {
        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
          var action = _step12.value;

          if (action === 'insert') {
            expectedSlice.push(expectedDom[counter.equal + counter.insert]);
          } else if (action === 'delete') {
            actualSlice.push(actualDom[counter.equal + counter.delete]);
          } else {
            // equal
            newActions = newActions.concat(diff_diff(actualSlice, expectedSlice, areSimilar).map(function (x) {
              return x === 'equal' ? 'replace' : x;
            }));
            newActions.push('equal'); // Reset stored elements on 'equal'.

            actualSlice = [];
            expectedSlice = [];
          }

          counter[action]++;
        }
      } catch (err) {
        _iterator12.e(err);
      } finally {
        _iterator12.f();
      }

      return newActions.concat(diff_diff(actualSlice, expectedSlice, areSimilar).map(function (x) {
        return x === 'equal' ? 'replace' : x;
      }));
    }
    /**
     * Marks text nodes to be synchronized.
     *
     * If a text node is passed, it will be marked. If an element is passed, all descendant text nodes inside it will be marked.
     *
     * @private
     * @param {module:engine/view/node~Node} viewNode View node to sync.
     */

  }, {
    key: "_markDescendantTextToSync",
    value: function _markDescendantTextToSync(viewNode) {
      if (!viewNode) {
        return;
      }

      if (viewNode.is('text')) {
        this.markedTexts.add(viewNode);
      } else if (viewNode.is('element')) {
        var _iterator13 = _createForOfIteratorHelper(viewNode.getChildren()),
            _step13;

        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
            var child = _step13.value;

            this._markDescendantTextToSync(child);
          }
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }
      }
    }
    /**
     * Checks if the selection needs to be updated and possibly updates it.
     *
     * @private
     */

  }, {
    key: "_updateSelection",
    value: function _updateSelection() {
      // If there is no selection - remove DOM and fake selections.
      if (this.selection.rangeCount === 0) {
        this._removeDomSelection();

        this._removeFakeSelection();

        return;
      }

      var domRoot = this.domConverter.mapViewToDom(this.selection.editableElement); // Do nothing if there is no focus, or there is no DOM element corresponding to selection's editable element.

      if (!this.isFocused || !domRoot) {
        return;
      } // Render selection.


      if (this.selection.isFake) {
        this._updateFakeSelection(domRoot);
      } else {
        this._removeFakeSelection();

        this._updateDomSelection(domRoot);
      }
    }
    /**
     * Updates the fake selection.
     *
     * @private
     * @param {HTMLElement} domRoot A valid DOM root where the fake selection container should be added.
     */

  }, {
    key: "_updateFakeSelection",
    value: function _updateFakeSelection(domRoot) {
      var domDocument = domRoot.ownerDocument;

      if (!this._fakeSelectionContainer) {
        this._fakeSelectionContainer = createFakeSelectionContainer(domDocument);
      }

      var container = this._fakeSelectionContainer; // Bind fake selection container with the current selection *position*.

      this.domConverter.bindFakeSelection(container, this.selection);

      if (!this._fakeSelectionNeedsUpdate(domRoot)) {
        return;
      }

      if (!container.parentElement || container.parentElement != domRoot) {
        domRoot.appendChild(container);
      }

      container.textContent = this.selection.fakeSelectionLabel || "\xA0";
      var domSelection = domDocument.getSelection();
      var domRange = domDocument.createRange();
      domSelection.removeAllRanges();
      domRange.selectNodeContents(container);
      domSelection.addRange(domRange);
    }
    /**
     * Updates the DOM selection.
     *
     * @private
     * @param {HTMLElement} domRoot A valid DOM root where the DOM selection should be rendered.
     */

  }, {
    key: "_updateDomSelection",
    value: function _updateDomSelection(domRoot) {
      var domSelection = domRoot.ownerDocument.defaultView.getSelection(); // Let's check whether DOM selection needs updating at all.

      if (!this._domSelectionNeedsUpdate(domSelection)) {
        return;
      } // Multi-range selection is not available in most browsers, and, at least in Chrome, trying to
      // set such selection, that is not continuous, throws an error. Because of that, we will just use anchor
      // and focus of view selection.
      // Since we are not supporting multi-range selection, we also do not need to check if proper editable is
      // selected. If there is any editable selected, it is okay (editable is taken from selection anchor).


      var anchor = this.domConverter.viewPositionToDom(this.selection.anchor);
      var focus = this.domConverter.viewPositionToDom(this.selection.focus); // Focus the new editing host.
      // Otherwise, FF may throw an error (https://github.com/ckeditor/ckeditor5/issues/721).

      domRoot.focus();
      domSelection.collapse(anchor.parent, anchor.offset);
      domSelection.extend(focus.parent, focus.offset); // Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).

      if (src_env.isGecko) {
        fixGeckoSelectionAfterBr(focus, domSelection);
      }
    }
    /**
     * Checks whether a given DOM selection needs to be updated.
     *
     * @private
     * @param {Selection} domSelection The DOM selection to check.
     * @returns {Boolean}
     */

  }, {
    key: "_domSelectionNeedsUpdate",
    value: function _domSelectionNeedsUpdate(domSelection) {
      if (!this.domConverter.isDomSelectionCorrect(domSelection)) {
        // Current DOM selection is in incorrect position. We need to update it.
        return true;
      }

      var oldViewSelection = domSelection && this.domConverter.domSelectionToView(domSelection);

      if (oldViewSelection && this.selection.isEqual(oldViewSelection)) {
        return false;
      } // If selection is not collapsed, it does not need to be updated if it is similar.


      if (!this.selection.isCollapsed && this.selection.isSimilar(oldViewSelection)) {
        // Selection did not changed and is correct, do not update.
        return false;
      } // Selections are not similar.


      return true;
    }
    /**
     * Checks whether the fake selection needs to be updated.
     *
     * @private
     * @param {HTMLElement} domRoot A valid DOM root where a new fake selection container should be added.
     * @returns {Boolean}
     */

  }, {
    key: "_fakeSelectionNeedsUpdate",
    value: function _fakeSelectionNeedsUpdate(domRoot) {
      var container = this._fakeSelectionContainer;
      var domSelection = domRoot.ownerDocument.getSelection(); // Fake selection needs to be updated if there's no fake selection container, or the container currently sits
      // in a different root.

      if (!container || container.parentElement !== domRoot) {
        return true;
      } // Make sure that the selection actually is within the fake selection.


      if (domSelection.anchorNode !== container && !container.contains(domSelection.anchorNode)) {
        return true;
      }

      return container.textContent !== this.selection.fakeSelectionLabel;
    }
    /**
     * Removes the DOM selection.
     *
     * @private
     */

  }, {
    key: "_removeDomSelection",
    value: function _removeDomSelection() {
      var _iterator14 = _createForOfIteratorHelper(this.domDocuments),
          _step14;

      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var doc = _step14.value;
          var domSelection = doc.getSelection();

          if (domSelection.rangeCount) {
            var activeDomElement = doc.activeElement;
            var viewElement = this.domConverter.mapDomToView(activeDomElement);

            if (activeDomElement && viewElement) {
              doc.getSelection().removeAllRanges();
            }
          }
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }
    }
    /**
     * Removes the fake selection.
     *
     * @private
     */

  }, {
    key: "_removeFakeSelection",
    value: function _removeFakeSelection() {
      var container = this._fakeSelectionContainer;

      if (container) {
        container.remove();
      }
    }
    /**
     * Checks if focus needs to be updated and possibly updates it.
     *
     * @private
     */

  }, {
    key: "_updateFocus",
    value: function _updateFocus() {
      if (this.isFocused) {
        var editable = this.selection.editableElement;

        if (editable) {
          this.domConverter.focus(editable);
        }
      }
    }
  }]);

  return Renderer;
}();


mix(renderer_Renderer, observablemixin); // Checks if provided element is editable.
//
// @private
// @param {module:engine/view/element~Element} element
// @returns {Boolean}

function isEditable(element) {
  if (element.getAttribute('contenteditable') == 'false') {
    return false;
  }

  var parent = element.findAncestor(function (element) {
    return element.hasAttribute('contenteditable');
  });
  return !parent || parent.getAttribute('contenteditable') == 'true';
} // Adds inline filler at a given position.
//
// The position can be given as an array of DOM nodes and an offset in that array,
// or a DOM parent element and an offset in that element.
//
// @private
// @param {Document} domDocument
// @param {Element|Array.<Node>} domParentOrArray
// @param {Number} offset
// @returns {Text} The DOM text node that contains an inline filler.


function addInlineFiller(domDocument, domParentOrArray, offset) {
  var childNodes = domParentOrArray instanceof Array ? domParentOrArray : domParentOrArray.childNodes;
  var nodeAfterFiller = childNodes[offset];

  if (istext_isText(nodeAfterFiller)) {
    nodeAfterFiller.data = INLINE_FILLER + nodeAfterFiller.data;
    return nodeAfterFiller;
  } else {
    var fillerNode = domDocument.createTextNode(INLINE_FILLER);

    if (Array.isArray(domParentOrArray)) {
      childNodes.splice(offset, 0, fillerNode);
    } else {
      insertat_insertAt(domParentOrArray, offset, fillerNode);
    }

    return fillerNode;
  }
} // Whether two DOM nodes should be considered as similar.
// Nodes are considered similar if they have the same tag name.
//
// @private
// @param {Node} node1
// @param {Node} node2
// @returns {Boolean}


function areSimilar(node1, node2) {
  return isNode(node1) && isNode(node2) && !istext_isText(node1) && !istext_isText(node2) && node1.nodeType !== Node.COMMENT_NODE && node2.nodeType !== Node.COMMENT_NODE && node1.tagName.toLowerCase() === node2.tagName.toLowerCase();
} // Whether two dom nodes should be considered as the same.
// Two nodes which are considered the same are:
//
//		* Text nodes with the same text.
//		* Element nodes represented by the same object.
//		* Two block filler elements.
//
// @private
// @param {String} blockFillerMode Block filler mode, see {@link module:engine/view/domconverter~DomConverter#blockFillerMode}.
// @param {Node} node1
// @param {Node} node2
// @returns {Boolean}


function renderer_sameNodes(domConverter, actualDomChild, expectedDomChild) {
  // Elements.
  if (actualDomChild === expectedDomChild) {
    return true;
  } // Texts.
  else if (istext_isText(actualDomChild) && istext_isText(expectedDomChild)) {
      return actualDomChild.data === expectedDomChild.data;
    } // Block fillers.
    else if (domConverter.isBlockFiller(actualDomChild) && domConverter.isBlockFiller(expectedDomChild)) {
        return true;
      } // Not matching types.


  return false;
} // The following is a Firefox–specific hack (https://github.com/ckeditor/ckeditor5-engine/issues/1439).
// When the native DOM selection is at the end of the block and preceded by <br /> e.g.
//
//		<p>foo<br/>[]</p>
//
// which happens a lot when using the soft line break, the browser fails to (visually) move the
// caret to the new line. A quick fix is as simple as force–refreshing the selection with the same range.


function fixGeckoSelectionAfterBr(focus, domSelection) {
  var parent = focus.parent; // This fix works only when the focus point is at the very end of an element.
  // There is no point in running it in cases unrelated to the browser bug.

  if (parent.nodeType != Node.ELEMENT_NODE || focus.offset != parent.childNodes.length - 1) {
    return;
  }

  var childAtOffset = parent.childNodes[focus.offset]; // To stay on the safe side, the fix being as specific as possible, it targets only the
  // selection which is at the very end of the element and preceded by <br />.

  if (childAtOffset && childAtOffset.tagName == 'BR') {
    domSelection.addRange(domSelection.getRangeAt(0));
  }
}

function filterOutFakeSelectionContainer(domChildList, fakeSelectionContainer) {
  var childList = Array.from(domChildList);

  if (childList.length == 0 || !fakeSelectionContainer) {
    return childList;
  }

  var last = childList[childList.length - 1];

  if (last == fakeSelectionContainer) {
    childList.pop();
  }

  return childList;
} // Creates a fake selection container for a given document.
//
// @private
// @param {Document} domDocument
// @returns {HTMLElement}


function createFakeSelectionContainer(domDocument) {
  var container = domDocument.createElement('div');
  Object.assign(container.style, {
    position: 'fixed',
    top: 0,
    left: '-9999px',
    // See https://github.com/ckeditor/ckeditor5/issues/752.
    width: '42px'
  }); // Fill it with a text node so we can update it later.

  container.textContent = "\xA0";
  return container;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/global.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* globals window, document */

/**
 * @module utils/dom/global
 */

/**
 * A helper (module) giving an access to the global DOM objects such as `window` and
 * `document`. Accessing these objects using this helper allows easy and bulletproof
 * testing, i.e. stubbing native properties:
 *
 *		import global from 'ckeditor5/utils/dom/global.js';
 *
 *		// This stub will work for any code using global module.
 *		testUtils.sinon.stub( global, 'window', {
 *			innerWidth: 10000
 *		} );
 *
 *		console.log( global.window.innerWidth );
 */
/* harmony default export */ var global = ({
  window: window,
  document: document
});
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/indexof.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/dom/indexof
 */

/**
 * Returns index of the node in the parent element.
 *
 * @param {Node} node Node which index is tested.
 * @returns {Number} Index of the node in the parent element. Returns 0 if node has no parent.
 */
function indexOf(node) {
  var index = 0;

  while (node.previousSibling) {
    node = node.previousSibling;
    index++;
  }

  return index;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/getancestors.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* globals Node */

/**
 * @module utils/dom/getancestors
 */

/**
 * Returns all ancestors of given DOM node, starting from the top-most (root). Includes the given node itself. If the
 * node is a part of `DocumentFragment` that `DocumentFragment` will be returned. In contrary, if the node is
 * appended to a `Document`, that `Document` will not be returned (algorithms operating on DOM tree care for `Document#documentElement`
 * at most, which will be returned).
 *
 * @param {Node} node DOM node.
 * @returns {Array.<Node|DocumentFragment>} Array of given `node` parents.
 */
function getAncestors(node) {
  var nodes = []; // We are interested in `Node`s `DocumentFragment`s only.

  while (node && node.nodeType != Node.DOCUMENT_NODE) {
    nodes.unshift(node);
    node = node.parentNode;
  }

  return nodes;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/getcommonancestor.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/dom/getcommonancestor
 */

/**
 * Searches and returns the lowest common ancestor of two given nodes.
 *
 * @param {Node} nodeA First node.
 * @param {Node} nodeB Second node.
 * @returns {Node|DocumentFragment|Document|null} Lowest common ancestor of both nodes or `null` if nodes do not have a common ancestor.
 */

function getCommonAncestor(nodeA, nodeB) {
  var ancestorsA = getAncestors(nodeA);
  var ancestorsB = getAncestors(nodeB);
  var i = 0; // It does not matter which array is shorter.

  while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
    i++;
  }

  return i === 0 ? null : ancestorsA[i - 1];
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/domconverter.js



















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/domconverter
 */

/* globals document, Node, NodeFilter, Text */













 // eslint-disable-next-line new-cap

var BR_FILLER_REF = BR_FILLER(document);
/**
 * DomConverter is a set of tools to do transformations between DOM nodes and view nodes. It also handles
 * {@link module:engine/view/domconverter~DomConverter#bindElements binding} these nodes.
 *
 * The instance of DOMConverter is available in {@link module:engine/view/view~View#domConverter `editor.editing.view.domConverter`}.
 *
 * DomConverter does not check which nodes should be rendered (use {@link module:engine/view/renderer~Renderer}), does not keep a
 * state of a tree nor keeps synchronization between tree view and DOM tree (use {@link module:engine/view/document~Document}).
 *
 * DomConverter keeps DOM elements to View element bindings, so when the converter will be destroyed, the binding will
 * be lost. Two converters will keep separate binding maps, so one tree view can be bound with two DOM trees.
 */

var domconverter_DomConverter = /*#__PURE__*/function () {
  /**
   * Creates DOM converter.
   *
   * @param {module:engine/view/document~Document} document The view document instance.
   * @param {Object} options Object with configuration options.
   * @param {module:engine/view/filler~BlockFillerMode} [options.blockFillerMode='br'] The type of the block filler to use.
   */
  function DomConverter(document) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    Object(classCallCheck["a" /* default */])(this, DomConverter);

    /**
     * @readonly
     * @type {module:engine/view/document~Document}
     */
    this.document = document;
    /**
     * The mode of a block filler used by DOM converter.
     *
     * @readonly
     * @member {'br'|'nbsp'} module:engine/view/domconverter~DomConverter#blockFillerMode
     */

    this.blockFillerMode = options.blockFillerMode || 'br';
    /**
     * Elements which are considered pre-formatted elements.
     *
     * @readonly
     * @member {Array.<String>} module:engine/view/domconverter~DomConverter#preElements
     */

    this.preElements = ['pre'];
    /**
     * Elements which are considered block elements (and hence should be filled with a
     * {@link #isBlockFiller block filler}).
     *
     * Whether an element is considered a block element also affects handling of trailing whitespaces.
     *
     * You can extend this array if you introduce support for block elements which are not yet recognized here.
     *
     * @readonly
     * @member {Array.<String>} module:engine/view/domconverter~DomConverter#blockElements
     */

    this.blockElements = ['p', 'div', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'dd', 'dt', 'figcaption'];
    /**
     * Block {@link module:engine/view/filler filler} creator, which is used to create all block fillers during the
     * view to DOM conversion and to recognize block fillers during the DOM to view conversion.
     *
     * @readonly
     * @private
     * @member {Function} module:engine/view/domconverter~DomConverter#_blockFiller
     */

    this._blockFiller = this.blockFillerMode == 'br' ? BR_FILLER : NBSP_FILLER;
    /**
     * DOM to View mapping.
     *
     * @private
     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_domToViewMapping
     */

    this._domToViewMapping = new WeakMap();
    /**
     * View to DOM mapping.
     *
     * @private
     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_viewToDomMapping
     */

    this._viewToDomMapping = new WeakMap();
    /**
     * Holds mapping between fake selection containers and corresponding view selections.
     *
     * @private
     * @member {WeakMap} module:engine/view/domconverter~DomConverter#_fakeSelectionMapping
     */

    this._fakeSelectionMapping = new WeakMap();
  }
  /**
   * Binds given DOM element that represents fake selection to a **position** of a
   * {@link module:engine/view/documentselection~DocumentSelection document selection}.
   * Document selection copy is stored and can be retrieved by
   * {@link module:engine/view/domconverter~DomConverter#fakeSelectionToView} method.
   *
   * @param {HTMLElement} domElement
   * @param {module:engine/view/documentselection~DocumentSelection} viewDocumentSelection
   */


  Object(createClass["a" /* default */])(DomConverter, [{
    key: "bindFakeSelection",
    value: function bindFakeSelection(domElement, viewDocumentSelection) {
      this._fakeSelectionMapping.set(domElement, new selection_Selection(viewDocumentSelection));
    }
    /**
     * Returns {@link module:engine/view/selection~Selection view selection} instance corresponding to
     * given DOM element that represents fake selection. Returns `undefined` if binding to given DOM element does not exists.
     *
     * @param {HTMLElement} domElement
     * @returns {module:engine/view/selection~Selection|undefined}
     */

  }, {
    key: "fakeSelectionToView",
    value: function fakeSelectionToView(domElement) {
      return this._fakeSelectionMapping.get(domElement);
    }
    /**
     * Binds DOM and View elements, so it will be possible to get corresponding elements using
     * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and
     * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.
     *
     * @param {HTMLElement} domElement DOM element to bind.
     * @param {module:engine/view/element~Element} viewElement View element to bind.
     */

  }, {
    key: "bindElements",
    value: function bindElements(domElement, viewElement) {
      this._domToViewMapping.set(domElement, viewElement);

      this._viewToDomMapping.set(viewElement, domElement);
    }
    /**
     * Unbinds given `domElement` from the view element it was bound to. Unbinding is deep, meaning that all children of
     * `domElement` will be unbound too.
     *
     * @param {HTMLElement} domElement DOM element to unbind.
     */

  }, {
    key: "unbindDomElement",
    value: function unbindDomElement(domElement) {
      var viewElement = this._domToViewMapping.get(domElement);

      if (viewElement) {
        this._domToViewMapping.delete(domElement);

        this._viewToDomMapping.delete(viewElement);

        var _iterator = _createForOfIteratorHelper(domElement.childNodes),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var child = _step.value;
            this.unbindDomElement(child);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }
    /**
     * Binds DOM and View document fragments, so it will be possible to get corresponding document fragments using
     * {@link module:engine/view/domconverter~DomConverter#mapDomToView} and
     * {@link module:engine/view/domconverter~DomConverter#mapViewToDom}.
     *
     * @param {DocumentFragment} domFragment DOM document fragment to bind.
     * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment View document fragment to bind.
     */

  }, {
    key: "bindDocumentFragments",
    value: function bindDocumentFragments(domFragment, viewFragment) {
      this._domToViewMapping.set(domFragment, viewFragment);

      this._viewToDomMapping.set(viewFragment, domFragment);
    }
    /**
     * Converts view to DOM. For all text nodes, not bound elements and document fragments new items will
     * be created. For bound elements and document fragments function will return corresponding items.
     *
     * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} viewNode
     * View node or document fragment to transform.
     * @param {Document} domDocument Document which will be used to create DOM nodes.
     * @param {Object} [options] Conversion options.
     * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.
     * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.
     * @returns {Node|DocumentFragment} Converted node or DocumentFragment.
     */

  }, {
    key: "viewToDom",
    value: function viewToDom(viewNode, domDocument) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (viewNode.is('text')) {
        var textData = this._processDataFromViewText(viewNode);

        return domDocument.createTextNode(textData);
      } else {
        if (this.mapViewToDom(viewNode)) {
          return this.mapViewToDom(viewNode);
        }

        var domElement;

        if (viewNode.is('documentFragment')) {
          // Create DOM document fragment.
          domElement = domDocument.createDocumentFragment();

          if (options.bind) {
            this.bindDocumentFragments(domElement, viewNode);
          }
        } else if (viewNode.is('uiElement')) {
          // UIElement has its own render() method (see #799).
          domElement = viewNode.render(domDocument);

          if (options.bind) {
            this.bindElements(domElement, viewNode);
          }

          return domElement;
        } else {
          // Create DOM element.
          if (viewNode.hasAttribute('xmlns')) {
            domElement = domDocument.createElementNS(viewNode.getAttribute('xmlns'), viewNode.name);
          } else {
            domElement = domDocument.createElement(viewNode.name);
          }

          if (options.bind) {
            this.bindElements(domElement, viewNode);
          } // Copy element's attributes.


          var _iterator2 = _createForOfIteratorHelper(viewNode.getAttributeKeys()),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var key = _step2.value;
              domElement.setAttribute(key, viewNode.getAttribute(key));
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }

        if (options.withChildren || options.withChildren === undefined) {
          var _iterator3 = _createForOfIteratorHelper(this.viewChildrenToDom(viewNode, domDocument, options)),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var child = _step3.value;
              domElement.appendChild(child);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }

        return domElement;
      }
    }
    /**
     * Converts children of the view element to DOM using the
     * {@link module:engine/view/domconverter~DomConverter#viewToDom} method.
     * Additionally, this method adds block {@link module:engine/view/filler filler} to the list of children, if needed.
     *
     * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElement Parent view element.
     * @param {Document} domDocument Document which will be used to create DOM nodes.
     * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#viewToDom} options parameter.
     * @returns {Iterable.<Node>} DOM nodes.
     */

  }, {
    key: "viewChildrenToDom",
    value: /*#__PURE__*/regeneratorRuntime.mark(function viewChildrenToDom(viewElement, domDocument) {
      var options,
          fillerPositionOffset,
          offset,
          _iterator4,
          _step4,
          childView,
          _args = arguments;

      return regeneratorRuntime.wrap(function viewChildrenToDom$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              options = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
              fillerPositionOffset = viewElement.getFillerOffset && viewElement.getFillerOffset();
              offset = 0;
              _iterator4 = _createForOfIteratorHelper(viewElement.getChildren());
              _context.prev = 4;

              _iterator4.s();

            case 6:
              if ((_step4 = _iterator4.n()).done) {
                _context.next = 16;
                break;
              }

              childView = _step4.value;

              if (!(fillerPositionOffset === offset)) {
                _context.next = 11;
                break;
              }

              _context.next = 11;
              return this._blockFiller(domDocument);

            case 11:
              _context.next = 13;
              return this.viewToDom(childView, domDocument, options);

            case 13:
              offset++;

            case 14:
              _context.next = 6;
              break;

            case 16:
              _context.next = 21;
              break;

            case 18:
              _context.prev = 18;
              _context.t0 = _context["catch"](4);

              _iterator4.e(_context.t0);

            case 21:
              _context.prev = 21;

              _iterator4.f();

              return _context.finish(21);

            case 24:
              if (!(fillerPositionOffset === offset)) {
                _context.next = 27;
                break;
              }

              _context.next = 27;
              return this._blockFiller(domDocument);

            case 27:
            case "end":
              return _context.stop();
          }
        }
      }, viewChildrenToDom, this, [[4, 18, 21, 24]]);
    })
    /**
     * Converts view {@link module:engine/view/range~Range} to DOM range.
     * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
     *
     * @param {module:engine/view/range~Range} viewRange View range.
     * @returns {Range} DOM range.
     */

  }, {
    key: "viewRangeToDom",
    value: function viewRangeToDom(viewRange) {
      var domStart = this.viewPositionToDom(viewRange.start);
      var domEnd = this.viewPositionToDom(viewRange.end);
      var domRange = document.createRange();
      domRange.setStart(domStart.parent, domStart.offset);
      domRange.setEnd(domEnd.parent, domEnd.offset);
      return domRange;
    }
    /**
     * Converts view {@link module:engine/view/position~Position} to DOM parent and offset.
     *
     * Inline and block {@link module:engine/view/filler fillers} are handled during the conversion.
     * If the converted position is directly before inline filler it is moved inside the filler.
     *
     * @param {module:engine/view/position~Position} viewPosition View position.
     * @returns {Object|null} position DOM position or `null` if view position could not be converted to DOM.
     * @returns {Node} position.parent DOM position parent.
     * @returns {Number} position.offset DOM position offset.
     */

  }, {
    key: "viewPositionToDom",
    value: function viewPositionToDom(viewPosition) {
      var viewParent = viewPosition.parent;

      if (viewParent.is('text')) {
        var domParent = this.findCorrespondingDomText(viewParent);

        if (!domParent) {
          // Position is in a view text node that has not been rendered to DOM yet.
          return null;
        }

        var offset = viewPosition.offset;

        if (startsWithFiller(domParent)) {
          offset += INLINE_FILLER_LENGTH;
        }

        return {
          parent: domParent,
          offset: offset
        };
      } else {
        // viewParent is instance of ViewElement.
        var _domParent, domBefore, domAfter;

        if (viewPosition.offset === 0) {
          _domParent = this.mapViewToDom(viewParent);

          if (!_domParent) {
            // Position is in a view element that has not been rendered to DOM yet.
            return null;
          }

          domAfter = _domParent.childNodes[0];
        } else {
          var nodeBefore = viewPosition.nodeBefore;
          domBefore = nodeBefore.is('text') ? this.findCorrespondingDomText(nodeBefore) : this.mapViewToDom(viewPosition.nodeBefore);

          if (!domBefore) {
            // Position is after a view element that has not been rendered to DOM yet.
            return null;
          }

          _domParent = domBefore.parentNode;
          domAfter = domBefore.nextSibling;
        } // If there is an inline filler at position return position inside the filler. We should never return
        // the position before the inline filler.


        if (istext_isText(domAfter) && startsWithFiller(domAfter)) {
          return {
            parent: domAfter,
            offset: INLINE_FILLER_LENGTH
          };
        }

        var _offset = domBefore ? indexOf(domBefore) + 1 : 0;

        return {
          parent: _domParent,
          offset: _offset
        };
      }
    }
    /**
     * Converts DOM to view. For all text nodes, not bound elements and document fragments new items will
     * be created. For bound elements and document fragments function will return corresponding items. For
     * {@link module:engine/view/filler fillers} `null` will be returned.
     * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.
     *
     * @param {Node|DocumentFragment} domNode DOM node or document fragment to transform.
     * @param {Object} [options] Conversion options.
     * @param {Boolean} [options.bind=false] Determines whether new elements will be bound.
     * @param {Boolean} [options.withChildren=true] If `true`, node's and document fragment's children will be converted too.
     * @param {Boolean} [options.keepOriginalCase=false] If `false`, node's tag name will be converter to lower case.
     * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null} Converted node or document fragment
     * or `null` if DOM node is a {@link module:engine/view/filler filler} or the given node is an empty text node.
     */

  }, {
    key: "domToView",
    value: function domToView(domNode) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.isBlockFiller(domNode, this.blockFillerMode)) {
        return null;
      } // When node is inside UIElement return that UIElement as it's view representation.


      var uiElement = this.getParentUIElement(domNode, this._domToViewMapping);

      if (uiElement) {
        return uiElement;
      }

      if (istext_isText(domNode)) {
        if (isInlineFiller(domNode)) {
          return null;
        } else {
          var textData = this._processDataFromDomText(domNode);

          return textData === '' ? null : new text_Text(this.document, textData);
        }
      } else if (this.isComment(domNode)) {
        return null;
      } else {
        if (this.mapDomToView(domNode)) {
          return this.mapDomToView(domNode);
        }

        var viewElement;

        if (this.isDocumentFragment(domNode)) {
          // Create view document fragment.
          viewElement = new documentfragment_DocumentFragment(this.document);

          if (options.bind) {
            this.bindDocumentFragments(domNode, viewElement);
          }
        } else {
          // Create view element.
          var viewName = options.keepOriginalCase ? domNode.tagName : domNode.tagName.toLowerCase();
          viewElement = new element_Element(this.document, viewName);

          if (options.bind) {
            this.bindElements(domNode, viewElement);
          } // Copy element's attributes.


          var attrs = domNode.attributes;

          for (var i = attrs.length - 1; i >= 0; i--) {
            viewElement._setAttribute(attrs[i].name, attrs[i].value);
          }
        }

        if (options.withChildren || options.withChildren === undefined) {
          var _iterator5 = _createForOfIteratorHelper(this.domChildrenToView(domNode, options)),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var child = _step5.value;

              viewElement._appendChild(child);
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }

        return viewElement;
      }
    }
    /**
     * Converts children of the DOM element to view nodes using
     * the {@link module:engine/view/domconverter~DomConverter#domToView} method.
     * Additionally this method omits block {@link module:engine/view/filler filler}, if it exists in the DOM parent.
     *
     * @param {HTMLElement} domElement Parent DOM element.
     * @param {Object} options See {@link module:engine/view/domconverter~DomConverter#domToView} options parameter.
     * @returns {Iterable.<module:engine/view/node~Node>} View nodes.
     */

  }, {
    key: "domChildrenToView",
    value: /*#__PURE__*/regeneratorRuntime.mark(function domChildrenToView(domElement) {
      var options,
          i,
          domChild,
          viewChild,
          _args2 = arguments;
      return regeneratorRuntime.wrap(function domChildrenToView$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              options = _args2.length > 1 && _args2[1] !== undefined ? _args2[1] : {};
              i = 0;

            case 2:
              if (!(i < domElement.childNodes.length)) {
                _context2.next = 11;
                break;
              }

              domChild = domElement.childNodes[i];
              viewChild = this.domToView(domChild, options);

              if (!(viewChild !== null)) {
                _context2.next = 8;
                break;
              }

              _context2.next = 8;
              return viewChild;

            case 8:
              i++;
              _context2.next = 2;
              break;

            case 11:
            case "end":
              return _context2.stop();
          }
        }
      }, domChildrenToView, this);
    })
    /**
     * Converts DOM selection to view {@link module:engine/view/selection~Selection}.
     * Ranges which cannot be converted will be omitted.
     *
     * @param {Selection} domSelection DOM selection.
     * @returns {module:engine/view/selection~Selection} View selection.
     */

  }, {
    key: "domSelectionToView",
    value: function domSelectionToView(domSelection) {
      // DOM selection might be placed in fake selection container.
      // If container contains fake selection - return corresponding view selection.
      if (domSelection.rangeCount === 1) {
        var container = domSelection.getRangeAt(0).startContainer; // The DOM selection might be moved to the text node inside the fake selection container.

        if (istext_isText(container)) {
          container = container.parentNode;
        }

        var viewSelection = this.fakeSelectionToView(container);

        if (viewSelection) {
          return viewSelection;
        }
      }

      var isBackward = this.isDomSelectionBackward(domSelection);
      var viewRanges = [];

      for (var i = 0; i < domSelection.rangeCount; i++) {
        // DOM Range have correct start and end, no matter what is the DOM Selection direction. So we don't have to fix anything.
        var domRange = domSelection.getRangeAt(i);
        var viewRange = this.domRangeToView(domRange);

        if (viewRange) {
          viewRanges.push(viewRange);
        }
      }

      return new selection_Selection(viewRanges, {
        backward: isBackward
      });
    }
    /**
     * Converts DOM Range to view {@link module:engine/view/range~Range}.
     * If the start or end position can not be converted `null` is returned.
     *
     * @param {Range} domRange DOM range.
     * @returns {module:engine/view/range~Range|null} View range.
     */

  }, {
    key: "domRangeToView",
    value: function domRangeToView(domRange) {
      var viewStart = this.domPositionToView(domRange.startContainer, domRange.startOffset);
      var viewEnd = this.domPositionToView(domRange.endContainer, domRange.endOffset);

      if (viewStart && viewEnd) {
        return new range_Range(viewStart, viewEnd);
      }

      return null;
    }
    /**
     * Converts DOM parent and offset to view {@link module:engine/view/position~Position}.
     *
     * If the position is inside a {@link module:engine/view/filler filler} which has no corresponding view node,
     * position of the filler will be converted and returned.
     *
     * If the position is inside DOM element rendered by {@link module:engine/view/uielement~UIElement}
     * that position will be converted to view position before that UIElement.
     *
     * If structures are too different and it is not possible to find corresponding position then `null` will be returned.
     *
     * @param {Node} domParent DOM position parent.
     * @param {Number} domOffset DOM position offset.
     * @returns {module:engine/view/position~Position} viewPosition View position.
     */

  }, {
    key: "domPositionToView",
    value: function domPositionToView(domParent, domOffset) {
      if (this.isBlockFiller(domParent, this.blockFillerMode)) {
        return this.domPositionToView(domParent.parentNode, indexOf(domParent));
      } // If position is somewhere inside UIElement - return position before that element.


      var viewElement = this.mapDomToView(domParent);

      if (viewElement && viewElement.is('uiElement')) {
        return position_Position._createBefore(viewElement);
      }

      if (istext_isText(domParent)) {
        if (isInlineFiller(domParent)) {
          return this.domPositionToView(domParent.parentNode, indexOf(domParent));
        }

        var viewParent = this.findCorrespondingViewText(domParent);
        var offset = domOffset;

        if (!viewParent) {
          return null;
        }

        if (startsWithFiller(domParent)) {
          offset -= INLINE_FILLER_LENGTH;
          offset = offset < 0 ? 0 : offset;
        }

        return new position_Position(viewParent, offset);
      } // domParent instanceof HTMLElement.
      else {
          if (domOffset === 0) {
            var _viewParent = this.mapDomToView(domParent);

            if (_viewParent) {
              return new position_Position(_viewParent, 0);
            }
          } else {
            var domBefore = domParent.childNodes[domOffset - 1];
            var viewBefore = istext_isText(domBefore) ? this.findCorrespondingViewText(domBefore) : this.mapDomToView(domBefore); // TODO #663

            if (viewBefore && viewBefore.parent) {
              return new position_Position(viewBefore.parent, viewBefore.index + 1);
            }
          }

          return null;
        }
    }
    /**
     * Returns corresponding view {@link module:engine/view/element~Element Element} or
     * {@link module:engine/view/documentfragment~DocumentFragment} for provided DOM element or
     * document fragment. If there is no view item {@link module:engine/view/domconverter~DomConverter#bindElements bound}
     * to the given DOM - `undefined` is returned.
     * For all DOM elements rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.
     *
     * @param {DocumentFragment|Element} domElementOrDocumentFragment DOM element or document fragment.
     * @returns {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment|undefined}
     * Corresponding view element, document fragment or `undefined` if no element was bound.
     */

  }, {
    key: "mapDomToView",
    value: function mapDomToView(domElementOrDocumentFragment) {
      return this.getParentUIElement(domElementOrDocumentFragment) || this._domToViewMapping.get(domElementOrDocumentFragment);
    }
    /**
     * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},
     * corresponding text node is returned based on the sibling or parent.
     *
     * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used
     * to find the corresponding text node.
     *
     * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}
     * element, it is used to find the corresponding text node.
     *
     * For all text nodes rendered by {@link module:engine/view/uielement~UIElement} that UIElement will be returned.
     *
     * Otherwise `null` is returned.
     *
     * Note that for the block or inline {@link module:engine/view/filler filler} this method returns `null`.
     *
     * @param {Text} domText DOM text node.
     * @returns {module:engine/view/text~Text|null} Corresponding view text node or `null`, if it was not possible to find a
     * corresponding node.
     */

  }, {
    key: "findCorrespondingViewText",
    value: function findCorrespondingViewText(domText) {
      if (isInlineFiller(domText)) {
        return null;
      } // If DOM text was rendered by UIElement - return that element.


      var uiElement = this.getParentUIElement(domText);

      if (uiElement) {
        return uiElement;
      }

      var previousSibling = domText.previousSibling; // Try to use previous sibling to find the corresponding text node.

      if (previousSibling) {
        if (!this.isElement(previousSibling)) {
          // The previous is text or comment.
          return null;
        }

        var viewElement = this.mapDomToView(previousSibling);

        if (viewElement) {
          var nextSibling = viewElement.nextSibling; // It might be filler which has no corresponding view node.

          if (nextSibling instanceof text_Text) {
            return viewElement.nextSibling;
          } else {
            return null;
          }
        }
      } // Try to use parent to find the corresponding text node.
      else {
          var _viewElement = this.mapDomToView(domText.parentNode);

          if (_viewElement) {
            var firstChild = _viewElement.getChild(0); // It might be filler which has no corresponding view node.


            if (firstChild instanceof text_Text) {
              return firstChild;
            } else {
              return null;
            }
          }
        }

      return null;
    }
    /**
     * Returns corresponding DOM item for provided {@link module:engine/view/element~Element Element} or
     * {@link module:engine/view/documentfragment~DocumentFragment DocumentFragment}.
     * To find a corresponding text for {@link module:engine/view/text~Text view Text instance}
     * use {@link #findCorrespondingDomText}.
     *
     * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewNode
     * View element or document fragment.
     * @returns {Node|DocumentFragment|undefined} Corresponding DOM node or document fragment.
     */

  }, {
    key: "mapViewToDom",
    value: function mapViewToDom(documentFragmentOrElement) {
      return this._viewToDomMapping.get(documentFragmentOrElement);
    }
    /**
     * Finds corresponding text node. Text nodes are not {@link module:engine/view/domconverter~DomConverter#bindElements bound},
     * corresponding text node is returned based on the sibling or parent.
     *
     * If the directly previous sibling is a {@link module:engine/view/domconverter~DomConverter#bindElements bound} element, it is used
     * to find the corresponding text node.
     *
     * If this is a first child in the parent and the parent is a {@link module:engine/view/domconverter~DomConverter#bindElements bound}
     * element, it is used to find the corresponding text node.
     *
     * Otherwise `null` is returned.
     *
     * @param {module:engine/view/text~Text} viewText View text node.
     * @returns {Text|null} Corresponding DOM text node or `null`, if it was not possible to find a corresponding node.
     */

  }, {
    key: "findCorrespondingDomText",
    value: function findCorrespondingDomText(viewText) {
      var previousSibling = viewText.previousSibling; // Try to use previous sibling to find the corresponding text node.

      if (previousSibling && this.mapViewToDom(previousSibling)) {
        return this.mapViewToDom(previousSibling).nextSibling;
      } // If this is a first node, try to use parent to find the corresponding text node.


      if (!previousSibling && viewText.parent && this.mapViewToDom(viewText.parent)) {
        return this.mapViewToDom(viewText.parent).childNodes[0];
      }

      return null;
    }
    /**
     * Focuses DOM editable that is corresponding to provided {@link module:engine/view/editableelement~EditableElement}.
     *
     * @param {module:engine/view/editableelement~EditableElement} viewEditable
     */

  }, {
    key: "focus",
    value: function focus(viewEditable) {
      var domEditable = this.mapViewToDom(viewEditable);

      if (domEditable && domEditable.ownerDocument.activeElement !== domEditable) {
        // Save the scrollX and scrollY positions before the focus.
        var _global$window = global.window,
            scrollX = _global$window.scrollX,
            scrollY = _global$window.scrollY;
        var scrollPositions = []; // Save all scrollLeft and scrollTop values starting from domEditable up to
        // document#documentElement.

        forEachDomNodeAncestor(domEditable, function (node) {
          var scrollLeft = node.scrollLeft,
              scrollTop = node.scrollTop;
          scrollPositions.push([scrollLeft, scrollTop]);
        });
        domEditable.focus(); // Restore scrollLeft and scrollTop values starting from domEditable up to
        // document#documentElement.
        // https://github.com/ckeditor/ckeditor5-engine/issues/951
        // https://github.com/ckeditor/ckeditor5-engine/issues/957

        forEachDomNodeAncestor(domEditable, function (node) {
          var _scrollPositions$shif = scrollPositions.shift(),
              _scrollPositions$shif2 = _slicedToArray(_scrollPositions$shif, 2),
              scrollLeft = _scrollPositions$shif2[0],
              scrollTop = _scrollPositions$shif2[1];

          node.scrollLeft = scrollLeft;
          node.scrollTop = scrollTop;
        }); // Restore the scrollX and scrollY positions after the focus.
        // https://github.com/ckeditor/ckeditor5-engine/issues/951

        global.window.scrollTo(scrollX, scrollY);
      }
    }
    /**
     * Returns `true` when `node.nodeType` equals `Node.ELEMENT_NODE`.
     *
     * @param {Node} node Node to check.
     * @returns {Boolean}
     */

  }, {
    key: "isElement",
    value: function isElement(node) {
      return node && node.nodeType == Node.ELEMENT_NODE;
    }
    /**
     * Returns `true` when `node.nodeType` equals `Node.DOCUMENT_FRAGMENT_NODE`.
     *
     * @param {Node} node Node to check.
     * @returns {Boolean}
     */

  }, {
    key: "isDocumentFragment",
    value: function isDocumentFragment(node) {
      return node && node.nodeType == Node.DOCUMENT_FRAGMENT_NODE;
    }
    /**
     * Returns `true` when `node.nodeType` equals `Node.COMMENT_NODE`.
     *
     * @param {Node} node Node to check.
     * @returns {Boolean}
     */

  }, {
    key: "isComment",
    value: function isComment(node) {
      return node && node.nodeType == Node.COMMENT_NODE;
    }
    /**
     * Checks if the node is an instance of the block filler for this DOM converter.
     *
     *		const converter = new DomConverter( viewDocument, { blockFillerMode: 'br' } );
     *
     *		converter.isBlockFiller( BR_FILLER( document ) ); // true
     *		converter.isBlockFiller( NBSP_FILLER( document ) ); // false
     *
     * **Note:**: For the `'nbsp'` mode the method also checks context of a node so it cannot be a detached node.
     *
     * **Note:** A special case in the `'nbsp'` mode exists where the `<br>` in `<p><br></p>` is treated as a block filler.
     *
     * @param {Node} domNode DOM node to check.
     * @returns {Boolean} True if a node is considered a block filler for given mode.
     */

  }, {
    key: "isBlockFiller",
    value: function isBlockFiller(domNode) {
      if (this.blockFillerMode == 'br') {
        return domNode.isEqualNode(BR_FILLER_REF);
      } // Special case for <p><br></p> in which case the <br> should be treated as filler even
      // when we're in the 'nbsp' mode. See ckeditor5#5564.


      if (domNode.tagName === 'BR' && hasBlockParent(domNode, this.blockElements) && domNode.parentNode.childNodes.length === 1) {
        return true;
      }

      return isNbspBlockFiller(domNode, this.blockElements);
    }
    /**
     * Returns `true` if given selection is a backward selection, that is, if it's `focus` is before `anchor`.
     *
     * @param {Selection} DOM Selection instance to check.
     * @returns {Boolean}
     */

  }, {
    key: "isDomSelectionBackward",
    value: function isDomSelectionBackward(selection) {
      if (selection.isCollapsed) {
        return false;
      } // Since it takes multiple lines of code to check whether a "DOM Position" is before/after another "DOM Position",
      // we will use the fact that range will collapse if it's end is before it's start.


      var range = document.createRange();
      range.setStart(selection.anchorNode, selection.anchorOffset);
      range.setEnd(selection.focusNode, selection.focusOffset);
      var backward = range.collapsed;
      range.detach();
      return backward;
    }
    /**
     * Returns parent {@link module:engine/view/uielement~UIElement} for provided DOM node. Returns `null` if there is no
     * parent UIElement.
     *
     * @param {Node} domNode
     * @returns {module:engine/view/uielement~UIElement|null}
     */

  }, {
    key: "getParentUIElement",
    value: function getParentUIElement(domNode) {
      var ancestors = getAncestors(domNode); // Remove domNode from the list.

      ancestors.pop();

      while (ancestors.length) {
        var _domNode = ancestors.pop();

        var viewNode = this._domToViewMapping.get(_domNode);

        if (viewNode && viewNode.is('uiElement')) {
          return viewNode;
        }
      }

      return null;
    }
    /**
     * Checks if given selection's boundaries are at correct places.
     *
     * The following places are considered as incorrect for selection boundaries:
     * * before or in the middle of the inline filler sequence,
     * * inside the DOM element which represents {@link module:engine/view/uielement~UIElement a view ui element}.
     *
     * @param {Selection} domSelection DOM Selection object to be checked.
     * @returns {Boolean} `true` if the given selection is at a correct place, `false` otherwise.
     */

  }, {
    key: "isDomSelectionCorrect",
    value: function isDomSelectionCorrect(domSelection) {
      return this._isDomSelectionPositionCorrect(domSelection.anchorNode, domSelection.anchorOffset) && this._isDomSelectionPositionCorrect(domSelection.focusNode, domSelection.focusOffset);
    }
    /**
     * Checks if the given DOM position is a correct place for selection boundary. See {@link #isDomSelectionCorrect}.
     *
     * @private
     * @param {Element} domParent Position parent.
     * @param {Number} offset Position offset.
     * @returns {Boolean} `true` if given position is at a correct place for selection boundary, `false` otherwise.
     */

  }, {
    key: "_isDomSelectionPositionCorrect",
    value: function _isDomSelectionPositionCorrect(domParent, offset) {
      // If selection is before or in the middle of inline filler string, it is incorrect.
      if (istext_isText(domParent) && startsWithFiller(domParent) && offset < INLINE_FILLER_LENGTH) {
        // Selection in a text node, at wrong position (before or in the middle of filler).
        return false;
      }

      if (this.isElement(domParent) && startsWithFiller(domParent.childNodes[offset])) {
        // Selection in an element node, before filler text node.
        return false;
      }

      var viewParent = this.mapDomToView(domParent); // If selection is in `view.UIElement`, it is incorrect. Note that `mapDomToView()` returns `view.UIElement`
      // also for any dom element that is inside the view ui element (so we don't need to perform any additional checks).

      if (viewParent && viewParent.is('uiElement')) {
        return false;
      }

      return true;
    }
    /**
     * Takes text data from a given {@link module:engine/view/text~Text#data} and processes it so
     * it is correctly displayed in the DOM.
     *
     * Following changes are done:
     *
     * * a space at the beginning is changed to `&nbsp;` if this is the first text node in its container
     * element or if a previous text node ends with a space character,
     * * space at the end of the text node is changed to `&nbsp;` if there are two spaces at the end of a node or if next node
     * starts with a space or if it is the last text node in its container,
     * * remaining spaces are replaced to a chain of spaces and `&nbsp;` (e.g. `'x   x'` becomes `'x &nbsp; x'`).
     *
     * Content of {@link #preElements} is not processed.
     *
     * @private
     * @param {module:engine/view/text~Text} node View text node to process.
     * @returns {String} Processed text data.
     */

  }, {
    key: "_processDataFromViewText",
    value: function _processDataFromViewText(node) {
      var _this = this;

      var data = node.data; // If any of node ancestors has a name which is in `preElements` array, then currently processed
      // view text node is (will be) in preformatted element. We should not change whitespaces then.

      if (node.getAncestors().some(function (parent) {
        return _this.preElements.includes(parent.name);
      })) {
        return data;
      } // 1. Replace the first space with a nbsp if the previous node ends with a space or there is no previous node
      // (container element boundary).


      if (data.charAt(0) == ' ') {
        var prevNode = this._getTouchingViewTextNode(node, false);

        var prevEndsWithSpace = prevNode && this._nodeEndsWithSpace(prevNode);

        if (prevEndsWithSpace || !prevNode) {
          data = "\xA0" + data.substr(1);
        }
      } // 2. Replace the last space with nbsp if there are two spaces at the end or if the next node starts with space or there is no
      // next node (container element boundary).
      //
      // Keep in mind that Firefox prefers $nbsp; before tag, not inside it:
      //
      // Foo <span>&nbsp;bar</span>  <-- bad.
      // Foo&nbsp;<span> bar</span>  <-- good.
      //
      // More here: https://github.com/ckeditor/ckeditor5-engine/issues/1747.


      if (data.charAt(data.length - 1) == ' ') {
        var nextNode = this._getTouchingViewTextNode(node, true);

        if (data.charAt(data.length - 2) == ' ' || !nextNode || nextNode.data.charAt(0) == ' ') {
          data = data.substr(0, data.length - 1) + "\xA0";
        }
      } // 3. Create space+nbsp pairs.


      return data.replace(/ {2}/g, " \xA0");
    }
    /**
     * Checks whether given node ends with a space character after changing appropriate space characters to `&nbsp;`s.
     *
     * @private
     * @param {module:engine/view/text~Text} node Node to check.
     * @returns {Boolean} `true` if given `node` ends with space, `false` otherwise.
     */

  }, {
    key: "_nodeEndsWithSpace",
    value: function _nodeEndsWithSpace(node) {
      var _this2 = this;

      if (node.getAncestors().some(function (parent) {
        return _this2.preElements.includes(parent.name);
      })) {
        return false;
      }

      var data = this._processDataFromViewText(node);

      return data.charAt(data.length - 1) == ' ';
    }
    /**
     * Takes text data from native `Text` node and processes it to a correct {@link module:engine/view/text~Text view text node} data.
     *
     * Following changes are done:
     *
     * * multiple whitespaces are replaced to a single space,
     * * space at the beginning of a text node is removed if it is the first text node in its container
     * element or if the previous text node ends with a space character,
     * * space at the end of the text node is removed if there are two spaces at the end of a node or if next node
     * starts with a space or if it is the last text node in its container
     * * nbsps are converted to spaces.
     *
     * @param {Node} node DOM text node to process.
     * @returns {String} Processed data.
     * @private
     */

  }, {
    key: "_processDataFromDomText",
    value: function _processDataFromDomText(node) {
      var data = node.data;

      if (_hasDomParentOfType(node, this.preElements)) {
        return getDataWithoutFiller(node);
      } // Change all consecutive whitespace characters (from the [ \n\t\r] set –
      // see https://github.com/ckeditor/ckeditor5-engine/issues/822#issuecomment-311670249) to a single space character.
      // That's how multiple whitespaces are treated when rendered, so we normalize those whitespaces.
      // We're replacing 1+ (and not 2+) to also normalize singular \n\t\r characters (#822).


      data = data.replace(/[ \n\t\r]{1,}/g, ' ');

      var prevNode = this._getTouchingInlineDomNode(node, false);

      var nextNode = this._getTouchingInlineDomNode(node, true);

      var shouldLeftTrim = this._checkShouldLeftTrimDomText(prevNode);

      var shouldRightTrim = this._checkShouldRightTrimDomText(node, nextNode); // If the previous dom text node does not exist or it ends by whitespace character, remove space character from the beginning
      // of this text node. Such space character is treated as a whitespace.


      if (shouldLeftTrim) {
        data = data.replace(/^ /, '');
      } // If the next text node does not exist remove space character from the end of this text node.


      if (shouldRightTrim) {
        data = data.replace(/ $/, '');
      } // At the beginning and end of a block element, Firefox inserts normal space + <br> instead of non-breaking space.
      // This means that the text node starts/end with normal space instead of non-breaking space.
      // This causes a problem because the normal space would be removed in `.replace` calls above. To prevent that,
      // the inline filler is removed only after the data is initially processed (by the `.replace` above). See ckeditor5#692.


      data = getDataWithoutFiller(new Text(data)); // At this point we should have removed all whitespaces from DOM text data.
      //
      // Now, We will reverse the process that happens in `_processDataFromViewText`.
      //
      // We have to change &nbsp; chars, that were in DOM text data because of rendering reasons, to spaces.
      // First, change all ` \u00A0` pairs (space + &nbsp;) to two spaces. DOM converter changes two spaces from model/view to
      // ` \u00A0` to ensure proper rendering. Since here we convert back, we recognize those pairs and change them back to `  `.

      data = data.replace(/ \u00A0/g, '  '); // Then, let's change the last nbsp to a space.

      if (/( |\u00A0)\u00A0$/.test(data) || !nextNode || nextNode.data && nextNode.data.charAt(0) == ' ') {
        data = data.replace(/\u00A0$/, ' ');
      } // Then, change &nbsp; character that is at the beginning of the text node to space character.
      // We do that replacement only if this is the first node or the previous node ends on whitespace character.


      if (shouldLeftTrim) {
        data = data.replace(/^\u00A0/, ' ');
      } // At this point, all whitespaces should be removed and all &nbsp; created for rendering reasons should be
      // changed to normal space. All left &nbsp; are &nbsp; inserted intentionally.


      return data;
    }
    /**
     * Helper function which checks if a DOM text node, preceded by the given `prevNode` should
     * be trimmed from the left side.
     *
     * @param {Node} prevNode
     */

  }, {
    key: "_checkShouldLeftTrimDomText",
    value: function _checkShouldLeftTrimDomText(prevNode) {
      if (!prevNode) {
        return true;
      }

      if (lodash_es_isElement(prevNode)) {
        return true;
      }

      return /[^\S\u00A0]/.test(prevNode.data.charAt(prevNode.data.length - 1));
    }
    /**
     * Helper function which checks if a DOM text node, succeeded by the given `nextNode` should
     * be trimmed from the right side.
     *
     * @param {Node} node
     * @param {Node} nextNode
     */

  }, {
    key: "_checkShouldRightTrimDomText",
    value: function _checkShouldRightTrimDomText(node, nextNode) {
      if (nextNode) {
        return false;
      }

      return !startsWithFiller(node);
    }
    /**
     * Helper function. For given {@link module:engine/view/text~Text view text node}, it finds previous or next sibling
     * that is contained in the same container element. If there is no such sibling, `null` is returned.
     *
     * @param {module:engine/view/text~Text} node Reference node.
     * @param {Boolean} getNext
     * @returns {module:engine/view/text~Text|null} Touching text node or `null` if there is no next or previous touching text node.
     */

  }, {
    key: "_getTouchingViewTextNode",
    value: function _getTouchingViewTextNode(node, getNext) {
      var treeWalker = new treewalker_TreeWalker({
        startPosition: getNext ? position_Position._createAfter(node) : position_Position._createBefore(node),
        direction: getNext ? 'forward' : 'backward'
      });

      var _iterator6 = _createForOfIteratorHelper(treeWalker),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var value = _step6.value;

          // ViewContainerElement is found on a way to next ViewText node, so given `node` was first/last
          // text node in its container element.
          if (value.item.is('containerElement')) {
            return null;
          } // <br> found – it works like a block boundary, so do not scan further.
          else if (value.item.is('br')) {
              return null;
            } // Found a text node in the same container element.
            else if (value.item.is('textProxy')) {
                return value.item;
              }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      return null;
    }
    /**
     * Helper function. For the given text node, it finds the closest touching node which is either
     * a text node or a `<br>`. The search is terminated at block element boundaries and if a matching node
     * wasn't found so far, `null` is returned.
     *
     * In the following DOM structure:
     *
     *		<p>foo<b>bar</b><br>bom</p>
     *
     * * `foo` doesn't have its previous touching inline node (`null` is returned),
     * * `foo`'s next touching inline node is `bar`
     * * `bar`'s next touching inline node is `<br>`
     *
     * This method returns text nodes and `<br>` elements because these types of nodes affect how
     * spaces in the given text node need to be converted.
     *
     * @private
     * @param {Text} node
     * @param {Boolean} getNext
     * @returns {Text|Element|null}
     */

  }, {
    key: "_getTouchingInlineDomNode",
    value: function _getTouchingInlineDomNode(node, getNext) {
      if (!node.parentNode) {
        return null;
      }

      var direction = getNext ? 'nextNode' : 'previousNode';
      var document = node.ownerDocument;
      var topmostParent = getAncestors(node)[0];
      var treeWalker = document.createTreeWalker(topmostParent, NodeFilter.SHOW_TEXT | NodeFilter.SHOW_ELEMENT, {
        acceptNode: function acceptNode(node) {
          if (istext_isText(node)) {
            return NodeFilter.FILTER_ACCEPT;
          }

          if (node.tagName == 'BR') {
            return NodeFilter.FILTER_ACCEPT;
          }

          return NodeFilter.FILTER_SKIP;
        }
      });
      treeWalker.currentNode = node;
      var touchingNode = treeWalker[direction]();

      if (touchingNode !== null) {
        var lca = getCommonAncestor(node, touchingNode); // If there is common ancestor between the text node and next/prev text node,
        // and there are no block elements on a way from the text node to that ancestor,
        // and there are no block elements on a way from next/prev text node to that ancestor...

        if (lca && !_hasDomParentOfType(node, this.blockElements, lca) && !_hasDomParentOfType(touchingNode, this.blockElements, lca)) {
          // Then they are in the same container element.
          return touchingNode;
        }
      }

      return null;
    }
  }]);

  return DomConverter;
}(); // Helper function.
// Used to check if given native `Element` or `Text` node has parent with tag name from `types` array.
//
// @param {Node} node
// @param {Array.<String>} types
// @param {Boolean} [boundaryParent] Can be given if parents should be checked up to a given element (excluding that element).
// @returns {Boolean} `true` if such parent exists or `false` if it does not.




function _hasDomParentOfType(node, types, boundaryParent) {
  var parents = getAncestors(node);

  if (boundaryParent) {
    parents = parents.slice(parents.indexOf(boundaryParent) + 1);
  }

  return parents.some(function (parent) {
    return parent.tagName && types.includes(parent.tagName.toLowerCase());
  });
} // A helper that executes given callback for each DOM node's ancestor, starting from the given node
// and ending in document#documentElement.
//
// @param {Node} node
// @param {Function} callback A callback to be executed for each ancestor.


function forEachDomNodeAncestor(node, callback) {
  while (node && node != global.document) {
    callback(node);
    node = node.parentNode;
  }
} // Checks if given node is a nbsp block filler.
//
// A &nbsp; is a block filler only if it is a single child of a block element.
//
// @param {Node} domNode DOM node.
// @returns {Boolean}


function isNbspBlockFiller(domNode, blockElements) {
  var isNBSP = istext_isText(domNode) && domNode.data == "\xA0";
  return isNBSP && hasBlockParent(domNode, blockElements) && domNode.parentNode.childNodes.length === 1;
} // Checks if domNode has block parent.
//
// @param {Node} domNode DOM node.
// @returns {Boolean}


function hasBlockParent(domNode, blockElements) {
  var parent = domNode.parentNode;
  return parent && parent.tagName && blockElements.includes(parent.tagName.toLowerCase());
}
/**
 * Enum representing type of the block filler.
 *
 * Possible values:
 *
 * * `br` - for `<br>` block filler used in editing view,
 * * `nbsp` - for `&nbsp;` block fillers used in the data.
 *
 * @typedef {String} module:engine/view/filler~BlockFillerMode
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/iswindow.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/dom/iswindow
 */

/**
 * Checks if the object is a native DOM Window.
 *
 * @param {*} obj
 * @returns {Boolean}
 */
function isWindow(obj) {
  var stringifiedObject = Object.prototype.toString.apply(obj); // Returns `true` for the `window` object in browser environments.

  if (stringifiedObject == '[object Window]') {
    return true;
  } // Returns `true` for the `window` object in the Electron environment.


  if (stringifiedObject == '[object global]') {
    return true;
  }

  return false;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/emittermixin.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/dom/emittermixin
 */





/**
 * Mixin that injects the DOM events API into its host. It provides the API
 * compatible with {@link module:utils/emittermixin~EmitterMixin}.
 *
 * DOM emitter mixin is by default available in the {@link module:ui/view~View} class,
 * but it can also be mixed into any other class:
 *
 *		import mix from '../utils/mix.js';
 *		import DomEmitterMixin from '../utils/dom/emittermixin.js';
 *
 *		class SomeView {}
 *		mix( SomeView, DomEmitterMixin );
 *
 *		const view = new SomeView();
 *		view.listenTo( domElement, ( evt, domEvt ) => {
 *			console.log( evt, domEvt );
 *		} );
 *
 * @mixin EmitterMixin
 * @mixes module:utils/emittermixin~EmitterMixin
 * @implements module:utils/dom/emittermixin~Emitter
 */

var DomEmitterMixin = lodash_es_assignIn({}, emittermixin, {
  /**
   * Registers a callback function to be executed when an event is fired in a specific Emitter or DOM Node.
   * It is backwards compatible with {@link module:utils/emittermixin~EmitterMixin#listenTo}.
   *
   * @param {module:utils/emittermixin~Emitter|Node} emitter The object that fires the event.
   * @param {String} event The name of the event.
   * @param {Function} callback The function to be called on event.
   * @param {Object} [options={}] Additional options.
   * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of this event callback. The higher
   * the priority value the sooner the callback will be fired. Events having the same priority are called in the
   * order they were added.
   * @param {Boolean} [options.useCapture=false] Indicates that events of this type will be dispatched to the registered
   * listener before being dispatched to any EventTarget beneath it in the DOM tree.
   */
  listenTo: function listenTo(emitter) {
    var _EmitterMixin$listenT;

    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }

    // Check if emitter is an instance of DOM Node. If so, replace the argument with
    // corresponding ProxyEmitter (or create one if not existing).
    if (isNode(emitter) || isWindow(emitter)) {
      var proxy = this._getProxyEmitter(emitter) || new emittermixin_ProxyEmitter(emitter);
      proxy.attach.apply(proxy, rest);
      emitter = proxy;
    } // Execute parent class method with Emitter (or ProxyEmitter) instance.


    (_EmitterMixin$listenT = emittermixin.listenTo).call.apply(_EmitterMixin$listenT, [this, emitter].concat(rest));
  },

  /**
   * Stops listening for events. It can be used at different levels:
   * It is backwards compatible with {@link module:utils/emittermixin~EmitterMixin#listenTo}.
   *
   * * To stop listening to a specific callback.
   * * To stop listening to a specific event.
   * * To stop listening to all events fired by a specific object.
   * * To stop listening to all events fired by all object.
   *
   * @param {module:utils/emittermixin~Emitter|Node} [emitter] The object to stop listening to. If omitted, stops it for all objects.
   * @param {String} [event] (Requires the `emitter`) The name of the event to stop listening to. If omitted, stops it
   * for all events from `emitter`.
   * @param {Function} [callback] (Requires the `event`) The function to be removed from the call list for the given
   * `event`.
   */
  stopListening: function stopListening(emitter, event, callback) {
    // Check if emitter is an instance of DOM Node. If so, replace the argument with corresponding ProxyEmitter.
    if (isNode(emitter) || isWindow(emitter)) {
      var proxy = this._getProxyEmitter(emitter); // Element has no listeners.


      if (!proxy) {
        return;
      }

      emitter = proxy;
    } // Execute parent class method with Emitter (or ProxyEmitter) instance.


    emittermixin.stopListening.call(this, emitter, event, callback);

    if (emitter instanceof emittermixin_ProxyEmitter) {
      emitter.detach(event);
    }
  },

  /**
   * Retrieves ProxyEmitter instance for given DOM Node residing in this Host.
   *
   * @private
   * @param {Node} node DOM Node of the ProxyEmitter.
   * @returns {module:utils/dom/emittermixin~ProxyEmitter} ProxyEmitter instance or null.
   */
  _getProxyEmitter: function _getProxyEmitter(node) {
    return _getEmitterListenedTo(this, getNodeUID(node));
  }
});
/* harmony default export */ var dom_emittermixin = (DomEmitterMixin);
/**
 * Creates a ProxyEmitter instance. Such an instance is a bridge between a DOM Node firing events
 * and any Host listening to them. It is backwards compatible with {@link module:utils/emittermixin~EmitterMixin#on}.
 *
 *                                  listenTo( click, ... )
 *                    +-----------------------------------------+
 *                    |              stopListening( ... )       |
 *     +----------------------------+                           |             addEventListener( click, ... )
 *     | Host                       |                           |   +---------------------------------------------+
 *     +----------------------------+                           |   |       removeEventListener( click, ... )     |
 *     | _listeningTo: {            |                +----------v-------------+                                   |
 *     |   UID: {                   |                | ProxyEmitter           |                                   |
 *     |     emitter: ProxyEmitter, |                +------------------------+                      +------------v----------+
 *     |     callbacks: {           |                | events: {              |                      | Node (HTMLElement)    |
 *     |       click: [ callbacks ] |                |   click: [ callbacks ] |                      +-----------------------+
 *     |     }                      |                | },                     |                      | data-ck-expando: UID  |
 *     |   }                        |                | _domNode: Node,        |                      +-----------------------+
 *     | }                          |                | _domListeners: {},     |                                   |
 *     | +------------------------+ |                | _emitterId: UID        |                                   |
 *     | | DomEmitterMixin        | |                +--------------^---------+                                   |
 *     | +------------------------+ |                           |   |                                             |
 *     +--------------^-------------+                           |   +---------------------------------------------+
 *                    |                                         |                  click (DOM Event)
 *                    +-----------------------------------------+
 *                                fire( click, DOM Event )
 *
 * @mixes module:utils/emittermixin~EmitterMixin
 * @implements module:utils/dom/emittermixin~Emitter
 * @private
 */

var emittermixin_ProxyEmitter =
/**
 * @param {Node} node DOM Node that fires events.
 * @returns {Object} ProxyEmitter instance bound to the DOM Node.
 */
function ProxyEmitter(node) {
  Object(classCallCheck["a" /* default */])(this, ProxyEmitter);

  // Set emitter ID to match DOM Node "expando" property.
  _setEmitterId(this, getNodeUID(node)); // Remember the DOM Node this ProxyEmitter is bound to.


  this._domNode = node;
};

lodash_es_assignIn(emittermixin_ProxyEmitter.prototype, emittermixin, {
  /**
   * Collection of native DOM listeners.
   *
   * @private
   * @member {Object} module:utils/dom/emittermixin~ProxyEmitter#_domListeners
   */

  /**
   * Registers a callback function to be executed when an event is fired.
   *
   * It attaches a native DOM listener to the DOM Node. When fired,
   * a corresponding Emitter event will also fire with DOM Event object as an argument.
   *
   * @method module:utils/dom/emittermixin~ProxyEmitter#attach
   * @param {String} event The name of the event.
   * @param {Function} callback The function to be called on event.
   * @param {Object} [options={}] Additional options.
   * @param {Boolean} [options.useCapture=false] Indicates that events of this type will be dispatched to the registered
   * listener before being dispatched to any EventTarget beneath it in the DOM tree.
   */
  attach: function attach(event, callback) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    // If the DOM Listener for given event already exist it is pointless
    // to attach another one.
    if (this._domListeners && this._domListeners[event]) {
      return;
    }

    var domListener = this._createDomListener(event, !!options.useCapture); // Attach the native DOM listener to DOM Node.


    this._domNode.addEventListener(event, domListener, !!options.useCapture);

    if (!this._domListeners) {
      this._domListeners = {};
    } // Store the native DOM listener in this ProxyEmitter. It will be helpful
    // when stopping listening to the event.


    this._domListeners[event] = domListener;
  },

  /**
   * Stops executing the callback on the given event.
   *
   * @method module:utils/dom/emittermixin~ProxyEmitter#detach
   * @param {String} event The name of the event.
   */
  detach: function detach(event) {
    var events; // Remove native DOM listeners which are orphans. If no callbacks
    // are awaiting given event, detach native DOM listener from DOM Node.
    // See: {@link attach}.

    if (this._domListeners[event] && (!(events = this._events[event]) || !events.callbacks.length)) {
      this._domListeners[event].removeListener();
    }
  },

  /**
   * Creates a native DOM listener callback. When the native DOM event
   * is fired it will fire corresponding event on this ProxyEmitter.
   * Note: A native DOM Event is passed as an argument.
   *
   * @private
   * @method module:utils/dom/emittermixin~ProxyEmitter#_createDomListener
   * @param {String} event The name of the event.
   * @param {Boolean} useCapture Indicates whether the listener was created for capturing event.
   * @returns {Function} The DOM listener callback.
   */
  _createDomListener: function _createDomListener(event, useCapture) {
    var _this = this;

    var domListener = function domListener(domEvt) {
      _this.fire(event, domEvt);
    }; // Supply the DOM listener callback with a function that will help
    // detach it from the DOM Node, when it is no longer necessary.
    // See: {@link detach}.


    domListener.removeListener = function () {
      _this._domNode.removeEventListener(event, domListener, useCapture);

      delete _this._domListeners[event];
    };

    return domListener;
  }
}); // Gets an unique DOM Node identifier. The identifier will be set if not defined.
//
// @private
// @param {Node} node
// @returns {String} UID for given DOM Node.

function getNodeUID(node) {
  return node['data-ck-expando'] || (node['data-ck-expando'] = uid_uid());
}
/**
 * Interface representing classes which mix in {@link module:utils/dom/emittermixin~EmitterMixin}.
 *
 * @interface Emitter
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/observer/observer.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/observer/observer
 */


/**
 * Abstract base observer class. Observers are classes which listen to DOM events, do the preliminary
 * processing and fire events on the {@link module:engine/view/document~Document} objects.
 * Observers can also add features to the view, for instance by updating its status or marking elements
 * which need refresh on DOM events.
 *
 * @abstract
 */

var observer_Observer = /*#__PURE__*/function () {
  /**
   * Creates an instance of the observer.
   *
   * @param {module:engine/view/view~View} view
   */
  function Observer(view) {
    Object(classCallCheck["a" /* default */])(this, Observer);

    /**
     * Instance of the view controller.
     *
     * @readonly
     * @member {module:engine/view/view~View}
     */
    this.view = view;
    /**
     * Reference to the {@link module:engine/view/document~Document} object.
     *
     * @readonly
     * @member {module:engine/view/document~Document}
     */

    this.document = view.document;
    /**
     * State of the observer. If it is disabled events will not be fired.
     *
     * @readonly
     * @member {Boolean}
     */

    this.isEnabled = false;
  }
  /**
   * Enables the observer. This method is called when the observer is registered to the
   * {@link module:engine/view/view~View} and after {@link module:engine/view/view~View#forceRender rendering}
   * (all observers are {@link #disable disabled} before rendering).
   *
   * A typical use case for disabling observers is that mutation observers need to be disabled for the rendering.
   * However, a child class may not need to be disabled, so it can implement an empty method.
   *
   * @see module:engine/view/observer/observer~Observer#disable
   */


  Object(createClass["a" /* default */])(Observer, [{
    key: "enable",
    value: function enable() {
      this.isEnabled = true;
    }
    /**
     * Disables the observer. This method is called before
     * {@link module:engine/view/view~View#forceRender rendering} to prevent firing events during rendering.
     *
     * @see module:engine/view/observer/observer~Observer#enable
     */

  }, {
    key: "disable",
    value: function disable() {
      this.isEnabled = false;
    }
    /**
     * Disables and destroys the observer, among others removes event listeners created by the observer.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.disable();
      this.stopListening();
    }
    /**
     * Starts observing the given root element.
     *
     * @method #observe
     * @param {HTMLElement} domElement
     * @param {String} name The name of the root element.
     */

  }]);

  return Observer;
}();


mix(observer_Observer, dom_emittermixin);
// CONCATENATED MODULE: ./node_modules/lodash-es/_setCacheAdd.js
/** Used to stand-in for `undefined` hash values. */
var _setCacheAdd_HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, _setCacheAdd_HASH_UNDEFINED);
  return this;
}

/* harmony default export */ var _setCacheAdd = (setCacheAdd);

// CONCATENATED MODULE: ./node_modules/lodash-es/_setCacheHas.js
/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

/* harmony default export */ var _setCacheHas = (setCacheHas);

// CONCATENATED MODULE: ./node_modules/lodash-es/_SetCache.js




/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new _MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = _setCacheAdd;
SetCache.prototype.has = _setCacheHas;

/* harmony default export */ var _SetCache = (SetCache);

// CONCATENATED MODULE: ./node_modules/lodash-es/_arraySome.js
/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

/* harmony default export */ var _arraySome = (arraySome);

// CONCATENATED MODULE: ./node_modules/lodash-es/_cacheHas.js
/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

/* harmony default export */ var _cacheHas = (cacheHas);

// CONCATENATED MODULE: ./node_modules/lodash-es/_equalArrays.js




/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(array);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new _SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!_arraySome(other, function(othValue, othIndex) {
            if (!_cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

/* harmony default export */ var _equalArrays = (equalArrays);

// CONCATENATED MODULE: ./node_modules/lodash-es/_mapToArray.js
/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

/* harmony default export */ var _mapToArray = (mapToArray);

// CONCATENATED MODULE: ./node_modules/lodash-es/_setToArray.js
/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

/* harmony default export */ var _setToArray = (setToArray);

// CONCATENATED MODULE: ./node_modules/lodash-es/_equalByTag.js







/** Used to compose bitmasks for value comparisons. */
var _equalByTag_COMPARE_PARTIAL_FLAG = 1,
    _equalByTag_COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var _equalByTag_boolTag = '[object Boolean]',
    _equalByTag_dateTag = '[object Date]',
    _equalByTag_errorTag = '[object Error]',
    _equalByTag_mapTag = '[object Map]',
    _equalByTag_numberTag = '[object Number]',
    _equalByTag_regexpTag = '[object RegExp]',
    _equalByTag_setTag = '[object Set]',
    _equalByTag_stringTag = '[object String]',
    _equalByTag_symbolTag = '[object Symbol]';

var _equalByTag_arrayBufferTag = '[object ArrayBuffer]',
    _equalByTag_dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var _equalByTag_symbolProto = _Symbol ? _Symbol.prototype : undefined,
    _equalByTag_symbolValueOf = _equalByTag_symbolProto ? _equalByTag_symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case _equalByTag_dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case _equalByTag_arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new _Uint8Array(object), new _Uint8Array(other))) {
        return false;
      }
      return true;

    case _equalByTag_boolTag:
    case _equalByTag_dateTag:
    case _equalByTag_numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return lodash_es_eq(+object, +other);

    case _equalByTag_errorTag:
      return object.name == other.name && object.message == other.message;

    case _equalByTag_regexpTag:
    case _equalByTag_stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case _equalByTag_mapTag:
      var convert = _mapToArray;

    case _equalByTag_setTag:
      var isPartial = bitmask & _equalByTag_COMPARE_PARTIAL_FLAG;
      convert || (convert = _setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= _equalByTag_COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = _equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case _equalByTag_symbolTag:
      if (_equalByTag_symbolValueOf) {
        return _equalByTag_symbolValueOf.call(object) == _equalByTag_symbolValueOf.call(other);
      }
  }
  return false;
}

/* harmony default export */ var _equalByTag = (equalByTag);

// CONCATENATED MODULE: ./node_modules/lodash-es/_equalObjects.js


/** Used to compose bitmasks for value comparisons. */
var _equalObjects_COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var _equalObjects_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _equalObjects_hasOwnProperty = _equalObjects_objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & _equalObjects_COMPARE_PARTIAL_FLAG,
      objProps = _getAllKeys(object),
      objLength = objProps.length,
      othProps = _getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : _equalObjects_hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Assume cyclic values are equal.
  var stacked = stack.get(object);
  if (stacked && stack.get(other)) {
    return stacked == other;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

/* harmony default export */ var _equalObjects = (equalObjects);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsEqualDeep.js









/** Used to compose bitmasks for value comparisons. */
var _baseIsEqualDeep_COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var _baseIsEqualDeep_argsTag = '[object Arguments]',
    _baseIsEqualDeep_arrayTag = '[object Array]',
    _baseIsEqualDeep_objectTag = '[object Object]';

/** Used for built-in method references. */
var _baseIsEqualDeep_objectProto = Object.prototype;

/** Used to check objects for own properties. */
var _baseIsEqualDeep_hasOwnProperty = _baseIsEqualDeep_objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = lodash_es_isArray(object),
      othIsArr = lodash_es_isArray(other),
      objTag = objIsArr ? _baseIsEqualDeep_arrayTag : _getTag(object),
      othTag = othIsArr ? _baseIsEqualDeep_arrayTag : _getTag(other);

  objTag = objTag == _baseIsEqualDeep_argsTag ? _baseIsEqualDeep_objectTag : objTag;
  othTag = othTag == _baseIsEqualDeep_argsTag ? _baseIsEqualDeep_objectTag : othTag;

  var objIsObj = objTag == _baseIsEqualDeep_objectTag,
      othIsObj = othTag == _baseIsEqualDeep_objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && Object(isBuffer["a" /* default */])(object)) {
    if (!Object(isBuffer["a" /* default */])(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new _Stack);
    return (objIsArr || lodash_es_isTypedArray(object))
      ? _equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : _equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & _baseIsEqualDeep_COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && _baseIsEqualDeep_hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && _baseIsEqualDeep_hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new _Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new _Stack);
  return _equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

/* harmony default export */ var _baseIsEqualDeep = (baseIsEqualDeep);

// CONCATENATED MODULE: ./node_modules/lodash-es/_baseIsEqual.js



/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!lodash_es_isObjectLike(value) && !lodash_es_isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return _baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

/* harmony default export */ var _baseIsEqual = (baseIsEqual);

// CONCATENATED MODULE: ./node_modules/lodash-es/isEqualWith.js


/**
 * This method is like `_.isEqual` except that it accepts `customizer` which
 * is invoked to compare values. If `customizer` returns `undefined`, comparisons
 * are handled by the method instead. The `customizer` is invoked with up to
 * six arguments: (objValue, othValue [, index|key, object, other, stack]).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {Function} [customizer] The function to customize comparisons.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * function isGreeting(value) {
 *   return /^h(?:i|ello)$/.test(value);
 * }
 *
 * function customizer(objValue, othValue) {
 *   if (isGreeting(objValue) && isGreeting(othValue)) {
 *     return true;
 *   }
 * }
 *
 * var array = ['hello', 'goodbye'];
 * var other = ['hi', 'goodbye'];
 *
 * _.isEqualWith(array, other, customizer);
 * // => true
 */
function isEqualWith(value, other, customizer) {
  customizer = typeof customizer == 'function' ? customizer : undefined;
  var result = customizer ? customizer(value, other) : undefined;
  return result === undefined ? _baseIsEqual(value, other, undefined, customizer) : !!result;
}

/* harmony default export */ var lodash_es_isEqualWith = (isEqualWith);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/observer/mutationobserver.js
















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/observer/mutationobserver
 */

/* globals window */




/**
 * Mutation observer class observes changes in the DOM, fires {@link module:engine/view/document~Document#event:mutations} event, mark view
 * elements as changed and call {@link module:engine/view/renderer~Renderer#render}.
 * Because all mutated nodes are marked as "to be rendered" and the
 * {@link module:engine/view/renderer~Renderer#render} is called, all changes will be reverted, unless the mutation will be handled by the
 * {@link module:engine/view/document~Document#event:mutations} event listener. It means user will see only handled changes, and the editor
 * will block all changes which are not handled.
 *
 * Mutation Observer also take care of reducing number of mutations which are fired. It removes duplicates and
 * mutations on elements which do not have corresponding view elements. Also
 * {@link module:engine/view/observer/mutationobserver~MutatedText text mutation} is fired only if parent element do not change child list.
 *
 * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.
 *
 * @extends module:engine/view/observer/observer~Observer
 */

var mutationobserver_MutationObserver = /*#__PURE__*/function (_Observer) {
  Object(inherits["a" /* default */])(MutationObserver, _Observer);

  var _super = Object(createSuper["a" /* default */])(MutationObserver);

  function MutationObserver(view) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, MutationObserver);

    _this = _super.call(this, view);
    /**
     * Native mutation observer config.
     *
     * @private
     * @member {Object}
     */

    _this._config = {
      childList: true,
      characterData: true,
      characterDataOldValue: true,
      subtree: true
    };
    /**
     * Reference to the {@link module:engine/view/view~View#domConverter}.
     *
     * @member {module:engine/view/domconverter~DomConverter}
     */

    _this.domConverter = view.domConverter;
    /**
     * Reference to the {@link module:engine/view/view~View#_renderer}.
     *
     * @member {module:engine/view/renderer~Renderer}
     */

    _this.renderer = view._renderer;
    /**
     * Observed DOM elements.
     *
     * @private
     * @member {Array.<HTMLElement>}
     */

    _this._domElements = [];
    /**
     * Native mutation observer.
     *
     * @private
     * @member {MutationObserver}
     */

    _this._mutationObserver = new window.MutationObserver(_this._onMutations.bind(Object(assertThisInitialized["a" /* default */])(_this)));
    return _this;
  }
  /**
   * Synchronously fires {@link module:engine/view/document~Document#event:mutations} event with all mutations in record queue.
   * At the same time empties the queue so mutations will not be fired twice.
   */


  Object(createClass["a" /* default */])(MutationObserver, [{
    key: "flush",
    value: function flush() {
      this._onMutations(this._mutationObserver.takeRecords());
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "observe",
    value: function observe(domElement) {
      this._domElements.push(domElement);

      if (this.isEnabled) {
        this._mutationObserver.observe(domElement, this._config);
      }
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "enable",
    value: function enable() {
      get_get(Object(getPrototypeOf["a" /* default */])(MutationObserver.prototype), "enable", this).call(this);

      var _iterator = _createForOfIteratorHelper(this._domElements),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var domElement = _step.value;

          this._mutationObserver.observe(domElement, this._config);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "disable",
    value: function disable() {
      get_get(Object(getPrototypeOf["a" /* default */])(MutationObserver.prototype), "disable", this).call(this);

      this._mutationObserver.disconnect();
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "destroy",
    value: function destroy() {
      get_get(Object(getPrototypeOf["a" /* default */])(MutationObserver.prototype), "destroy", this).call(this);

      this._mutationObserver.disconnect();
    }
    /**
     * Handles mutations. Deduplicates, mark view elements to sync, fire event and call render.
     *
     * @private
     * @param {Array.<Object>} domMutations Array of native mutations.
     */

  }, {
    key: "_onMutations",
    value: function _onMutations(domMutations) {
      // As a result of this.flush() we can have an empty collection.
      if (domMutations.length === 0) {
        return;
      }

      var domConverter = this.domConverter; // Use map and set for deduplication.

      var mutatedTexts = new Map();
      var mutatedElements = new Set(); // Handle `childList` mutations first, so we will be able to check if the `characterData` mutation is in the
      // element with changed structure anyway.

      var _iterator2 = _createForOfIteratorHelper(domMutations),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var mutation = _step2.value;

          if (mutation.type === 'childList') {
            var element = domConverter.mapDomToView(mutation.target); // Do not collect mutations from UIElements.

            if (element && element.is('uiElement')) {
              continue;
            }

            if (element && !this._isBogusBrMutation(mutation)) {
              mutatedElements.add(element);
            }
          }
        } // Handle `characterData` mutations later, when we have the full list of nodes which changed structure.

      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var _iterator3 = _createForOfIteratorHelper(domMutations),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _mutation = _step3.value;

          var _element = domConverter.mapDomToView(_mutation.target); // Do not collect mutations from UIElements.


          if (_element && _element.is('uiElement')) {
            continue;
          }

          if (_mutation.type === 'characterData') {
            var text = domConverter.findCorrespondingViewText(_mutation.target);

            if (text && !mutatedElements.has(text.parent)) {
              // Use text as a key, for deduplication. If there will be another mutation on the same text element
              // we will have only one in the map.
              mutatedTexts.set(text, {
                type: 'text',
                oldText: text.data,
                newText: getDataWithoutFiller(_mutation.target),
                node: text
              });
            } // When we added first letter to the text node which had only inline filler, for the DOM it is mutation
            // on text, but for the view, where filler text node did not existed, new text node was created, so we
            // need to fire 'children' mutation instead of 'text'.
            else if (!text && startsWithFiller(_mutation.target)) {
                mutatedElements.add(domConverter.mapDomToView(_mutation.target.parentNode));
              }
          }
        } // Now we build the list of mutations to fire and mark elements. We did not do it earlier to avoid marking the
        // same node multiple times in case of duplication.
        // List of mutations we will fire.

      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      var viewMutations = [];

      var _iterator4 = _createForOfIteratorHelper(mutatedTexts.values()),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var mutatedText = _step4.value;
          this.renderer.markToSync('text', mutatedText.node);
          viewMutations.push(mutatedText);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      var _iterator5 = _createForOfIteratorHelper(mutatedElements),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var viewElement = _step5.value;
          var domElement = domConverter.mapViewToDom(viewElement);
          var viewChildren = Array.from(viewElement.getChildren());
          var newViewChildren = Array.from(domConverter.domChildrenToView(domElement, {
            withChildren: false
          })); // It may happen that as a result of many changes (sth was inserted and then removed),
          // both elements haven't really changed. #1031

          if (!lodash_es_isEqualWith(viewChildren, newViewChildren, sameNodes)) {
            this.renderer.markToSync('children', viewElement);
            viewMutations.push({
              type: 'children',
              oldChildren: viewChildren,
              newChildren: newViewChildren,
              node: viewElement
            });
          }
        } // Retrieve `domSelection` using `ownerDocument` of one of mutated nodes.
        // There should not be simultaneous mutation in multiple documents, so it's fine.

      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      var domSelection = domMutations[0].target.ownerDocument.getSelection();
      var viewSelection = null;

      if (domSelection && domSelection.anchorNode) {
        // If `domSelection` is inside a dom node that is already bound to a view node from view tree, get
        // corresponding selection in the view and pass it together with `viewMutations`. The `viewSelection` may
        // be used by features handling mutations.
        // Only one range is supported.
        var viewSelectionAnchor = domConverter.domPositionToView(domSelection.anchorNode, domSelection.anchorOffset);
        var viewSelectionFocus = domConverter.domPositionToView(domSelection.focusNode, domSelection.focusOffset); // Anchor and focus has to be properly mapped to view.

        if (viewSelectionAnchor && viewSelectionFocus) {
          viewSelection = new selection_Selection(viewSelectionAnchor);
          viewSelection.setFocus(viewSelectionFocus);
        }
      } // In case only non-relevant mutations were recorded it skips the event and force render (#5600).


      if (viewMutations.length) {
        this.document.fire('mutations', viewMutations, viewSelection); // If nothing changes on `mutations` event, at this point we have "dirty DOM" (changed) and de-synched
        // view (which has not been changed). In order to "reset DOM" we render the view again.

        this.view.forceRender();
      }

      function sameNodes(child1, child2) {
        // First level of comparison (array of children vs array of children) – use the Lodash's default behavior.
        if (Array.isArray(child1)) {
          return;
        } // Elements.


        if (child1 === child2) {
          return true;
        } // Texts.
        else if (child1.is('text') && child2.is('text')) {
            return child1.data === child2.data;
          } // Not matching types.


        return false;
      }
    }
    /**
     * Checks if mutation was generated by the browser inserting bogus br on the end of the block element.
     * Such mutations are generated while pressing space or performing native spellchecker correction
     * on the end of the block element in Firefox browser.
     *
     * @private
     * @param {Object} mutation Native mutation object.
     * @returns {Boolean}
     */

  }, {
    key: "_isBogusBrMutation",
    value: function _isBogusBrMutation(mutation) {
      var addedNode = null; // Check if mutation added only one node on the end of its parent.

      if (mutation.nextSibling === null && mutation.removedNodes.length === 0 && mutation.addedNodes.length == 1) {
        addedNode = this.domConverter.domToView(mutation.addedNodes[0], {
          withChildren: false
        });
      }

      return addedNode && addedNode.is('element', 'br');
    }
  }]);

  return MutationObserver;
}(observer_Observer);
/**
 * Fired when mutation occurred. If tree view is not changed on this event, DOM will be reverted to the state before
 * mutation, so all changes which should be applied, should be handled on this event.
 *
 * Introduced by {@link module:engine/view/observer/mutationobserver~MutationObserver}.
 *
 * Note that because {@link module:engine/view/observer/mutationobserver~MutationObserver} is attached by the
 * {@link module:engine/view/view~View} this event is available by default.
 *
 * @see module:engine/view/observer/mutationobserver~MutationObserver
 * @event module:engine/view/document~Document#event:mutations
 * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|module:engine/view/observer/mutationobserver~MutatedChildren>}
 * viewMutations Array of mutations.
 * For mutated texts it will be {@link module:engine/view/observer/mutationobserver~MutatedText} and for mutated elements it will be
 * {@link module:engine/view/observer/mutationobserver~MutatedChildren}. You can recognize the type based on the `type` property.
 * @param {module:engine/view/selection~Selection|null} viewSelection View selection that is a result of converting DOM selection to view.
 * Keep in
 * mind that the DOM selection is already "updated", meaning that it already acknowledges changes done in mutation.
 */

/**
 * Mutation item for text.
 *
 * @see module:engine/view/document~Document#event:mutations
 * @see module:engine/view/observer/mutationobserver~MutatedChildren
 *
 * @typedef {Object} module:engine/view/observer/mutationobserver~MutatedText
 *
 * @property {String} type For text mutations it is always 'text'.
 * @property {module:engine/view/text~Text} node Mutated text node.
 * @property {String} oldText Old text.
 * @property {String} newText New text.
 */

/**
 * Mutation item for child nodes.
 *
 * @see module:engine/view/document~Document#event:mutations
 * @see module:engine/view/observer/mutationobserver~MutatedText
 *
 * @typedef {Object} module:engine/view/observer/mutationobserver~MutatedChildren
 *
 * @property {String} type For child nodes mutations it is always 'children'.
 * @property {module:engine/view/element~Element} node Parent of the mutated children.
 * @property {Array.<module:engine/view/node~Node>} oldChildren Old child nodes.
 * @property {Array.<module:engine/view/node~Node>} newChildren New child nodes.
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/observer/domeventdata.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/observer/domeventdata
 */

/**
 * Information about a DOM event in context of the {@link module:engine/view/document~Document}.
 * It wraps the native event, which usually should not be used as the wrapper contains
 * additional data (like key code for keyboard events).
 */

var domeventdata_DomEventData = /*#__PURE__*/function () {
  /**
   * @param {module:engine/view/view~View} view The instance of the view controller.
   * @param {Event} domEvent The DOM event.
   * @param {Object} [additionalData] Additional properties that the instance should contain.
   */
  function DomEventData(view, domEvent, additionalData) {
    Object(classCallCheck["a" /* default */])(this, DomEventData);

    /**
     * Instance of the view controller.
     *
     * @readonly
     * @member {module:engine/view/view~View} module:engine/view/observer/observer~Observer.DomEvent#view
     */
    this.view = view;
    /**
     * The instance of the document.
     *
     * @readonly
     * @member {module:engine/view/document~Document} module:engine/view/observer/observer~Observer.DomEvent#document
     */

    this.document = view.document;
    /**
     * The DOM event.
     *
     * @readonly
     * @member {Event} module:engine/view/observer/observer~Observer.DomEvent#domEvent
     */

    this.domEvent = domEvent;
    /**
     * The DOM target.
     *
     * @readonly
     * @member {HTMLElement} module:engine/view/observer/observer~Observer.DomEvent#target
     */

    this.domTarget = domEvent.target;
    lodash_es_assignIn(this, additionalData);
  }
  /**
   * The tree view element representing the target.
   *
   * @readonly
   * @type module:engine/view/element~Element
   */


  Object(createClass["a" /* default */])(DomEventData, [{
    key: "preventDefault",

    /**
     * Prevents the native's event default action.
     */
    value: function preventDefault() {
      this.domEvent.preventDefault();
    }
    /**
     * Stops native event propagation.
     */

  }, {
    key: "stopPropagation",
    value: function stopPropagation() {
      this.domEvent.stopPropagation();
    }
  }, {
    key: "target",
    get: function get() {
      return this.view.domConverter.mapDomToView(this.domTarget);
    }
  }]);

  return DomEventData;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/observer/domeventobserver.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/observer/domeventobserver
 */


/**
 * Base class for DOM event observers. This class handles
 * {@link module:engine/view/observer/observer~Observer#observe adding} listeners to DOM elements,
 * {@link module:engine/view/observer/observer~Observer#disable disabling} and
 * {@link module:engine/view/observer/observer~Observer#enable re-enabling} events.
 * Child class needs to define
 * {@link module:engine/view/observer/domeventobserver~DomEventObserver#domEventType DOM event type} and
 * {@link module:engine/view/observer/domeventobserver~DomEventObserver#onDomEvent callback}.
 *
 * For instance:
 *
 *		class ClickObserver extends DomEventObserver {
 *			// It can also be defined as a normal property in the constructor.
 *			get domEventType() {
 *				return 'click';
 *			}
 *
 *			onDomEvent( domEvent ) {
 *				this.fire( 'click', domEvent );
 *			}
 *		}
 *
 * @extends module:engine/view/observer/observer~Observer
 */

var domeventobserver_DomEventObserver = /*#__PURE__*/function (_Observer) {
  Object(inherits["a" /* default */])(DomEventObserver, _Observer);

  var _super = Object(createSuper["a" /* default */])(DomEventObserver);

  /**
   * Type of the DOM event the observer should listen on. Array of types can be defined
   * if the obsever should listen to multiple DOM events.
   *
   * @readonly
   * @member {String|Array.<String>} #domEventType
   */

  /**
   * Callback which should be called when the DOM event occurred. Note that the callback will not be called if
   * observer {@link #isEnabled is not enabled}.
   *
   * @see #domEventType
   * @abstract
   * @method #onDomEvent
   */

  /**
   * @inheritDoc
   */
  function DomEventObserver(view) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, DomEventObserver);

    _this = _super.call(this, view);
    /**
     * If set to `true` DOM events will be listened on the capturing phase.
     * Default value is `false`.
     *
     * @member {Boolean}
     */

    _this.useCapture = false;
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(DomEventObserver, [{
    key: "observe",
    value: function observe(domElement) {
      var _this2 = this;

      var types = typeof this.domEventType == 'string' ? [this.domEventType] : this.domEventType;
      types.forEach(function (type) {
        _this2.listenTo(domElement, type, function (eventInfo, domEvent) {
          if (_this2.isEnabled) {
            _this2.onDomEvent(domEvent);
          }
        }, {
          useCapture: _this2.useCapture
        });
      });
    }
    /**
     * Calls `Document#fire()` if observer {@link #isEnabled is enabled}.
     *
     * @see module:utils/emittermixin~EmitterMixin#fire
     * @param {String} eventType The event type (name).
     * @param {Event} domEvent The DOM event.
     * @param {Object} [additionalData] The additional data which should extend the
     * {@link module:engine/view/observer/domeventdata~DomEventData event data} object.
     */

  }, {
    key: "fire",
    value: function fire(eventType, domEvent, additionalData) {
      if (this.isEnabled) {
        this.document.fire(eventType, new domeventdata_DomEventData(this.view, domEvent, additionalData));
      }
    }
  }]);

  return DomEventObserver;
}(observer_Observer);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/observer/keyobserver.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/observer/keyobserver
 */


/**
 * Observer for events connected with pressing keyboard keys.
 *
 * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.
 *
 * @extends module:engine/view/observer/domeventobserver~DomEventObserver
 */

var keyobserver_KeyObserver = /*#__PURE__*/function (_DomEventObserver) {
  Object(inherits["a" /* default */])(KeyObserver, _DomEventObserver);

  var _super = Object(createSuper["a" /* default */])(KeyObserver);

  function KeyObserver(view) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, KeyObserver);

    _this = _super.call(this, view);
    _this.domEventType = ['keydown', 'keyup'];
    return _this;
  }

  Object(createClass["a" /* default */])(KeyObserver, [{
    key: "onDomEvent",
    value: function onDomEvent(domEvt) {
      this.fire(domEvt.type, domEvt, {
        keyCode: domEvt.keyCode,
        altKey: domEvt.altKey,
        ctrlKey: domEvt.ctrlKey || domEvt.metaKey,
        shiftKey: domEvt.shiftKey,

        get keystroke() {
          return getCode(this);
        }

      });
    }
  }]);

  return KeyObserver;
}(domeventobserver_DomEventObserver);
/**
 * Fired when a key has been pressed.
 *
 * Introduced by {@link module:engine/view/observer/keyobserver~KeyObserver}.
 *
 * Note that because {@link module:engine/view/observer/keyobserver~KeyObserver} is attached by the
 * {@link module:engine/view/view~View} this event is available by default.
 *
 * @see module:engine/view/observer/keyobserver~KeyObserver
 * @event module:engine/view/document~Document#event:keydown
 * @param {module:engine/view/observer/keyobserver~KeyEventData} keyEventData
 */

/**
 * Fired when a key has been released.
 *
 * Introduced by {@link module:engine/view/observer/keyobserver~KeyObserver}.
 *
 * Note that because {@link module:engine/view/observer/keyobserver~KeyObserver} is attached by the
 * {@link module:engine/view/view~View} this event is available by default.
 *
 * @see module:engine/view/observer/keyobserver~KeyObserver
 * @event module:engine/view/document~Document#event:keyup
 * @param {module:engine/view/observer/keyobserver~KeyEventData} keyEventData
 */

/**
 * The value of both events - {@link module:engine/view/document~Document#event:keydown} and
 * {@link module:engine/view/document~Document#event:keyup}.
 *
 * @class module:engine/view/observer/keyobserver~KeyEventData
 * @extends module:engine/view/observer/domeventdata~DomEventData
 * @implements module:utils/keyboard~KeystrokeInfo
 */

/**
 * Code of the whole keystroke. See {@link module:utils/keyboard~getCode}.
 *
 * @readonly
 * @member {Number} module:engine/view/observer/keyobserver~KeyEventData#keystroke
 */



// CONCATENATED MODULE: ./node_modules/lodash-es/now.js


/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
var now = function() {
  return _root["a" /* default */].Date.now();
};

/* harmony default export */ var lodash_es_now = (now);

// CONCATENATED MODULE: ./node_modules/lodash-es/toNumber.js



/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (lodash_es_isSymbol(value)) {
    return NAN;
  }
  if (lodash_es_isObject(value)) {
    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
    value = lodash_es_isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

/* harmony default export */ var lodash_es_toNumber = (toNumber);

// CONCATENATED MODULE: ./node_modules/lodash-es/debounce.js




/** Error message constants. */
var debounce_FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var debounce_nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide `options` to indicate whether `func` should be invoked on the
 * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent
 * calls to the debounced function return the result of the last `func`
 * invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the debounced function
 * is invoked more than once during the `wait` timeout.
 *
 * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
 * until to the next tick, similar to `setTimeout` with a timeout of `0`.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(debounce_FUNC_ERROR_TEXT);
  }
  wait = lodash_es_toNumber(wait) || 0;
  if (lodash_es_isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? debounce_nativeMax(lodash_es_toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        timeWaiting = wait - timeSinceLastCall;

    return maxing
      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
      : timeWaiting;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = lodash_es_now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    if (timerId !== undefined) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(lodash_es_now());
  }

  function debounced() {
    var time = lodash_es_now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

/* harmony default export */ var lodash_es_debounce = (debounce);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/observer/fakeselectionobserver.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/observer/fakeselectionobserver
 */




/**
 * Fake selection observer class. If view selection is fake it is placed in dummy DOM container. This observer listens
 * on {@link module:engine/view/document~Document#event:keydown keydown} events and handles moving fake view selection to the correct place
 * if arrow keys are pressed.
 * Fires {@link module:engine/view/document~Document#event:selectionChange selectionChange event} simulating natural behaviour of
 * {@link module:engine/view/observer/selectionobserver~SelectionObserver SelectionObserver}.
 *
 * @extends module:engine/view/observer/observer~Observer
 */

var fakeselectionobserver_FakeSelectionObserver = /*#__PURE__*/function (_Observer) {
  Object(inherits["a" /* default */])(FakeSelectionObserver, _Observer);

  var _super = Object(createSuper["a" /* default */])(FakeSelectionObserver);

  /**
   * Creates new FakeSelectionObserver instance.
   *
   * @param {module:engine/view/view~View} view
   */
  function FakeSelectionObserver(view) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, FakeSelectionObserver);

    _this = _super.call(this, view);
    /**
     * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.
     *
     * @private
     * @param {Object} data Selection change data.
     * @method #_fireSelectionChangeDoneDebounced
     */

    _this._fireSelectionChangeDoneDebounced = lodash_es_debounce(function (data) {
      return _this.document.fire('selectionChangeDone', data);
    }, 200);
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(FakeSelectionObserver, [{
    key: "observe",
    value: function observe() {
      var _this2 = this;

      var document = this.document;
      document.on('keydown', function (eventInfo, data) {
        var selection = document.selection;

        if (selection.isFake && _isArrowKeyCode(data.keyCode) && _this2.isEnabled) {
          // Prevents default key down handling - no selection change will occur.
          data.preventDefault();

          _this2._handleSelectionMove(data.keyCode);
        }
      }, {
        priority: 'lowest'
      });
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "destroy",
    value: function destroy() {
      get_get(Object(getPrototypeOf["a" /* default */])(FakeSelectionObserver.prototype), "destroy", this).call(this);

      this._fireSelectionChangeDoneDebounced.cancel();
    }
    /**
     * Handles collapsing view selection according to given key code. If left or up key is provided - new selection will be
     * collapsed to left. If right or down key is pressed - new selection will be collapsed to right.
     *
     * This method fires {@link module:engine/view/document~Document#event:selectionChange} and
     * {@link module:engine/view/document~Document#event:selectionChangeDone} events imitating behaviour of
     * {@link module:engine/view/observer/selectionobserver~SelectionObserver}.
     *
     * @private
     * @param {Number} keyCode
     * @fires module:engine/view/document~Document#event:selectionChange
     * @fires module:engine/view/document~Document#event:selectionChangeDone
     */

  }, {
    key: "_handleSelectionMove",
    value: function _handleSelectionMove(keyCode) {
      var selection = this.document.selection;
      var newSelection = new selection_Selection(selection.getRanges(), {
        backward: selection.isBackward,
        fake: false
      }); // Left or up arrow pressed - move selection to start.

      if (keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup) {
        newSelection.setTo(newSelection.getFirstPosition());
      } // Right or down arrow pressed - move selection to end.


      if (keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowdown) {
        newSelection.setTo(newSelection.getLastPosition());
      }

      var data = {
        oldSelection: selection,
        newSelection: newSelection,
        domSelection: null
      }; // Fire dummy selection change event.

      this.document.fire('selectionChange', data); // Call` #_fireSelectionChangeDoneDebounced` every time when `selectionChange` event is fired.
      // This function is debounced what means that `selectionChangeDone` event will be fired only when
      // defined int the function time will elapse since the last time the function was called.
      // So `selectionChangeDone` will be fired when selection will stop changing.

      this._fireSelectionChangeDoneDebounced(data);
    }
  }]);

  return FakeSelectionObserver;
}(observer_Observer); // Checks if one of the arrow keys is pressed.
//
// @private
// @param {Number} keyCode
// @returns {Boolean}




function _isArrowKeyCode(keyCode) {
  return keyCode == keyCodes.arrowright || keyCode == keyCodes.arrowleft || keyCode == keyCodes.arrowup || keyCode == keyCodes.arrowdown;
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.weak-set.js
var es_weak_set = __webpack_require__("1fe2");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/observer/selectionobserver.js












/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/observer/selectionobserver
 */

/* global setInterval, clearInterval */



/**
 * Selection observer class observes selection changes in the document. If selection changes on the document this
 * observer checks if there are any mutations and if DOM selection is different than the
 * {@link module:engine/view/document~Document#selection view selection}. Selection observer fires
 * {@link module:engine/view/document~Document#event:selectionChange} event only if selection change was the only change in the document
 * and DOM selection is different then the view selection.
 *
 * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.
 *
 * @see module:engine/view/observer/mutationobserver~MutationObserver
 * @extends module:engine/view/observer/observer~Observer
 */

var selectionobserver_SelectionObserver = /*#__PURE__*/function (_Observer) {
  Object(inherits["a" /* default */])(SelectionObserver, _Observer);

  var _super = Object(createSuper["a" /* default */])(SelectionObserver);

  function SelectionObserver(view) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, SelectionObserver);

    _this = _super.call(this, view);
    /**
     * Instance of the mutation observer. Selection observer calls
     * {@link module:engine/view/observer/mutationobserver~MutationObserver#flush} to ensure that the mutations will be handled
     * before the {@link module:engine/view/document~Document#event:selectionChange} event is fired.
     *
     * @readonly
     * @member {module:engine/view/observer/mutationobserver~MutationObserver}
     * module:engine/view/observer/selectionobserver~SelectionObserver#mutationObserver
     */

    _this.mutationObserver = view.getObserver(mutationobserver_MutationObserver);
    /**
     * Reference to the view {@link module:engine/view/documentselection~DocumentSelection} object used to compare
     * new selection with it.
     *
     * @readonly
     * @member {module:engine/view/documentselection~DocumentSelection}
     * module:engine/view/observer/selectionobserver~SelectionObserver#selection
     */

    _this.selection = _this.document.selection;
    /* eslint-disable max-len */

    /**
     * Reference to the {@link module:engine/view/view~View#domConverter}.
     *
     * @readonly
     * @member {module:engine/view/domconverter~DomConverter} module:engine/view/observer/selectionobserver~SelectionObserver#domConverter
     */

    /* eslint-enable max-len */

    _this.domConverter = view.domConverter;
    /**
     * Set of documents which have added "selectionchange" listener to avoid adding listener twice to the same
     * document.
     *
     * @private
     * @member {WeakSet.<Document>} module:engine/view/observer/selectionobserver~SelectionObserver#_documents
     */

    _this._documents = new WeakSet();
    /**
     * Fires debounced event `selectionChangeDone`. It uses `lodash#debounce` method to delay function call.
     *
     * @private
     * @param {Object} data Selection change data.
     * @method #_fireSelectionChangeDoneDebounced
     */

    _this._fireSelectionChangeDoneDebounced = lodash_es_debounce(function (data) {
      return _this.document.fire('selectionChangeDone', data);
    }, 200);
    _this._clearInfiniteLoopInterval = setInterval(function () {
      return _this._clearInfiniteLoop();
    }, 1000);
    /**
     * Private property to check if the code does not enter infinite loop.
     *
     * @private
     * @member {Number} module:engine/view/observer/selectionobserver~SelectionObserver#_loopbackCounter
     */

    _this._loopbackCounter = 0;
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(SelectionObserver, [{
    key: "observe",
    value: function observe(domElement) {
      var _this2 = this;

      var domDocument = domElement.ownerDocument; // Add listener once per each document.

      if (this._documents.has(domDocument)) {
        return;
      }

      this.listenTo(domDocument, 'selectionchange', function () {
        _this2._handleSelectionChange(domDocument);
      });

      this._documents.add(domDocument);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "destroy",
    value: function destroy() {
      get_get(Object(getPrototypeOf["a" /* default */])(SelectionObserver.prototype), "destroy", this).call(this);

      clearInterval(this._clearInfiniteLoopInterval);

      this._fireSelectionChangeDoneDebounced.cancel();
    }
    /**
     * Selection change listener. {@link module:engine/view/observer/mutationobserver~MutationObserver#flush Flush} mutations, check if
     * selection changes and fires {@link module:engine/view/document~Document#event:selectionChange} event on every change
     * and {@link module:engine/view/document~Document#event:selectionChangeDone} when selection stop changing.
     *
     * @private
     * @param {Document} domDocument DOM document.
     */

  }, {
    key: "_handleSelectionChange",
    value: function _handleSelectionChange(domDocument) {
      if (!this.isEnabled) {
        return;
      } // Ensure the mutation event will be before selection event on all browsers.


      this.mutationObserver.flush(); // If there were mutations then the view will be re-rendered by the mutation observer and selection
      // will be updated, so selections will equal and event will not be fired, as expected.

      var domSelection = domDocument.defaultView.getSelection();
      var newViewSelection = this.domConverter.domSelectionToView(domSelection); // Do not convert selection change if the new view selection has no ranges in it.
      //
      // It means that the DOM selection is in some way incorrect. Ranges that were in the DOM selection could not be
      // converted to the view. This happens when the DOM selection was moved outside of the editable element.

      if (newViewSelection.rangeCount == 0) {
        this.view.hasDomSelection = false;
        return;
      }

      this.view.hasDomSelection = true;

      if (this.selection.isEqual(newViewSelection) && this.domConverter.isDomSelectionCorrect(domSelection)) {
        return;
      } // Ensure we are not in the infinite loop (#400).
      // This counter is reset each second. 60 selection changes in 1 second is enough high number
      // to be very difficult (impossible) to achieve using just keyboard keys (during normal editor use).


      if (++this._loopbackCounter > 60) {
        // Selection change observer detected an infinite rendering loop.
        // Most probably you try to put the selection in the position which is not allowed
        // by the browser and browser fixes it automatically what causes `selectionchange` event on
        // which a loopback through a model tries to re-render the wrong selection and again.
        //
        // @if CK_DEBUG // console.warn( 'Selection change observer detected an infinite rendering loop.' );
        return;
      }

      if (this.selection.isSimilar(newViewSelection)) {
        // If selection was equal and we are at this point of algorithm, it means that it was incorrect.
        // Just re-render it, no need to fire any events, etc.
        this.view.forceRender();
      } else {
        var data = {
          oldSelection: this.selection,
          newSelection: newViewSelection,
          domSelection: domSelection
        }; // Prepare data for new selection and fire appropriate events.

        this.document.fire('selectionChange', data); // Call` #_fireSelectionChangeDoneDebounced` every time when `selectionChange` event is fired.
        // This function is debounced what means that `selectionChangeDone` event will be fired only when
        // defined int the function time will elapse since the last time the function was called.
        // So `selectionChangeDone` will be fired when selection will stop changing.

        this._fireSelectionChangeDoneDebounced(data);
      }
    }
    /**
     * Clears `SelectionObserver` internal properties connected with preventing infinite loop.
     *
     * @protected
     */

  }, {
    key: "_clearInfiniteLoop",
    value: function _clearInfiniteLoop() {
      this._loopbackCounter = 0;
    }
  }]);

  return SelectionObserver;
}(observer_Observer);
/**
 * Fired when selection has changed. This event is fired only when the selection change was the only change that happened
 * in the document, and old selection is different then the new selection.
 *
 * Introduced by {@link module:engine/view/observer/selectionobserver~SelectionObserver}.
 *
 * Note that because {@link module:engine/view/observer/selectionobserver~SelectionObserver} is attached by the
 * {@link module:engine/view/view~View} this event is available by default.
 *
 * @see module:engine/view/observer/selectionobserver~SelectionObserver
 * @event module:engine/view/document~Document#event:selectionChange
 * @param {Object} data
 * @param {module:engine/view/documentselection~DocumentSelection} data.oldSelection Old View selection which is
 * {@link module:engine/view/document~Document#selection}.
 * @param {module:engine/view/selection~Selection} data.newSelection New View selection which is converted DOM selection.
 * @param {Selection} data.domSelection Native DOM selection.
 */

/**
 * Fired when selection stops changing.
 *
 * Introduced by {@link module:engine/view/observer/selectionobserver~SelectionObserver}.
 *
 * Note that because {@link module:engine/view/observer/selectionobserver~SelectionObserver} is attached by the
 * {@link module:engine/view/view~View} this event is available by default.
 *
 * @see module:engine/view/observer/selectionobserver~SelectionObserver
 * @event module:engine/view/document~Document#event:selectionChangeDone
 * @param {Object} data
 * @param {module:engine/view/documentselection~DocumentSelection} data.oldSelection Old View selection which is
 * {@link module:engine/view/document~Document#selection}.
 * @param {module:engine/view/selection~Selection} data.newSelection New View selection which is converted DOM selection.
 * @param {Selection} data.domSelection Native DOM selection.
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/observer/focusobserver.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/observer/focusobserver
 */

/* globals setTimeout, clearTimeout */

/**
 * {@link module:engine/view/document~Document#event:focus Focus}
 * and {@link module:engine/view/document~Document#event:blur blur} events observer.
 * Focus observer handle also {@link module:engine/view/rooteditableelement~RootEditableElement#isFocused isFocused} property of the
 * {@link module:engine/view/rooteditableelement~RootEditableElement root elements}.
 *
 * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.
 *
 * @extends module:engine/view/observer/domeventobserver~DomEventObserver
 */

var focusobserver_FocusObserver = /*#__PURE__*/function (_DomEventObserver) {
  Object(inherits["a" /* default */])(FocusObserver, _DomEventObserver);

  var _super = Object(createSuper["a" /* default */])(FocusObserver);

  function FocusObserver(view) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, FocusObserver);

    _this = _super.call(this, view);
    _this.domEventType = ['focus', 'blur'];
    _this.useCapture = true;
    var document = _this.document;
    document.on('focus', function () {
      document.isFocused = true; // Unfortunately native `selectionchange` event is fired asynchronously.
      // We need to wait until `SelectionObserver` handle the event and then render. Otherwise rendering will
      // overwrite new DOM selection with selection from the view.
      // See https://github.com/ckeditor/ckeditor5-engine/issues/795 for more details.
      // Long timeout is needed to solve #676 and https://github.com/ckeditor/ckeditor5-engine/issues/1157 issues.

      _this._renderTimeoutId = setTimeout(function () {
        return view.forceRender();
      }, 50);
    });
    document.on('blur', function (evt, data) {
      var selectedEditable = document.selection.editableElement;

      if (selectedEditable === null || selectedEditable === data.target) {
        document.isFocused = false; // Re-render the document to update view elements.

        view.forceRender();
      }
    });
    /**
     * Identifier of the timeout currently used by focus listener to delay rendering execution.
     *
     * @private
     * @member {Number} #_renderTimeoutId
     */

    return _this;
  }

  Object(createClass["a" /* default */])(FocusObserver, [{
    key: "onDomEvent",
    value: function onDomEvent(domEvent) {
      this.fire(domEvent.type, domEvent);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "destroy",
    value: function destroy() {
      if (this._renderTimeoutId) {
        clearTimeout(this._renderTimeoutId);
      }

      get_get(Object(getPrototypeOf["a" /* default */])(FocusObserver.prototype), "destroy", this).call(this);
    }
  }]);

  return FocusObserver;
}(domeventobserver_DomEventObserver);
/**
 * Fired when one of the editables gets focus.
 *
 * Introduced by {@link module:engine/view/observer/focusobserver~FocusObserver}.
 *
 * Note that because {@link module:engine/view/observer/focusobserver~FocusObserver} is attached by the
 * {@link module:engine/view/view~View} this event is available by default.
 *
 * @see module:engine/view/observer/focusobserver~FocusObserver
 * @event module:engine/view/document~Document#event:focus
 * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.
 */

/**
 * Fired when one of the editables loses focus.
 *
 * Introduced by {@link module:engine/view/observer/focusobserver~FocusObserver}.
 *
 * Note that because {@link module:engine/view/observer/focusobserver~FocusObserver} is attached by the
 * {@link module:engine/view/view~View} this event is available by default.
 *
 * @see module:engine/view/observer/focusobserver~FocusObserver
 * @event module:engine/view/document~Document#event:blur
 * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/observer/compositionobserver.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/observer/compositionobserver
 */

/**
 * {@link module:engine/view/document~Document#event:compositionstart Compositionstart},
 * {@link module:engine/view/document~Document#event:compositionupdate compositionupdate} and
 * {@link module:engine/view/document~Document#event:compositionend compositionend} events observer.
 *
 * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.
 *
 * @extends module:engine/view/observer/domeventobserver~DomEventObserver
 */

var compositionobserver_CompositionObserver = /*#__PURE__*/function (_DomEventObserver) {
  Object(inherits["a" /* default */])(CompositionObserver, _DomEventObserver);

  var _super = Object(createSuper["a" /* default */])(CompositionObserver);

  function CompositionObserver(view) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, CompositionObserver);

    _this = _super.call(this, view);
    _this.domEventType = ['compositionstart', 'compositionupdate', 'compositionend'];
    var document = _this.document;
    document.on('compositionstart', function () {
      document.isComposing = true;
    });
    document.on('compositionend', function () {
      document.isComposing = false;
    });
    return _this;
  }

  Object(createClass["a" /* default */])(CompositionObserver, [{
    key: "onDomEvent",
    value: function onDomEvent(domEvent) {
      this.fire(domEvent.type, domEvent);
    }
  }]);

  return CompositionObserver;
}(domeventobserver_DomEventObserver);
/**
 * Fired when composition starts inside one of the editables.
 *
 * Introduced by {@link module:engine/view/observer/compositionobserver~CompositionObserver}.
 *
 * Note that because {@link module:engine/view/observer/compositionobserver~CompositionObserver} is attached by the
 * {@link module:engine/view/view~View} this event is available by default.
 *
 * @see module:engine/view/observer/compositionobserver~CompositionObserver
 * @event module:engine/view/document~Document#event:compositionstart
 * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.
 */

/**
 * Fired when composition is updated inside one of the editables.
 *
 * Introduced by {@link module:engine/view/observer/compositionobserver~CompositionObserver}.
 *
 * Note that because {@link module:engine/view/observer/compositionobserver~CompositionObserver} is attached by the
 * {@link module:engine/view/view~View} this event is available by default.
 *
 * @see module:engine/view/observer/compositionobserver~CompositionObserver
 * @event module:engine/view/document~Document#event:compositionupdate
 * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.
 */

/**
 * Fired when composition ends inside one of the editables.
 *
 * Introduced by {@link module:engine/view/observer/compositionobserver~CompositionObserver}.
 *
 * Note that because {@link module:engine/view/observer/compositionobserver~CompositionObserver} is attached by the
 * {@link module:engine/view/view~View} this event is available by default.
 *
 * @see module:engine/view/observer/compositionobserver~CompositionObserver
 * @event module:engine/view/document~Document#event:compositionend
 * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/observer/inputobserver.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module engine/view/observer/inputobserver
 */

/**
 * Observer for events connected with data input.
 *
 * Note that this observer is attached by the {@link module:engine/view/view~View} and is available by default.
 *
 * @extends module:engine/view/observer/domeventobserver~DomEventObserver
 */

var inputobserver_InputObserver = /*#__PURE__*/function (_DomEventObserver) {
  Object(inherits["a" /* default */])(InputObserver, _DomEventObserver);

  var _super = Object(createSuper["a" /* default */])(InputObserver);

  function InputObserver(view) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, InputObserver);

    _this = _super.call(this, view);
    _this.domEventType = ['beforeinput'];
    return _this;
  }

  Object(createClass["a" /* default */])(InputObserver, [{
    key: "onDomEvent",
    value: function onDomEvent(domEvent) {
      this.fire(domEvent.type, domEvent);
    }
  }]);

  return InputObserver;
}(domeventobserver_DomEventObserver);
/**
 * Fired before browser inputs (or deletes) some data.
 *
 * This event is available only on browsers which support DOM `beforeinput` event.
 *
 * Introduced by {@link module:engine/view/observer/inputobserver~InputObserver}.
 *
 * Note that because {@link module:engine/view/observer/inputobserver~InputObserver} is attached by the
 * {@link module:engine/view/view~View} this event is available by default.
 *
 * @see module:engine/view/observer/inputobserver~InputObserver
 * @event module:engine/view/document~Document#event:beforeinput
 * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/isrange.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/dom/isrange
 */

/**
 * Checks if the object is a native DOM Range.
 *
 * @param {*} obj
 * @returns {Boolean}
 */
function isRange(obj) {
  return Object.prototype.toString.apply(obj) == '[object Range]';
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/getborderwidths.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/dom/getborderwidths
 */

/**
 * Returns an object containing CSS border widths of a specified HTML element.
 *
 * @param {HTMLElement} element An element which has CSS borders.
 * @returns {Object} An object containing `top`, `left`, `right` and `bottom` properties
 * with numerical values of the `border-[top,left,right,bottom]-width` CSS styles.
 */
function getBorderWidths(element) {
  // Call getComputedStyle on the window the element document belongs to.
  var style = element.ownerDocument.defaultView.getComputedStyle(element);
  return {
    top: parseInt(style.borderTopWidth, 10),
    right: parseInt(style.borderRightWidth, 10),
    bottom: parseInt(style.borderBottomWidth, 10),
    left: parseInt(style.borderLeftWidth, 10)
  };
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/rect.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/dom/rect
 */





var rectProperties = ['top', 'right', 'bottom', 'left', 'width', 'height'];
/**
 * A helper class representing a `ClientRect` object, e.g. value returned by
 * the native `object.getBoundingClientRect()` method. Provides a set of methods
 * to manipulate the rect and compare it against other rect instances.
 */

var rect_Rect = /*#__PURE__*/function () {
  /**
   * Creates an instance of rect.
   *
   *		// Rect of an HTMLElement.
   *		const rectA = new Rect( document.body );
   *
   *		// Rect of a DOM Range.
   *		const rectB = new Rect( document.getSelection().getRangeAt( 0 ) );
   *
   *		// Rect of a window (web browser viewport).
   *		const rectC = new Rect( window );
   *
   *		// Rect out of an object.
   *		const rectD = new Rect( { top: 0, right: 10, bottom: 10, left: 0, width: 10, height: 10 } );
   *
   *		// Rect out of another Rect instance.
   *		const rectE = new Rect( rectD );
   *
   *		// Rect out of a ClientRect.
   *		const rectF = new Rect( document.body.getClientRects().item( 0 ) );
   *
   * **Note**: By default a rect of an HTML element includes its CSS borders and scrollbars (if any)
   * ant the rect of a `window` includes scrollbars too. Use {@link #excludeScrollbarsAndBorders}
   * to get the inner part of the rect.
   *
   * @param {HTMLElement|Range|Window|ClientRect|module:utils/dom/rect~Rect|Object} source A source object to create the rect.
   */
  function Rect(source) {
    Object(classCallCheck["a" /* default */])(this, Rect);

    var isSourceRange = isRange(source);
    /**
     * The object this rect is for.
     *
     * @protected
     * @readonly
     * @member {HTMLElement|Range|ClientRect|module:utils/dom/rect~Rect|Object} #_source
     */

    Object.defineProperty(this, '_source', {
      // If the source is a Rect instance, copy it's #_source.
      value: source._source || source,
      writable: true,
      enumerable: false
    });

    if (lodash_es_isElement(source) || isSourceRange) {
      // The `Rect` class depends on `getBoundingClientRect` and `getClientRects` DOM methods. If the source
      // of a rect in an HTML element or a DOM range but it does not belong to any rendered DOM tree, these methods
      // will fail to obtain the geometry and the rect instance makes little sense to the features using it.
      // To get rid of this warning make sure the source passed to the constructor is a descendant of `window.document.body`.
      // @if CK_DEBUG // const sourceNode = isSourceRange ? source.startContainer : source;
      // @if CK_DEBUG // if ( !sourceNode.ownerDocument || !sourceNode.ownerDocument.body.contains( sourceNode ) ) {
      // @if CK_DEBUG // 	console.warn(
      // @if CK_DEBUG // 		'rect-source-not-in-dom: The source of this rect does not belong to any rendered DOM tree.',
      // @if CK_DEBUG // 		{ source } );
      // @if CK_DEBUG // }
      if (isSourceRange) {
        copyRectProperties(this, Rect.getDomRangeRects(source)[0]);
      } else {
        copyRectProperties(this, source.getBoundingClientRect());
      }
    } else if (isWindow(source)) {
      var innerWidth = source.innerWidth,
          innerHeight = source.innerHeight;
      copyRectProperties(this, {
        top: 0,
        right: innerWidth,
        bottom: innerHeight,
        left: 0,
        width: innerWidth,
        height: innerHeight
      });
    } else {
      copyRectProperties(this, source);
    }
    /**
     * The "top" value of the rect.
     *
     * @readonly
     * @member {Number} #top
     */

    /**
     * The "right" value of the rect.
     *
     * @readonly
     * @member {Number} #right
     */

    /**
     * The "bottom" value of the rect.
     *
     * @readonly
     * @member {Number} #bottom
     */

    /**
     * The "left" value of the rect.
     *
     * @readonly
     * @member {Number} #left
     */

    /**
     * The "width" value of the rect.
     *
     * @readonly
     * @member {Number} #width
     */

    /**
     * The "height" value of the rect.
     *
     * @readonly
     * @member {Number} #height
     */

  }
  /**
   * Returns a clone of the rect.
   *
   * @returns {module:utils/dom/rect~Rect} A cloned rect.
   */


  Object(createClass["a" /* default */])(Rect, [{
    key: "clone",
    value: function clone() {
      return new Rect(this);
    }
    /**
     * Moves the rect so that its upper–left corner lands in desired `[ x, y ]` location.
     *
     * @param {Number} x Desired horizontal location.
     * @param {Number} y Desired vertical location.
     * @returns {module:utils/dom/rect~Rect} A rect which has been moved.
     */

  }, {
    key: "moveTo",
    value: function moveTo(x, y) {
      this.top = y;
      this.right = x + this.width;
      this.bottom = y + this.height;
      this.left = x;
      return this;
    }
    /**
     * Moves the rect in–place by a dedicated offset.
     *
     * @param {Number} x A horizontal offset.
     * @param {Number} y A vertical offset
     * @returns {module:utils/dom/rect~Rect} A rect which has been moved.
     */

  }, {
    key: "moveBy",
    value: function moveBy(x, y) {
      this.top += y;
      this.right += x;
      this.left += x;
      this.bottom += y;
      return this;
    }
    /**
     * Returns a new rect a a result of intersection with another rect.
     *
     * @param {module:utils/dom/rect~Rect} anotherRect
     * @returns {module:utils/dom/rect~Rect}
     */

  }, {
    key: "getIntersection",
    value: function getIntersection(anotherRect) {
      var rect = {
        top: Math.max(this.top, anotherRect.top),
        right: Math.min(this.right, anotherRect.right),
        bottom: Math.min(this.bottom, anotherRect.bottom),
        left: Math.max(this.left, anotherRect.left)
      };
      rect.width = rect.right - rect.left;
      rect.height = rect.bottom - rect.top;

      if (rect.width < 0 || rect.height < 0) {
        return null;
      } else {
        return new Rect(rect);
      }
    }
    /**
     * Returns the area of intersection with another rect.
     *
     * @param {module:utils/dom/rect~Rect} anotherRect [description]
     * @returns {Number} Area of intersection.
     */

  }, {
    key: "getIntersectionArea",
    value: function getIntersectionArea(anotherRect) {
      var rect = this.getIntersection(anotherRect);

      if (rect) {
        return rect.getArea();
      } else {
        return 0;
      }
    }
    /**
     * Returns the area of the rect.
     *
     * @returns {Number}
     */

  }, {
    key: "getArea",
    value: function getArea() {
      return this.width * this.height;
    }
    /**
     * Returns a new rect, a part of the original rect, which is actually visible to the user,
     * e.g. an original rect cropped by parent element rects which have `overflow` set in CSS
     * other than `"visible"`.
     *
     * If there's no such visible rect, which is when the rect is limited by one or many of
     * the ancestors, `null` is returned.
     *
     * @returns {module:utils/dom/rect~Rect|null} A visible rect instance or `null`, if there's none.
     */

  }, {
    key: "getVisible",
    value: function getVisible() {
      var source = this._source;
      var visibleRect = this.clone(); // There's no ancestor to crop <body> with the overflow.

      if (!isBody(source)) {
        var parent = source.parentNode || source.commonAncestorContainer; // Check the ancestors all the way up to the <body>.

        while (parent && !isBody(parent)) {
          var parentRect = new Rect(parent);
          var intersectionRect = visibleRect.getIntersection(parentRect);

          if (intersectionRect) {
            if (intersectionRect.getArea() < visibleRect.getArea()) {
              // Reduce the visible rect to the intersection.
              visibleRect = intersectionRect;
            }
          } else {
            // There's no intersection, the rect is completely invisible.
            return null;
          }

          parent = parent.parentNode;
        }
      }

      return visibleRect;
    }
    /**
     * Checks if all property values ({@link #top}, {@link #left}, {@link #right},
     * {@link #bottom}, {@link #width} and {@link #height}) are the equal in both rect
     * instances.
     *
     * @param {module:utils/dom/rect~Rect} rect A rect instance to compare with.
     * @returns {Boolean} `true` when Rects are equal. `false` otherwise.
     */

  }, {
    key: "isEqual",
    value: function isEqual(anotherRect) {
      var _iterator = _createForOfIteratorHelper(rectProperties),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var prop = _step.value;

          if (this[prop] !== anotherRect[prop]) {
            return false;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return true;
    }
    /**
     * Checks whether a rect fully contains another rect instance.
     *
     * @param {module:utils/dom/rect~Rect} anotherRect
     * @returns {Boolean} `true` if contains, `false` otherwise.
     */

  }, {
    key: "contains",
    value: function contains(anotherRect) {
      var intersectRect = this.getIntersection(anotherRect);
      return !!(intersectRect && intersectRect.isEqual(anotherRect));
    }
    /**
     * Excludes scrollbars and CSS borders from the rect.
     *
     * * Borders are removed when {@link #_source} is an HTML element.
     * * Scrollbars are excluded from HTML elements and the `window`.
     *
     * @returns {module:utils/dom/rect~Rect} A rect which has been updated.
     */

  }, {
    key: "excludeScrollbarsAndBorders",
    value: function excludeScrollbarsAndBorders() {
      var source = this._source;
      var scrollBarWidth, scrollBarHeight, direction;

      if (isWindow(source)) {
        scrollBarWidth = source.innerWidth - source.document.documentElement.clientWidth;
        scrollBarHeight = source.innerHeight - source.document.documentElement.clientHeight;
        direction = source.getComputedStyle(source.document.documentElement).direction;
      } else {
        var borderWidths = getBorderWidths(this._source);
        scrollBarWidth = source.offsetWidth - source.clientWidth - borderWidths.left - borderWidths.right;
        scrollBarHeight = source.offsetHeight - source.clientHeight - borderWidths.top - borderWidths.bottom;
        direction = source.ownerDocument.defaultView.getComputedStyle(source).direction;
        this.left += borderWidths.left;
        this.top += borderWidths.top;
        this.right -= borderWidths.right;
        this.bottom -= borderWidths.bottom;
        this.width = this.right - this.left;
        this.height = this.bottom - this.top;
      }

      this.width -= scrollBarWidth;

      if (direction === 'ltr') {
        this.right -= scrollBarWidth;
      } else {
        this.left += scrollBarWidth;
      }

      this.height -= scrollBarHeight;
      this.bottom -= scrollBarHeight;
      return this;
    }
    /**
     * Returns an array of rects of the given native DOM Range.
     *
     * @param {Range} range A native DOM range.
     * @returns {Array.<module:utils/dom/rect~Rect>} DOM Range rects.
     */

  }], [{
    key: "getDomRangeRects",
    value: function getDomRangeRects(range) {
      var rects = []; // Safari does not iterate over ClientRectList using for...of loop.

      var clientRects = Array.from(range.getClientRects());

      if (clientRects.length) {
        var _iterator2 = _createForOfIteratorHelper(clientRects),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var rect = _step2.value;
            rects.push(new Rect(rect));
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } // If there's no client rects for the Range, use parent container's bounding rect
      // instead and adjust rect's width to simulate the actual geometry of such range.
      // https://github.com/ckeditor/ckeditor5-utils/issues/153
      // https://github.com/ckeditor/ckeditor5-ui/issues/317
      else {
          var startContainer = range.startContainer;

          if (istext_isText(startContainer)) {
            startContainer = startContainer.parentNode;
          }

          var _rect = new Rect(startContainer.getBoundingClientRect());

          _rect.right = _rect.left;
          _rect.width = 0;
          rects.push(_rect);
        }

      return rects;
    }
  }]);

  return Rect;
}(); // Acquires all the rect properties from the passed source.
//
// @private
// @param {module:utils/dom/rect~Rect} rect
// @param {ClientRect|module:utils/dom/rect~Rect|Object} source




function copyRectProperties(rect, source) {
  var _iterator3 = _createForOfIteratorHelper(rectProperties),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var p = _step3.value;
      rect[p] = source[p];
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
} // Checks if provided object is a <body> HTML element.
//
// @private
// @param {HTMLElement|Range} elementOrRange
// @returns {Boolean}


function isBody(elementOrRange) {
  if (!lodash_es_isElement(elementOrRange)) {
    return false;
  }

  return elementOrRange === elementOrRange.ownerDocument.body;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/scroll.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/dom/scroll
 */



var utils = {};
/**
 * Makes any page `HTMLElement` or `Range` (`target`) visible inside the browser viewport.
 * This helper will scroll all `target` ancestors and the web browser viewport to reveal the target to
 * the user. If the `target` is already visible, nothing will happen.
 *
 * @param {HTMLElement|Range} options.target A target, which supposed to become visible to the user.
 * @param {Number} [options.viewportOffset] An offset from the edge of the viewport (in pixels)
 * the `target` will be moved by when the viewport is scrolled. It enhances the user experience
 * by keeping the `target` some distance from the edge of the viewport and thus making it easier to
 * read or edit by the user.
 */

function scrollViewportToShowTarget(_ref) {
  var target = _ref.target,
      _ref$viewportOffset = _ref.viewportOffset,
      viewportOffset = _ref$viewportOffset === void 0 ? 0 : _ref$viewportOffset;
  var targetWindow = getWindow(target);
  var currentWindow = targetWindow;
  var currentFrame = null; // Iterate over all windows, starting from target's parent window up to window#top.

  while (currentWindow) {
    var firstAncestorToScroll = void 0; // Let's scroll target's ancestors first to reveal it. Then, once the ancestor scrolls
    // settled down, the algorithm can eventually scroll the viewport of the current window.
    //
    // Note: If the current window is target's **original** window (e.g. the first one),
    // start scrolling the closest parent of the target. If not, scroll the closest parent
    // of an iframe that resides in the current window.

    if (currentWindow == targetWindow) {
      firstAncestorToScroll = getParentElement(target);
    } else {
      firstAncestorToScroll = getParentElement(currentFrame);
    } // Scroll the target's ancestors first. Once done, scrolling the viewport is easy.


    scrollAncestorsToShowRect(firstAncestorToScroll, function () {
      // Note: If the target does not belong to the current window **directly**,
      // i.e. it resides in an iframe belonging to the window, obtain the target's rect
      // in the coordinates of the current window. By default, a Rect returns geometry
      // relative to the current window's viewport. To make it work in a parent window,
      // it must be shifted.
      return getRectRelativeToWindow(target, currentWindow);
    }); // Obtain the rect of the target after it has been scrolled within its ancestors.
    // It's time to scroll the viewport.

    var targetRect = getRectRelativeToWindow(target, currentWindow);
    scrollWindowToShowRect(currentWindow, targetRect, viewportOffset);

    if (currentWindow.parent != currentWindow) {
      // Keep the reference to the <iframe> element the "previous current window" was
      // rendered within. It will be useful to re–calculate the rect of the target
      // in the parent window's relative geometry. The target's rect must be shifted
      // by it's iframe's position.
      currentFrame = currentWindow.frameElement;
      currentWindow = currentWindow.parent; // If the current window has some parent but frameElement is inaccessible, then they have
      // different domains/ports and, due to security reasons, accessing and scrolling
      // the parent window won't be possible.
      // See https://github.com/ckeditor/ckeditor5/issues/930.

      if (!currentFrame) {
        return;
      }
    } else {
      currentWindow = null;
    }
  }
}
/**
 * Makes any page `HTMLElement` or `Range` (target) visible within its scrollable ancestors,
 * e.g. if they have `overflow: scroll` CSS style.
 *
 * @param {HTMLElement|Range} target A target, which supposed to become visible to the user.
 */

function scrollAncestorsToShowTarget(target) {
  var targetParent = getParentElement(target);
  scrollAncestorsToShowRect(targetParent, function () {
    return new rect_Rect(target);
  });
} // TODO: Using a property value shorthand in the top of the file
// causes JSDoc to throw errors. See https://github.com/cksource/docs-builder/issues/75.

Object.assign(utils, {
  scrollViewportToShowTarget: scrollViewportToShowTarget,
  scrollAncestorsToShowTarget: scrollAncestorsToShowTarget
}); // Makes a given rect visible within its parent window.
//
// Note: Avoid the situation where the caret is still in the viewport, but totally
// at the edge of it. In such situation, if it moved beyond the viewport in the next
// action e.g. after paste, the scrolling would move it to the viewportOffset level
// and it all would look like the caret visually moved up/down:
//
// 1.
//		| foo[]
//		|                                    <--- N px of space below the caret
//		+---------------------------------...
//
// 2. *paste*
// 3.
//		|
//		|
//		+-foo-----------------------------...
//		  bar[]                              <--- caret below viewport, scrolling...
//
// 4. *scrolling*
// 5.
//		|
//		| foo
//		| bar[]                              <--- caret precisely at the edge
//		+---------------------------------...
//
// To prevent this, this method checks the rects moved by the viewportOffset to cover
// the upper/lower edge of the viewport. It makes sure if the action repeats, there's
// no twitching – it's a purely visual improvement:
//
// 5. (after fix)
//		|
//		| foo
//		| bar[]
//		|                                    <--- N px of space below the caret
//		+---------------------------------...
//
// @private
// @param {Window} window A window which is scrolled to reveal the rect.
// @param {module:utils/dom/rect~Rect} rect A rect which is to be revealed.
// @param {Number} viewportOffset See scrollViewportToShowTarget.

function scrollWindowToShowRect(window, rect, viewportOffset) {
  var targetShiftedDownRect = rect.clone().moveBy(0, viewportOffset);
  var targetShiftedUpRect = rect.clone().moveBy(0, -viewportOffset);
  var viewportRect = new rect_Rect(window).excludeScrollbarsAndBorders();
  var rects = [targetShiftedUpRect, targetShiftedDownRect];

  if (!rects.every(function (rect) {
    return viewportRect.contains(rect);
  })) {
    var scrollX = window.scrollX,
        scrollY = window.scrollY;

    if (isAbove(targetShiftedUpRect, viewportRect)) {
      scrollY -= viewportRect.top - rect.top + viewportOffset;
    } else if (isBelow(targetShiftedDownRect, viewportRect)) {
      scrollY += rect.bottom - viewportRect.bottom + viewportOffset;
    } // TODO: Web browsers scroll natively to place the target in the middle
    // of the viewport. It's not a very popular case, though.


    if (isLeftOf(rect, viewportRect)) {
      scrollX -= viewportRect.left - rect.left + viewportOffset;
    } else if (isRightOf(rect, viewportRect)) {
      scrollX += rect.right - viewportRect.right + viewportOffset;
    }

    window.scrollTo(scrollX, scrollY);
  }
} // Recursively scrolls element ancestors to visually reveal a rect.
//
// @private
// @param {HTMLElement} A parent The first ancestors to start scrolling.
// @param {Function} getRect A function which returns the Rect, which is to be revealed.


function scrollAncestorsToShowRect(parent, getRect) {
  var parentWindow = getWindow(parent);
  var parentRect, targetRect;

  while (parent != parentWindow.document.body) {
    targetRect = getRect();
    parentRect = new rect_Rect(parent).excludeScrollbarsAndBorders();

    if (!parentRect.contains(targetRect)) {
      if (isAbove(targetRect, parentRect)) {
        parent.scrollTop -= parentRect.top - targetRect.top;
      } else if (isBelow(targetRect, parentRect)) {
        parent.scrollTop += targetRect.bottom - parentRect.bottom;
      }

      if (isLeftOf(targetRect, parentRect)) {
        parent.scrollLeft -= parentRect.left - targetRect.left;
      } else if (isRightOf(targetRect, parentRect)) {
        parent.scrollLeft += targetRect.right - parentRect.right;
      }
    }

    parent = parent.parentNode;
  }
} // Determines if a given `Rect` extends beyond the bottom edge of the second `Rect`.
//
// @private
// @param {module:utils/dom/rect~Rect} firstRect
// @param {module:utils/dom/rect~Rect} secondRect


function isBelow(firstRect, secondRect) {
  return firstRect.bottom > secondRect.bottom;
} // Determines if a given `Rect` extends beyond the top edge of the second `Rect`.
//
// @private
// @param {module:utils/dom/rect~Rect} firstRect
// @param {module:utils/dom/rect~Rect} secondRect


function isAbove(firstRect, secondRect) {
  return firstRect.top < secondRect.top;
} // Determines if a given `Rect` extends beyond the left edge of the second `Rect`.
//
// @private
// @param {module:utils/dom/rect~Rect} firstRect
// @param {module:utils/dom/rect~Rect} secondRect


function isLeftOf(firstRect, secondRect) {
  return firstRect.left < secondRect.left;
} // Determines if a given `Rect` extends beyond the right edge of the second `Rect`.
//
// @private
// @param {module:utils/dom/rect~Rect} firstRect
// @param {module:utils/dom/rect~Rect} secondRect


function isRightOf(firstRect, secondRect) {
  return firstRect.right > secondRect.right;
} // Returns the closest window of an element or range.
//
// @private
// @param {HTMLElement|Range} firstRect
// @returns {Window}


function getWindow(elementOrRange) {
  if (isRange(elementOrRange)) {
    return elementOrRange.startContainer.ownerDocument.defaultView;
  } else {
    return elementOrRange.ownerDocument.defaultView;
  }
} // Returns the closest parent of an element or DOM range.
//
// @private
// @param {HTMLElement|Range} firstRect
// @returns {HTMLelement}


function getParentElement(elementOrRange) {
  if (isRange(elementOrRange)) {
    var parent = elementOrRange.commonAncestorContainer; // If a Range is attached to the Text, use the closest element ancestor.

    if (istext_isText(parent)) {
      parent = parent.parentNode;
    }

    return parent;
  } else {
    return elementOrRange.parentNode;
  }
} // Returns the rect of an element or range residing in an iframe.
// The result rect is relative to the geometry of the passed window instance.
//
// @private
// @param {HTMLElement|Range} target Element or range which rect should be returned.
// @param {Window} relativeWindow A window the rect should be relative to.
// @returns {module:utils/dom/rect~Rect}


function getRectRelativeToWindow(target, relativeWindow) {
  var targetWindow = getWindow(target);
  var rect = new rect_Rect(target);

  if (targetWindow === relativeWindow) {
    return rect;
  } else {
    var currentWindow = targetWindow;

    while (currentWindow != relativeWindow) {
      var frame = currentWindow.frameElement;
      var frameRect = new rect_Rect(frame).excludeScrollbarsAndBorders();
      rect.moveBy(frameRect.left, frameRect.top);
      currentWindow = currentWindow.parent;
    }
  }

  return rect;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/view.js

















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/view
 */





















/**
 * Editor's view controller class. Its main responsibility is DOM - View management for editing purposes, to provide
 * abstraction over the DOM structure and events and hide all browsers quirks.
 *
 * View controller renders view document to DOM whenever view structure changes. To determine when view can be rendered,
 * all changes need to be done using the {@link module:engine/view/view~View#change} method, using
 * {@link module:engine/view/downcastwriter~DowncastWriter}:
 *
 *		view.change( writer => {
 *			writer.insert( position, writer.createText( 'foo' ) );
 *		} );
 *
 * View controller also register {@link module:engine/view/observer/observer~Observer observers} which observes changes
 * on DOM and fire events on the {@link module:engine/view/document~Document Document}.
 * Note that the following observers are added by the class constructor and are always available:
 *
 * * {@link module:engine/view/observer/mutationobserver~MutationObserver},
 * * {@link module:engine/view/observer/selectionobserver~SelectionObserver},
 * * {@link module:engine/view/observer/focusobserver~FocusObserver},
 * * {@link module:engine/view/observer/keyobserver~KeyObserver},
 * * {@link module:engine/view/observer/fakeselectionobserver~FakeSelectionObserver}.
 * * {@link module:engine/view/observer/compositionobserver~CompositionObserver}.
 *
 * This class also {@link module:engine/view/view~View#attachDomRoot binds the DOM and the view elements}.
 *
 * If you do not need full a DOM - view management, and only want to transform a tree of view elements to a tree of DOM
 * elements you do not need this controller. You can use the {@link module:engine/view/domconverter~DomConverter DomConverter} instead.
 *
 * @mixes module:utils/observablemixin~ObservableMixin
 */

var view_View = /*#__PURE__*/function () {
  /**
   * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.
   */
  function View(stylesProcessor) {
    var _this = this;

    Object(classCallCheck["a" /* default */])(this, View);

    /**
     * Instance of the {@link module:engine/view/document~Document} associated with this view controller.
     *
     * @readonly
     * @type {module:engine/view/document~Document}
     */
    this.document = new document_Document(stylesProcessor);
    /**
     * Instance of the {@link module:engine/view/domconverter~DomConverter domConverter} used by
     * {@link module:engine/view/view~View#_renderer renderer}
     * and {@link module:engine/view/observer/observer~Observer observers}.
     *
     * @readonly
     * @type {module:engine/view/domconverter~DomConverter}
     */

    this.domConverter = new domconverter_DomConverter(this.document);
    /**
     * Roots of the DOM tree. Map on the `HTMLElement`s with roots names as keys.
     *
     * @readonly
     * @type {Map.<String, HTMLElement>}
     */

    this.domRoots = new Map();
    /**
     * Used to prevent calling {@link #forceRender} and {@link #change} during rendering view to the DOM.
     *
     * @readonly
     * @member {Boolean} #isRenderingInProgress
     */

    this.set('isRenderingInProgress', false);
    /**
     * Informs whether the DOM selection is inside any of the DOM roots managed by the view.
     *
     * @readonly
     * @member {Boolean} #hasDomSelection
     */

    this.set('hasDomSelection', false);
    /**
     * Instance of the {@link module:engine/view/renderer~Renderer renderer}.
     *
     * @protected
     * @type {module:engine/view/renderer~Renderer}
     */

    this._renderer = new renderer_Renderer(this.domConverter, this.document.selection);

    this._renderer.bind('isFocused').to(this.document);
    /**
     * A DOM root attributes cache. It saves the initial values of DOM root attributes before the DOM element
     * is {@link module:engine/view/view~View#attachDomRoot attached} to the view so later on, when
     * the view is destroyed ({@link module:engine/view/view~View#detachDomRoot}), they can be easily restored.
     * This way, the DOM element can go back to the (clean) state as if the editing view never used it.
     *
     * @private
     * @member {WeakMap.<HTMLElement,Object>}
     */


    this._initialDomRootAttributes = new WeakMap();
    /**
     * Map of registered {@link module:engine/view/observer/observer~Observer observers}.
     *
     * @private
     * @type {Map.<Function, module:engine/view/observer/observer~Observer>}
     */

    this._observers = new Map();
    /**
     * Is set to `true` when {@link #change view changes} are currently in progress.
     *
     * @private
     * @type {Boolean}
     */

    this._ongoingChange = false;
    /**
     * Used to prevent calling {@link #forceRender} and {@link #change} during rendering view to the DOM.
     *
     * @private
     * @type {Boolean}
     */

    this._postFixersInProgress = false;
    /**
     * Internal flag to temporary disable rendering. See the usage in the {@link #_disableRendering}.
     *
     * @private
     * @type {Boolean}
     */

    this._renderingDisabled = false;
    /**
     * Internal flag that disables rendering when there are no changes since the last rendering.
     * It stores information about changed selection and changed elements from attached document roots.
     *
     * @private
     * @type {Boolean}
     */

    this._hasChangedSinceTheLastRendering = false;
    /**
     * DowncastWriter instance used in {@link #change change method} callbacks.
     *
     * @private
     * @type {module:engine/view/downcastwriter~DowncastWriter}
     */

    this._writer = new downcastwriter_DowncastWriter(this.document); // Add default observers.

    this.addObserver(mutationobserver_MutationObserver);
    this.addObserver(selectionobserver_SelectionObserver);
    this.addObserver(focusobserver_FocusObserver);
    this.addObserver(keyobserver_KeyObserver);
    this.addObserver(fakeselectionobserver_FakeSelectionObserver);
    this.addObserver(compositionobserver_CompositionObserver);

    if (src_env.isAndroid) {
      this.addObserver(inputobserver_InputObserver);
    } // Inject quirks handlers.


    injectQuirksHandling(this);
    injectUiElementHandling(this); // Use 'normal' priority so that rendering is performed as first when using that priority.

    this.on('render', function () {
      _this._render(); // Informs that layout has changed after render.


      _this.document.fire('layoutChanged'); // Reset the `_hasChangedSinceTheLastRendering` flag after rendering.


      _this._hasChangedSinceTheLastRendering = false;
    }); // Listen to the document selection changes directly.

    this.listenTo(this.document.selection, 'change', function () {
      _this._hasChangedSinceTheLastRendering = true;
    });
  }
  /**
   * Attaches a DOM root element to the view element and enable all observers on that element.
   * Also {@link module:engine/view/renderer~Renderer#markToSync mark element} to be synchronized
   * with the view what means that all child nodes will be removed and replaced with content of the view root.
   *
   * This method also will change view element name as the same as tag name of given dom root.
   * Name is always transformed to lower case.
   *
   * **Note:** Use {@link #detachDomRoot `detachDomRoot()`} to revert this action.
   *
   * @param {Element} domRoot DOM root element.
   * @param {String} [name='main'] Name of the root.
   */


  Object(createClass["a" /* default */])(View, [{
    key: "attachDomRoot",
    value: function attachDomRoot(domRoot) {
      var _this2 = this;

      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'main';
      var viewRoot = this.document.getRoot(name); // Set view root name the same as DOM root tag name.

      viewRoot._name = domRoot.tagName.toLowerCase();
      var initialDomRootAttributes = {}; // 1. Copy and cache the attributes to remember the state of the element before attaching.
      //    The cached attributes will be restored in detachDomRoot() so the element goes to the
      //    clean state as if the editing view never used it.
      // 2. Apply the attributes using the view writer, so they all go under the control of the engine.
      //    The editing view takes over the attribute management completely because various
      //    features (e.g. addPlaceholder()) require dynamic changes of those attributes and they
      //    cannot be managed by the engine and the UI library at the same time.

      for (var _i = 0, _Array$from = Array.from(domRoot.attributes); _i < _Array$from.length; _i++) {
        var _Array$from$_i = _Array$from[_i],
            _name = _Array$from$_i.name,
            value = _Array$from$_i.value;
        initialDomRootAttributes[_name] = value; // Do not use writer.setAttribute() for the class attribute. The EditableUIView class
        // and its descendants could have already set some using the writer.addClass() on the view
        // document root. They haven't been rendered yet so they are not present in the DOM root.
        // Using writer.setAttribute( 'class', ... ) would override them completely.

        if (_name === 'class') {
          this._writer.addClass(value.split(' '), viewRoot);
        } else {
          this._writer.setAttribute(_name, value, viewRoot);
        }
      }

      this._initialDomRootAttributes.set(domRoot, initialDomRootAttributes);

      var updateContenteditableAttribute = function updateContenteditableAttribute() {
        _this2._writer.setAttribute('contenteditable', !viewRoot.isReadOnly, viewRoot);

        if (viewRoot.isReadOnly) {
          _this2._writer.addClass('ck-read-only', viewRoot);
        } else {
          _this2._writer.removeClass('ck-read-only', viewRoot);
        }
      }; // Set initial value.


      updateContenteditableAttribute();
      this.domRoots.set(name, domRoot);
      this.domConverter.bindElements(domRoot, viewRoot);

      this._renderer.markToSync('children', viewRoot);

      this._renderer.markToSync('attributes', viewRoot);

      this._renderer.domDocuments.add(domRoot.ownerDocument);

      viewRoot.on('change:children', function (evt, node) {
        return _this2._renderer.markToSync('children', node);
      });
      viewRoot.on('change:attributes', function (evt, node) {
        return _this2._renderer.markToSync('attributes', node);
      });
      viewRoot.on('change:text', function (evt, node) {
        return _this2._renderer.markToSync('text', node);
      });
      viewRoot.on('change:isReadOnly', function () {
        return _this2.change(updateContenteditableAttribute);
      });
      viewRoot.on('change', function () {
        _this2._hasChangedSinceTheLastRendering = true;
      });

      var _iterator = _createForOfIteratorHelper(this._observers.values()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var observer = _step.value;
          observer.observe(domRoot, name);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Detaches a DOM root element from the view element and restores its attributes to the state before
     * {@link #attachDomRoot `attachDomRoot()`}.
     *
     * @param {String} name Name of the root to detach.
     */

  }, {
    key: "detachDomRoot",
    value: function detachDomRoot(name) {
      var domRoot = this.domRoots.get(name); // Remove all root attributes so the DOM element is "bare".

      Array.from(domRoot.attributes).forEach(function (_ref) {
        var name = _ref.name;
        return domRoot.removeAttribute(name);
      });

      var initialDomRootAttributes = this._initialDomRootAttributes.get(domRoot); // Revert all view root attributes back to the state before attachDomRoot was called.


      for (var attribute in initialDomRootAttributes) {
        domRoot.setAttribute(attribute, initialDomRootAttributes[attribute]);
      }

      this.domRoots.delete(name);
      this.domConverter.unbindDomElement(domRoot);
    }
    /**
     * Gets DOM root element.
     *
     * @param {String} [name='main']  Name of the root.
     * @returns {Element} DOM root element instance.
     */

  }, {
    key: "getDomRoot",
    value: function getDomRoot() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';
      return this.domRoots.get(name);
    }
    /**
     * Creates observer of the given type if not yet created, {@link module:engine/view/observer/observer~Observer#enable enables} it
     * and {@link module:engine/view/observer/observer~Observer#observe attaches} to all existing and future
     * {@link #domRoots DOM roots}.
     *
     * Note: Observers are recognized by their constructor (classes). A single observer will be instantiated and used only
     * when registered for the first time. This means that features and other components can register a single observer
     * multiple times without caring whether it has been already added or not.
     *
     * @param {Function} Observer The constructor of an observer to add.
     * Should create an instance inheriting from {@link module:engine/view/observer/observer~Observer}.
     * @returns {module:engine/view/observer/observer~Observer} Added observer instance.
     */

  }, {
    key: "addObserver",
    value: function addObserver(Observer) {
      var observer = this._observers.get(Observer);

      if (observer) {
        return observer;
      }

      observer = new Observer(this);

      this._observers.set(Observer, observer);

      var _iterator2 = _createForOfIteratorHelper(this.domRoots),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value = _slicedToArray(_step2.value, 2),
              name = _step2$value[0],
              domElement = _step2$value[1];

          observer.observe(domElement, name);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      observer.enable();
      return observer;
    }
    /**
     * Returns observer of the given type or `undefined` if such observer has not been added yet.
     *
     * @param {Function} Observer The constructor of an observer to get.
     * @returns {module:engine/view/observer/observer~Observer|undefined} Observer instance or undefined.
     */

  }, {
    key: "getObserver",
    value: function getObserver(Observer) {
      return this._observers.get(Observer);
    }
    /**
     * Disables all added observers.
     */

  }, {
    key: "disableObservers",
    value: function disableObservers() {
      var _iterator3 = _createForOfIteratorHelper(this._observers.values()),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var observer = _step3.value;
          observer.disable();
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
    /**
     * Enables all added observers.
     */

  }, {
    key: "enableObservers",
    value: function enableObservers() {
      var _iterator4 = _createForOfIteratorHelper(this._observers.values()),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var observer = _step4.value;
          observer.enable();
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
    /**
     * Scrolls the page viewport and {@link #domRoots} with their ancestors to reveal the
     * caret, if not already visible to the user.
     */

  }, {
    key: "scrollToTheSelection",
    value: function scrollToTheSelection() {
      var range = this.document.selection.getFirstRange();

      if (range) {
        scrollViewportToShowTarget({
          target: this.domConverter.viewRangeToDom(range),
          viewportOffset: 20
        });
      }
    }
    /**
     * It will focus DOM element representing {@link module:engine/view/editableelement~EditableElement EditableElement}
     * that is currently having selection inside.
     */

  }, {
    key: "focus",
    value: function focus() {
      if (!this.document.isFocused) {
        var editable = this.document.selection.editableElement;

        if (editable) {
          this.domConverter.focus(editable);
          this.forceRender();
        } else {// Before focusing view document, selection should be placed inside one of the view's editables.
          // Normally its selection will be converted from model document (which have default selection), but
          // when using view document on its own, we need to manually place selection before focusing it.
          //
          // @if CK_DEBUG // console.warn( 'There is no selection in any editable to focus.' );
        }
      }
    }
    /**
     * The `change()` method is the primary way of changing the view. You should use it to modify any node in the view tree.
     * It makes sure that after all changes are made the view is rendered to the DOM (assuming that the view will be changed
     * inside the callback). It prevents situations when the DOM is updated when the view state is not yet correct. It allows
     * to nest calls one inside another and still performs a single rendering after all those changes are made.
     * It also returns the return value of its callback.
     *
     *		const text = view.change( writer => {
     *			const newText = writer.createText( 'foo' );
     *			writer.insert( position1, newText );
     *
     *			view.change( writer => {
     *				writer.insert( position2, writer.createText( 'bar' ) );
     *			} );
     *
     * 			writer.remove( range );
     *
     * 			return newText;
     *		} );
     *
     * When the outermost change block is done and rendering to the DOM is over the
     * {@link module:engine/view/view~View#event:render `View#render`} event is fired.
     *
     * This method throws a `applying-view-changes-on-rendering` error when
     * the change block is used after rendering to the DOM has started.
     *
     * @param {Function} callback Callback function which may modify the view.
     * @returns {*} Value returned by the callback.
     */

  }, {
    key: "change",
    value: function change(callback) {
      if (this.isRenderingInProgress || this._postFixersInProgress) {
        /**
         * Thrown when there is an attempt to make changes to the view tree when it is in incorrect state. This may
         * cause some unexpected behaviour and inconsistency between the DOM and the view.
         * This may be caused by:
         *
         * * calling {@link #change} or {@link #forceRender} during rendering process,
         * * calling {@link #change} or {@link #forceRender} inside of
         *   {@link module:engine/view/document~Document#registerPostFixer post-fixer function}.
         *
         * @error cannot-change-view-tree
         */
        throw new ckeditorerror["b" /* default */]('cannot-change-view-tree: ' + 'Attempting to make changes to the view when it is in an incorrect state: rendering or post-fixers are in progress. ' + 'This may cause some unexpected behavior and inconsistency between the DOM and the view.', this);
      }

      try {
        // Recursive call to view.change() method - execute listener immediately.
        if (this._ongoingChange) {
          return callback(this._writer);
        } // This lock will assure that all recursive calls to view.change() will end up in same block - one "render"
        // event for all nested calls.


        this._ongoingChange = true;
        var callbackResult = callback(this._writer);
        this._ongoingChange = false; // This lock is used by editing controller to render changes from outer most model.change() once. As plugins might call
        // view.change() inside model.change() block - this will ensures that postfixers and rendering are called once after all
        // changes. Also, we don't need to render anything if there're no changes since last rendering.

        if (!this._renderingDisabled && this._hasChangedSinceTheLastRendering) {
          this._postFixersInProgress = true;

          this.document._callPostFixers(this._writer);

          this._postFixersInProgress = false;
          this.fire('render');
        }

        return callbackResult;
      } catch (err) {
        // @if CK_DEBUG // throw err;

        /* istanbul ignore next */
        ckeditorerror["b" /* default */].rethrowUnexpectedError(err, this);
      }
    }
    /**
     * Forces rendering {@link module:engine/view/document~Document view document} to DOM. If any view changes are
     * currently in progress, rendering will start after all {@link #change change blocks} are processed.
     *
     * Note that this method is dedicated for special cases. All view changes should be wrapped in the {@link #change}
     * block and the view will automatically check whether it needs to render DOM or not.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `applying-view-changes-on-rendering` when
     * trying to re-render when rendering to DOM has already started.
     */

  }, {
    key: "forceRender",
    value: function forceRender() {
      this._hasChangedSinceTheLastRendering = true;
      this.change(function () {});
    }
    /**
     * Destroys this instance. Makes sure that all observers are destroyed and listeners removed.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      var _iterator5 = _createForOfIteratorHelper(this._observers.values()),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var observer = _step5.value;
          observer.destroy();
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      this.document.destroy();
      this.stopListening();
    }
    /**
     * Creates position at the given location. The location can be specified as:
     *
     * * a {@link module:engine/view/position~Position position},
     * * parent element and offset (offset defaults to `0`),
     * * parent element and `'end'` (sets position at the end of that element),
     * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
     *
     * This method is a shortcut to other constructors such as:
     *
     * * {@link #createPositionBefore},
     * * {@link #createPositionAfter},
     *
     * @param {module:engine/view/item~Item|module:engine/model/position~Position} itemOrPosition
     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when
     * first parameter is a {@link module:engine/view/item~Item view item}.
     */

  }, {
    key: "createPositionAt",
    value: function createPositionAt(itemOrPosition, offset) {
      return position_Position._createAt(itemOrPosition, offset);
    }
    /**
     * Creates a new position after given view item.
     *
     * @param {module:engine/view/item~Item} item View item after which the position should be located.
     * @returns {module:engine/view/position~Position}
     */

  }, {
    key: "createPositionAfter",
    value: function createPositionAfter(item) {
      return position_Position._createAfter(item);
    }
    /**
     * Creates a new position before given view item.
     *
     * @param {module:engine/view/item~Item} item View item before which the position should be located.
     * @returns {module:engine/view/position~Position}
     */

  }, {
    key: "createPositionBefore",
    value: function createPositionBefore(item) {
      return position_Position._createBefore(item);
    }
    /**
     * Creates a range spanning from `start` position to `end` position.
     *
     * **Note:** This factory method creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
     *
     * @param {module:engine/view/position~Position} start Start position.
     * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at `start` position.
     * @returns {module:engine/view/range~Range}
     */

  }, {
    key: "createRange",
    value: function createRange(start, end) {
      return new range_Range(start, end);
    }
    /**
     * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
     *
     * @param {module:engine/view/item~Item} item
     * @returns {module:engine/view/range~Range}
     */

  }, {
    key: "createRangeOn",
    value: function createRangeOn(item) {
      return range_Range._createOn(item);
    }
    /**
     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
     * that element and ends after the last child of that element.
     *
     * @param {module:engine/view/element~Element} element Element which is a parent for the range.
     * @returns {module:engine/view/range~Range}
     */

  }, {
    key: "createRangeIn",
    value: function createRangeIn(element) {
      return range_Range._createIn(element);
    }
    /**
     Creates new {@link module:engine/view/selection~Selection} instance.
     *
     * 		// Creates empty selection without ranges.
     *		const selection = view.createSelection();
     *
     *		// Creates selection at the given range.
     *		const range = view.createRange( start, end );
     *		const selection = view.createSelection( range );
     *
     *		// Creates selection at the given ranges
     * 		const ranges = [ view.createRange( start1, end2 ), view.createRange( star2, end2 ) ];
     *		const selection = view.createSelection( ranges );
     *
     *		// Creates selection from the other selection.
     *		const otherSelection = view.createSelection();
     *		const selection = view.createSelection( otherSelection );
     *
     *		// Creates selection from the document selection.
     *		const selection = view.createSelection( editor.editing.view.document.selection );
     *
     * 		// Creates selection at the given position.
     *		const position = view.createPositionFromPath( root, path );
     *		const selection = view.createSelection( position );
     *
     *		// Creates collapsed selection at the position of given item and offset.
     *		const paragraph = view.createContainerElement( 'paragraph' );
     *		const selection = view.createSelection( paragraph, offset );
     *
     *		// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the
     *		// first child of that element and ends after the last child of that element.
     *		const selection = view.createSelection( paragraph, 'in' );
     *
     *		// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends
     *		// just after the item.
     *		const selection = view.createSelection( paragraph, 'on' );
     *
     * `Selection`'s factory method allow passing additional options (`backward`, `fake` and `label`) as the last argument.
     *
     *		// Creates backward selection.
     *		const selection = view.createSelection( range, { backward: true } );
     *
     * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
     * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
     * represented in other way, for example by applying proper CSS class.
     *
     * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
     * (and be  properly handled by screen readers).
     *
     *		// Creates fake selection with label.
     *		const selection = view.createSelection( range, { fake: true, label: 'foo' } );
     *
     * @param {module:engine/view/selection~Selectable} [selectable=null]
     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.
     * @param {Object} [options]
     * @param {Boolean} [options.backward] Sets this selection instance to be backward.
     * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.
     * @param {String} [options.label] Label for the fake selection.
     * @returns {module:engine/view/selection~Selection}
     */

  }, {
    key: "createSelection",
    value: function createSelection(selectable, placeOrOffset, options) {
      return new selection_Selection(selectable, placeOrOffset, options);
    }
    /**
     * Disables or enables rendering. If the flag is set to `true` then the rendering will be disabled.
     * If the flag is set to `false` and if there was some change in the meantime, then the rendering action will be performed.
     *
     * @protected
     * @param {Boolean} flag A flag indicates whether the rendering should be disabled.
     */

  }, {
    key: "_disableRendering",
    value: function _disableRendering(flag) {
      this._renderingDisabled = flag;

      if (flag == false) {
        // Render when you stop blocking rendering.
        this.change(function () {});
      }
    }
    /**
     * Renders all changes. In order to avoid triggering the observers (e.g. mutations) all observers are disabled
     * before rendering and re-enabled after that.
     *
     * @private
     */

  }, {
    key: "_render",
    value: function _render() {
      this.isRenderingInProgress = true;
      this.disableObservers();

      this._renderer.render();

      this.enableObservers();
      this.isRenderingInProgress = false;
    }
    /**
     * Fired after a topmost {@link module:engine/view/view~View#change change block} and all
     * {@link module:engine/view/document~Document#registerPostFixer post-fixers} are executed.
     *
     * Actual rendering is performed as a first listener on 'normal' priority.
     *
     *		view.on( 'render', () => {
     *			// Rendering to the DOM is complete.
     *		} );
     *
     * This event is useful when you want to update interface elements after the rendering, e.g. position of the
     * balloon panel. If you wants to change view structure use
     * {@link module:engine/view/document~Document#registerPostFixer post-fixers}.
     *
     * @event module:engine/view/view~View#event:render
     */

  }]);

  return View;
}();


mix(view_View, observablemixin);
// EXTERNAL MODULE: ./node_modules/core-js/modules/web.url.to-json.js
var web_url_to_json = __webpack_require__("bf19");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/node.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/node
 */


 // To check if component is loaded more than once.


/**
 * Model node. Most basic structure of model tree.
 *
 * This is an abstract class that is a base for other classes representing different nodes in model.
 *
 * **Note:** If a node is detached from the model tree, you can manipulate it using it's API.
 * However, it is **very important** that nodes already attached to model tree should be only changed through
 * {@link module:engine/model/writer~Writer Writer API}.
 *
 * Changes done by `Node` methods, like {@link module:engine/model/element~Element#_insertChild _insertChild} or
 * {@link module:engine/model/node~Node#_setAttribute _setAttribute}
 * do not generate {@link module:engine/model/operation/operation~Operation operations}
 * which are essential for correct editor work if you modify nodes in {@link module:engine/model/document~Document document} root.
 *
 * The flow of working on `Node` (and classes that inherits from it) is as such:
 * 1. You can create a `Node` instance, modify it using it's API.
 * 2. Add `Node` to the model using `Batch` API.
 * 3. Change `Node` that was already added to the model using `Batch` API.
 *
 * Similarly, you cannot use `Batch` API on a node that has not been added to the model tree, with the exception
 * of {@link module:engine/model/writer~Writer#insert inserting} that node to the model tree.
 *
 * Be aware that using {@link module:engine/model/writer~Writer#remove remove from Batch API} does not allow to use `Node` API because
 * the information about `Node` is still kept in model document.
 *
 * In case of {@link module:engine/model/element~Element element node}, adding and removing children also counts as changing a node and
 * follows same rules.
 */

var model_node_Node = /*#__PURE__*/function () {
  /**
   * Creates a model node.
   *
   * This is an abstract class, so this constructor should not be used directly.
   *
   * @abstract
   * @param {Object} [attrs] Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
   */
  function Node(attrs) {
    Object(classCallCheck["a" /* default */])(this, Node);

    /**
     * Parent of this node. It could be {@link module:engine/model/element~Element}
     * or {@link module:engine/model/documentfragment~DocumentFragment}.
     * Equals to `null` if the node has no parent.
     *
     * @readonly
     * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}
     */
    this.parent = null;
    /**
     * Attributes set on this node.
     *
     * @private
     * @member {Map} module:engine/model/node~Node#_attrs
     */

    this._attrs = toMap(attrs);
  }
  /**
   * Index of this node in it's parent or `null` if the node has no parent.
   *
   * Accessing this property throws an error if this node's parent element does not contain it.
   * This means that model tree got broken.
   *
   * @readonly
   * @type {Number|null}
   */


  Object(createClass["a" /* default */])(Node, [{
    key: "isAttached",

    /**
     * Returns true if the node is in a tree rooted in the document (is a descendant of one of its roots).
     *
     * @returns {Boolean}
     */
    value: function isAttached() {
      return this.root.is('rootElement');
    }
    /**
     * Gets path to the node. The path is an array containing starting offsets of consecutive ancestors of this node,
     * beginning from {@link module:engine/model/node~Node#root root}, down to this node's starting offset. The path can be used to
     * create {@link module:engine/model/position~Position Position} instance.
     *
     *		const abc = new Text( 'abc' );
     *		const foo = new Text( 'foo' );
     *		const h1 = new Element( 'h1', null, new Text( 'header' ) );
     *		const p = new Element( 'p', null, [ abc, foo ] );
     *		const div = new Element( 'div', null, [ h1, p ] );
     *		foo.getPath(); // Returns [ 1, 3 ]. `foo` is in `p` which is in `div`. `p` starts at offset 1, while `foo` at 3.
     *		h1.getPath(); // Returns [ 0 ].
     *		div.getPath(); // Returns [].
     *
     * @returns {Array.<Number>} The path.
     */

  }, {
    key: "getPath",
    value: function getPath() {
      var path = [];
      var node = this; // eslint-disable-line consistent-this

      while (node.parent) {
        path.unshift(node.startOffset);
        node = node.parent;
      }

      return path;
    }
    /**
     * Returns ancestors array of this node.
     *
     * @param {Object} options Options object.
     * @param {Boolean} [options.includeSelf=false] When set to `true` this node will be also included in parent's array.
     * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from node's parent to root element,
     * otherwise root element will be the first item in the array.
     * @returns {Array} Array with ancestors.
     */

  }, {
    key: "getAncestors",
    value: function getAncestors() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        includeSelf: false,
        parentFirst: false
      };
      var ancestors = [];
      var parent = options.includeSelf ? this : this.parent;

      while (parent) {
        ancestors[options.parentFirst ? 'push' : 'unshift'](parent);
        parent = parent.parent;
      }

      return ancestors;
    }
    /**
     * Returns a {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
     * which is a common ancestor of both nodes.
     *
     * @param {module:engine/model/node~Node} node The second node.
     * @param {Object} options Options object.
     * @param {Boolean} [options.includeSelf=false] When set to `true` both nodes will be considered "ancestors" too.
     * Which means that if e.g. node A is inside B, then their common ancestor will be B.
     * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}
     */

  }, {
    key: "getCommonAncestor",
    value: function getCommonAncestor(node) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var ancestorsA = this.getAncestors(options);
      var ancestorsB = node.getAncestors(options);
      var i = 0;

      while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
        i++;
      }

      return i === 0 ? null : ancestorsA[i - 1];
    }
    /**
     * Returns whether this node is before given node. `false` is returned if nodes are in different trees (for example,
     * in different {@link module:engine/model/documentfragment~DocumentFragment}s).
     *
     * @param {module:engine/model/node~Node} node Node to compare with.
     * @returns {Boolean}
     */

  }, {
    key: "isBefore",
    value: function isBefore(node) {
      // Given node is not before this node if they are same.
      if (this == node) {
        return false;
      } // Return `false` if it is impossible to compare nodes.


      if (this.root !== node.root) {
        return false;
      }

      var thisPath = this.getPath();
      var nodePath = node.getPath();
      var result = compareArrays(thisPath, nodePath);

      switch (result) {
        case 'prefix':
          return true;

        case 'extension':
          return false;

        default:
          return thisPath[result] < nodePath[result];
      }
    }
    /**
     * Returns whether this node is after given node. `false` is returned if nodes are in different trees (for example,
     * in different {@link module:engine/model/documentfragment~DocumentFragment}s).
     *
     * @param {module:engine/model/node~Node} node Node to compare with.
     * @returns {Boolean}
     */

  }, {
    key: "isAfter",
    value: function isAfter(node) {
      // Given node is not before this node if they are same.
      if (this == node) {
        return false;
      } // Return `false` if it is impossible to compare nodes.


      if (this.root !== node.root) {
        return false;
      } // In other cases, just check if the `node` is before, and return the opposite.


      return !this.isBefore(node);
    }
    /**
     * Checks if the node has an attribute with given key.
     *
     * @param {String} key Key of attribute to check.
     * @returns {Boolean} `true` if attribute with given key is set on node, `false` otherwise.
     */

  }, {
    key: "hasAttribute",
    value: function hasAttribute(key) {
      return this._attrs.has(key);
    }
    /**
     * Gets an attribute value for given key or `undefined` if that attribute is not set on node.
     *
     * @param {String} key Key of attribute to look for.
     * @returns {*} Attribute value or `undefined`.
     */

  }, {
    key: "getAttribute",
    value: function getAttribute(key) {
      return this._attrs.get(key);
    }
    /**
     * Returns iterator that iterates over this node's attributes.
     *
     * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
     * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
     *
     * @returns {Iterable.<*>}
     */

  }, {
    key: "getAttributes",
    value: function getAttributes() {
      return this._attrs.entries();
    }
    /**
     * Returns iterator that iterates over this node's attribute keys.
     *
     * @returns {Iterable.<String>}
     */

  }, {
    key: "getAttributeKeys",
    value: function getAttributeKeys() {
      return this._attrs.keys();
    }
    /**
     * Converts `Node` to plain object and returns it.
     *
     * @returns {Object} `Node` converted to plain object.
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = {}; // Serializes attributes to the object.
      // attributes = { a: 'foo', b: 1, c: true }.

      if (this._attrs.size) {
        json.attributes = Array.from(this._attrs).reduce(function (result, attr) {
          result[attr[0]] = attr[1];
          return result;
        }, {});
      }

      return json;
    }
    /**
     * Checks whether this object is of the given type.
     *
     * This method is useful when processing model objects that are of unknown type. For example, a function
     * may return a {@link module:engine/model/documentfragment~DocumentFragment} or a {@link module:engine/model/node~Node}
     * that can be either a text node or an element. This method can be used to check what kind of object is returned.
     *
     *		someObject.is( 'element' ); // -> true if this is an element
     *		someObject.is( 'node' ); // -> true if this is a node (a text node or an element)
     *		someObject.is( 'documentFragment' ); // -> true if this is a document fragment
     *
     * Since this method is also available on a range of view objects, you can prefix the type of the object with
     * `model:` or `view:` to check, for example, if this is the model's or view's element:
     *
     *		modelElement.is( 'model:element' ); // -> true
     *		modelElement.is( 'view:element' ); // -> false
     *
     * By using this method it is also possible to check a name of an element:
     *
     *		imageElement.is( 'image' ); // -> true
     *		imageElement.is( 'element', 'image' ); // -> same as above
     *		imageElement.is( 'model:element', 'image' ); // -> same as above, but more precise
     *
     * The list of model objects which implement the `is()` method:
     *
     * * {@link module:engine/model/node~Node#is `Node#is()`}
     * * {@link module:engine/model/text~Text#is `Text#is()`}
     * * {@link module:engine/model/element~Element#is `Element#is()`}
     * * {@link module:engine/model/rootelement~RootElement#is `RootElement#is()`}
     * * {@link module:engine/model/position~Position#is `Position#is()`}
     * * {@link module:engine/model/liveposition~LivePosition#is `LivePosition#is()`}
     * * {@link module:engine/model/range~Range#is `Range#is()`}
     * * {@link module:engine/model/liverange~LiveRange#is `LiveRange#is()`}
     * * {@link module:engine/model/documentfragment~DocumentFragment#is `DocumentFragment#is()`}
     * * {@link module:engine/model/selection~Selection#is `Selection#is()`}
     * * {@link module:engine/model/documentselection~DocumentSelection#is `DocumentSelection#is()`}
     * * {@link module:engine/model/markercollection~Marker#is `Marker#is()`}
     * * {@link module:engine/model/textproxy~TextProxy#is `TextProxy#is()`}
     *
     * @method #is
     * @param {String} type
     * @returns {Boolean}
     */

  }, {
    key: "is",
    value: function is(type) {
      return type === 'node' || type === 'model:node';
    }
    /**
     * Creates a copy of this node, that is a node with exactly same attributes, and returns it.
     *
     * @protected
     * @returns {module:engine/model/node~Node} Node with same attributes as this node.
     */

  }, {
    key: "_clone",
    value: function _clone() {
      return new Node(this._attrs);
    }
    /**
     * Removes this node from it's parent.
     *
     * @see module:engine/model/writer~Writer#remove
     * @protected
     */

  }, {
    key: "_remove",
    value: function _remove() {
      this.parent._removeChildren(this.index);
    }
    /**
     * Sets attribute on the node. If attribute with the same key already is set, it's value is overwritten.
     *
     * @see module:engine/model/writer~Writer#setAttribute
     * @protected
     * @param {String} key Key of attribute to set.
     * @param {*} value Attribute value.
     */

  }, {
    key: "_setAttribute",
    value: function _setAttribute(key, value) {
      this._attrs.set(key, value);
    }
    /**
     * Removes all attributes from the node and sets given attributes.
     *
     * @see module:engine/model/writer~Writer#setAttributes
     * @protected
     * @param {Object} [attrs] Attributes to set. See {@link module:utils/tomap~toMap} for a list of accepted values.
     */

  }, {
    key: "_setAttributesTo",
    value: function _setAttributesTo(attrs) {
      this._attrs = toMap(attrs);
    }
    /**
     * Removes an attribute with given key from the node.
     *
     * @see module:engine/model/writer~Writer#removeAttribute
     * @protected
     * @param {String} key Key of attribute to remove.
     * @returns {Boolean} `true` if the attribute was set on the element, `false` otherwise.
     */

  }, {
    key: "_removeAttribute",
    value: function _removeAttribute(key) {
      return this._attrs.delete(key);
    }
    /**
     * Removes all attributes from the node.
     *
     * @see module:engine/model/writer~Writer#clearAttributes
     * @protected
     */

  }, {
    key: "_clearAttributes",
    value: function _clearAttributes() {
      this._attrs.clear();
    }
  }, {
    key: "index",
    get: function get() {
      var pos;

      if (!this.parent) {
        return null;
      }

      if ((pos = this.parent.getChildIndex(this)) === null) {
        throw new ckeditorerror["b" /* default */]('model-node-not-found-in-parent: The node\'s parent does not contain this node.', this);
      }

      return pos;
    }
    /**
     * Offset at which this node starts in it's parent. It is equal to the sum of {@link #offsetSize offsetSize}
     * of all it's previous siblings. Equals to `null` if node has no parent.
     *
     * Accessing this property throws an error if this node's parent element does not contain it.
     * This means that model tree got broken.
     *
     * @readonly
     * @type {Number|null}
     */

  }, {
    key: "startOffset",
    get: function get() {
      var pos;

      if (!this.parent) {
        return null;
      }

      if ((pos = this.parent.getChildStartOffset(this)) === null) {
        throw new ckeditorerror["b" /* default */]('model-node-not-found-in-parent: The node\'s parent does not contain this node.', this);
      }

      return pos;
    }
    /**
     * Offset size of this node. Represents how much "offset space" is occupied by the node in it's parent.
     * It is important for {@link module:engine/model/position~Position position}. When node has `offsetSize` greater than `1`, position
     * can be placed between that node start and end. `offsetSize` greater than `1` is for nodes that represents more
     * than one entity, i.e. {@link module:engine/model/text~Text text node}.
     *
     * @readonly
     * @type {Number}
     */

  }, {
    key: "offsetSize",
    get: function get() {
      return 1;
    }
    /**
     * Offset at which this node ends in it's parent. It is equal to the sum of this node's
     * {@link module:engine/model/node~Node#startOffset start offset} and {@link #offsetSize offset size}.
     * Equals to `null` if the node has no parent.
     *
     * @readonly
     * @type {Number|null}
     */

  }, {
    key: "endOffset",
    get: function get() {
      if (!this.parent) {
        return null;
      }

      return this.startOffset + this.offsetSize;
    }
    /**
     * Node's next sibling or `null` if the node is a last child of it's parent or if the node has no parent.
     *
     * @readonly
     * @type {module:engine/model/node~Node|null}
     */

  }, {
    key: "nextSibling",
    get: function get() {
      var index = this.index;
      return index !== null && this.parent.getChild(index + 1) || null;
    }
    /**
     * Node's previous sibling or `null` if the node is a first child of it's parent or if the node has no parent.
     *
     * @readonly
     * @type {module:engine/model/node~Node|null}
     */

  }, {
    key: "previousSibling",
    get: function get() {
      var index = this.index;
      return index !== null && this.parent.getChild(index - 1) || null;
    }
    /**
     * The top-most ancestor of the node. If node has no parent it is the root itself. If the node is a part
     * of {@link module:engine/model/documentfragment~DocumentFragment}, it's `root` is equal to that `DocumentFragment`.
     *
     * @readonly
     * @type {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}
     */

  }, {
    key: "root",
    get: function get() {
      var root = this; // eslint-disable-line consistent-this

      while (root.parent) {
        root = root.parent;
      }

      return root;
    }
  }]);

  return Node;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/text.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/text
 */
 // @if CK_DEBUG_ENGINE // const { convertMapToStringifiedObject } = require( '../dev-utils/utils' );

/**
 * Model text node. Type of {@link module:engine/model/node~Node node} that contains {@link module:engine/model/text~Text#data text data}.
 *
 * **Important:** see {@link module:engine/model/node~Node} to read about restrictions using `Text` and `Node` API.
 *
 * **Note:** keep in mind that `Text` instances might indirectly got removed from model tree when model is changed.
 * This happens when {@link module:engine/model/writer~Writer model writer} is used to change model and the text node is merged with
 * another text node. Then, both text nodes are removed and a new text node is inserted into the model. Because of
 * this behavior, keeping references to `Text` is not recommended. Instead, consider creating
 * {@link module:engine/model/liveposition~LivePosition live position} placed before the text node.
 *
 * @extends module:engine/model/node~Node
 */

var model_text_Text = /*#__PURE__*/function (_Node) {
  Object(inherits["a" /* default */])(Text, _Node);

  var _super = Object(createSuper["a" /* default */])(Text);

  /**
   * Creates a text node.
   *
   * **Note:** Constructor of this class shouldn't be used directly in the code.
   * Use the {@link module:engine/model/writer~Writer#createText} method instead.
   *
   * @protected
   * @param {String} data Node's text.
   * @param {Object} [attrs] Node's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
   */
  function Text(data, attrs) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Text);

    _this = _super.call(this, attrs);
    /**
     * Text data contained in this text node.
     *
     * @protected
     * @type {String}
     */

    _this._data = data || '';
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(Text, [{
    key: "is",

    /**
     * Checks whether this object is of the given.
     *
     *		text.is( 'text' ); // -> true
     *		text.is( 'node' ); // -> true
     *		text.is( 'model:text' ); // -> true
     *		text.is( 'model:node' ); // -> true
     *
     *		text.is( 'view:text' ); // -> false
     *		text.is( 'documentSelection' ); // -> false
     *
     * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.
     *
     * @param {String} type Type to check when `name` parameter is present.
     * Otherwise, it acts like the `name` parameter.
     * @returns {Boolean}
     */
    value: function is(type) {
      return type === 'text' || type === 'model:text' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
      type === 'node' || type === 'model:node';
    }
    /**
     * Converts `Text` instance to plain object and returns it.
     *
     * @returns {Object} `Text` instance converted to plain object.
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = get_get(Object(getPrototypeOf["a" /* default */])(Text.prototype), "toJSON", this).call(this);

      json.data = this.data;
      return json;
    }
    /**
     * Creates a copy of this text node and returns it. Created text node has same text data and attributes as original text node.
     *
     * @protected
     * @returns {module:engine/model/text~Text} `Text` instance created using given plain object.
     */

  }, {
    key: "_clone",
    value: function _clone() {
      return new Text(this.data, this.getAttributes());
    }
    /**
     * Creates a `Text` instance from given plain object (i.e. parsed JSON string).
     *
     * @param {Object} json Plain object to be converted to `Text`.
     * @returns {module:engine/model/text~Text} `Text` instance created using given plain object.
     */

  }, {
    key: "offsetSize",
    get: function get() {
      return this.data.length;
    }
    /**
     * Returns a text data contained in the node.
     *
     * @readonly
     * @type {String}
     */

  }, {
    key: "data",
    get: function get() {
      return this._data;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(json) {
      return new Text(json.data, json.attributes);
    } // @if CK_DEBUG_ENGINE // toString() {
    // @if CK_DEBUG_ENGINE // 	return `#${ this.data }`;
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // logExtended() {
    // @if CK_DEBUG_ENGINE // 	console.log( `ModelText: ${ this }, attrs: ${ convertMapToStringifiedObject( this.getAttributes() ) }` );
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // log() {
    // @if CK_DEBUG_ENGINE // 	console.log( 'ModelText: ' + this );
    // @if CK_DEBUG_ENGINE // }

  }]);

  return Text;
}(model_node_Node);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/textproxy.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/textproxy
 */
 // @if CK_DEBUG_ENGINE // const { convertMapToStringifiedObject } = require( '../dev-utils/utils' );

/**
 * `TextProxy` represents a part of {@link module:engine/model/text~Text text node}.
 *
 * Since {@link module:engine/model/position~Position positions} can be placed between characters of a text node,
 * {@link module:engine/model/range~Range ranges} may contain only parts of text nodes. When {@link module:engine/model/range~Range#getItems
 * getting items}
 * contained in such range, we need to represent a part of that text node, since returning the whole text node would be incorrect.
 * `TextProxy` solves this issue.
 *
 * `TextProxy` has an API similar to {@link module:engine/model/text~Text Text} and allows to do most of the common tasks performed
 * on model nodes.
 *
 * **Note:** Some `TextProxy` instances may represent whole text node, not just a part of it.
 * See {@link module:engine/model/textproxy~TextProxy#isPartial}.
 *
 * **Note:** `TextProxy` is not an instance of {@link module:engine/model/node~Node node}. Keep this in mind when using it as a
 * parameter of methods.
 *
 * **Note:** `TextProxy` is a readonly interface. If you want to perform changes on model data represented by a `TextProxy`
 * use {@link module:engine/model/writer~Writer model writer API}.
 *
 * **Note:** `TextProxy` instances are created on the fly, basing on the current state of model. Because of this, it is
 * highly unrecommended to store references to `TextProxy` instances. `TextProxy` instances are not refreshed when
 * model changes, so they might get invalidated. Instead, consider creating {@link module:engine/model/liveposition~LivePosition live
 * position}.
 *
 * `TextProxy` instances are created by {@link module:engine/model/treewalker~TreeWalker model tree walker}. You should not need to create
 * an instance of this class by your own.
 */

var model_textproxy_TextProxy = /*#__PURE__*/function () {
  /**
   * Creates a text proxy.
   *
   * @protected
   * @param {module:engine/model/text~Text} textNode Text node which part is represented by this text proxy.
   * @param {Number} offsetInText Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy
   * starts.
   * @param {Number} length Text proxy length, that is how many text node's characters, starting from `offsetInText` it represents.
   * @constructor
   */
  function TextProxy(textNode, offsetInText, length) {
    Object(classCallCheck["a" /* default */])(this, TextProxy);

    /**
     * Text node which part is represented by this text proxy.
     *
     * @readonly
     * @member {module:engine/model/text~Text}
     */
    this.textNode = textNode;

    if (offsetInText < 0 || offsetInText > textNode.offsetSize) {
      /**
       * Given `offsetInText` value is incorrect.
       *
       * @error model-textproxy-wrong-offsetintext
       */
      throw new ckeditorerror["b" /* default */]('model-textproxy-wrong-offsetintext: Given offsetInText value is incorrect.', this);
    }

    if (length < 0 || offsetInText + length > textNode.offsetSize) {
      /**
       * Given `length` value is incorrect.
       *
       * @error model-textproxy-wrong-length
       */
      throw new ckeditorerror["b" /* default */]('model-textproxy-wrong-length: Given length value is incorrect.', this);
    }
    /**
     * Text data represented by this text proxy.
     *
     * @readonly
     * @member {String}
     */


    this.data = textNode.data.substring(offsetInText, offsetInText + length);
    /**
     * Offset in {@link module:engine/model/textproxy~TextProxy#textNode text node} from which the text proxy starts.
     *
     * @readonly
     * @member {Number}
     */

    this.offsetInText = offsetInText;
  }
  /**
   * Offset at which this text proxy starts in it's parent.
   *
   * @see module:engine/model/node~Node#startOffset
   * @readonly
   * @type {Number}
   */


  Object(createClass["a" /* default */])(TextProxy, [{
    key: "is",

    /**
     * Checks whether this object is of the given.
     *
     *		textProxy.is( 'textProxy' ); // -> true
     *		textProxy.is( 'model:textProxy' ); // -> true
     *
     *		textProxy.is( 'view:textProxy' ); // -> false
     *		textProxy.is( 'range' ); // -> false
     *
     * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.
     *
     * @param {String} type
     * @returns {Boolean}
     */
    value: function is(type) {
      return type === 'textProxy' || type === 'model:textProxy';
    }
    /**
     * Gets path to this text proxy.
     *
     * @see module:engine/model/node~Node#getPath
     * @returns {Array.<Number>}
     */

  }, {
    key: "getPath",
    value: function getPath() {
      var path = this.textNode.getPath();

      if (path.length > 0) {
        path[path.length - 1] += this.offsetInText;
      }

      return path;
    }
    /**
     * Returns ancestors array of this text proxy.
     *
     * @param {Object} options Options object.
     * @param {Boolean} [options.includeSelf=false] When set to `true` this text proxy will be also included in parent's array.
     * @param {Boolean} [options.parentFirst=false] When set to `true`, array will be sorted from text proxy parent to root element,
     * otherwise root element will be the first item in the array.
     * @returns {Array} Array with ancestors.
     */

  }, {
    key: "getAncestors",
    value: function getAncestors() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        includeSelf: false,
        parentFirst: false
      };
      var ancestors = [];
      var parent = options.includeSelf ? this : this.parent;

      while (parent) {
        ancestors[options.parentFirst ? 'push' : 'unshift'](parent);
        parent = parent.parent;
      }

      return ancestors;
    }
    /**
     * Checks if this text proxy has an attribute for given key.
     *
     * @param {String} key Key of attribute to check.
     * @returns {Boolean} `true` if attribute with given key is set on text proxy, `false` otherwise.
     */

  }, {
    key: "hasAttribute",
    value: function hasAttribute(key) {
      return this.textNode.hasAttribute(key);
    }
    /**
     * Gets an attribute value for given key or `undefined` if that attribute is not set on text proxy.
     *
     * @param {String} key Key of attribute to look for.
     * @returns {*} Attribute value or `undefined`.
     */

  }, {
    key: "getAttribute",
    value: function getAttribute(key) {
      return this.textNode.getAttribute(key);
    }
    /**
     * Returns iterator that iterates over this node's attributes. Attributes are returned as arrays containing two
     * items. First one is attribute key and second is attribute value.
     *
     * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
     *
     * @returns {Iterable.<*>}
     */

  }, {
    key: "getAttributes",
    value: function getAttributes() {
      return this.textNode.getAttributes();
    }
    /**
     * Returns iterator that iterates over this node's attribute keys.
     *
     * @returns {Iterable.<String>}
     */

  }, {
    key: "getAttributeKeys",
    value: function getAttributeKeys() {
      return this.textNode.getAttributeKeys();
    } // @if CK_DEBUG_ENGINE // toString() {
    // @if CK_DEBUG_ENGINE // 	return `#${ this.data }`;
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // log() {
    // @if CK_DEBUG_ENGINE // 	console.log( 'ModelTextProxy: ' + this );
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // logExtended() {
    // @if CK_DEBUG_ENGINE // 	console.log( `ModelTextProxy: ${ this }, ` +
    // @if CK_DEBUG_ENGINE // 		`attrs: ${ convertMapToStringifiedObject( this.getAttributes() ) }` );
    // @if CK_DEBUG_ENGINE // }

  }, {
    key: "startOffset",
    get: function get() {
      return this.textNode.startOffset !== null ? this.textNode.startOffset + this.offsetInText : null;
    }
    /**
     * Offset size of this text proxy. Equal to the number of characters represented by the text proxy.
     *
     * @see module:engine/model/node~Node#offsetSize
     * @readonly
     * @type {Number}
     */

  }, {
    key: "offsetSize",
    get: function get() {
      return this.data.length;
    }
    /**
     * Offset at which this text proxy ends in it's parent.
     *
     * @see module:engine/model/node~Node#endOffset
     * @readonly
     * @type {Number}
     */

  }, {
    key: "endOffset",
    get: function get() {
      return this.startOffset !== null ? this.startOffset + this.offsetSize : null;
    }
    /**
     * Flag indicating whether `TextProxy` instance covers only part of the original {@link module:engine/model/text~Text text node}
     * (`true`) or the whole text node (`false`).
     *
     * This is `false` when text proxy starts at the very beginning of {@link module:engine/model/textproxy~TextProxy#textNode textNode}
     * ({@link module:engine/model/textproxy~TextProxy#offsetInText offsetInText} equals `0`) and text proxy sizes is equal to
     * text node size.
     *
     * @readonly
     * @type {Boolean}
     */

  }, {
    key: "isPartial",
    get: function get() {
      return this.offsetSize !== this.textNode.offsetSize;
    }
    /**
     * Parent of this text proxy, which is same as parent of text node represented by this text proxy.
     *
     * @readonly
     * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}
     */

  }, {
    key: "parent",
    get: function get() {
      return this.textNode.parent;
    }
    /**
     * Root of this text proxy, which is same as root of text node represented by this text proxy.
     *
     * @readonly
     * @type {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}
     */

  }, {
    key: "root",
    get: function get() {
      return this.textNode.root;
    }
  }]);

  return TextProxy;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/nodelist.js



















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/nodelist
 */


/**
 * Provides an interface to operate on a list of {@link module:engine/model/node~Node nodes}. `NodeList` is used internally
 * in classes like {@link module:engine/model/element~Element Element}
 * or {@link module:engine/model/documentfragment~DocumentFragment DocumentFragment}.
 */

var nodelist_NodeList = /*#__PURE__*/function () {
  /**
   * Creates an empty node list.
   *
   * @protected
   * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes contained in this node list.
   */
  function NodeList(nodes) {
    Object(classCallCheck["a" /* default */])(this, NodeList);

    /**
     * Nodes contained in this node list.
     *
     * @private
     * @member {Array.<module:engine/model/node~Node>}
     */
    this._nodes = [];

    if (nodes) {
      this._insertNodes(0, nodes);
    }
  }
  /**
   * Iterable interface.
   *
   * Iterates over all nodes contained inside this node list.
   *
   * @returns {Iterable.<module:engine/model/node~Node>}
   */


  Object(createClass["a" /* default */])(NodeList, [{
    key: Symbol.iterator,
    value: function value() {
      return this._nodes[Symbol.iterator]();
    }
    /**
     * Number of nodes contained inside this node list.
     *
     * @readonly
     * @type {Number}
     */

  }, {
    key: "getNode",

    /**
     * Gets the node at the given index. Returns `null` if incorrect index was passed.
     *
     * @param {Number} index Index of node.
     * @returns {module:engine/model/node~Node|null} Node at given index.
     */
    value: function getNode(index) {
      return this._nodes[index] || null;
    }
    /**
     * Returns an index of the given node. Returns `null` if given node is not inside this node list.
     *
     * @param {module:engine/model/node~Node} node Child node to look for.
     * @returns {Number|null} Child node's index.
     */

  }, {
    key: "getNodeIndex",
    value: function getNodeIndex(node) {
      var index = this._nodes.indexOf(node);

      return index == -1 ? null : index;
    }
    /**
     * Returns the starting offset of given node. Starting offset is equal to the sum of
     * {@link module:engine/model/node~Node#offsetSize offset sizes} of all nodes that are before this node in this node list.
     *
     * @param {module:engine/model/node~Node} node Node to look for.
     * @returns {Number|null} Node's starting offset.
     */

  }, {
    key: "getNodeStartOffset",
    value: function getNodeStartOffset(node) {
      var index = this.getNodeIndex(node);
      return index === null ? null : this._nodes.slice(0, index).reduce(function (sum, node) {
        return sum + node.offsetSize;
      }, 0);
    }
    /**
     * Converts index to offset in node list.
     *
     * Returns starting offset of a node that is at given index. Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
     * `model-nodelist-index-out-of-bounds` if given index is less than `0` or more than {@link #length}.
     *
     * @param {Number} index Node's index.
     * @returns {Number} Node's starting offset.
     */

  }, {
    key: "indexToOffset",
    value: function indexToOffset(index) {
      if (index == this._nodes.length) {
        return this.maxOffset;
      }

      var node = this._nodes[index];

      if (!node) {
        /**
         * Given index cannot be found in the node list.
         *
         * @error nodelist-index-out-of-bounds
         */
        throw new ckeditorerror["b" /* default */]('model-nodelist-index-out-of-bounds: Given index cannot be found in the node list.', this);
      }

      return this.getNodeStartOffset(node);
    }
    /**
     * Converts offset in node list to index.
     *
     * Returns index of a node that occupies given offset. Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError}
     * `model-nodelist-offset-out-of-bounds` if given offset is less than `0` or more than {@link #maxOffset}.
     *
     * @param {Number} offset Offset to look for.
     * @returns {Number} Index of a node that occupies given offset.
     */

  }, {
    key: "offsetToIndex",
    value: function offsetToIndex(offset) {
      var totalOffset = 0;

      var _iterator = _createForOfIteratorHelper(this._nodes),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var node = _step.value;

          if (offset >= totalOffset && offset < totalOffset + node.offsetSize) {
            return this.getNodeIndex(node);
          }

          totalOffset += node.offsetSize;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if (totalOffset != offset) {
        /**
         * Given offset cannot be found in the node list.
         *
         * @error model-nodelist-offset-out-of-bounds
         * @param {Number} offset
         * @param {module:engine/model/nodelist~NodeList} nodeList Stringified node list.
         */
        throw new ckeditorerror["b" /* default */]('model-nodelist-offset-out-of-bounds: Given offset cannot be found in the node list.', this, {
          offset: offset,
          nodeList: this
        });
      }

      return this.length;
    }
    /**
     * Inserts given nodes at given index.
     *
     * @protected
     * @param {Number} index Index at which nodes should be inserted.
     * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes to be inserted.
     */

  }, {
    key: "_insertNodes",
    value: function _insertNodes(index, nodes) {
      var _this$_nodes;

      // Validation.
      var _iterator2 = _createForOfIteratorHelper(nodes),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var node = _step2.value;

          if (!(node instanceof model_node_Node)) {
            /**
             * Trying to insert an object which is not a Node instance.
             *
             * @error nodelist-insertNodes-not-node
             */
            throw new ckeditorerror["b" /* default */]('model-nodelist-insertNodes-not-node: Trying to insert an object which is not a Node instance.', this);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      (_this$_nodes = this._nodes).splice.apply(_this$_nodes, [index, 0].concat(_toConsumableArray(nodes)));
    }
    /**
     * Removes one or more nodes starting at the given index.
     *
     * @protected
     * @param {Number} indexStart Index of the first node to remove.
     * @param {Number} [howMany=1] Number of nodes to remove.
     * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.
     */

  }, {
    key: "_removeNodes",
    value: function _removeNodes(indexStart) {
      var howMany = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      return this._nodes.splice(indexStart, howMany);
    }
    /**
     * Converts `NodeList` instance to an array containing nodes that were inserted in the node list. Nodes
     * are also converted to their plain object representation.
     *
     * @returns {Array.<module:engine/model/node~Node>} `NodeList` instance converted to `Array`.
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      return this._nodes.map(function (node) {
        return node.toJSON();
      });
    }
  }, {
    key: "length",
    get: function get() {
      return this._nodes.length;
    }
    /**
     * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all nodes contained inside this node list.
     *
     * @readonly
     * @type {Number}
     */

  }, {
    key: "maxOffset",
    get: function get() {
      return this._nodes.reduce(function (sum, node) {
        return sum + node.offsetSize;
      }, 0);
    }
  }]);

  return NodeList;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/element.js



















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/element
 */




 // @if CK_DEBUG_ENGINE // const { stringifyMap, convertMapToStringifiedObject, convertMapToTags } = require( '../dev-utils/utils' );

/**
 * Model element. Type of {@link module:engine/model/node~Node node} that has a {@link module:engine/model/element~Element#name name} and
 * {@link module:engine/model/element~Element#getChildren child nodes}.
 *
 * **Important**: see {@link module:engine/model/node~Node} to read about restrictions using `Element` and `Node` API.
 *
 * @extends module:engine/model/node~Node
 */

var model_element_Element = /*#__PURE__*/function (_Node) {
  Object(inherits["a" /* default */])(Element, _Node);

  var _super = Object(createSuper["a" /* default */])(Element);

  /**
   * Creates a model element.
   *
   * **Note:** Constructor of this class shouldn't be used directly in the code.
   * Use the {@link module:engine/model/writer~Writer#createElement} method instead.
   *
   * @protected
   * @param {String} name Element's name.
   * @param {Object} [attrs] Element's attributes. See {@link module:utils/tomap~toMap} for a list of accepted values.
   * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]
   * One or more nodes to be inserted as children of created element.
   */
  function Element(name, attrs, children) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, Element);

    _this = _super.call(this, attrs);
    /**
     * Element name.
     *
     * @readonly
     * @member {String} module:engine/model/element~Element#name
     */

    _this.name = name;
    /**
     * List of children nodes.
     *
     * @private
     * @member {module:engine/model/nodelist~NodeList} module:engine/model/element~Element#_children
     */

    _this._children = new nodelist_NodeList();

    if (children) {
      _this._insertChild(0, children);
    }

    return _this;
  }
  /**
   * Number of this element's children.
   *
   * @readonly
   * @type {Number}
   */


  Object(createClass["a" /* default */])(Element, [{
    key: "is",

    /**
     * Checks whether this object is of the given.
     *
     *		element.is( 'element' ); // -> true
     *		element.is( 'node' ); // -> true
     *		element.is( 'model:element' ); // -> true
     *		element.is( 'model:node' ); // -> true
     *
     *		element.is( 'view:element' ); // -> false
     *		element.is( 'documentSelection' ); // -> false
     *
     * Assuming that the object being checked is an element, you can also check its
     * {@link module:engine/model/element~Element#name name}:
     *
     *		element.is( 'image' ); // -> true if this is an <image> element
     *		element.is( 'element', 'image' ); // -> same as above
     *		text.is( 'image' ); -> false
     *
     * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.
     *
     * @param {String} type Type to check when `name` parameter is present.
     * Otherwise, it acts like the `name` parameter.
     * @param {String} [name] Element name.
     * @returns {Boolean}
     */
    value: function is(type) {
      var name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (!name) {
        return type === 'element' || type === 'model:element' || type === this.name || type === 'model:' + this.name || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'node' || type === 'model:node';
      }

      return name === this.name && (type === 'element' || type === 'model:element');
    }
    /**
     * Gets the child at the given index.
     *
     * @param {Number} index Index of child.
     * @returns {module:engine/model/node~Node} Child node.
     */

  }, {
    key: "getChild",
    value: function getChild(index) {
      return this._children.getNode(index);
    }
    /**
     * Returns an iterator that iterates over all of this element's children.
     *
     * @returns {Iterable.<module:engine/model/node~Node>}
     */

  }, {
    key: "getChildren",
    value: function getChildren() {
      return this._children[Symbol.iterator]();
    }
    /**
     * Returns an index of the given child node. Returns `null` if given node is not a child of this element.
     *
     * @param {module:engine/model/node~Node} node Child node to look for.
     * @returns {Number} Child node's index in this element.
     */

  }, {
    key: "getChildIndex",
    value: function getChildIndex(node) {
      return this._children.getNodeIndex(node);
    }
    /**
     * Returns the starting offset of given child. Starting offset is equal to the sum of
     * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
     * given node is not a child of this element.
     *
     * @param {module:engine/model/node~Node} node Child node to look for.
     * @returns {Number} Child node's starting offset.
     */

  }, {
    key: "getChildStartOffset",
    value: function getChildStartOffset(node) {
      return this._children.getNodeStartOffset(node);
    }
    /**
     * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
     * too high, returns {@link module:engine/model/element~Element#getChildIndex index after last child}.
     *
     *		const textNode = new Text( 'foo' );
     *		const pElement = new Element( 'p' );
     *		const divElement = new Element( [ textNode, pElement ] );
     *		divElement.offsetToIndex( -1 ); // Returns 0, because offset is too low.
     *		divElement.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
     *		divElement.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
     *		divElement.offsetToIndex( 2 ); // Returns 0.
     *		divElement.offsetToIndex( 3 ); // Returns 1.
     *		divElement.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
     *
     * @param {Number} offset Offset to look for.
     * @returns {Number}
     */

  }, {
    key: "offsetToIndex",
    value: function offsetToIndex(offset) {
      return this._children.offsetToIndex(offset);
    }
    /**
     * Returns a descendant node by its path relative to this element.
     *
     *		// <this>a<b>c</b></this>
     *		this.getNodeByPath( [ 0 ] );     // -> "a"
     *		this.getNodeByPath( [ 1 ] );     // -> <b>
     *		this.getNodeByPath( [ 1, 0 ] );  // -> "c"
     *
     * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.
     * @returns {module:engine/model/node~Node}
     */

  }, {
    key: "getNodeByPath",
    value: function getNodeByPath(relativePath) {
      var node = this; // eslint-disable-line consistent-this

      var _iterator = _createForOfIteratorHelper(relativePath),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var index = _step.value;
          node = node.getChild(node.offsetToIndex(index));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return node;
    }
    /**
     * Converts `Element` instance to plain object and returns it. Takes care of converting all of this element's children.
     *
     * @returns {Object} `Element` instance converted to plain object.
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = get_get(Object(getPrototypeOf["a" /* default */])(Element.prototype), "toJSON", this).call(this);

      json.name = this.name;

      if (this._children.length > 0) {
        json.children = [];

        var _iterator2 = _createForOfIteratorHelper(this._children),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var node = _step2.value;
            json.children.push(node.toJSON());
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }

      return json;
    }
    /**
     * Creates a copy of this element and returns it. Created element has the same name and attributes as the original element.
     * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.
     *
     * @protected
     * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,
     * element will be cloned without any child.
     */

  }, {
    key: "_clone",
    value: function _clone() {
      var deep = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var children = deep ? Array.from(this._children).map(function (node) {
        return node._clone(true);
      }) : null;
      return new Element(this.name, this.getAttributes(), children);
    }
    /**
     * {@link module:engine/model/element~Element#_insertChild Inserts} one or more nodes at the end of this element.
     *
     * @see module:engine/model/writer~Writer#append
     * @protected
     * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} nodes Nodes to be inserted.
     */

  }, {
    key: "_appendChild",
    value: function _appendChild(nodes) {
      this._insertChild(this.childCount, nodes);
    }
    /**
     * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes
     * to this element.
     *
     * @see module:engine/model/writer~Writer#insert
     * @protected
     * @param {Number} index Index at which nodes should be inserted.
     * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.
     */

  }, {
    key: "_insertChild",
    value: function _insertChild(index, items) {
      var nodes = element_normalize(items);

      var _iterator3 = _createForOfIteratorHelper(nodes),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var node = _step3.value;

          // If node that is being added to this element is already inside another element, first remove it from the old parent.
          if (node.parent !== null) {
            node._remove();
          }

          node.parent = this;
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this._children._insertNodes(index, nodes);
    }
    /**
     * Removes one or more nodes starting at the given index and sets
     * {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.
     *
     * @see module:engine/model/writer~Writer#remove
     * @protected
     * @param {Number} index Index of the first node to remove.
     * @param {Number} [howMany=1] Number of nodes to remove.
     * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.
     */

  }, {
    key: "_removeChildren",
    value: function _removeChildren(index) {
      var howMany = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      var nodes = this._children._removeNodes(index, howMany);

      var _iterator4 = _createForOfIteratorHelper(nodes),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var node = _step4.value;
          node.parent = null;
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      return nodes;
    }
    /**
     * Creates an `Element` instance from given plain object (i.e. parsed JSON string).
     * Converts `Element` children to proper nodes.
     *
     * @param {Object} json Plain object to be converted to `Element`.
     * @returns {module:engine/model/element~Element} `Element` instance created using given plain object.
     */

  }, {
    key: "childCount",
    get: function get() {
      return this._children.length;
    }
    /**
     * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this element's children.
     *
     * @readonly
     * @type {Number}
     */

  }, {
    key: "maxOffset",
    get: function get() {
      return this._children.maxOffset;
    }
    /**
     * Is `true` if there are no nodes inside this element, `false` otherwise.
     *
     * @readonly
     * @type {Boolean}
     */

  }, {
    key: "isEmpty",
    get: function get() {
      return this.childCount === 0;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(json) {
      var children = null;

      if (json.children) {
        children = [];

        var _iterator5 = _createForOfIteratorHelper(json.children),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var child = _step5.value;

            if (child.name) {
              // If child has name property, it is an Element.
              children.push(Element.fromJSON(child));
            } else {
              // Otherwise, it is a Text node.
              children.push(model_text_Text.fromJSON(child));
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      }

      return new Element(json.name, json.attributes, children);
    } // @if CK_DEBUG_ENGINE // toString() {
    // @if CK_DEBUG_ENGINE // 	return `<${ this.rootName || this.name }>`;
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // log() {
    // @if CK_DEBUG_ENGINE // 	console.log( 'ModelElement: ' + this );
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // logExtended() {
    // @if CK_DEBUG_ENGINE // 	console.log( `ModelElement: ${ this }, ${ this.childCount } children,
    // @if CK_DEBUG_ENGINE //		attrs: ${ convertMapToStringifiedObject( this.getAttributes() ) }` );
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // logAll() {
    // @if CK_DEBUG_ENGINE // 	console.log( '--------------------' );
    // @if CK_DEBUG_ENGINE //
    // @if CK_DEBUG_ENGINE // 	this.logExtended();
    // @if CK_DEBUG_ENGINE //	console.log( 'List of children:' );
    // @if CK_DEBUG_ENGINE //
    // @if CK_DEBUG_ENGINE // 	for ( const child of this.getChildren() ) {
    // @if CK_DEBUG_ENGINE // 		child.log();
    // @if CK_DEBUG_ENGINE // 	}
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // printTree( level = 0) {
    // @if CK_DEBUG_ENGINE // 	let string = '';
    // @if CK_DEBUG_ENGINE // 	string += '\t'.repeat( level );
    // @if CK_DEBUG_ENGINE // 	string += `<${ this.rootName || this.name }${ convertMapToTags( this.getAttributes() ) }>`;
    // @if CK_DEBUG_ENGINE // 	for ( const child of this.getChildren() ) {
    // @if CK_DEBUG_ENGINE // 		string += '\n';
    // @if CK_DEBUG_ENGINE // 		if ( child.is( 'text' ) ) {
    // @if CK_DEBUG_ENGINE // 			const textAttrs = convertMapToTags( child._attrs );
    // @if CK_DEBUG_ENGINE // 			string += '\t'.repeat( level + 1 );
    // @if CK_DEBUG_ENGINE // 			if ( textAttrs !== '' ) {
    // @if CK_DEBUG_ENGINE // 				string += `<$text${ textAttrs }>` + child.data + '</$text>';
    // @if CK_DEBUG_ENGINE // 			} else {
    // @if CK_DEBUG_ENGINE // 				string += child.data;
    // @if CK_DEBUG_ENGINE // 			}
    // @if CK_DEBUG_ENGINE // 		} else {
    // @if CK_DEBUG_ENGINE // 			string += child.printTree( level + 1 );
    // @if CK_DEBUG_ENGINE // 		}
    // @if CK_DEBUG_ENGINE // 	}
    // @if CK_DEBUG_ENGINE // 	if ( this.childCount ) {
    // @if CK_DEBUG_ENGINE // 		string += '\n' + '\t'.repeat( level );
    // @if CK_DEBUG_ENGINE // 	}
    // @if CK_DEBUG_ENGINE // 	string += `</${ this.rootName || this.name }>`;
    // @if CK_DEBUG_ENGINE // 	return string;
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // logTree() {
    // @if CK_DEBUG_ENGINE // 	console.log( this.printTree() );
    // @if CK_DEBUG_ENGINE // }

  }]);

  return Element;
}(model_node_Node); // Converts strings to Text and non-iterables to arrays.
//
// @param {String|module:engine/model/item~Item|Iterable.<String|module:engine/model/item~Item>}
// @returns {Iterable.<module:engine/model/node~Node>}




function element_normalize(nodes) {
  // Separate condition because string is iterable.
  if (typeof nodes == 'string') {
    return [new model_text_Text(nodes)];
  }

  if (!isIterable(nodes)) {
    nodes = [nodes];
  } // Array.from to enable .map() on non-arrays.


  return Array.from(nodes).map(function (node) {
    if (typeof node == 'string') {
      return new model_text_Text(node);
    }

    if (node instanceof model_textproxy_TextProxy) {
      return new model_text_Text(node.data, node.getAttributes());
    }

    return node;
  });
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/treewalker.js










/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/treewalker
 */





/**
 * Position iterator class. It allows to iterate forward and backward over the document.
 */

var model_treewalker_TreeWalker = /*#__PURE__*/function () {
  /**
   * Creates a range iterator. All parameters are optional, but you have to specify either `boundaries` or `startPosition`.
   *
   * @constructor
   * @param {Object} [options={}] Object with configuration.
   * @param {'forward'|'backward'} [options.direction='forward'] Walking direction.
   * @param {module:engine/model/range~Range} [options.boundaries=null] Range to define boundaries of the iterator.
   * @param {module:engine/model/position~Position} [options.startPosition] Starting position.
   * @param {Boolean} [options.singleCharacters=false] Flag indicating whether all consecutive characters with the same attributes
   * should be returned one by one as multiple {@link module:engine/model/textproxy~TextProxy} (`true`) objects or as one
   * {@link module:engine/model/textproxy~TextProxy} (`false`).
   * @param {Boolean} [options.shallow=false] Flag indicating whether iterator should enter elements or not. If the
   * iterator is shallow child nodes of any iterated node will not be returned along with `elementEnd` tag.
   * @param {Boolean} [options.ignoreElementEnd=false] Flag indicating whether iterator should ignore `elementEnd`
   * tags. If the option is true walker will not return a parent node of start position. If this option is `true`
   * each {@link module:engine/model/element~Element} will be returned once, while if the option is `false` they might be returned
   * twice: for `'elementStart'` and `'elementEnd'`.
   */
  function TreeWalker() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    Object(classCallCheck["a" /* default */])(this, TreeWalker);

    if (!options.boundaries && !options.startPosition) {
      /**
       * Neither boundaries nor starting position of a `TreeWalker` have been defined.
       *
       * @error model-tree-walker-no-start-position
       */
      throw new ckeditorerror["b" /* default */]('model-tree-walker-no-start-position: Neither boundaries nor starting position have been defined.', null);
    }

    var direction = options.direction || 'forward';

    if (direction != 'forward' && direction != 'backward') {
      throw new ckeditorerror["b" /* default */]('model-tree-walker-unknown-direction: Only `backward` and `forward` direction allowed.', options, {
        direction: direction
      });
    }
    /**
     * Walking direction. Defaults `'forward'`.
     *
     * @readonly
     * @member {'backward'|'forward'} module:engine/model/treewalker~TreeWalker#direction
     */


    this.direction = direction;
    /**
     * Iterator boundaries.
     *
     * When the iterator is walking `'forward'` on the end of boundary or is walking `'backward'`
     * on the start of boundary, then `{ done: true }` is returned.
     *
     * If boundaries are not defined they are set before first and after last child of the root node.
     *
     * @readonly
     * @member {module:engine/model/range~Range} module:engine/model/treewalker~TreeWalker#boundaries
     */

    this.boundaries = options.boundaries || null;
    /**
     * Iterator position. This is always static position, even if the initial position was a
     * {@link module:engine/model/liveposition~LivePosition live position}. If start position is not defined then position depends
     * on {@link #direction}. If direction is `'forward'` position starts form the beginning, when direction
     * is `'backward'` position starts from the end.
     *
     * @readonly
     * @member {module:engine/model/position~Position} module:engine/model/treewalker~TreeWalker#position
     */

    if (options.startPosition) {
      this.position = options.startPosition.clone();
    } else {
      this.position = model_position_Position._createAt(this.boundaries[this.direction == 'backward' ? 'end' : 'start']);
    } // Reset position stickiness in case it was set to other value, as the stickiness is kept after cloning.


    this.position.stickiness = 'toNone';
    /**
     * Flag indicating whether all consecutive characters with the same attributes should be
     * returned as one {@link module:engine/model/textproxy~TextProxy} (`true`) or one by one (`false`).
     *
     * @readonly
     * @member {Boolean} module:engine/model/treewalker~TreeWalker#singleCharacters
     */

    this.singleCharacters = !!options.singleCharacters;
    /**
     * Flag indicating whether iterator should enter elements or not. If the iterator is shallow child nodes of any
     * iterated node will not be returned along with `elementEnd` tag.
     *
     * @readonly
     * @member {Boolean} module:engine/model/treewalker~TreeWalker#shallow
     */

    this.shallow = !!options.shallow;
    /**
     * Flag indicating whether iterator should ignore `elementEnd` tags. If the option is true walker will not
     * return a parent node of the start position. If this option is `true` each {@link module:engine/model/element~Element} will
     * be returned once, while if the option is `false` they might be returned twice:
     * for `'elementStart'` and `'elementEnd'`.
     *
     * @readonly
     * @member {Boolean} module:engine/model/treewalker~TreeWalker#ignoreElementEnd
     */

    this.ignoreElementEnd = !!options.ignoreElementEnd;
    /**
     * Start boundary cached for optimization purposes.
     *
     * @private
     * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryStartParent
     */

    this._boundaryStartParent = this.boundaries ? this.boundaries.start.parent : null;
    /**
     * End boundary cached for optimization purposes.
     *
     * @private
     * @member {module:engine/model/element~Element} module:engine/model/treewalker~TreeWalker#_boundaryEndParent
     */

    this._boundaryEndParent = this.boundaries ? this.boundaries.end.parent : null;
    /**
     * Parent of the most recently visited node. Cached for optimization purposes.
     *
     * @private
     * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}
     * module:engine/model/treewalker~TreeWalker#_visitedParent
     */

    this._visitedParent = this.position.parent;
  }
  /**
   * Iterable interface.
   *
   * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}
   */


  Object(createClass["a" /* default */])(TreeWalker, [{
    key: Symbol.iterator,
    value: function value() {
      return this;
    }
    /**
     * Moves {@link #position} in the {@link #direction} skipping values as long as the callback function returns `true`.
     *
     * For example:
     *
     * 		walker.skip( value => value.type == 'text' ); // <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>
     * 		walker.skip( () => true ); // Move the position to the end: <paragraph>[]foo</paragraph> -> <paragraph>foo</paragraph>[]
     * 		walker.skip( () => false ); // Do not move the position.
     *
     * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should
     * return `true` if the value should be skipped or `false` if not.
     */

  }, {
    key: "skip",
    value: function skip(_skip) {
      var done, value, prevPosition, prevVisitedParent;

      do {
        prevPosition = this.position;
        prevVisitedParent = this._visitedParent;

        var _this$next = this.next();

        done = _this$next.done;
        value = _this$next.value;
      } while (!done && _skip(value));

      if (!done) {
        this.position = prevPosition;
        this._visitedParent = prevVisitedParent;
      }
    }
    /**
     * Gets the next tree walker's value.
     *
     * @returns {module:engine/model/treewalker~TreeWalkerValue} Next tree walker's value.
     */

  }, {
    key: "next",
    value: function next() {
      if (this.direction == 'forward') {
        return this._next();
      } else {
        return this._previous();
      }
    }
    /**
     * Makes a step forward in model. Moves the {@link #position} to the next position and returns the encountered value.
     *
     * @private
     * @returns {Object}
     * @returns {Boolean} return.done True if iterator is done.
     * @returns {module:engine/model/treewalker~TreeWalkerValue} return.value Information about taken step.
     */

  }, {
    key: "_next",
    value: function _next() {
      var previousPosition = this.position;
      var position = this.position.clone();
      var parent = this._visitedParent; // We are at the end of the root.

      if (parent.parent === null && position.offset === parent.maxOffset) {
        return {
          done: true
        };
      } // We reached the walker boundary.


      if (parent === this._boundaryEndParent && position.offset == this.boundaries.end.offset) {
        return {
          done: true
        };
      } // Get node just after the current position.
      // Use a highly optimized version instead of checking the text node first and then getting the node after. See #6582.


      var positionParent = position.parent;
      var textNodeAtPosition = getTextNodeAtPosition(position, positionParent);
      var node = textNodeAtPosition ? textNodeAtPosition : getNodeAfterPosition(position, positionParent, textNodeAtPosition);

      if (node instanceof model_element_Element) {
        if (!this.shallow) {
          // Manual operations on path internals for optimization purposes. Here and in the rest of the method.
          position.path.push(0);
          this._visitedParent = node;
        } else {
          position.offset++;
        }

        this.position = position;
        return formatReturnValue('elementStart', node, previousPosition, position, 1);
      } else if (node instanceof model_text_Text) {
        var charactersCount;

        if (this.singleCharacters) {
          charactersCount = 1;
        } else {
          var offset = node.endOffset;

          if (this._boundaryEndParent == parent && this.boundaries.end.offset < offset) {
            offset = this.boundaries.end.offset;
          }

          charactersCount = offset - position.offset;
        }

        var offsetInTextNode = position.offset - node.startOffset;
        var item = new model_textproxy_TextProxy(node, offsetInTextNode, charactersCount);
        position.offset += charactersCount;
        this.position = position;
        return formatReturnValue('text', item, previousPosition, position, charactersCount);
      } else {
        // `node` is not set, we reached the end of current `parent`.
        position.path.pop();
        position.offset++;
        this.position = position;
        this._visitedParent = parent.parent;

        if (this.ignoreElementEnd) {
          return this._next();
        } else {
          return formatReturnValue('elementEnd', parent, previousPosition, position);
        }
      }
    }
    /**
     * Makes a step backward in model. Moves the {@link #position} to the previous position and returns the encountered value.
     *
     * @private
     * @returns {Object}
     * @returns {Boolean} return.done True if iterator is done.
     * @returns {module:engine/model/treewalker~TreeWalkerValue} return.value Information about taken step.
     */

  }, {
    key: "_previous",
    value: function _previous() {
      var previousPosition = this.position;
      var position = this.position.clone();
      var parent = this._visitedParent; // We are at the beginning of the root.

      if (parent.parent === null && position.offset === 0) {
        return {
          done: true
        };
      } // We reached the walker boundary.


      if (parent == this._boundaryStartParent && position.offset == this.boundaries.start.offset) {
        return {
          done: true
        };
      } // Get node just before the current position.
      // Use a highly optimized version instead of checking the text node first and then getting the node before. See #6582.


      var positionParent = position.parent;
      var textNodeAtPosition = getTextNodeAtPosition(position, positionParent);
      var node = textNodeAtPosition ? textNodeAtPosition : getNodeBeforePosition(position, positionParent, textNodeAtPosition);

      if (node instanceof model_element_Element) {
        position.offset--;

        if (!this.shallow) {
          position.path.push(node.maxOffset);
          this.position = position;
          this._visitedParent = node;

          if (this.ignoreElementEnd) {
            return this._previous();
          } else {
            return formatReturnValue('elementEnd', node, previousPosition, position);
          }
        } else {
          this.position = position;
          return formatReturnValue('elementStart', node, previousPosition, position, 1);
        }
      } else if (node instanceof model_text_Text) {
        var charactersCount;

        if (this.singleCharacters) {
          charactersCount = 1;
        } else {
          var offset = node.startOffset;

          if (this._boundaryStartParent == parent && this.boundaries.start.offset > offset) {
            offset = this.boundaries.start.offset;
          }

          charactersCount = position.offset - offset;
        }

        var offsetInTextNode = position.offset - node.startOffset;
        var item = new model_textproxy_TextProxy(node, offsetInTextNode - charactersCount, charactersCount);
        position.offset -= charactersCount;
        this.position = position;
        return formatReturnValue('text', item, previousPosition, position, charactersCount);
      } else {
        // `node` is not set, we reached the beginning of current `parent`.
        position.path.pop();
        this.position = position;
        this._visitedParent = parent.parent;
        return formatReturnValue('elementStart', parent, previousPosition, position, 1);
      }
    }
  }]);

  return TreeWalker;
}();



function formatReturnValue(type, item, previousPosition, nextPosition, length) {
  return {
    done: false,
    value: {
      type: type,
      item: item,
      previousPosition: previousPosition,
      nextPosition: nextPosition,
      length: length
    }
  };
}
/**
 * Type of the step made by {@link module:engine/model/treewalker~TreeWalker}.
 * Possible values: `'elementStart'` if walker is at the beginning of a node, `'elementEnd'` if walker is at the end of node,
 * `'character'` if walker traversed over a character, or `'text'` if walker traversed over multiple characters (available in
 * character merging mode, see {@link module:engine/model/treewalker~TreeWalker#constructor}).
 *
 * @typedef {'elementStart'|'elementEnd'|'character'|'text'} module:engine/model/treewalker~TreeWalkerValueType
 */

/**
 * Object returned by {@link module:engine/model/treewalker~TreeWalker} when traversing tree model.
 *
 * @typedef {Object} module:engine/model/treewalker~TreeWalkerValue
 * @property {module:engine/model/treewalker~TreeWalkerValueType} type
 * @property {module:engine/model/item~Item} item Item between old and new positions of {@link module:engine/model/treewalker~TreeWalker}.
 * @property {module:engine/model/position~Position} previousPosition Previous position of the iterator.
 * * Forward iteration: For `'elementEnd'` it is the last position inside the element. For all other types it is the
 * position before the item.
 * * Backward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is
 * the position after item.
 * @property {module:engine/model/position~Position} nextPosition Next position of the iterator.
 * * Forward iteration: For `'elementStart'` it is the first position inside the element. For all other types it is
 * the position after the item.
 * * Backward iteration: For `'elementEnd'` it is last position inside element. For all other types it is the position
 * before the item.
 * @property {Number} [length] Length of the item. For `'elementStart'` and `'character'` it is 1. For `'text'` it is
 * the length of the text. For `'elementEnd'` it is `undefined`.
 */

/**
 * Tree walking directions.
 *
 * @typedef {'forward'|'backward'} module:engine/view/treewalker~TreeWalkerDirection
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/position.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/position
 */


 // To check if component is loaded more than once.


/**
 * Represents a position in the model tree.
 *
 * A position is represented by its {@link module:engine/model/position~Position#root} and
 * a {@link module:engine/model/position~Position#path} in that root.
 *
 * You can create position instances via its constructor or the `createPosition*()` factory methods of
 * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.
 *
 * **Note:** Position is based on offsets, not indexes. This means that a position between two text nodes
 * `foo` and `bar` has offset `3`, not `1`. See {@link module:engine/model/position~Position#path} for more information.
 *
 * Since a position in the model is represented by a {@link module:engine/model/position~Position#root position root} and
 * {@link module:engine/model/position~Position#path position path} it is possible to create positions placed in non-existing places.
 * This requirement is important for operational transformation algorithms.
 *
 * Also, {@link module:engine/model/operation/operation~Operation operations}
 * kept in the {@link module:engine/model/document~Document#history document history}
 * are storing positions (and ranges) which were correct when those operations were applied, but may not be correct
 * after the document has changed.
 *
 * When changes are applied to the model, it may also happen that {@link module:engine/model/position~Position#parent position parent}
 * will change even if position path has not changed. Keep in mind, that if a position leads to non-existing element,
 * {@link module:engine/model/position~Position#parent} and some other properties and methods will throw errors.
 *
 * In most cases, position with wrong path is caused by an error in code, but it is sometimes needed, as described above.
 */

var model_position_Position = /*#__PURE__*/function () {
  /**
   * Creates a position.
   *
   * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.
   * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.
   * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.
   * See {@link module:engine/model/position~PositionStickiness}.
   */
  function Position(root, path) {
    var stickiness = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'toNone';

    Object(classCallCheck["a" /* default */])(this, Position);

    if (!root.is('element') && !root.is('documentFragment')) {
      /**
       * Position root is invalid.
       *
       * Positions can only be anchored in elements or document fragments.
       *
       * @error model-position-root-invalid
       */
      throw new ckeditorerror["b" /* default */]('model-position-root-invalid: Position root invalid.', root);
    }

    if (!(path instanceof Array) || path.length === 0) {
      /**
       * Position path must be an array with at least one item.
       *
       * @error model-position-path-incorrect-format
       * @param path
       */
      throw new ckeditorerror["b" /* default */]('model-position-path-incorrect-format: Position path must be an array with at least one item.', root, {
        path: path
      });
    } // Normalize the root and path when element (not root) is passed.


    if (root.is('rootElement')) {
      path = path.slice();
    } else {
      path = [].concat(_toConsumableArray(root.getPath()), _toConsumableArray(path));
      root = root.root;
    }
    /**
     * Root of the position path.
     *
     * @readonly
     * @member {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}
     * module:engine/model/position~Position#root
     */


    this.root = root;
    /**
     * Position of the node in the tree. **Path contains offsets, not indexes.**
     *
     * Position can be placed before, after or in a {@link module:engine/model/node~Node node} if that node has
     * {@link module:engine/model/node~Node#offsetSize} greater than `1`. Items in position path are
     * {@link module:engine/model/node~Node#startOffset starting offsets} of position ancestors, starting from direct root children,
     * down to the position offset in it's parent.
     *
     *		 ROOT
     *		  |- P            before: [ 0 ]         after: [ 1 ]
     *		  |- UL           before: [ 1 ]         after: [ 2 ]
     *		     |- LI        before: [ 1, 0 ]      after: [ 1, 1 ]
     *		     |  |- foo    before: [ 1, 0, 0 ]   after: [ 1, 0, 3 ]
     *		     |- LI        before: [ 1, 1 ]      after: [ 1, 2 ]
     *		        |- bar    before: [ 1, 1, 0 ]   after: [ 1, 1, 3 ]
     *
     * `foo` and `bar` are representing {@link module:engine/model/text~Text text nodes}. Since text nodes has offset size
     * greater than `1` you can place position offset between their start and end:
     *
     *		 ROOT
     *		  |- P
     *		  |- UL
     *		     |- LI
     *		     |  |- f^o|o  ^ has path: [ 1, 0, 1 ]   | has path: [ 1, 0, 2 ]
     *		     |- LI
     *		        |- b^a|r  ^ has path: [ 1, 1, 1 ]   | has path: [ 1, 1, 2 ]
     *
     * @readonly
     * @member {Array.<Number>} module:engine/model/position~Position#path
     */

    this.path = path;
    /**
     * Position stickiness. See {@link module:engine/model/position~PositionStickiness}.
     *
     * @member {module:engine/model/position~PositionStickiness} module:engine/model/position~Position#stickiness
     */

    this.stickiness = stickiness;
  }
  /**
   * Offset at which this position is located in its {@link module:engine/model/position~Position#parent parent}. It is equal
   * to the last item in position {@link module:engine/model/position~Position#path path}.
   *
   * @type {Number}
   */


  Object(createClass["a" /* default */])(Position, [{
    key: "compareWith",

    /**
     * Checks whether this position is before or after given position.
     *
     * This method is safe to use it on non-existing positions (for example during operational transformation).
     *
     * @param {module:engine/model/position~Position} otherPosition Position to compare with.
     * @returns {module:engine/model/position~PositionRelation}
     */
    value: function compareWith(otherPosition) {
      if (this.root != otherPosition.root) {
        return 'different';
      }

      var result = compareArrays(this.path, otherPosition.path);

      switch (result) {
        case 'same':
          return 'same';

        case 'prefix':
          return 'before';

        case 'extension':
          return 'after';

        default:
          return this.path[result] < otherPosition.path[result] ? 'before' : 'after';
      }
    }
    /**
     * Gets the farthest position which matches the callback using
     * {@link module:engine/model/treewalker~TreeWalker TreeWalker}.
     *
     * For example:
     *
     * 		getLastMatchingPosition( value => value.type == 'text' );
     * 		// <paragraph>[]foo</paragraph> -> <paragraph>foo[]</paragraph>
     *
     * 		getLastMatchingPosition( value => value.type == 'text', { direction: 'backward' } );
     * 		// <paragraph>foo[]</paragraph> -> <paragraph>[]foo</paragraph>
     *
     * 		getLastMatchingPosition( value => false );
     * 		// Do not move the position.
     *
     * @param {Function} skip Callback function. Gets {@link module:engine/model/treewalker~TreeWalkerValue} and should
     * return `true` if the value should be skipped or `false` if not.
     * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
     *
     * @returns {module:engine/model/position~Position} The position after the last item which matches the `skip` callback test.
     */

  }, {
    key: "getLastMatchingPosition",
    value: function getLastMatchingPosition(skip) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      options.startPosition = this;
      var treeWalker = new model_treewalker_TreeWalker(options);
      treeWalker.skip(skip);
      return treeWalker.position;
    }
    /**
     * Returns a path to this position's parent. Parent path is equal to position {@link module:engine/model/position~Position#path path}
     * but without the last item.
     *
     * This method is safe to use it on non-existing positions (for example during operational transformation).
     *
     * @returns {Array.<Number>} Path to the parent.
     */

  }, {
    key: "getParentPath",
    value: function getParentPath() {
      return this.path.slice(0, -1);
    }
    /**
     * Returns ancestors array of this position, that is this position's parent and its ancestors.
     *
     * @returns {Array.<module:engine/model/item~Item>} Array with ancestors.
     */

  }, {
    key: "getAncestors",
    value: function getAncestors() {
      var parent = this.parent;

      if (parent.is('documentFragment')) {
        return [parent];
      } else {
        return parent.getAncestors({
          includeSelf: true
        });
      }
    }
    /**
     * Returns the slice of two position {@link #path paths} which is identical. The {@link #root roots}
     * of these two paths must be identical.
     *
     * This method is safe to use it on non-existing positions (for example during operational transformation).
     *
     * @param {module:engine/model/position~Position} position The second position.
     * @returns {Array.<Number>} The common path.
     */

  }, {
    key: "getCommonPath",
    value: function getCommonPath(position) {
      if (this.root != position.root) {
        return [];
      } // We find on which tree-level start and end have the lowest common ancestor


      var cmp = compareArrays(this.path, position.path); // If comparison returned string it means that arrays are same.

      var diffAt = typeof cmp == 'string' ? Math.min(this.path.length, position.path.length) : cmp;
      return this.path.slice(0, diffAt);
    }
    /**
     * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
     * which is a common ancestor of both positions. The {@link #root roots} of these two positions must be identical.
     *
     * @param {module:engine/model/position~Position} position The second position.
     * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}
     */

  }, {
    key: "getCommonAncestor",
    value: function getCommonAncestor(position) {
      var ancestorsA = this.getAncestors();
      var ancestorsB = position.getAncestors();
      var i = 0;

      while (ancestorsA[i] == ancestorsB[i] && ancestorsA[i]) {
        i++;
      }

      return i === 0 ? null : ancestorsA[i - 1];
    }
    /**
     * Returns a new instance of `Position`, that has same {@link #parent parent} but it's offset
     * is shifted by `shift` value (can be a negative value).
     *
     * This method is safe to use it on non-existing positions (for example during operational transformation).
     *
     * @param {Number} shift Offset shift. Can be a negative value.
     * @returns {module:engine/model/position~Position} Shifted position.
     */

  }, {
    key: "getShiftedBy",
    value: function getShiftedBy(shift) {
      var shifted = this.clone();
      var offset = shifted.offset + shift;
      shifted.offset = offset < 0 ? 0 : offset;
      return shifted;
    }
    /**
     * Checks whether this position is after given position.
     *
     * This method is safe to use it on non-existing positions (for example during operational transformation).
     *
     * @see module:engine/model/position~Position#isBefore
     * @param {module:engine/model/position~Position} otherPosition Position to compare with.
     * @returns {Boolean} True if this position is after given position.
     */

  }, {
    key: "isAfter",
    value: function isAfter(otherPosition) {
      return this.compareWith(otherPosition) == 'after';
    }
    /**
     * Checks whether this position is before given position.
     *
     * **Note:** watch out when using negation of the value returned by this method, because the negation will also
     * be `true` if positions are in different roots and you might not expect this. You should probably use
     * `a.isAfter( b ) || a.isEqual( b )` or `!a.isBefore( p ) && a.root == b.root` in most scenarios. If your
     * condition uses multiple `isAfter` and `isBefore` checks, build them so they do not use negated values, i.e.:
     *
     *		if ( a.isBefore( b ) && c.isAfter( d ) ) {
     *			// do A.
     *		} else {
     *			// do B.
     *		}
     *
     * or, if you have only one if-branch:
     *
     *		if ( !( a.isBefore( b ) && c.isAfter( d ) ) {
     *			// do B.
     *		}
     *
     * rather than:
     *
     *		if ( !a.isBefore( b ) || && !c.isAfter( d ) ) {
     *			// do B.
     *		} else {
     *			// do A.
     *		}
     *
     * This method is safe to use it on non-existing positions (for example during operational transformation).
     *
     * @param {module:engine/model/position~Position} otherPosition Position to compare with.
     * @returns {Boolean} True if this position is before given position.
     */

  }, {
    key: "isBefore",
    value: function isBefore(otherPosition) {
      return this.compareWith(otherPosition) == 'before';
    }
    /**
     * Checks whether this position is equal to given position.
     *
     * This method is safe to use it on non-existing positions (for example during operational transformation).
     *
     * @param {module:engine/model/position~Position} otherPosition Position to compare with.
     * @returns {Boolean} True if positions are same.
     */

  }, {
    key: "isEqual",
    value: function isEqual(otherPosition) {
      return this.compareWith(otherPosition) == 'same';
    }
    /**
     * Checks whether this position is touching given position. Positions touch when there are no text nodes
     * or empty nodes in a range between them. Technically, those positions are not equal but in many cases
     * they are very similar or even indistinguishable.
     *
     * @param {module:engine/model/position~Position} otherPosition Position to compare with.
     * @returns {Boolean} True if positions touch.
     */

  }, {
    key: "isTouching",
    value: function isTouching(otherPosition) {
      var left = null;
      var right = null;
      var compare = this.compareWith(otherPosition);

      switch (compare) {
        case 'same':
          return true;

        case 'before':
          left = Position._createAt(this);
          right = Position._createAt(otherPosition);
          break;

        case 'after':
          left = Position._createAt(otherPosition);
          right = Position._createAt(this);
          break;

        default:
          return false;
      } // Cached for optimization purposes.


      var leftParent = left.parent;

      while (left.path.length + right.path.length) {
        if (left.isEqual(right)) {
          return true;
        }

        if (left.path.length > right.path.length) {
          if (left.offset !== leftParent.maxOffset) {
            return false;
          }

          left.path = left.path.slice(0, -1);
          leftParent = leftParent.parent;
          left.offset++;
        } else {
          if (right.offset !== 0) {
            return false;
          }

          right.path = right.path.slice(0, -1);
        }
      }
    }
    /**
     * Checks whether this object is of the given.
     *
     *		position.is( 'position' ); // -> true
     *		position.is( 'model:position' ); // -> true
     *
     *		position.is( 'view:position' ); // -> false
     *		position.is( 'documentSelection' ); // -> false
     *
     * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.
     *
     * @param {String} type
     * @returns {Boolean}
     */

  }, {
    key: "is",
    value: function is(type) {
      return type === 'position' || type === 'model:position';
    }
    /**
     * Checks if two positions are in the same parent.
     *
     * This method is safe to use it on non-existing positions (for example during operational transformation).
     *
     * @param {module:engine/model/position~Position} position Position to compare with.
     * @returns {Boolean} `true` if positions have the same parent, `false` otherwise.
     */

  }, {
    key: "hasSameParentAs",
    value: function hasSameParentAs(position) {
      if (this.root !== position.root) {
        return false;
      }

      var thisParentPath = this.getParentPath();
      var posParentPath = position.getParentPath();
      return compareArrays(thisParentPath, posParentPath) == 'same';
    }
    /**
     * Returns a copy of this position that is transformed by given `operation`.
     *
     * The new position's parameters are updated accordingly to the effect of the `operation`.
     *
     * For example, if `n` nodes are inserted before the position, the returned position {@link ~Position#offset} will be
     * increased by `n`. If the position was in a merged element, it will be accordingly moved to the new element, etc.
     *
     * This method is safe to use it on non-existing positions (for example during operational transformation).
     *
     * @param {module:engine/model/operation/operation~Operation} operation Operation to transform by.
     * @returns {module:engine/model/position~Position} Transformed position.
     */

  }, {
    key: "getTransformedByOperation",
    value: function getTransformedByOperation(operation) {
      var result;

      switch (operation.type) {
        case 'insert':
          result = this._getTransformedByInsertOperation(operation);
          break;

        case 'move':
        case 'remove':
        case 'reinsert':
          result = this._getTransformedByMoveOperation(operation);
          break;

        case 'split':
          result = this._getTransformedBySplitOperation(operation);
          break;

        case 'merge':
          result = this._getTransformedByMergeOperation(operation);
          break;

        default:
          result = Position._createAt(this);
          break;
      }

      return result;
    }
    /**
     * Returns a copy of this position transformed by an insert operation.
     *
     * @protected
     * @param {module:engine/model/operation/insertoperation~InsertOperation} operation
     * @returns {module:engine/model/position~Position}
     */

  }, {
    key: "_getTransformedByInsertOperation",
    value: function _getTransformedByInsertOperation(operation) {
      return this._getTransformedByInsertion(operation.position, operation.howMany);
    }
    /**
     * Returns a copy of this position transformed by a move operation.
     *
     * @protected
     * @param {module:engine/model/operation/moveoperation~MoveOperation} operation
     * @returns {module:engine/model/position~Position}
     */

  }, {
    key: "_getTransformedByMoveOperation",
    value: function _getTransformedByMoveOperation(operation) {
      return this._getTransformedByMove(operation.sourcePosition, operation.targetPosition, operation.howMany);
    }
    /**
     * Returns a copy of this position transformed by a split operation.
     *
     * @protected
     * @param {module:engine/model/operation/splitoperation~SplitOperation} operation
     * @returns {module:engine/model/position~Position}
     */

  }, {
    key: "_getTransformedBySplitOperation",
    value: function _getTransformedBySplitOperation(operation) {
      var movedRange = operation.movedRange;
      var isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this) && this.stickiness == 'toNext';

      if (isContained) {
        return this._getCombined(operation.splitPosition, operation.moveTargetPosition);
      } else {
        if (operation.graveyardPosition) {
          return this._getTransformedByMove(operation.graveyardPosition, operation.insertionPosition, 1);
        } else {
          return this._getTransformedByInsertion(operation.insertionPosition, 1);
        }
      }
    }
    /**
     * Returns a copy of this position transformed by merge operation.
     *
     * @protected
     * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation
     * @returns {module:engine/model/position~Position}
     */

  }, {
    key: "_getTransformedByMergeOperation",
    value: function _getTransformedByMergeOperation(operation) {
      var movedRange = operation.movedRange;
      var isContained = movedRange.containsPosition(this) || movedRange.start.isEqual(this);
      var pos;

      if (isContained) {
        pos = this._getCombined(operation.sourcePosition, operation.targetPosition);

        if (operation.sourcePosition.isBefore(operation.targetPosition)) {
          // Above happens during OT when the merged element is moved before the merged-to element.
          pos = pos._getTransformedByDeletion(operation.deletionPosition, 1);
        }
      } else if (this.isEqual(operation.deletionPosition)) {
        pos = Position._createAt(operation.deletionPosition);
      } else {
        pos = this._getTransformedByMove(operation.deletionPosition, operation.graveyardPosition, 1);
      }

      return pos;
    }
    /**
     * Returns a copy of this position that is updated by removing `howMany` nodes starting from `deletePosition`.
     * It may happen that this position is in a removed node. If that is the case, `null` is returned instead.
     *
     * @protected
     * @param {module:engine/model/position~Position} deletePosition Position before the first removed node.
     * @param {Number} howMany How many nodes are removed.
     * @returns {module:engine/model/position~Position|null} Transformed position or `null`.
     */

  }, {
    key: "_getTransformedByDeletion",
    value: function _getTransformedByDeletion(deletePosition, howMany) {
      var transformed = Position._createAt(this); // This position can't be affected if deletion was in a different root.


      if (this.root != deletePosition.root) {
        return transformed;
      }

      if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == 'same') {
        // If nodes are removed from the node that is pointed by this position...
        if (deletePosition.offset < this.offset) {
          // And are removed from before an offset of that position...
          if (deletePosition.offset + howMany > this.offset) {
            // Position is in removed range, it's no longer in the tree.
            return null;
          } else {
            // Decrement the offset accordingly.
            transformed.offset -= howMany;
          }
        }
      } else if (compareArrays(deletePosition.getParentPath(), this.getParentPath()) == 'prefix') {
        // If nodes are removed from a node that is on a path to this position...
        var i = deletePosition.path.length - 1;

        if (deletePosition.offset <= this.path[i]) {
          // And are removed from before next node of that path...
          if (deletePosition.offset + howMany > this.path[i]) {
            // If the next node of that path is removed return null
            // because the node containing this position got removed.
            return null;
          } else {
            // Otherwise, decrement index on that path.
            transformed.path[i] -= howMany;
          }
        }
      }

      return transformed;
    }
    /**
     * Returns a copy of this position that is updated by inserting `howMany` nodes at `insertPosition`.
     *
     * @protected
     * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.
     * @param {Number} howMany How many nodes are inserted.
     * @returns {module:engine/model/position~Position} Transformed position.
     */

  }, {
    key: "_getTransformedByInsertion",
    value: function _getTransformedByInsertion(insertPosition, howMany) {
      var transformed = Position._createAt(this); // This position can't be affected if insertion was in a different root.


      if (this.root != insertPosition.root) {
        return transformed;
      }

      if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == 'same') {
        // If nodes are inserted in the node that is pointed by this position...
        if (insertPosition.offset < this.offset || insertPosition.offset == this.offset && this.stickiness != 'toPrevious') {
          // And are inserted before an offset of that position...
          // "Push" this positions offset.
          transformed.offset += howMany;
        }
      } else if (compareArrays(insertPosition.getParentPath(), this.getParentPath()) == 'prefix') {
        // If nodes are inserted in a node that is on a path to this position...
        var i = insertPosition.path.length - 1;

        if (insertPosition.offset <= this.path[i]) {
          // And are inserted before next node of that path...
          // "Push" the index on that path.
          transformed.path[i] += howMany;
        }
      }

      return transformed;
    }
    /**
     * Returns a copy of this position that is updated by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
     *
     * @protected
     * @param {module:engine/model/position~Position} sourcePosition Position before the first element to move.
     * @param {module:engine/model/position~Position} targetPosition Position where moved elements will be inserted.
     * @param {Number} howMany How many consecutive nodes to move, starting from `sourcePosition`.
     * @returns {module:engine/model/position~Position} Transformed position.
     */

  }, {
    key: "_getTransformedByMove",
    value: function _getTransformedByMove(sourcePosition, targetPosition, howMany) {
      // Update target position, as it could be affected by nodes removal.
      targetPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);

      if (sourcePosition.isEqual(targetPosition)) {
        // If `targetPosition` is equal to `sourcePosition` this isn't really any move. Just return position as it is.
        return Position._createAt(this);
      } // Moving a range removes nodes from their original position. We acknowledge this by proper transformation.


      var transformed = this._getTransformedByDeletion(sourcePosition, howMany);

      var isMoved = transformed === null || sourcePosition.isEqual(this) && this.stickiness == 'toNext' || sourcePosition.getShiftedBy(howMany).isEqual(this) && this.stickiness == 'toPrevious';

      if (isMoved) {
        // This position is inside moved range (or sticks to it).
        // In this case, we calculate a combination of this position, move source position and target position.
        return this._getCombined(sourcePosition, targetPosition);
      } else {
        // This position is not inside a removed range.
        //
        // In next step, we simply reflect inserting `howMany` nodes, which might further affect the position.
        return transformed._getTransformedByInsertion(targetPosition, howMany);
      }
    }
    /**
     * Returns a new position that is a combination of this position and given positions.
     *
     * The combined position is a copy of this position transformed by moving a range starting at `source` position
     * to the `target` position. It is expected that this position is inside the moved range.
     *
     * Example:
     *
     *		let original = model.createPositionFromPath( root, [ 2, 3, 1 ] );
     *		let source = model.createPositionFromPath( root, [ 2, 2 ] );
     *		let target = model.createPositionFromPath( otherRoot, [ 1, 1, 3 ] );
     *		original._getCombined( source, target ); // path is [ 1, 1, 4, 1 ], root is `otherRoot`
     *
     * Explanation:
     *
     * We have a position `[ 2, 3, 1 ]` and move some nodes from `[ 2, 2 ]` to `[ 1, 1, 3 ]`. The original position
     * was inside moved nodes and now should point to the new place. The moved nodes will be after
     * positions `[ 1, 1, 3 ]`, `[ 1, 1, 4 ]`, `[ 1, 1, 5 ]`. Since our position was in the second moved node,
     * the transformed position will be in a sub-tree of a node at `[ 1, 1, 4 ]`. Looking at original path, we
     * took care of `[ 2, 3 ]` part of it. Now we have to add the rest of the original path to the transformed path.
     * Finally, the transformed position will point to `[ 1, 1, 4, 1 ]`.
     *
     * @protected
     * @param {module:engine/model/position~Position} source Beginning of the moved range.
     * @param {module:engine/model/position~Position} target Position where the range is moved.
     * @returns {module:engine/model/position~Position} Combined position.
     */

  }, {
    key: "_getCombined",
    value: function _getCombined(source, target) {
      var i = source.path.length - 1; // The first part of a path to combined position is a path to the place where nodes were moved.

      var combined = Position._createAt(target);

      combined.stickiness = this.stickiness; // Then we have to update the rest of the path.
      // Fix the offset because this position might be after `from` position and we have to reflect that.

      combined.offset = combined.offset + this.path[i] - source.offset; // Then, add the rest of the path.
      // If this position is at the same level as `from` position nothing will get added.

      combined.path = [].concat(_toConsumableArray(combined.path), _toConsumableArray(this.path.slice(i + 1)));
      return combined;
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        root: this.root.toJSON(),
        path: Array.from(this.path),
        stickiness: this.stickiness
      };
    }
    /**
     * Returns a new position that is equal to current position.
     *
     * @returns {module:engine/model/position~Position}
     */

  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.root, this.path, this.stickiness);
    }
    /**
     * Creates position at the given location. The location can be specified as:
     *
     * * a {@link module:engine/model/position~Position position},
     * * parent element and offset (offset defaults to `0`),
     * * parent element and `'end'` (sets position at the end of that element),
     * * {@link module:engine/model/item~Item model item} and `'before'` or `'after'` (sets position before or after given model item).
     *
     * This method is a shortcut to other factory methods such as:
     *
     * * {@link module:engine/model/position~Position._createBefore},
     * * {@link module:engine/model/position~Position._createAfter}.
     *
     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition
     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when the
     * first parameter is a {@link module:engine/model/item~Item model item}.
     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness. Used only when the
     * first parameter is a {@link module:engine/model/item~Item model item}.
     * @protected
     */

  }, {
    key: "offset",
    get: function get() {
      return this.path[this.path.length - 1];
    }
    /**
     * @param {Number} newOffset
     */
    ,
    set: function set(newOffset) {
      this.path[this.path.length - 1] = newOffset;
    }
    /**
     * Parent element of this position.
     *
     * Keep in mind that `parent` value is calculated when the property is accessed.
     * If {@link module:engine/model/position~Position#path position path}
     * leads to a non-existing element, `parent` property will throw error.
     *
     * Also it is a good idea to cache `parent` property if it is used frequently in an algorithm (i.e. in a long loop).
     *
     * @readonly
     * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}
     */

  }, {
    key: "parent",
    get: function get() {
      var parent = this.root;

      for (var i = 0; i < this.path.length - 1; i++) {
        parent = parent.getChild(parent.offsetToIndex(this.path[i]));

        if (!parent) {
          throw new ckeditorerror["b" /* default */]('model-position-path-incorrect: The position\'s path is incorrect.', this, {
            position: this
          });
        }
      }

      if (parent.is('text')) {
        /**
         * The position's path is incorrect. This means that a position does not point to
         * a correct place in the tree and hence, some of its methods and getters cannot work correctly.
         *
         * **Note**: Unlike DOM and view positions, in the model, the
         * {@link module:engine/model/position~Position#parent position's parent} is always an element or a document fragment.
         * The last offset in the {@link module:engine/model/position~Position#path position's path} is the point in this element where
         * this position points.
         *
         * Read more about model positions and offsets in
         * the {@glink framework/guides/architecture/editing-engine#indexes-and-offsets Editing engine architecture guide}.
         *
         * @error position-incorrect-path
         * @param {module:engine/model/position~Position} position The incorrect position.
         */
        throw new ckeditorerror["b" /* default */]('model-position-path-incorrect: The position\'s path is incorrect.', this, {
          position: this
        });
      }

      return parent;
    }
    /**
     * Position {@link module:engine/model/position~Position#offset offset} converted to an index in position's parent node. It is
     * equal to the {@link module:engine/model/node~Node#index index} of a node after this position. If position is placed
     * in text node, position index is equal to the index of that text node.
     *
     * @readonly
     * @type {Number}
     */

  }, {
    key: "index",
    get: function get() {
      return this.parent.offsetToIndex(this.offset);
    }
    /**
     * Returns {@link module:engine/model/text~Text text node} instance in which this position is placed or `null` if this
     * position is not in a text node.
     *
     * @readonly
     * @type {module:engine/model/text~Text|null}
     */

  }, {
    key: "textNode",
    get: function get() {
      return getTextNodeAtPosition(this, this.parent);
    }
    /**
     * Node directly after this position or `null` if this position is in text node.
     *
     * @readonly
     * @type {module:engine/model/node~Node|null}
     */

  }, {
    key: "nodeAfter",
    get: function get() {
      // Cache the parent and reuse for performance reasons. See #6579 and #6582.
      var parent = this.parent;
      return getNodeAfterPosition(this, parent, getTextNodeAtPosition(this, parent));
    }
    /**
     * Node directly before this position or `null` if this position is in text node.
     *
     * @readonly
     * @type {module:engine/model/node~Node|null}
     */

  }, {
    key: "nodeBefore",
    get: function get() {
      // Cache the parent and reuse for performance reasons. See #6579 and #6582.
      var parent = this.parent;
      return getNodeBeforePosition(this, parent, getTextNodeAtPosition(this, parent));
    }
    /**
     * Is `true` if position is at the beginning of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.
     *
     * @readonly
     * @type {Boolean}
     */

  }, {
    key: "isAtStart",
    get: function get() {
      return this.offset === 0;
    }
    /**
     * Is `true` if position is at the end of its {@link module:engine/model/position~Position#parent parent}, `false` otherwise.
     *
     * @readonly
     * @type {Boolean}
     */

  }, {
    key: "isAtEnd",
    get: function get() {
      return this.offset == this.parent.maxOffset;
    }
  }], [{
    key: "_createAt",
    value: function _createAt(itemOrPosition, offset) {
      var stickiness = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'toNone';

      if (itemOrPosition instanceof Position) {
        return new Position(itemOrPosition.root, itemOrPosition.path, itemOrPosition.stickiness);
      } else {
        var node = itemOrPosition;

        if (offset == 'end') {
          offset = node.maxOffset;
        } else if (offset == 'before') {
          return this._createBefore(node, stickiness);
        } else if (offset == 'after') {
          return this._createAfter(node, stickiness);
        } else if (offset !== 0 && !offset) {
          /**
           * {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}
           * requires the offset to be specified when the first parameter is a model item.
           *
           * @error model-createPositionAt-offset-required
           */
          throw new ckeditorerror["b" /* default */]('model-createPositionAt-offset-required: ' + 'Model#createPositionAt() requires the offset when the first parameter is a model item.', [this, itemOrPosition]);
        }

        if (!node.is('element') && !node.is('documentFragment')) {
          /**
           * Position parent have to be a model element or model document fragment.
           *
           * @error model-position-parent-incorrect
           */
          throw new ckeditorerror["b" /* default */]('model-position-parent-incorrect: Position parent have to be a element or document fragment.', [this, itemOrPosition]);
        }

        var path = node.getPath();
        path.push(offset);
        return new this(node.root, path, stickiness);
      }
    }
    /**
     * Creates a new position, after given {@link module:engine/model/item~Item model item}.
     *
     * @param {module:engine/model/item~Item} item Item after which the position should be placed.
     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.
     * @returns {module:engine/model/position~Position}
     * @protected
     */

  }, {
    key: "_createAfter",
    value: function _createAfter(item, stickiness) {
      if (!item.parent) {
        /**
         * You can not make a position after a root element.
         *
         * @error model-position-after-root
         * @param {module:engine/model/item~Item} root
         */
        throw new ckeditorerror["b" /* default */]('model-position-after-root: You cannot make a position after root.', [this, item], {
          root: item
        });
      }

      return this._createAt(item.parent, item.endOffset, stickiness);
    }
    /**
     * Creates a new position, before the given {@link module:engine/model/item~Item model item}.
     *
     * @param {module:engine/model/item~Item} item Item before which the position should be placed.
     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.
     * @returns {module:engine/model/position~Position}
     * @protected
     */

  }, {
    key: "_createBefore",
    value: function _createBefore(item, stickiness) {
      if (!item.parent) {
        /**
         * You can not make a position before a root element.
         *
         * @error model-position-before-root
         * @param {module:engine/model/item~Item} root
         */
        throw new ckeditorerror["b" /* default */]('model-position-before-root: You cannot make a position before root.', item, {
          root: item
        });
      }

      return this._createAt(item.parent, item.startOffset, stickiness);
    }
    /**
     * Creates a `Position` instance from given plain object (i.e. parsed JSON string).
     *
     * @param {Object} json Plain object to be converted to `Position`.
     * @param {module:engine/model/document~Document} doc Document object that will be position owner.
     * @returns {module:engine/model/position~Position} `Position` instance created using given plain object.
     */

  }, {
    key: "fromJSON",
    value: function fromJSON(json, doc) {
      if (json.root === '$graveyard') {
        var pos = new Position(doc.graveyard, json.path);
        pos.stickiness = json.stickiness;
        return pos;
      }

      if (!doc.getRoot(json.root)) {
        /**
         * Cannot create position for document. Root with specified name does not exist.
         *
         * @error model-position-fromjson-no-root
         * @param {String} rootName
         */
        throw new ckeditorerror["b" /* default */]('model-position-fromjson-no-root: Cannot create position for document. Root with specified name does not exist.', doc, {
          rootName: json.root
        });
      }

      return new Position(doc.getRoot(json.root), json.path, json.stickiness);
    } // @if CK_DEBUG_ENGINE // toString() {
    // @if CK_DEBUG_ENGINE // 	return `${ this.root } [ ${ this.path.join( ', ' ) } ]`;
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // log() {
    // @if CK_DEBUG_ENGINE // 	console.log( 'ModelPosition: ' + this );
    // @if CK_DEBUG_ENGINE // }

  }]);

  return Position;
}();
/**
 * A flag indicating whether this position is `'before'` or `'after'` or `'same'` as given position.
 * If positions are in different roots `'different'` flag is returned.
 *
 * @typedef {String} module:engine/model/position~PositionRelation
 */

/**
 * Represents how position is "sticking" with neighbour nodes. Used to define how position should be transformed (moved)
 * in edge cases. Possible values: `'toNone'`, `'toNext'`, `'toPrevious'`.
 *
 * Examples:
 *
 *		Insert. Position is at | and nodes are inserted at the same position, marked as ^:
 *
 *		- sticks to none:           <p>f^|oo</p>  ->  <p>fbar|oo</p>
 *		- sticks to next node:      <p>f^|oo</p>  ->  <p>fbar|oo</p>
 *		- sticks to previous node:  <p>f|^oo</p>  ->  <p>f|baroo</p>
 *
 *
 *		Move. Position is at | and range [oo] is moved to position ^:
 *
 *		- sticks to none:           <p>f|[oo]</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>
 *		- sticks to none:           <p>f[oo]|</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>
 *
 *		- sticks to next node:      <p>f|[oo]</p><p>b^ar</p>  ->  <p>f</p><p>b|ooar</p>
 *		- sticks to next node:      <p>f[oo]|</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>
 *
 *		- sticks to previous node:  <p>f|[oo]</p><p>b^ar</p>  ->  <p>f|</p><p>booar</p>
 *		- sticks to previous node:  <p>f[oo]|</p><p>b^ar</p>  ->  <p>f</p><p>boo|ar</p>
 *
 * @typedef {String} module:engine/model/position~PositionStickiness
 */

/**
 * Returns a text node at the given position.
 *
 * This is a helper function optimized to reuse the position parent instance for performance reasons.
 *
 * Normally, you should use {@link module:engine/model/position~Position#textNode `Position#textNode`}.
 * If you start hitting performance issues with {@link module:engine/model/position~Position#parent `Position#parent`}
 * check if your algorithm does not access it multiple times (which can happen directly or indirectly via other position properties).
 *
 * See https://github.com/ckeditor/ckeditor5/issues/6579.
 *
 * See also:
 *
 * * {@link module:engine/model/position~getNodeAfterPosition}
 * * {@link module:engine/model/position~getNodeBeforePosition}
 *
 * @param {module:engine/model/position~Position} position
 * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the
 * given position.
 * @returns {module:engine/model/text~Text|null}
 */



function getTextNodeAtPosition(position, positionParent) {
  var node = positionParent.getChild(positionParent.offsetToIndex(position.offset));

  if (node && node.is('text') && node.startOffset < position.offset) {
    return node;
  }

  return null;
}
/**
 * Returns the node after the given position.
 *
 * This is a helper function optimized to reuse the position parent instance and the calculation of the text node at the
 * specific position for performance reasons.
 *
 * Normally, you should use {@link module:engine/model/position~Position#nodeAfter `Position#nodeAfter`}.
 * If you start hitting performance issues with {@link module:engine/model/position~Position#parent `Position#parent`} and/or
 * {@link module:engine/model/position~Position#textNode `Position#textNode`}
 * check if your algorithm does not access those properties multiple times
 * (which can happen directly or indirectly via other position properties).
 *
 * See https://github.com/ckeditor/ckeditor5/issues/6579 and https://github.com/ckeditor/ckeditor5/issues/6582.
 *
 * See also:
 *
 * * {@link module:engine/model/position~getTextNodeAtPosition}
 * * {@link module:engine/model/position~getNodeBeforePosition}
 *
 * @param {module:engine/model/position~Position} position
 * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the
 * given position.
 * @param {module:engine/model/text~Text|null} textNode Text node at the given position.
 * @returns {module:engine/model/node~Node|null}
 */

function getNodeAfterPosition(position, positionParent, textNode) {
  if (textNode !== null) {
    return null;
  }

  return positionParent.getChild(positionParent.offsetToIndex(position.offset));
}
/**
 * Returns the node before the given position.
 *
 * Refer to {@link module:engine/model/position~getNodeBeforePosition} for documentation on when to use this util method.
 *
 * See also:
 *
 * * {@link module:engine/model/position~getTextNodeAtPosition}
 * * {@link module:engine/model/position~getNodeAfterPosition}
 *
 * @param {module:engine/model/position~Position} position
 * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} positionParent The parent of the
 * given position.
 * @param {module:engine/model/text~Text|null} textNode Text node at the given position.
 * @returns {module:engine/model/node~Node|null}
 */

function getNodeBeforePosition(position, positionParent, textNode) {
  if (textNode !== null) {
    return null;
  }

  return positionParent.getChild(positionParent.offsetToIndex(position.offset) - 1);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/range.js


















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/range
 */




/**
 * Represents a range in the model tree.
 *
 * A range is defined by its {@link module:engine/model/range~Range#start} and {@link module:engine/model/range~Range#end}
 * positions.
 *
 * You can create range instances via its constructor or the `createRange*()` factory methods of
 * {@link module:engine/model/model~Model} and {@link module:engine/model/writer~Writer}.
 */

var model_range_Range = /*#__PURE__*/function () {
  /**
   * Creates a range spanning from `start` position to `end` position.
   *
   * @param {module:engine/model/position~Position} start Start position.
   * @param {module:engine/model/position~Position} [end] End position. If not set, range will be collapsed at `start` position.
   */
  function Range(start) {
    var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    Object(classCallCheck["a" /* default */])(this, Range);

    /**
     * Start position.
     *
     * @readonly
     * @member {module:engine/model/position~Position}
     */
    this.start = model_position_Position._createAt(start);
    /**
     * End position.
     *
     * @readonly
     * @member {module:engine/model/position~Position}
     */

    this.end = end ? model_position_Position._createAt(end) : model_position_Position._createAt(start); // If the range is collapsed, treat in a similar way as a position and set its boundaries stickiness to 'toNone'.
    // In other case, make the boundaries stick to the "inside" of the range.

    this.start.stickiness = this.isCollapsed ? 'toNone' : 'toNext';
    this.end.stickiness = this.isCollapsed ? 'toNone' : 'toPrevious';
  }
  /**
   * Iterable interface.
   *
   * Iterates over all {@link module:engine/model/item~Item items} that are in this range and returns
   * them together with additional information like length or {@link module:engine/model/position~Position positions},
   * grouped as {@link module:engine/model/treewalker~TreeWalkerValue}.
   * It iterates over all {@link module:engine/model/textproxy~TextProxy text contents} that are inside the range
   * and all the {@link module:engine/model/element~Element}s that are entered into when iterating over this range.
   *
   * This iterator uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range
   * and `ignoreElementEnd` option set to `true`.
   *
   * @returns {Iterable.<module:engine/model/treewalker~TreeWalkerValue>}
   */


  Object(createClass["a" /* default */])(Range, [{
    key: Symbol.iterator,
    value: /*#__PURE__*/regeneratorRuntime.mark(function value() {
      return regeneratorRuntime.wrap(function value$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.delegateYield(new model_treewalker_TreeWalker({
                boundaries: this,
                ignoreElementEnd: true
              }), "t0", 1);

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, value, this);
    })
    /**
     * Returns whether the range is collapsed, that is if {@link #start} and
     * {@link #end} positions are equal.
     *
     * @type {Boolean}
     */

  }, {
    key: "containsPosition",

    /**
     * Checks whether this range contains given {@link module:engine/model/position~Position position}.
     *
     * @param {module:engine/model/position~Position} position Position to check.
     * @returns {Boolean} `true` if given {@link module:engine/model/position~Position position} is contained
     * in this range,`false` otherwise.
     */
    value: function containsPosition(position) {
      return position.isAfter(this.start) && position.isBefore(this.end);
    }
    /**
     * Checks whether this range contains given {@link ~Range range}.
     *
     * @param {module:engine/model/range~Range} otherRange Range to check.
     * @param {Boolean} [loose=false] Whether the check is loose or strict. If the check is strict (`false`), compared range cannot
     * start or end at the same position as this range boundaries. If the check is loose (`true`), compared range can start, end or
     * even be equal to this range. Note that collapsed ranges are always compared in strict mode.
     * @returns {Boolean} `true` if given {@link ~Range range} boundaries are contained by this range, `false` otherwise.
     */

  }, {
    key: "containsRange",
    value: function containsRange(otherRange) {
      var loose = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (otherRange.isCollapsed) {
        loose = false;
      }

      var containsStart = this.containsPosition(otherRange.start) || loose && this.start.isEqual(otherRange.start);
      var containsEnd = this.containsPosition(otherRange.end) || loose && this.end.isEqual(otherRange.end);
      return containsStart && containsEnd;
    }
    /**
     * Checks whether given {@link module:engine/model/item~Item} is inside this range.
     *
     * @param {module:engine/model/item~Item} item Model item to check.
     */

  }, {
    key: "containsItem",
    value: function containsItem(item) {
      var pos = model_position_Position._createBefore(item);

      return this.containsPosition(pos) || this.start.isEqual(pos);
    }
    /**
     * Checks whether this object is of the given.
     *
     *		range.is( 'range' ); // -> true
     *		range.is( 'model:range' ); // -> true
     *
     *		range.is( 'view:range' ); // -> false
     *		range.is( 'documentSelection' ); // -> false
     *
     * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.
     *
     * @param {String} type
     * @returns {Boolean}
     */

  }, {
    key: "is",
    value: function is(type) {
      return type === 'range' || type === 'model:range';
    }
    /**
     * Two ranges are equal if their {@link #start} and {@link #end} positions are equal.
     *
     * @param {module:engine/model/range~Range} otherRange Range to compare with.
     * @returns {Boolean} `true` if ranges are equal, `false` otherwise.
     */

  }, {
    key: "isEqual",
    value: function isEqual(otherRange) {
      return this.start.isEqual(otherRange.start) && this.end.isEqual(otherRange.end);
    }
    /**
     * Checks and returns whether this range intersects with given range.
     *
     * @param {module:engine/model/range~Range} otherRange Range to compare with.
     * @returns {Boolean} `true` if ranges intersect, `false` otherwise.
     */

  }, {
    key: "isIntersecting",
    value: function isIntersecting(otherRange) {
      return this.start.isBefore(otherRange.end) && this.end.isAfter(otherRange.start);
    }
    /**
     * Computes which part(s) of this {@link ~Range range} is not a part of given {@link ~Range range}.
     * Returned array contains zero, one or two {@link ~Range ranges}.
     *
     * Examples:
     *
     *		let range = model.createRange(
     *			model.createPositionFromPath( root, [ 2, 7 ] ),
     *			model.createPositionFromPath( root, [ 4, 0, 1 ] )
     *		);
     *		let otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 5 ] ) );
     *		let transformed = range.getDifference( otherRange );
     *		// transformed array has no ranges because `otherRange` contains `range`
     *
     *		otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 3 ] ) );
     *		transformed = range.getDifference( otherRange );
     *		// transformed array has one range: from [ 3 ] to [ 4, 0, 1 ]
     *
     *		otherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 4 ] ) );
     *		transformed = range.getDifference( otherRange );
     *		// transformed array has two ranges: from [ 2, 7 ] to [ 3 ] and from [ 4 ] to [ 4, 0, 1 ]
     *
     * @param {module:engine/model/range~Range} otherRange Range to differentiate against.
     * @returns {Array.<module:engine/model/range~Range>} The difference between ranges.
     */

  }, {
    key: "getDifference",
    value: function getDifference(otherRange) {
      var ranges = [];

      if (this.isIntersecting(otherRange)) {
        // Ranges intersect.
        if (this.containsPosition(otherRange.start)) {
          // Given range start is inside this range. This means that we have to
          // add shrunken range - from the start to the middle of this range.
          ranges.push(new Range(this.start, otherRange.start));
        }

        if (this.containsPosition(otherRange.end)) {
          // Given range end is inside this range. This means that we have to
          // add shrunken range - from the middle of this range to the end.
          ranges.push(new Range(otherRange.end, this.end));
        }
      } else {
        // Ranges do not intersect, return the original range.
        ranges.push(new Range(this.start, this.end));
      }

      return ranges;
    }
    /**
     * Returns an intersection of this {@link ~Range range} and given {@link ~Range range}.
     * Intersection is a common part of both of those ranges. If ranges has no common part, returns `null`.
     *
     * Examples:
     *
     *		let range = model.createRange(
     *			model.createPositionFromPath( root, [ 2, 7 ] ),
     *			model.createPositionFromPath( root, [ 4, 0, 1 ] )
     *		);
     *		let otherRange = model.createRange( model.createPositionFromPath( root, [ 1 ] ), model.createPositionFromPath( root, [ 2 ] ) );
     *		let transformed = range.getIntersection( otherRange ); // null - ranges have no common part
     *
     *		otherRange = model.createRange( model.createPositionFromPath( root, [ 3 ] ), model.createPositionFromPath( root, [ 5 ] ) );
     *		transformed = range.getIntersection( otherRange ); // range from [ 3 ] to [ 4, 0, 1 ]
     *
     * @param {module:engine/model/range~Range} otherRange Range to check for intersection.
     * @returns {module:engine/model/range~Range|null} A common part of given ranges or `null` if ranges have no common part.
     */

  }, {
    key: "getIntersection",
    value: function getIntersection(otherRange) {
      if (this.isIntersecting(otherRange)) {
        // Ranges intersect, so a common range will be returned.
        // At most, it will be same as this range.
        var commonRangeStart = this.start;
        var commonRangeEnd = this.end;

        if (this.containsPosition(otherRange.start)) {
          // Given range start is inside this range. This means thaNt we have to
          // shrink common range to the given range start.
          commonRangeStart = otherRange.start;
        }

        if (this.containsPosition(otherRange.end)) {
          // Given range end is inside this range. This means that we have to
          // shrink common range to the given range end.
          commonRangeEnd = otherRange.end;
        }

        return new Range(commonRangeStart, commonRangeEnd);
      } // Ranges do not intersect, so they do not have common part.


      return null;
    }
    /**
     * Computes and returns the smallest set of {@link #isFlat flat} ranges, that covers this range in whole.
     *
     * See an example of a model structure (`[` and `]` are range boundaries):
     *
     *		root                                                            root
     *		 |- element DIV                         DIV             P2              P3             DIV
     *		 |   |- element H                   H        P1        f o o           b a r       H         P4
     *		 |   |   |- "fir[st"             fir[st     lorem                               se]cond     ipsum
     *		 |   |- element P1
     *		 |   |   |- "lorem"                                              ||
     *		 |- element P2                                                   ||
     *		 |   |- "foo"                                                    VV
     *		 |- element P3
     *		 |   |- "bar"                                                   root
     *		 |- element DIV                         DIV             [P2             P3]             DIV
     *		 |   |- element H                   H       [P1]       f o o           b a r        H         P4
     *		 |   |   |- "se]cond"            fir[st]    lorem                               [se]cond     ipsum
     *		 |   |- element P4
     *		 |   |   |- "ipsum"
     *
     * As it can be seen, letters contained in the range are: `stloremfoobarse`, spread across different parents.
     * We are looking for minimal set of flat ranges that contains the same nodes.
     *
     * Minimal flat ranges for above range `( [ 0, 0, 3 ], [ 3, 0, 2 ] )` will be:
     *
     *		( [ 0, 0, 3 ], [ 0, 0, 5 ] ) = "st"
     *		( [ 0, 1 ], [ 0, 2 ] ) = element P1 ("lorem")
     *		( [ 1 ], [ 3 ] ) = element P2, element P3 ("foobar")
     *		( [ 3, 0, 0 ], [ 3, 0, 2 ] ) = "se"
     *
     * **Note:** if an {@link module:engine/model/element~Element element} is not wholly contained in this range, it won't be returned
     * in any of the returned flat ranges. See in the example how `H` elements at the beginning and at the end of the range
     * were omitted. Only their parts that were wholly in the range were returned.
     *
     * **Note:** this method is not returning flat ranges that contain no nodes.
     *
     * @returns {Array.<module:engine/model/range~Range>} Array of flat ranges covering this range.
     */

  }, {
    key: "getMinimalFlatRanges",
    value: function getMinimalFlatRanges() {
      var ranges = [];
      var diffAt = this.start.getCommonPath(this.end).length;

      var pos = model_position_Position._createAt(this.start);

      var posParent = pos.parent; // Go up.

      while (pos.path.length > diffAt + 1) {
        var howMany = posParent.maxOffset - pos.offset;

        if (howMany !== 0) {
          ranges.push(new Range(pos, pos.getShiftedBy(howMany)));
        }

        pos.path = pos.path.slice(0, -1);
        pos.offset++;
        posParent = posParent.parent;
      } // Go down.


      while (pos.path.length <= this.end.path.length) {
        var offset = this.end.path[pos.path.length - 1];

        var _howMany = offset - pos.offset;

        if (_howMany !== 0) {
          ranges.push(new Range(pos, pos.getShiftedBy(_howMany)));
        }

        pos.offset = offset;
        pos.path.push(0);
      }

      return ranges;
    }
    /**
     * Creates a {@link module:engine/model/treewalker~TreeWalker TreeWalker} instance with this range as a boundary.
     *
     * For example, to iterate over all items in the entire document root:
     *
     *		// Create a range spanning over the entire root content:
     *		const range = editor.model.createRangeIn( editor.model.document.getRoot() );
     *
     *		// Iterate over all items in this range:
     *		for ( const value of range.getWalker() ) {
     *			console.log( value.item );
     *		}
     *
     * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
     * @param {module:engine/model/position~Position} [options.startPosition]
     * @param {Boolean} [options.singleCharacters=false]
     * @param {Boolean} [options.shallow=false]
     * @param {Boolean} [options.ignoreElementEnd=false]
     */

  }, {
    key: "getWalker",
    value: function getWalker() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      options.boundaries = this;
      return new model_treewalker_TreeWalker(options);
    }
    /**
     * Returns an iterator that iterates over all {@link module:engine/model/item~Item items} that are in this range and returns
     * them.
     *
     * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range and `ignoreElementEnd` option
     * set to `true`. However it returns only {@link module:engine/model/item~Item model items},
     * not {@link module:engine/model/treewalker~TreeWalkerValue}.
     *
     * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for
     * a full list of available options.
     *
     * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
     * @returns {Iterable.<module:engine/model/item~Item>}
     */

  }, {
    key: "getItems",
    value: /*#__PURE__*/regeneratorRuntime.mark(function getItems() {
      var options,
          treeWalker,
          _iterator,
          _step,
          _value,
          _args2 = arguments;

      return regeneratorRuntime.wrap(function getItems$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              options = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};
              options.boundaries = this;
              options.ignoreElementEnd = true;
              treeWalker = new model_treewalker_TreeWalker(options);
              _iterator = _createForOfIteratorHelper(treeWalker);
              _context2.prev = 5;

              _iterator.s();

            case 7:
              if ((_step = _iterator.n()).done) {
                _context2.next = 13;
                break;
              }

              _value = _step.value;
              _context2.next = 11;
              return _value.item;

            case 11:
              _context2.next = 7;
              break;

            case 13:
              _context2.next = 18;
              break;

            case 15:
              _context2.prev = 15;
              _context2.t0 = _context2["catch"](5);

              _iterator.e(_context2.t0);

            case 18:
              _context2.prev = 18;

              _iterator.f();

              return _context2.finish(18);

            case 21:
            case "end":
              return _context2.stop();
          }
        }
      }, getItems, this, [[5, 15, 18, 21]]);
    })
    /**
     * Returns an iterator that iterates over all {@link module:engine/model/position~Position positions} that are boundaries or
     * contained in this range.
     *
     * This method uses {@link module:engine/model/treewalker~TreeWalker} with `boundaries` set to this range. However it returns only
     * {@link module:engine/model/position~Position positions}, not {@link module:engine/model/treewalker~TreeWalkerValue}.
     *
     * You may specify additional options for the tree walker. See {@link module:engine/model/treewalker~TreeWalker} for
     * a full list of available options.
     *
     * @param {Object} options Object with configuration options. See {@link module:engine/model/treewalker~TreeWalker}.
     * @returns {Iterable.<module:engine/model/position~Position>}
     */

  }, {
    key: "getPositions",
    value: /*#__PURE__*/regeneratorRuntime.mark(function getPositions() {
      var options,
          treeWalker,
          _iterator2,
          _step2,
          _value2,
          _args3 = arguments;

      return regeneratorRuntime.wrap(function getPositions$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              options = _args3.length > 0 && _args3[0] !== undefined ? _args3[0] : {};
              options.boundaries = this;
              treeWalker = new model_treewalker_TreeWalker(options);
              _context3.next = 5;
              return treeWalker.position;

            case 5:
              _iterator2 = _createForOfIteratorHelper(treeWalker);
              _context3.prev = 6;

              _iterator2.s();

            case 8:
              if ((_step2 = _iterator2.n()).done) {
                _context3.next = 14;
                break;
              }

              _value2 = _step2.value;
              _context3.next = 12;
              return _value2.nextPosition;

            case 12:
              _context3.next = 8;
              break;

            case 14:
              _context3.next = 19;
              break;

            case 16:
              _context3.prev = 16;
              _context3.t0 = _context3["catch"](6);

              _iterator2.e(_context3.t0);

            case 19:
              _context3.prev = 19;

              _iterator2.f();

              return _context3.finish(19);

            case 22:
            case "end":
              return _context3.stop();
          }
        }
      }, getPositions, this, [[6, 16, 19, 22]]);
    })
    /**
     * Returns a range that is a result of transforming this range by given `operation`.
     *
     * **Note:** transformation may break one range into multiple ranges (for example, when a part of the range is
     * moved to a different part of document tree). For this reason, an array is returned by this method and it
     * may contain one or more `Range` instances.
     *
     * @param {module:engine/model/operation/operation~Operation} operation Operation to transform range by.
     * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.
     */

  }, {
    key: "getTransformedByOperation",
    value: function getTransformedByOperation(operation) {
      switch (operation.type) {
        case 'insert':
          return this._getTransformedByInsertOperation(operation);

        case 'move':
        case 'remove':
        case 'reinsert':
          return this._getTransformedByMoveOperation(operation);

        case 'split':
          return [this._getTransformedBySplitOperation(operation)];

        case 'merge':
          return [this._getTransformedByMergeOperation(operation)];
      }

      return [new Range(this.start, this.end)];
    }
    /**
     * Returns a range that is a result of transforming this range by multiple `operations`.
     *
     * @see ~Range#getTransformedByOperation
     * @param {Iterable.<module:engine/model/operation/operation~Operation>} operations Operations to transform the range by.
     * @returns {Array.<module:engine/model/range~Range>} Range which is the result of transformation.
     */

  }, {
    key: "getTransformedByOperations",
    value: function getTransformedByOperations(operations) {
      var ranges = [new Range(this.start, this.end)];

      var _iterator3 = _createForOfIteratorHelper(operations),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var operation = _step3.value;

          for (var _i = 0; _i < ranges.length; _i++) {
            var result = ranges[_i].getTransformedByOperation(operation);

            ranges.splice.apply(ranges, [_i, 1].concat(_toConsumableArray(result)));
            _i += result.length - 1;
          }
        } // It may happen that a range is split into two, and then the part of second "piece" is moved into first
        // "piece". In this case we will have incorrect third range, which should not be included in the result --
        // because it is already included in the first "piece". In this loop we are looking for all such ranges that
        // are inside other ranges and we simply remove them.

      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      for (var i = 0; i < ranges.length; i++) {
        var range = ranges[i];

        for (var j = i + 1; j < ranges.length; j++) {
          var next = ranges[j];

          if (range.containsRange(next) || next.containsRange(range) || range.isEqual(next)) {
            ranges.splice(j, 1);
          }
        }
      }

      return ranges;
    }
    /**
     * Returns an {@link module:engine/model/element~Element} or {@link module:engine/model/documentfragment~DocumentFragment}
     * which is a common ancestor of the range's both ends (in which the entire range is contained).
     *
     * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment|null}
     */

  }, {
    key: "getCommonAncestor",
    value: function getCommonAncestor() {
      return this.start.getCommonAncestor(this.end);
    }
    /**
     * Returns an {@link module:engine/model/element~Element Element} contained by the range.
     * The element will be returned when it is the **only** node within the range and **fully–contained**
     * at the same time.
     *
     * @returns {module:engine/model/element~Element|null}
     */

  }, {
    key: "getContainedElement",
    value: function getContainedElement() {
      if (this.isCollapsed) {
        return null;
      }

      var nodeAfterStart = this.start.nodeAfter;
      var nodeBeforeEnd = this.end.nodeBefore;

      if (nodeAfterStart && nodeAfterStart.is('element') && nodeAfterStart === nodeBeforeEnd) {
        return nodeAfterStart;
      }

      return null;
    }
    /**
     * Converts `Range` to plain object and returns it.
     *
     * @returns {Object} `Node` converted to plain object.
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      return {
        start: this.start.toJSON(),
        end: this.end.toJSON()
      };
    }
    /**
     * Returns a new range that is equal to current range.
     *
     * @returns {module:engine/model/range~Range}
     */

  }, {
    key: "clone",
    value: function clone() {
      return new this.constructor(this.start, this.end);
    }
    /**
     * Returns a result of transforming a copy of this range by insert operation.
     *
     * One or more ranges may be returned as a result of this transformation.
     *
     * @protected
     * @param {module:engine/model/operation/insertoperation~InsertOperation} operation
     * @returns {Array.<module:engine/model/range~Range>}
     */

  }, {
    key: "_getTransformedByInsertOperation",
    value: function _getTransformedByInsertOperation(operation) {
      var spread = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return this._getTransformedByInsertion(operation.position, operation.howMany, spread);
    }
    /**
     * Returns a result of transforming a copy of this range by move operation.
     *
     * One or more ranges may be returned as a result of this transformation.
     *
     * @protected
     * @param {module:engine/model/operation/moveoperation~MoveOperation} operation
     * @returns {Array.<module:engine/model/range~Range>}
     */

  }, {
    key: "_getTransformedByMoveOperation",
    value: function _getTransformedByMoveOperation(operation) {
      var spread = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var sourcePosition = operation.sourcePosition;
      var howMany = operation.howMany;
      var targetPosition = operation.targetPosition;
      return this._getTransformedByMove(sourcePosition, targetPosition, howMany, spread);
    }
    /**
     * Returns a result of transforming a copy of this range by split operation.
     *
     * Always one range is returned. The transformation is done in a way to not break the range.
     *
     * @protected
     * @param {module:engine/model/operation/splitoperation~SplitOperation} operation
     * @returns {module:engine/model/range~Range}
     */

  }, {
    key: "_getTransformedBySplitOperation",
    value: function _getTransformedBySplitOperation(operation) {
      var start = this.start._getTransformedBySplitOperation(operation);

      var end = this.end._getTransformedBySplitOperation(operation);

      if (this.end.isEqual(operation.insertionPosition)) {
        end = this.end.getShiftedBy(1);
      } // Below may happen when range contains graveyard element used by split operation.


      if (start.root != end.root) {
        // End position was next to the moved graveyard element and was moved with it.
        // Fix it by using old `end` which has proper `root`.
        end = this.end.getShiftedBy(-1);
      }

      return new Range(start, end);
    }
    /**
     * Returns a result of transforming a copy of this range by merge operation.
     *
     * Always one range is returned. The transformation is done in a way to not break the range.
     *
     * @protected
     * @param {module:engine/model/operation/mergeoperation~MergeOperation} operation
     * @returns {module:engine/model/range~Range}
     */

  }, {
    key: "_getTransformedByMergeOperation",
    value: function _getTransformedByMergeOperation(operation) {
      // Special case when the marker is set on "the closing tag" of an element. Marker can be set like that during
      // transformations, especially when a content of a few block elements were removed. For example:
      //
      // {} is the transformed range, [] is the removed range.
      // <p>F[o{o</p><p>B}ar</p><p>Xy]z</p>
      //
      // <p>Fo{o</p><p>B}ar</p><p>z</p>
      // <p>F{</p><p>B}ar</p><p>z</p>
      // <p>F{</p>}<p>z</p>
      // <p>F{}z</p>
      //
      if (this.start.isEqual(operation.targetPosition) && this.end.isEqual(operation.deletionPosition)) {
        return new Range(this.start);
      }

      var start = this.start._getTransformedByMergeOperation(operation);

      var end = this.end._getTransformedByMergeOperation(operation);

      if (start.root != end.root) {
        // This happens when the end position was next to the merged (deleted) element.
        // Then, the end position was moved to the graveyard root. In this case we need to fix
        // the range cause its boundaries would be in different roots.
        end = this.end.getShiftedBy(-1);
      }

      if (start.isAfter(end)) {
        // This happens in three following cases:
        //
        // Case 1: Merge operation source position is before the target position (due to some transformations, OT, etc.)
        //         This means that start can be moved before the end of the range.
        //
        // Before: <p>a{a</p><p>b}b</p><p>cc</p>
        // Merge:  <p>b}b</p><p>cca{a</p>
        // Fix:    <p>{b}b</p><p>ccaa</p>
        //
        // Case 2: Range start is before merged node but not directly.
        //         Result should include all nodes that were in the original range.
        //
        // Before: <p>aa</p>{<p>cc</p><p>b}b</p>
        // Merge:  <p>aab}b</p>{<p>cc</p>
        // Fix:    <p>aa{bb</p><p>cc</p>}
        //
        //         The range is expanded by an additional `b` letter but it is better than dropping the whole `cc` paragraph.
        //
        // Case 3: Range start is directly before merged node.
        //         Resulting range should include only nodes from the merged element:
        //
        // Before: <p>aa</p>{<p>b}b</p><p>cc</p>
        // Merge:  <p>aab}b</p>{<p>cc</p>
        // Fix:    <p>aa{b}b</p><p>cc</p>
        //
        if (operation.sourcePosition.isBefore(operation.targetPosition)) {
          // Case 1.
          start = model_position_Position._createAt(end);
          start.offset = 0;
        } else {
          if (!operation.deletionPosition.isEqual(start)) {
            // Case 2.
            end = operation.deletionPosition;
          } // In both case 2 and 3 start is at the end of the merge-to element.


          start = operation.targetPosition;
        }

        return new Range(start, end);
      }

      return new Range(start, end);
    }
    /**
     * Returns an array containing one or two {@link ~Range ranges} that are a result of transforming this
     * {@link ~Range range} by inserting `howMany` nodes at `insertPosition`. Two {@link ~Range ranges} are
     * returned if the insertion was inside this {@link ~Range range} and `spread` is set to `true`.
     *
     * Examples:
     *
     *		let range = model.createRange(
     *			model.createPositionFromPath( root, [ 2, 7 ] ),
     *			model.createPositionFromPath( root, [ 4, 0, 1 ] )
     *		);
     *		let transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 1 ] ), 2 );
     *		// transformed array has one range from [ 4, 7 ] to [ 6, 0, 1 ]
     *
     *		transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 4, 0, 0 ] ), 4 );
     *		// transformed array has one range from [ 2, 7 ] to [ 4, 0, 5 ]
     *
     *		transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4 );
     *		// transformed array has one range, which is equal to original range
     *
     *		transformed = range._getTransformedByInsertion( model.createPositionFromPath( root, [ 3, 2 ] ), 4, true );
     *		// transformed array has two ranges: from [ 2, 7 ] to [ 3, 2 ] and from [ 3, 6 ] to [ 4, 0, 1 ]
     *
     * @protected
     * @param {module:engine/model/position~Position} insertPosition Position where nodes are inserted.
     * @param {Number} howMany How many nodes are inserted.
     * @param {Boolean} [spread] Flag indicating whether this {~Range range} should be spread if insertion
     * was inside the range. Defaults to `false`.
     * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.
     */

  }, {
    key: "_getTransformedByInsertion",
    value: function _getTransformedByInsertion(insertPosition, howMany) {
      var spread = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

      if (spread && this.containsPosition(insertPosition)) {
        // Range has to be spread. The first part is from original start to the spread point.
        // The other part is from spread point to the original end, but transformed by
        // insertion to reflect insertion changes.
        return [new Range(this.start, insertPosition), new Range(insertPosition.getShiftedBy(howMany), this.end._getTransformedByInsertion(insertPosition, howMany))];
      } else {
        var range = new Range(this.start, this.end);
        range.start = range.start._getTransformedByInsertion(insertPosition, howMany);
        range.end = range.end._getTransformedByInsertion(insertPosition, howMany);
        return [range];
      }
    }
    /**
     * Returns an array containing {@link ~Range ranges} that are a result of transforming this
     * {@link ~Range range} by moving `howMany` nodes from `sourcePosition` to `targetPosition`.
     *
     * @protected
     * @param {module:engine/model/position~Position} sourcePosition Position from which nodes are moved.
     * @param {module:engine/model/position~Position} targetPosition Position to where nodes are moved.
     * @param {Number} howMany How many nodes are moved.
     * @param {Boolean} [spread=false] Whether the range should be spread if the move points inside the range.
     * @returns {Array.<module:engine/model/range~Range>} Result of the transformation.
     */

  }, {
    key: "_getTransformedByMove",
    value: function _getTransformedByMove(sourcePosition, targetPosition, howMany) {
      var spread = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

      // Special case for transforming a collapsed range. Just transform it like a position.
      if (this.isCollapsed) {
        var newPos = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);

        return [new Range(newPos)];
      } // Special case for transformation when a part of the range is moved towards the range.
      //
      // Examples:
      //
      // <div><p>ab</p><p>c[d</p></div><p>e]f</p> --> <div><p>ab</p></div><p>c[d</p><p>e]f</p>
      // <p>e[f</p><div><p>a]b</p><p>cd</p></div> --> <p>e[f</p><p>a]b</p><div><p>cd</p></div>
      //
      // Without this special condition, the default algorithm leaves an "artifact" range from one of `differenceSet` parts:
      //
      // <div><p>ab</p><p>c[d</p></div><p>e]f</p> --> <div><p>ab</p>{</div>}<p>c[d</p><p>e]f</p>
      //
      // This special case is applied only if the range is to be kept together (not spread).


      var moveRange = Range._createFromPositionAndShift(sourcePosition, howMany);

      var insertPosition = targetPosition._getTransformedByDeletion(sourcePosition, howMany);

      if (this.containsPosition(targetPosition) && !spread) {
        if (moveRange.containsPosition(this.start) || moveRange.containsPosition(this.end)) {
          var start = this.start._getTransformedByMove(sourcePosition, targetPosition, howMany);

          var end = this.end._getTransformedByMove(sourcePosition, targetPosition, howMany);

          return [new Range(start, end)];
        }
      } // Default algorithm.


      var result;
      var differenceSet = this.getDifference(moveRange);
      var difference = null;
      var common = this.getIntersection(moveRange);

      if (differenceSet.length == 1) {
        // `moveRange` and this range may intersect but may be separate.
        difference = new Range(differenceSet[0].start._getTransformedByDeletion(sourcePosition, howMany), differenceSet[0].end._getTransformedByDeletion(sourcePosition, howMany));
      } else if (differenceSet.length == 2) {
        // `moveRange` is inside this range.
        difference = new Range(this.start, this.end._getTransformedByDeletion(sourcePosition, howMany));
      } // else, `moveRange` contains this range.


      if (difference) {
        result = difference._getTransformedByInsertion(insertPosition, howMany, common !== null || spread);
      } else {
        result = [];
      }

      if (common) {
        var transformedCommon = new Range(common.start._getCombined(moveRange.start, insertPosition), common.end._getCombined(moveRange.start, insertPosition));

        if (result.length == 2) {
          result.splice(1, 0, transformedCommon);
        } else {
          result.push(transformedCommon);
        }
      }

      return result;
    }
    /**
     * Returns a copy of this range that is transformed by deletion of `howMany` nodes from `deletePosition`.
     *
     * If the deleted range is intersecting with the transformed range, the transformed range will be shrank.
     *
     * If the deleted range contains transformed range, `null` will be returned.
     *
     * @protected
     * @param {module:engine/model/position~Position} deletionPosition Position from which nodes are removed.
     * @param {Number} howMany How many nodes are removed.
     * @returns {module:engine/model/range~Range|null} Result of the transformation.
     */

  }, {
    key: "_getTransformedByDeletion",
    value: function _getTransformedByDeletion(deletePosition, howMany) {
      var newStart = this.start._getTransformedByDeletion(deletePosition, howMany);

      var newEnd = this.end._getTransformedByDeletion(deletePosition, howMany);

      if (newStart == null && newEnd == null) {
        return null;
      }

      if (newStart == null) {
        newStart = deletePosition;
      }

      if (newEnd == null) {
        newEnd = deletePosition;
      }

      return new Range(newStart, newEnd);
    }
    /**
     * Creates a new range, spreading from specified {@link module:engine/model/position~Position position} to a position moved by
     * given `shift`. If `shift` is a negative value, shifted position is treated as the beginning of the range.
     *
     * @protected
     * @param {module:engine/model/position~Position} position Beginning of the range.
     * @param {Number} shift How long the range should be.
     * @returns {module:engine/model/range~Range}
     */

  }, {
    key: "isCollapsed",
    get: function get() {
      return this.start.isEqual(this.end);
    }
    /**
     * Returns whether this range is flat, that is if {@link #start} position and
     * {@link #end} position are in the same {@link module:engine/model/position~Position#parent}.
     *
     * @type {Boolean}
     */

  }, {
    key: "isFlat",
    get: function get() {
      var startParentPath = this.start.getParentPath();
      var endParentPath = this.end.getParentPath();
      return compareArrays(startParentPath, endParentPath) == 'same';
    }
    /**
     * Range root element.
     *
     * @type {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}
     */

  }, {
    key: "root",
    get: function get() {
      return this.start.root;
    }
  }], [{
    key: "_createFromPositionAndShift",
    value: function _createFromPositionAndShift(position, shift) {
      var start = position;
      var end = position.getShiftedBy(shift);
      return shift > 0 ? new this(start, end) : new this(end, start);
    }
    /**
     * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of
     * that element and ends after the last child of that element.
     *
     * @protected
     * @param {module:engine/model/element~Element} element Element which is a parent for the range.
     * @returns {module:engine/model/range~Range}
     */

  }, {
    key: "_createIn",
    value: function _createIn(element) {
      return new this(model_position_Position._createAt(element, 0), model_position_Position._createAt(element, element.maxOffset));
    }
    /**
     * Creates a range that starts before given {@link module:engine/model/item~Item model item} and ends after it.
     *
     * @protected
     * @param {module:engine/model/item~Item} item
     * @returns {module:engine/model/range~Range}
     */

  }, {
    key: "_createOn",
    value: function _createOn(item) {
      return this._createFromPositionAndShift(model_position_Position._createBefore(item), item.offsetSize);
    }
    /**
     * Combines all ranges from the passed array into a one range. At least one range has to be passed.
     * Passed ranges must not have common parts.
     *
     * The first range from the array is a reference range. If other ranges start or end on the exactly same position where
     * the reference range, they get combined into one range.
     *
     *		[  ][]  [    ][ ][             ][ ][]  [  ]  // Passed ranges, shown sorted
     *		[    ]                                       // The result of the function if the first range was a reference range.
     *	            [                           ]        // The result of the function if the third-to-seventh range was a reference range.
     *	                                           [  ]  // The result of the function if the last range was a reference range.
     *
     * @param {Array.<module:engine/model/range~Range>} ranges Ranges to combine.
     * @returns {module:engine/model/range~Range} Combined range.
     */

  }, {
    key: "_createFromRanges",
    value: function _createFromRanges(ranges) {
      if (ranges.length === 0) {
        /**
         * At least one range has to be passed to
         * {@link module:engine/model/range~Range._createFromRanges `Range._createFromRanges()`}.
         *
         * @error range-create-from-ranges-empty-array
         */
        throw new ckeditorerror["b" /* default */]('range-create-from-ranges-empty-array: At least one range has to be passed.', null);
      } else if (ranges.length == 1) {
        return ranges[0].clone();
      } // 1. Set the first range in `ranges` array as a reference range.
      // If we are going to return just a one range, one of the ranges need to be the reference one.
      // Other ranges will be stuck to that range, if possible.


      var ref = ranges[0]; // 2. Sort all the ranges so it's easier to process them.

      ranges.sort(function (a, b) {
        return a.start.isAfter(b.start) ? 1 : -1;
      }); // 3. Check at which index the reference range is now.

      var refIndex = ranges.indexOf(ref); // 4. At this moment we don't need the original range.
      // We are going to modify the result and we need to return a new instance of Range.
      // We have to create a copy of the reference range.

      var result = new this(ref.start, ref.end); // 5. Ranges should be checked and glued starting from the range that is closest to the reference range.
      // Since ranges are sorted, start with the range with index that is closest to reference range index.

      if (refIndex > 0) {
        for (var i = refIndex - 1; true; i++) {
          if (ranges[i].end.isEqual(result.start)) {
            result.start = model_position_Position._createAt(ranges[i].start);
          } else {
            // If ranges are not starting/ending at the same position there is no point in looking further.
            break;
          }
        }
      } // 6. Ranges should be checked and glued starting from the range that is closest to the reference range.
      // Since ranges are sorted, start with the range with index that is closest to reference range index.


      for (var _i2 = refIndex + 1; _i2 < ranges.length; _i2++) {
        if (ranges[_i2].start.isEqual(result.end)) {
          result.end = model_position_Position._createAt(ranges[_i2].end);
        } else {
          // If ranges are not starting/ending at the same position there is no point in looking further.
          break;
        }
      }

      return result;
    }
    /**
     * Creates a `Range` instance from given plain object (i.e. parsed JSON string).
     *
     * @param {Object} json Plain object to be converted to `Range`.
     * @param {module:engine/model/document~Document} doc Document object that will be range owner.
     * @returns {module:engine/model/element~Element} `Range` instance created using given plain object.
     */

  }, {
    key: "fromJSON",
    value: function fromJSON(json, doc) {
      return new this(model_position_Position.fromJSON(json.start, doc), model_position_Position.fromJSON(json.end, doc));
    } // @if CK_DEBUG_ENGINE // toString() {
    // @if CK_DEBUG_ENGINE // 	return `${ this.root } [ ${ this.start.path.join( ', ' ) } ] - [ ${ this.end.path.join( ', ' ) } ]`;
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // log() {
    // @if CK_DEBUG_ENGINE // 	console.log( 'ModelPosition: ' + this );
    // @if CK_DEBUG_ENGINE // }

  }]);

  return Range;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/conversion/mapper.js













/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/conversion/mapper
 */







/**
 * Maps elements, positions and markers between {@link module:engine/view/document~Document the view} and
 * {@link module:engine/model/model the model}.
 *
 * The instance of the Mapper used for the editing pipeline is available in
 * {@link module:engine/controller/editingcontroller~EditingController#mapper `editor.editing.mapper`}.
 *
 * Mapper uses bound elements to find corresponding elements and positions, so, to get proper results,
 * all model elements should be {@link module:engine/conversion/mapper~Mapper#bindElements bound}.
 *
 * To map complex model to/from view relations, you may provide custom callbacks for
 * {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition modelToViewPosition event} and
 * {@link module:engine/conversion/mapper~Mapper#event:viewToModelPosition viewToModelPosition event} that are fired whenever
 * a position mapping request occurs.
 * Those events are fired by {@link module:engine/conversion/mapper~Mapper#toViewPosition toViewPosition}
 * and {@link module:engine/conversion/mapper~Mapper#toModelPosition toModelPosition} methods. `Mapper` adds it's own default callbacks
 * with `'lowest'` priority. To override default `Mapper` mapping, add custom callback with higher priority and
 * stop the event.
 */

var mapper_Mapper = /*#__PURE__*/function () {
  /**
   * Creates an instance of the mapper.
   */
  function Mapper() {
    var _this = this;

    Object(classCallCheck["a" /* default */])(this, Mapper);

    /**
     * Model element to view element mapping.
     *
     * @private
     * @member {WeakMap}
     */
    this._modelToViewMapping = new WeakMap();
    /**
     * View element to model element mapping.
     *
     * @private
     * @member {WeakMap}
     */

    this._viewToModelMapping = new WeakMap();
    /**
     * A map containing callbacks between view element names and functions evaluating length of view elements
     * in model.
     *
     * @private
     * @member {Map}
     */

    this._viewToModelLengthCallbacks = new Map();
    /**
     * Model marker name to view elements mapping.
     *
     * Keys are `String`s while values are `Set`s with {@link module:engine/view/element~Element view elements}.
     * One marker (name) can be mapped to multiple elements.
     *
     * @private
     * @member {Map}
     */

    this._markerNameToElements = new Map();
    /**
     * View element to model marker names mapping.
     *
     * This is reverse to {@link ~Mapper#_markerNameToElements} map.
     *
     * @private
     * @member {Map}
     */

    this._elementToMarkerNames = new Map();
    /**
     * Stores marker names of markers which has changed due to unbinding a view element (so it is assumed that the view element
     * has been removed, moved or renamed).
     *
     * @private
     * @member {Set.<module:engine/model/markercollection~Marker>}
     */

    this._unboundMarkerNames = new Set(); // Default mapper algorithm for mapping model position to view position.

    this.on('modelToViewPosition', function (evt, data) {
      if (data.viewPosition) {
        return;
      }

      var viewContainer = _this._modelToViewMapping.get(data.modelPosition.parent);

      data.viewPosition = _this._findPositionIn(viewContainer, data.modelPosition.offset);
    }, {
      priority: 'low'
    }); // Default mapper algorithm for mapping view position to model position.

    this.on('viewToModelPosition', function (evt, data) {
      if (data.modelPosition) {
        return;
      }

      var viewBlock = _this.findMappedViewAncestor(data.viewPosition);

      var modelParent = _this._viewToModelMapping.get(viewBlock);

      var modelOffset = _this._toModelOffset(data.viewPosition.parent, data.viewPosition.offset, viewBlock);

      data.modelPosition = model_position_Position._createAt(modelParent, modelOffset);
    }, {
      priority: 'low'
    });
  }
  /**
   * Marks model and view elements as corresponding. Corresponding elements can be retrieved by using
   * the {@link module:engine/conversion/mapper~Mapper#toModelElement toModelElement} and
   * {@link module:engine/conversion/mapper~Mapper#toViewElement toViewElement} methods.
   * The information that elements are bound is also used to translate positions.
   *
   * @param {module:engine/model/element~Element} modelElement Model element.
   * @param {module:engine/view/element~Element} viewElement View element.
   */


  Object(createClass["a" /* default */])(Mapper, [{
    key: "bindElements",
    value: function bindElements(modelElement, viewElement) {
      this._modelToViewMapping.set(modelElement, viewElement);

      this._viewToModelMapping.set(viewElement, modelElement);
    }
    /**
     * Unbinds given {@link module:engine/view/element~Element view element} from the map.
     *
     * **Note:** view-to-model binding will be removed, if it existed. However, corresponding model-to-view binding
     * will be removed only if model element is still bound to passed `viewElement`.
     *
     * This behavior lets for re-binding model element to another view element without fear of losing the new binding
     * when the previously bound view element is unbound.
     *
     * @param {module:engine/view/element~Element} viewElement View element to unbind.
     */

  }, {
    key: "unbindViewElement",
    value: function unbindViewElement(viewElement) {
      var modelElement = this.toModelElement(viewElement);

      this._viewToModelMapping.delete(viewElement);

      if (this._elementToMarkerNames.has(viewElement)) {
        var _iterator = _createForOfIteratorHelper(this._elementToMarkerNames.get(viewElement)),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var markerName = _step.value;

            this._unboundMarkerNames.add(markerName);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      if (this._modelToViewMapping.get(modelElement) == viewElement) {
        this._modelToViewMapping.delete(modelElement);
      }
    }
    /**
     * Unbinds given {@link module:engine/model/element~Element model element} from the map.
     *
     * **Note:** model-to-view binding will be removed, if it existed. However, corresponding view-to-model binding
     * will be removed only if view element is still bound to passed `modelElement`.
     *
     * This behavior lets for re-binding view element to another model element without fear of losing the new binding
     * when the previously bound model element is unbound.
     *
     * @param {module:engine/model/element~Element} modelElement Model element to unbind.
     */

  }, {
    key: "unbindModelElement",
    value: function unbindModelElement(modelElement) {
      var viewElement = this.toViewElement(modelElement);

      this._modelToViewMapping.delete(modelElement);

      if (this._viewToModelMapping.get(viewElement) == modelElement) {
        this._viewToModelMapping.delete(viewElement);
      }
    }
    /**
     * Binds given marker name with given {@link module:engine/view/element~Element view element}. The element
     * will be added to the current set of elements bound with given marker name.
     *
     * @param {module:engine/view/element~Element} element Element to bind.
     * @param {String} name Marker name.
     */

  }, {
    key: "bindElementToMarker",
    value: function bindElementToMarker(element, name) {
      var elements = this._markerNameToElements.get(name) || new Set();
      elements.add(element);
      var names = this._elementToMarkerNames.get(element) || new Set();
      names.add(name);

      this._markerNameToElements.set(name, elements);

      this._elementToMarkerNames.set(element, names);
    }
    /**
     * Unbinds an element from given marker name.
     *
     * @param {module:engine/view/element~Element} element Element to unbind.
     * @param {String} name Marker name.
     */

  }, {
    key: "unbindElementFromMarkerName",
    value: function unbindElementFromMarkerName(element, name) {
      var nameToElements = this._markerNameToElements.get(name);

      if (nameToElements) {
        nameToElements.delete(element);

        if (nameToElements.size == 0) {
          this._markerNameToElements.delete(name);
        }
      }

      var elementToNames = this._elementToMarkerNames.get(element);

      if (elementToNames) {
        elementToNames.delete(name);

        if (elementToNames.size == 0) {
          this._elementToMarkerNames.delete(element);
        }
      }
    }
    /**
     * Returns all marker names of markers which has changed due to unbinding a view element (so it is assumed that the view element
     * has been removed, moved or renamed) since the last flush. After returning, the marker names list is cleared.
     *
     * @returns {Array.<String>}
     */

  }, {
    key: "flushUnboundMarkerNames",
    value: function flushUnboundMarkerNames() {
      var markerNames = Array.from(this._unboundMarkerNames);

      this._unboundMarkerNames.clear();

      return markerNames;
    }
    /**
     * Removes all model to view and view to model bindings.
     */

  }, {
    key: "clearBindings",
    value: function clearBindings() {
      this._modelToViewMapping = new WeakMap();
      this._viewToModelMapping = new WeakMap();
      this._markerNameToElements = new Map();
      this._elementToMarkerNames = new Map();
      this._unboundMarkerNames = new Set();
    }
    /**
     * Gets the corresponding model element.
     *
     * **Note:** {@link module:engine/view/uielement~UIElement} does not have corresponding element in model.
     *
     * @param {module:engine/view/element~Element} viewElement View element.
     * @returns {module:engine/model/element~Element|undefined} Corresponding model element or `undefined` if not found.
     */

  }, {
    key: "toModelElement",
    value: function toModelElement(viewElement) {
      return this._viewToModelMapping.get(viewElement);
    }
    /**
     * Gets the corresponding view element.
     *
     * @param {module:engine/model/element~Element} modelElement Model element.
     * @returns {module:engine/view/element~Element|undefined} Corresponding view element or `undefined` if not found.
     */

  }, {
    key: "toViewElement",
    value: function toViewElement(modelElement) {
      return this._modelToViewMapping.get(modelElement);
    }
    /**
     * Gets the corresponding model range.
     *
     * @param {module:engine/view/range~Range} viewRange View range.
     * @returns {module:engine/model/range~Range} Corresponding model range.
     */

  }, {
    key: "toModelRange",
    value: function toModelRange(viewRange) {
      return new model_range_Range(this.toModelPosition(viewRange.start), this.toModelPosition(viewRange.end));
    }
    /**
     * Gets the corresponding view range.
     *
     * @param {module:engine/model/range~Range} modelRange Model range.
     * @returns {module:engine/view/range~Range} Corresponding view range.
     */

  }, {
    key: "toViewRange",
    value: function toViewRange(modelRange) {
      return new range_Range(this.toViewPosition(modelRange.start), this.toViewPosition(modelRange.end));
    }
    /**
     * Gets the corresponding model position.
     *
     * @fires viewToModelPosition
     * @param {module:engine/view/position~Position} viewPosition View position.
     * @returns {module:engine/model/position~Position} Corresponding model position.
     */

  }, {
    key: "toModelPosition",
    value: function toModelPosition(viewPosition) {
      var data = {
        viewPosition: viewPosition,
        mapper: this
      };
      this.fire('viewToModelPosition', data);
      return data.modelPosition;
    }
    /**
     * Gets the corresponding view position.
     *
     * @fires modelToViewPosition
     * @param {module:engine/model/position~Position} modelPosition Model position.
     * @param {Object} [options] Additional options for position mapping process.
     * @param {Boolean} [options.isPhantom=false] Should be set to `true` if the model position to map is pointing to a place
     * in model tree which no longer exists. For example, it could be an end of a removed model range.
     * @returns {module:engine/view/position~Position} Corresponding view position.
     */

  }, {
    key: "toViewPosition",
    value: function toViewPosition(modelPosition) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
        isPhantom: false
      };
      var data = {
        modelPosition: modelPosition,
        mapper: this,
        isPhantom: options.isPhantom
      };
      this.fire('modelToViewPosition', data);
      return data.viewPosition;
    }
    /**
     * Gets all view elements bound to the given marker name.
     *
     * @param {String} name Marker name.
     * @returns {Set.<module:engine/view/element~Element>|null} View elements bound with given marker name or `null`
     * if no elements are bound to given marker name.
     */

  }, {
    key: "markerNameToElements",
    value: function markerNameToElements(name) {
      var boundElements = this._markerNameToElements.get(name);

      if (!boundElements) {
        return null;
      }

      var elements = new Set();

      var _iterator2 = _createForOfIteratorHelper(boundElements),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var element = _step2.value;

          if (element.is('attributeElement')) {
            var _iterator3 = _createForOfIteratorHelper(element.getElementsWithSameId()),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var clone = _step3.value;
                elements.add(clone);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          } else {
            elements.add(element);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return elements;
    }
    /**
     * Registers a callback that evaluates the length in the model of a view element with given name.
     *
     * The callback is fired with one argument, which is a view element instance. The callback is expected to return
     * a number representing the length of view element in model.
     *
     *		// List item in view may contain nested list, which have other list items. In model though,
     *		// the lists are represented by flat structure. Because of those differences, length of list view element
     *		// may be greater than one. In the callback it's checked how many nested list items are in evaluated list item.
     *
     *		function getViewListItemLength( element ) {
     *			let length = 1;
     *
     *			for ( let child of element.getChildren() ) {
     *				if ( child.name == 'ul' || child.name == 'ol' ) {
     *					for ( let item of child.getChildren() ) {
     *						length += getViewListItemLength( item );
     *					}
     *				}
     *			}
     *
     *			return length;
     *		}
     *
     *		mapper.registerViewToModelLength( 'li', getViewListItemLength );
     *
     * @param {String} viewElementName Name of view element for which callback is registered.
     * @param {Function} lengthCallback Function return a length of view element instance in model.
     */

  }, {
    key: "registerViewToModelLength",
    value: function registerViewToModelLength(viewElementName, lengthCallback) {
      this._viewToModelLengthCallbacks.set(viewElementName, lengthCallback);
    }
    /**
     * For given `viewPosition`, finds and returns the closest ancestor of this position that has a mapping to
     * the model.
     *
     * @param {module:engine/view/position~Position} viewPosition Position for which mapped ancestor should be found.
     * @returns {module:engine/view/element~Element}
     */

  }, {
    key: "findMappedViewAncestor",
    value: function findMappedViewAncestor(viewPosition) {
      var parent = viewPosition.parent;

      while (!this._viewToModelMapping.has(parent)) {
        parent = parent.parent;
      }

      return parent;
    }
    /**
     * Calculates model offset based on the view position and the block element.
     *
     * Example:
     *
     *		<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, p ) -> 5
     *
     * Is a sum of:
     *
     *		<p>foo|<b>bar</b></p> // _toModelOffset( p, 3, p ) -> 3
     *		<p>foo<b>ba|r</b></p> // _toModelOffset( b, 2, b ) -> 2
     *
     * @private
     * @param {module:engine/view/element~Element} viewParent Position parent.
     * @param {Number} viewOffset Position offset.
     * @param {module:engine/view/element~Element} viewBlock Block used as a base to calculate offset.
     * @returns {Number} Offset in the model.
     */

  }, {
    key: "_toModelOffset",
    value: function _toModelOffset(viewParent, viewOffset, viewBlock) {
      if (viewBlock != viewParent) {
        // See example.
        var offsetToParentStart = this._toModelOffset(viewParent.parent, viewParent.index, viewBlock);

        var offsetInParent = this._toModelOffset(viewParent, viewOffset, viewParent);

        return offsetToParentStart + offsetInParent;
      } // viewBlock == viewParent, so we need to calculate the offset in the parent element.
      // If the position is a text it is simple ("ba|r" -> 2).


      if (viewParent.is('text')) {
        return viewOffset;
      } // If the position is in an element we need to sum lengths of siblings ( <b> bar </b> foo | -> 3 + 3 = 6 ).


      var modelOffset = 0;

      for (var i = 0; i < viewOffset; i++) {
        modelOffset += this.getModelLength(viewParent.getChild(i));
      }

      return modelOffset;
    }
    /**
     * Gets the length of the view element in the model.
     *
     * The length is calculated as follows:
     * * if {@link #registerViewToModelLength length mapping callback} is provided for given `viewNode` it is used to
     * evaluate model length (`viewNode` is used as first and only parameter passed to the callback),
     * * length of a {@link module:engine/view/text~Text text node} is equal to the length of it's
     * {@link module:engine/view/text~Text#data data},
     * * length of a {@link module:engine/view/uielement~UIElement ui element} is equal to 0,
     * * length of a mapped {@link module:engine/view/element~Element element} is equal to 1,
     * * length of a not-mapped {@link module:engine/view/element~Element element} is equal to the length of it's children.
     *
     * Examples:
     *
     *		foo                          -> 3 // Text length is equal to it's data length.
     *		<p>foo</p>                   -> 1 // Length of an element which is mapped is by default equal to 1.
     *		<b>foo</b>                   -> 3 // Length of an element which is not mapped is a length of its children.
     *		<div><p>x</p><p>y</p></div>  -> 2 // Assuming that <div> is not mapped and <p> are mapped.
     *
     * @param {module:engine/view/element~Element} viewNode View node.
     * @returns {Number} Length of the node in the tree model.
     */

  }, {
    key: "getModelLength",
    value: function getModelLength(viewNode) {
      if (this._viewToModelLengthCallbacks.get(viewNode.name)) {
        var callback = this._viewToModelLengthCallbacks.get(viewNode.name);

        return callback(viewNode);
      } else if (this._viewToModelMapping.has(viewNode)) {
        return 1;
      } else if (viewNode.is('text')) {
        return viewNode.data.length;
      } else if (viewNode.is('uiElement')) {
        return 0;
      } else {
        var len = 0;

        var _iterator4 = _createForOfIteratorHelper(viewNode.getChildren()),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var child = _step4.value;
            len += this.getModelLength(child);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }

        return len;
      }
    }
    /**
     * Finds the position in the view node (or its children) with the expected model offset.
     *
     * Example:
     *
     *		<p>fo<b>bar</b>bom</p> -> expected offset: 4
     *
     *		_findPositionIn( p, 4 ):
     *		<p>|fo<b>bar</b>bom</p> -> expected offset: 4, actual offset: 0
     *		<p>fo|<b>bar</b>bom</p> -> expected offset: 4, actual offset: 2
     *		<p>fo<b>bar</b>|bom</p> -> expected offset: 4, actual offset: 5 -> we are too far
     *
     *		_findPositionIn( b, 4 - ( 5 - 3 ) ):
     *		<p>fo<b>|bar</b>bom</p> -> expected offset: 2, actual offset: 0
     *		<p>fo<b>bar|</b>bom</p> -> expected offset: 2, actual offset: 3 -> we are too far
     *
     *		_findPositionIn( bar, 2 - ( 3 - 3 ) ):
     *		We are in the text node so we can simple find the offset.
     *		<p>fo<b>ba|r</b>bom</p> -> expected offset: 2, actual offset: 2 -> position found
     *
     * @private
     * @param {module:engine/view/element~Element} viewParent Tree view element in which we are looking for the position.
     * @param {Number} expectedOffset Expected offset.
     * @returns {module:engine/view/position~Position} Found position.
     */

  }, {
    key: "_findPositionIn",
    value: function _findPositionIn(viewParent, expectedOffset) {
      // Last scanned view node.
      var viewNode; // Length of the last scanned view node.

      var lastLength = 0;
      var modelOffset = 0;
      var viewOffset = 0; // In the text node it is simple: offset in the model equals offset in the text.

      if (viewParent.is('text')) {
        return new position_Position(viewParent, expectedOffset);
      } // In other cases we add lengths of child nodes to find the proper offset.
      // If it is smaller we add the length.


      while (modelOffset < expectedOffset) {
        viewNode = viewParent.getChild(viewOffset);
        lastLength = this.getModelLength(viewNode);
        modelOffset += lastLength;
        viewOffset++;
      } // If it equals we found the position.


      if (modelOffset == expectedOffset) {
        return this._moveViewPositionToTextNode(new position_Position(viewParent, viewOffset));
      } // If it is higher we need to enter last child.
      else {
          // ( modelOffset - lastLength ) is the offset to the child we enter,
          // so we subtract it from the expected offset to fine the offset in the child.
          return this._findPositionIn(viewNode, expectedOffset - (modelOffset - lastLength));
        }
    }
    /**
     * Because we prefer positions in text nodes over positions next to text node moves view position to the text node
     * if it was next to it.
     *
     *		<p>[]<b>foo</b></p> -> <p>[]<b>foo</b></p> // do not touch if position is not directly next to text
     *		<p>foo[]<b>foo</b></p> -> <p>foo{}<b>foo</b></p> // move to text node
     *		<p><b>[]foo</b></p> -> <p><b>{}foo</b></p> // move to text node
     *
     * @private
     * @param {module:engine/view/position~Position} viewPosition Position potentially next to text node.
     * @returns {module:engine/view/position~Position} Position in text node if possible.
     */

  }, {
    key: "_moveViewPositionToTextNode",
    value: function _moveViewPositionToTextNode(viewPosition) {
      // If the position is just after text node, put it at the end of that text node.
      // If the position is just before text node, put it at the beginning of that text node.
      var nodeBefore = viewPosition.nodeBefore;
      var nodeAfter = viewPosition.nodeAfter;

      if (nodeBefore instanceof text_Text) {
        return new position_Position(nodeBefore, nodeBefore.data.length);
      } else if (nodeAfter instanceof text_Text) {
        return new position_Position(nodeAfter, 0);
      } // Otherwise, just return the given position.


      return viewPosition;
    }
    /**
     * Fired for each model-to-view position mapping request. The purpose of this event is to enable custom model-to-view position
     * mapping. Callbacks added to this event take {@link module:engine/model/position~Position model position} and are expected to
     * calculate {@link module:engine/view/position~Position view position}. Calculated view position should be added as `viewPosition`
     * value in `data` object that is passed as one of parameters to the event callback.
     *
     * 		// Assume that "captionedImage" model element is converted to <img> and following <span> elements in view,
     * 		// and the model element is bound to <img> element. Force mapping model positions inside "captionedImage" to that
     * 		// <span> element.
     *		mapper.on( 'modelToViewPosition', ( evt, data ) => {
     *			const positionParent = modelPosition.parent;
     *
     *			if ( positionParent.name == 'captionedImage' ) {
     *				const viewImg = data.mapper.toViewElement( positionParent );
     *				const viewCaption = viewImg.nextSibling; // The <span> element.
     *
     *				data.viewPosition = new ViewPosition( viewCaption, modelPosition.offset );
     *
     *				// Stop the event if other callbacks should not modify calculated value.
     *				evt.stop();
     *			}
     *		} );
     *
     * **Note:** keep in mind that sometimes a "phantom" model position is being converted. "Phantom" model position is
     * a position that points to a non-existing place in model. Such position might still be valid for conversion, though
     * (it would point to a correct place in view when converted). One example of such situation is when a range is
     * removed from model, there may be a need to map the range's end (which is no longer valid model position). To
     * handle such situation, check `data.isPhantom` flag:
     *
     * 		// Assume that there is "customElement" model element and whenever position is before it, we want to move it
     * 		// to the inside of the view element bound to "customElement".
     *		mapper.on( 'modelToViewPosition', ( evt, data ) => {
     *			if ( data.isPhantom ) {
     *				return;
     *			}
     *
     *			// Below line might crash for phantom position that does not exist in model.
     *			const sibling = data.modelPosition.nodeBefore;
     *
     *			// Check if this is the element we are interested in.
     *			if ( !sibling.is( 'customElement' ) ) {
     *				return;
     *			}
     *
     *			const viewElement = data.mapper.toViewElement( sibling );
     *
     *			data.viewPosition = new ViewPosition( sibling, 0 );
     *
     *			evt.stop();
     *		} );
     *
     * **Note:** default mapping callback is provided with `low` priority setting and does not cancel the event, so it is possible to
     * attach a custom callback after default callback and also use `data.viewPosition` calculated by default callback
     * (for example to fix it).
     *
     * **Note:** default mapping callback will not fire if `data.viewPosition` is already set.
     *
     * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position
     * mapping between given model and view elements is unsolvable using just elements mapping and default algorithm. Also,
     * the condition that checks if special case scenario happened should be as simple as possible.
     *
     * @event modelToViewPosition
     * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add
     * `viewPosition` value to that object with calculated {@link module:engine/view/position~Position view position}.
     * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.
     */

    /**
     * Fired for each view-to-model position mapping request. See {@link module:engine/conversion/mapper~Mapper#event:modelToViewPosition}.
     *
     * 		// See example in `modelToViewPosition` event description.
     * 		// This custom mapping will map positions from <span> element next to <img> to the "captionedImage" element.
     *		mapper.on( 'viewToModelPosition', ( evt, data ) => {
     *			const positionParent = viewPosition.parent;
     *
     *			if ( positionParent.hasClass( 'image-caption' ) ) {
     *				const viewImg = positionParent.previousSibling;
     *				const modelImg = data.mapper.toModelElement( viewImg );
     *
     *				data.modelPosition = new ModelPosition( modelImg, viewPosition.offset );
     *				evt.stop();
     *			}
     *		} );
     *
     * **Note:** default mapping callback is provided with `low` priority setting and does not cancel the event, so it is possible to
     * attach a custom callback after default callback and also use `data.modelPosition` calculated by default callback
     * (for example to fix it).
     *
     * **Note:** default mapping callback will not fire if `data.modelPosition` is already set.
     *
     * **Note:** these callbacks are called **very often**. For efficiency reasons, it is advised to use them only when position
     * mapping between given model and view elements is unsolvable using just elements mapping and default algorithm. Also,
     * the condition that checks if special case scenario happened should be as simple as possible.
     *
     * @event viewToModelPosition
     * @param {Object} data Data pipeline object that can store and pass data between callbacks. The callback should add
     * `modelPosition` value to that object with calculated {@link module:engine/model/position~Position model position}.
     * @param {module:engine/conversion/mapper~Mapper} data.mapper Mapper instance that fired the event.
     */

  }]);

  return Mapper;
}();


mix(mapper_Mapper, emittermixin);
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/conversion/modelconsumable.js












/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/conversion/modelconsumable
 */

/**
 * Manages a list of consumable values for {@link module:engine/model/item~Item model items}.
 *
 * Consumables are various aspects of the model. A model item can be broken down into singular properties that might be
 * taken into consideration when converting that item.
 *
 * `ModelConsumable` is used by {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} while analyzing changed
 * parts of {@link module:engine/model/document~Document the document}. The added / changed / removed model items are broken down
 * into singular properties (the item itself and it's attributes). All those parts are saved in `ModelConsumable`. Then,
 * during conversion, when given part of model item is converted (i.e. the view element has been inserted into the view,
 * but without attributes), consumable value is removed from `ModelConsumable`.
 *
 * For model items, `ModelConsumable` stores consumable values of one of following types: `insert`, `addattribute:<attributeKey>`,
 * `changeattributes:<attributeKey>`, `removeattributes:<attributeKey>`.
 *
 * In most cases, it is enough to let {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}
 * gather consumable values, so there is no need to use
 * {@link module:engine/conversion/modelconsumable~ModelConsumable#add add method} directly.
 * However, it is important to understand how consumable values can be
 * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.
 * See {@link module:engine/conversion/downcasthelpers default downcast converters} for more information.
 *
 * Keep in mind, that one conversion event may have multiple callbacks (converters) attached to it. Each of those is
 * able to convert one or more parts of the model. However, when one of those callbacks actually converts
 * something, other should not, because they would duplicate the results. Using `ModelConsumable` helps avoiding
 * this situation, because callbacks should only convert those values, which were not yet consumed from `ModelConsumable`.
 *
 * Consuming multiple values in a single callback:
 *
 *		// Converter for custom `image` element that might have a `caption` element inside which changes
 *		// how the image is displayed in the view:
 *		//
 *		// Model:
 *		//
 *		// [image]
 *		//   └─ [caption]
 *		//       └─ foo
 *		//
 *		// View:
 *		//
 *		// <figure>
 *		//   ├─ <img />
 *		//   └─ <caption>
 *		//       └─ foo
 *		modelConversionDispatcher.on( 'insert:image', ( evt, data, conversionApi ) => {
 *			// First, consume the `image` element.
 *			conversionApi.consumable.consume( data.item, 'insert' );
 *
 *			// Just create normal image element for the view.
 *			// Maybe it will be "decorated" later.
 *			const viewImage = new ViewElement( 'img' );
 *			const insertPosition = conversionApi.mapper.toViewPosition( data.range.start );
 *			const viewWriter = conversionApi.writer;
 *
 *			// Check if the `image` element has children.
 *			if ( data.item.childCount > 0 ) {
 *				const modelCaption = data.item.getChild( 0 );
 *
 *				// `modelCaption` insertion change is consumed from consumable values.
 *				// It will not be converted by other converters, but it's children (probably some text) will be.
 *				// Through mapping, converters for text will know where to insert contents of `modelCaption`.
 *				if ( conversionApi.consumable.consume( modelCaption, 'insert' ) ) {
 *					const viewCaption = new ViewElement( 'figcaption' );
 *
 *					const viewImageHolder = new ViewElement( 'figure', null, [ viewImage, viewCaption ] );
 *
 *					conversionApi.mapper.bindElements( modelCaption, viewCaption );
 *					conversionApi.mapper.bindElements( data.item, viewImageHolder );
 *					viewWriter.insert( insertPosition, viewImageHolder );
 *				}
 *			} else {
 *				conversionApi.mapper.bindElements( data.item, viewImage );
 *				viewWriter.insert( insertPosition, viewImage );
 *			}
 *
 *			evt.stop();
 *		} );
 */

var modelconsumable_ModelConsumable = /*#__PURE__*/function () {
  /**
   * Creates an empty consumables list.
   */
  function ModelConsumable() {
    Object(classCallCheck["a" /* default */])(this, ModelConsumable);

    /**
     * Contains list of consumable values.
     *
     * @private
     * @member {Map} module:engine/conversion/modelconsumable~ModelConsumable#_consumable
     */
    this._consumable = new Map();
    /**
     * For each {@link module:engine/model/textproxy~TextProxy} added to `ModelConsumable`, this registry holds parent
     * of that `TextProxy` and start and end indices of that `TextProxy`. This allows identification of `TextProxy`
     * instances that points to the same part of the model but are different instances. Each distinct `TextProxy`
     * is given unique `Symbol` which is then registered as consumable. This process is transparent for `ModelConsumable`
     * API user because whenever `TextProxy` is added, tested, consumed or reverted, internal mechanisms of
     * `ModelConsumable` translates `TextProxy` to that unique `Symbol`.
     *
     * @private
     * @member {Map} module:engine/conversion/modelconsumable~ModelConsumable#_textProxyRegistry
     */

    this._textProxyRegistry = new Map();
  }
  /**
   * Adds a consumable value to the consumables list and links it with given model item.
   *
   *		modelConsumable.add( modelElement, 'insert' ); // Add `modelElement` insertion change to consumable values.
   *		modelConsumable.add( modelElement, 'addAttribute:bold' ); // Add `bold` attribute insertion on `modelElement` change.
   *		modelConsumable.add( modelElement, 'removeAttribute:bold' ); // Add `bold` attribute removal on `modelElement` change.
   *		modelConsumable.add( modelSelection, 'selection' ); // Add `modelSelection` to consumable values.
   *		modelConsumable.add( modelRange, 'range' ); // Add `modelRange` to consumable values.
   *
   * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item
   * Model item, range or selection that has the consumable.
   * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
   * Second colon and everything after will be cut. Passing event name is a safe and good practice.
   */


  Object(createClass["a" /* default */])(ModelConsumable, [{
    key: "add",
    value: function add(item, type) {
      type = _normalizeConsumableType(type);

      if (item instanceof model_textproxy_TextProxy) {
        item = this._getSymbolForTextProxy(item);
      }

      if (!this._consumable.has(item)) {
        this._consumable.set(item, new Map());
      }

      this._consumable.get(item).set(type, true);
    }
    /**
     * Removes given consumable value from given model item.
     *
     *		modelConsumable.consume( modelElement, 'insert' ); // Remove `modelElement` insertion change from consumable values.
     *		modelConsumable.consume( modelElement, 'addAttribute:bold' ); // Remove `bold` attribute insertion on `modelElement` change.
     *		modelConsumable.consume( modelElement, 'removeAttribute:bold' ); // Remove `bold` attribute removal on `modelElement` change.
     *		modelConsumable.consume( modelSelection, 'selection' ); // Remove `modelSelection` from consumable values.
     *		modelConsumable.consume( modelRange, 'range' ); // Remove 'modelRange' from consumable values.
     *
     * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item
     * Model item, range or selection from which consumable will be consumed.
     * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
     * Second colon and everything after will be cut. Passing event name is a safe and good practice.
     * @returns {Boolean} `true` if consumable value was available and was consumed, `false` otherwise.
     */

  }, {
    key: "consume",
    value: function consume(item, type) {
      type = _normalizeConsumableType(type);

      if (item instanceof model_textproxy_TextProxy) {
        item = this._getSymbolForTextProxy(item);
      }

      if (this.test(item, type)) {
        this._consumable.get(item).set(type, false);

        return true;
      } else {
        return false;
      }
    }
    /**
     * Tests whether there is a consumable value of given type connected with given model item.
     *
     *		modelConsumable.test( modelElement, 'insert' ); // Check for `modelElement` insertion change.
     *		modelConsumable.test( modelElement, 'addAttribute:bold' ); // Check for `bold` attribute insertion on `modelElement` change.
     *		modelConsumable.test( modelElement, 'removeAttribute:bold' ); // Check for `bold` attribute removal on `modelElement` change.
     *		modelConsumable.test( modelSelection, 'selection' ); // Check if `modelSelection` is consumable.
     *		modelConsumable.test( modelRange, 'range' ); // Check if `modelRange` is consumable.
     *
     * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item
     * Model item, range or selection to be tested.
     * @param {String} type Consumable type. Will be normalized to a proper form, that is either `<word>` or `<part>:<part>`.
     * Second colon and everything after will be cut. Passing event name is a safe and good practice.
     * @returns {null|Boolean} `null` if such consumable was never added, `false` if the consumable values was
     * already consumed or `true` if it was added and not consumed yet.
     */

  }, {
    key: "test",
    value: function test(item, type) {
      type = _normalizeConsumableType(type);

      if (item instanceof model_textproxy_TextProxy) {
        item = this._getSymbolForTextProxy(item);
      }

      var itemConsumables = this._consumable.get(item);

      if (itemConsumables === undefined) {
        return null;
      }

      var value = itemConsumables.get(type);

      if (value === undefined) {
        return null;
      }

      return value;
    }
    /**
     * Reverts consuming of consumable value.
     *
     *		modelConsumable.revert( modelElement, 'insert' ); // Revert consuming `modelElement` insertion change.
     *		modelConsumable.revert( modelElement, 'addAttribute:bold' ); // Revert consuming `bold` attribute insert from `modelElement`.
     *		modelConsumable.revert( modelElement, 'removeAttribute:bold' ); // Revert consuming `bold` attribute remove from `modelElement`.
     *		modelConsumable.revert( modelSelection, 'selection' ); // Revert consuming `modelSelection`.
     *		modelConsumable.revert( modelRange, 'range' ); // Revert consuming `modelRange`.
     *
     * @param {module:engine/model/item~Item|module:engine/model/selection~Selection|module:engine/model/range~Range} item
     * Model item, range or selection to be reverted.
     * @param {String} type Consumable type.
     * @returns {null|Boolean} `true` if consumable has been reversed, `false` otherwise. `null` if the consumable has
     * never been added.
     */

  }, {
    key: "revert",
    value: function revert(item, type) {
      type = _normalizeConsumableType(type);

      if (item instanceof model_textproxy_TextProxy) {
        item = this._getSymbolForTextProxy(item);
      }

      var test = this.test(item, type);

      if (test === false) {
        this._consumable.get(item).set(type, true);

        return true;
      } else if (test === true) {
        return false;
      }

      return null;
    }
    /**
     * Gets a unique symbol for passed {@link module:engine/model/textproxy~TextProxy} instance. All `TextProxy` instances that
     * have same parent, same start index and same end index will get the same symbol.
     *
     * Used internally to correctly consume `TextProxy` instances.
     *
     * @private
     * @param {module:engine/model/textproxy~TextProxy} textProxy `TextProxy` instance to get a symbol for.
     * @returns {Symbol} Symbol representing all equal instances of `TextProxy`.
     */

  }, {
    key: "_getSymbolForTextProxy",
    value: function _getSymbolForTextProxy(textProxy) {
      var symbol = null;

      var startMap = this._textProxyRegistry.get(textProxy.startOffset);

      if (startMap) {
        var endMap = startMap.get(textProxy.endOffset);

        if (endMap) {
          symbol = endMap.get(textProxy.parent);
        }
      }

      if (!symbol) {
        symbol = this._addSymbolForTextProxy(textProxy.startOffset, textProxy.endOffset, textProxy.parent);
      }

      return symbol;
    }
    /**
     * Adds a symbol for given properties that characterizes a {@link module:engine/model/textproxy~TextProxy} instance.
     *
     * Used internally to correctly consume `TextProxy` instances.
     *
     * @private
     * @param {Number} startIndex Text proxy start index in it's parent.
     * @param {Number} endIndex Text proxy end index in it's parent.
     * @param {module:engine/model/element~Element} parent Text proxy parent.
     * @returns {Symbol} Symbol generated for given properties.
     */

  }, {
    key: "_addSymbolForTextProxy",
    value: function _addSymbolForTextProxy(start, end, parent) {
      var symbol = Symbol('textProxySymbol');
      var startMap, endMap;
      startMap = this._textProxyRegistry.get(start);

      if (!startMap) {
        startMap = new Map();

        this._textProxyRegistry.set(start, startMap);
      }

      endMap = startMap.get(end);

      if (!endMap) {
        endMap = new Map();
        startMap.set(end, endMap);
      }

      endMap.set(parent, symbol);
      return symbol;
    }
  }]);

  return ModelConsumable;
}(); // Returns a normalized consumable type name from given string. A normalized consumable type name is a string that has
// at most one colon, for example: `insert` or `addMarker:highlight`. If string to normalize has more "parts" (more colons),
// the other parts are dropped, for example: `addattribute:bold:$text` -> `addattributes:bold`.
//
// @param {String} type Consumable type.
// @returns {String} Normalized consumable type.




function _normalizeConsumableType(type) {
  var parts = type.split(':');
  return parts.length > 1 ? parts[0] + ':' + parts[1] : parts[0];
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/conversion/downcastdispatcher.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/conversion/downcastdispatcher
 */





/**
 * `DowncastDispatcher` is a central point of downcasting (conversion from model to view), which is a process of reacting to changes
 * in the model and firing a set of events. Callbacks listening to those events are called converters. Those
 * converters role is to convert the model changes to changes in view (for example, adding view nodes or
 * changing attributes on view elements).
 *
 * During conversion process, `DowncastDispatcher` fires events, basing on state of the model and prepares
 * data for those events. It is important to understand that those events are connected with changes done on model,
 * for example: "node has been inserted" or "attribute has changed". This is in a contrary to upcasting (view to model conversion),
 * where we convert view state (view nodes) to a model tree.
 *
 * The events are prepared basing on a diff created by {@link module:engine/model/differ~Differ Differ}, which buffers them
 * and then passes to `DowncastDispatcher` as a diff between old model state and new model state.
 *
 * Note, that because changes are converted there is a need to have a mapping between model structure and view structure.
 * To map positions and elements during downcast (model to view conversion) use {@link module:engine/conversion/mapper~Mapper}.
 *
 * `DowncastDispatcher` fires following events for model tree changes:
 *
 * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert insert}
 * if a range of nodes has been inserted to the model tree,
 * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove remove}
 * if a range of nodes has been removed from the model tree,
 * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute attribute}
 * if attribute has been added, changed or removed from a model node.
 *
 * For {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert insert}
 * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute attribute},
 * `DowncastDispatcher` generates {@link module:engine/conversion/modelconsumable~ModelConsumable consumables}.
 * These are used to have a control over which changes has been already consumed. It is useful when some converters
 * overwrite other or converts multiple changes (for example converts insertion of an element and also converts that
 * element's attributes during insertion).
 *
 * Additionally, `DowncastDispatcher` fires events for {@link module:engine/model/markercollection~Marker marker} changes:
 *
 * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker} if a marker has been added,
 * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker} if a marker has been removed.
 *
 * Note, that changing a marker is done through removing the marker from the old range, and adding on the new range,
 * so both those events are fired.
 *
 * Finally, `DowncastDispatcher` also handles firing events for {@link module:engine/model/selection model selection}
 * conversion:
 *
 * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:selection}
 * which converts selection from model to view,
 * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute}
 * which is fired for every selection attribute,
 * * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}
 * which is fired for every marker which contains selection.
 *
 * Unlike model tree and markers, events for selection are not fired for changes but for selection state.
 *
 * When providing custom listeners for `DowncastDispatcher` remember to check whether given change has not been
 * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} yet.
 *
 * When providing custom listeners for `DowncastDispatcher` keep in mind that any callback that had
 * {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed} a value from a consumable and
 * converted the change should also stop the event (for efficiency purposes).
 *
 * When providing custom listeners for `DowncastDispatcher` remember to use provided
 * {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer} to apply changes to the view document.
 *
 * Example of a custom converter for `DowncastDispatcher`:
 *
 *		// We will convert inserting "paragraph" model element into the model.
 *		downcastDispatcher.on( 'insert:paragraph', ( evt, data, conversionApi ) => {
 *			// Remember to check whether the change has not been consumed yet and consume it.
 *			if ( conversionApi.consumable.consume( data.item, 'insert' ) ) {
 *				return;
 *			}
 *
 *			// Translate position in model to position in view.
 *			const viewPosition = conversionApi.mapper.toViewPosition( data.range.start );
 *
 *			// Create <p> element that will be inserted in view at `viewPosition`.
 *			const viewElement = conversionApi.writer.createContainerElement( 'p' );
 *
 *			// Bind the newly created view element to model element so positions will map accordingly in future.
 *			conversionApi.mapper.bindElements( data.item, viewElement );
 *
 *			// Add the newly created view element to the view.
 *			conversionApi.writer.insert( viewPosition, viewElement );
 *
 *			// Remember to stop the event propagation.
 *			evt.stop();
 *		} );
 */

var downcastdispatcher_DowncastDispatcher = /*#__PURE__*/function () {
  /**
   * Creates a `DowncastDispatcher` instance.
   *
   * @see module:engine/conversion/downcastdispatcher~DowncastConversionApi
   * @param {Object} conversionApi Additional properties for interface that will be passed to events fired
   * by `DowncastDispatcher`.
   */
  function DowncastDispatcher(conversionApi) {
    Object(classCallCheck["a" /* default */])(this, DowncastDispatcher);

    /**
     * Interface passed by dispatcher to the events callbacks.
     *
     * @member {module:engine/conversion/downcastdispatcher~DowncastConversionApi}
     */
    this.conversionApi = lodash_es_assignIn({
      dispatcher: this
    }, conversionApi);
  }
  /**
   * Takes {@link module:engine/model/differ~Differ model differ} object with buffered changes and fires conversion basing on it.
   *
   * @param {module:engine/model/differ~Differ} differ Differ object with buffered changes.
   * @param {module:engine/model/markercollection~MarkerCollection} markers Markers connected with converted model.
   * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.
   */


  Object(createClass["a" /* default */])(DowncastDispatcher, [{
    key: "convertChanges",
    value: function convertChanges(differ, markers, writer) {
      // Before the view is updated, remove markers which have changed.
      var _iterator = _createForOfIteratorHelper(differ.getMarkersToRemove()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var change = _step.value;
          this.convertMarkerRemove(change.name, change.range, writer);
        } // Convert changes that happened on model tree.

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var _iterator2 = _createForOfIteratorHelper(differ.getChanges()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var entry = _step2.value;

          if (entry.type == 'insert') {
            this.convertInsert(model_range_Range._createFromPositionAndShift(entry.position, entry.length), writer);
          } else if (entry.type == 'remove') {
            this.convertRemove(entry.position, entry.length, entry.name, writer);
          } else {
            // entry.type == 'attribute'.
            this.convertAttribute(entry.range, entry.attributeKey, entry.attributeOldValue, entry.attributeNewValue, writer);
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var _iterator3 = _createForOfIteratorHelper(this.conversionApi.mapper.flushUnboundMarkerNames()),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var markerName = _step3.value;
          var markerRange = markers.get(markerName).getRange();
          this.convertMarkerRemove(markerName, markerRange, writer);
          this.convertMarkerAdd(markerName, markerRange, writer);
        } // After the view is updated, convert markers which have changed.

      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      var _iterator4 = _createForOfIteratorHelper(differ.getMarkersToAdd()),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var _change = _step4.value;
          this.convertMarkerAdd(_change.name, _change.range, writer);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    }
    /**
     * Starts conversion of a range insertion.
     *
     * For each node in the range, {@link #event:insert insert event is fired}. For each attribute on each node,
     * {@link #event:attribute attribute event is fired}.
     *
     * @fires insert
     * @fires attribute
     * @param {module:engine/model/range~Range} range Inserted range.
     * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.
     */

  }, {
    key: "convertInsert",
    value: function convertInsert(range, writer) {
      this.conversionApi.writer = writer; // Create a list of things that can be consumed, consisting of nodes and their attributes.

      this.conversionApi.consumable = this._createInsertConsumable(range); // Fire a separate insert event for each node and text fragment contained in the range.

      var _iterator5 = _createForOfIteratorHelper(range),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var value = _step5.value;
          var item = value.item;

          var itemRange = model_range_Range._createFromPositionAndShift(value.previousPosition, value.length);

          var data = {
            item: item,
            range: itemRange
          };

          this._testAndFire('insert', data); // Fire a separate addAttribute event for each attribute that was set on inserted items.
          // This is important because most attributes converters will listen only to add/change/removeAttribute events.
          // If we would not add this part, attributes on inserted nodes would not be converted.


          var _iterator6 = _createForOfIteratorHelper(item.getAttributeKeys()),
              _step6;

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var key = _step6.value;
              data.attributeKey = key;
              data.attributeOldValue = null;
              data.attributeNewValue = item.getAttribute(key);

              this._testAndFire("attribute:".concat(key), data);
            }
          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      this._clearConversionApi();
    }
    /**
     * Fires conversion of a single node removal. Fires {@link #event:remove remove event} with provided data.
     *
     * @param {module:engine/model/position~Position} position Position from which node was removed.
     * @param {Number} length Offset size of removed node.
     * @param {String} name Name of removed node.
     * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.
     */

  }, {
    key: "convertRemove",
    value: function convertRemove(position, length, name, writer) {
      this.conversionApi.writer = writer;
      this.fire('remove:' + name, {
        position: position,
        length: length
      }, this.conversionApi);

      this._clearConversionApi();
    }
    /**
     * Starts conversion of attribute change on given `range`.
     *
     * For each node in the given `range`, {@link #event:attribute attribute event} is fired with the passed data.
     *
     * @fires attribute
     * @param {module:engine/model/range~Range} range Changed range.
     * @param {String} key Key of the attribute that has changed.
     * @param {*} oldValue Attribute value before the change or `null` if the attribute has not been set before.
     * @param {*} newValue New attribute value or `null` if the attribute has been removed.
     * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.
     */

  }, {
    key: "convertAttribute",
    value: function convertAttribute(range, key, oldValue, newValue, writer) {
      this.conversionApi.writer = writer; // Create a list with attributes to consume.

      this.conversionApi.consumable = this._createConsumableForRange(range, "attribute:".concat(key)); // Create a separate attribute event for each node in the range.

      var _iterator7 = _createForOfIteratorHelper(range),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var value = _step7.value;
          var item = value.item;

          var itemRange = model_range_Range._createFromPositionAndShift(value.previousPosition, value.length);

          var data = {
            item: item,
            range: itemRange,
            attributeKey: key,
            attributeOldValue: oldValue,
            attributeNewValue: newValue
          };

          this._testAndFire("attribute:".concat(key), data);
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }

      this._clearConversionApi();
    }
    /**
     * Starts model selection conversion.
     *
     * Fires events for given {@link module:engine/model/selection~Selection selection} to start selection conversion.
     *
     * @fires selection
     * @fires addMarker
     * @fires attribute
     * @param {module:engine/model/selection~Selection} selection Selection to convert.
     * @param {module:engine/model/markercollection~MarkerCollection} markers Markers connected with converted model.
     * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.
     */

  }, {
    key: "convertSelection",
    value: function convertSelection(selection, markers, writer) {
      var markersAtSelection = Array.from(markers.getMarkersAtPosition(selection.getFirstPosition()));
      this.conversionApi.writer = writer;
      this.conversionApi.consumable = this._createSelectionConsumable(selection, markersAtSelection);
      this.fire('selection', {
        selection: selection
      }, this.conversionApi);

      if (!selection.isCollapsed) {
        return;
      }

      for (var _i = 0, _markersAtSelection = markersAtSelection; _i < _markersAtSelection.length; _i++) {
        var marker = _markersAtSelection[_i];
        var markerRange = marker.getRange();

        if (!shouldMarkerChangeBeConverted(selection.getFirstPosition(), marker, this.conversionApi.mapper)) {
          continue;
        }

        var data = {
          item: selection,
          markerName: marker.name,
          markerRange: markerRange
        };

        if (this.conversionApi.consumable.test(selection, 'addMarker:' + marker.name)) {
          this.fire('addMarker:' + marker.name, data, this.conversionApi);
        }
      }

      var _iterator8 = _createForOfIteratorHelper(selection.getAttributeKeys()),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var key = _step8.value;
          var _data = {
            item: selection,
            range: selection.getFirstRange(),
            attributeKey: key,
            attributeOldValue: null,
            attributeNewValue: selection.getAttribute(key)
          }; // Do not fire event if the attribute has been consumed.

          if (this.conversionApi.consumable.test(selection, 'attribute:' + _data.attributeKey)) {
            this.fire('attribute:' + _data.attributeKey + ':$text', _data, this.conversionApi);
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }

      this._clearConversionApi();
    }
    /**
     * Converts added marker. Fires {@link #event:addMarker addMarker} event for each item
     * in marker's range. If range is collapsed single event is dispatched. See event description for more details.
     *
     * @fires addMarker
     * @param {String} markerName Marker name.
     * @param {module:engine/model/range~Range} markerRange Marker range.
     * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.
     */

  }, {
    key: "convertMarkerAdd",
    value: function convertMarkerAdd(markerName, markerRange, writer) {
      // Do not convert if range is in graveyard or not in the document (e.g. in DocumentFragment).
      if (!markerRange.root.document || markerRange.root.rootName == '$graveyard') {
        return;
      }

      this.conversionApi.writer = writer; // In markers' case, event name == consumable name.

      var eventName = 'addMarker:' + markerName; //
      // First, fire an event for the whole marker.
      //

      var consumable = new modelconsumable_ModelConsumable();
      consumable.add(markerRange, eventName);
      this.conversionApi.consumable = consumable;
      this.fire(eventName, {
        markerName: markerName,
        markerRange: markerRange
      }, this.conversionApi); //
      // Do not fire events for each item inside the range if the range got consumed.
      //

      if (!consumable.test(markerRange, eventName)) {
        return;
      } //
      // Then, fire an event for each item inside the marker range.
      //


      this.conversionApi.consumable = this._createConsumableForRange(markerRange, eventName);

      var _iterator9 = _createForOfIteratorHelper(markerRange.getItems()),
          _step9;

      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var item = _step9.value;

          // Do not fire event for already consumed items.
          if (!this.conversionApi.consumable.test(item, eventName)) {
            continue;
          }

          var data = {
            item: item,
            range: model_range_Range._createOn(item),
            markerName: markerName,
            markerRange: markerRange
          };
          this.fire(eventName, data, this.conversionApi);
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }

      this._clearConversionApi();
    }
    /**
     * Fires conversion of marker removal. Fires {@link #event:removeMarker removeMarker} event with provided data.
     *
     * @fires removeMarker
     * @param {String} markerName Marker name.
     * @param {module:engine/model/range~Range} markerRange Marker range.
     * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that should be used to modify view document.
     */

  }, {
    key: "convertMarkerRemove",
    value: function convertMarkerRemove(markerName, markerRange, writer) {
      // Do not convert if range is in graveyard or not in the document (e.g. in DocumentFragment).
      if (!markerRange.root.document || markerRange.root.rootName == '$graveyard') {
        return;
      }

      this.conversionApi.writer = writer;
      this.fire('removeMarker:' + markerName, {
        markerName: markerName,
        markerRange: markerRange
      }, this.conversionApi);

      this._clearConversionApi();
    }
    /**
     * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume from given range,
     * assuming that the range has just been inserted to the model.
     *
     * @private
     * @param {module:engine/model/range~Range} range Inserted range.
     * @returns {module:engine/conversion/modelconsumable~ModelConsumable} Values to consume.
     */

  }, {
    key: "_createInsertConsumable",
    value: function _createInsertConsumable(range) {
      var consumable = new modelconsumable_ModelConsumable();

      var _iterator10 = _createForOfIteratorHelper(range),
          _step10;

      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var value = _step10.value;
          var item = value.item;
          consumable.add(item, 'insert');

          var _iterator11 = _createForOfIteratorHelper(item.getAttributeKeys()),
              _step11;

          try {
            for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
              var key = _step11.value;
              consumable.add(item, 'attribute:' + key);
            }
          } catch (err) {
            _iterator11.e(err);
          } finally {
            _iterator11.f();
          }
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }

      return consumable;
    }
    /**
     * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with values to consume for given range.
     *
     * @private
     * @param {module:engine/model/range~Range} range Affected range.
     * @param {String} type Consumable type.
     * @returns {module:engine/conversion/modelconsumable~ModelConsumable} Values to consume.
     */

  }, {
    key: "_createConsumableForRange",
    value: function _createConsumableForRange(range, type) {
      var consumable = new modelconsumable_ModelConsumable();

      var _iterator12 = _createForOfIteratorHelper(range.getItems()),
          _step12;

      try {
        for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
          var item = _step12.value;
          consumable.add(item, type);
        }
      } catch (err) {
        _iterator12.e(err);
      } finally {
        _iterator12.f();
      }

      return consumable;
    }
    /**
     * Creates {@link module:engine/conversion/modelconsumable~ModelConsumable} with selection consumable values.
     *
     * @private
     * @param {module:engine/model/selection~Selection} selection Selection to create consumable from.
     * @param {Iterable.<module:engine/model/markercollection~Marker>} markers Markers which contains selection.
     * @returns {module:engine/conversion/modelconsumable~ModelConsumable} Values to consume.
     */

  }, {
    key: "_createSelectionConsumable",
    value: function _createSelectionConsumable(selection, markers) {
      var consumable = new modelconsumable_ModelConsumable();
      consumable.add(selection, 'selection');

      var _iterator13 = _createForOfIteratorHelper(markers),
          _step13;

      try {
        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
          var marker = _step13.value;
          consumable.add(selection, 'addMarker:' + marker.name);
        }
      } catch (err) {
        _iterator13.e(err);
      } finally {
        _iterator13.f();
      }

      var _iterator14 = _createForOfIteratorHelper(selection.getAttributeKeys()),
          _step14;

      try {
        for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
          var key = _step14.value;
          consumable.add(selection, 'attribute:' + key);
        }
      } catch (err) {
        _iterator14.e(err);
      } finally {
        _iterator14.f();
      }

      return consumable;
    }
    /**
     * Tests passed `consumable` to check whether given event can be fired and if so, fires it.
     *
     * @private
     * @fires insert
     * @fires attribute
     * @param {String} type Event type.
     * @param {Object} data Event data.
     */

  }, {
    key: "_testAndFire",
    value: function _testAndFire(type, data) {
      if (!this.conversionApi.consumable.test(data.item, type)) {
        // Do not fire event if the item was consumed.
        return;
      }

      var name = data.item.name || '$text';
      this.fire(type + ':' + name, data, this.conversionApi);
    }
    /**
     * Clears conversion API object.
     *
     * @private
     */

  }, {
    key: "_clearConversionApi",
    value: function _clearConversionApi() {
      delete this.conversionApi.writer;
      delete this.conversionApi.consumable;
    }
    /**
     * Fired for inserted nodes.
     *
     * `insert` is a namespace for a class of events. Names of actually called events follow this pattern:
     * `insert:name`. `name` is either `'$text'`, when {@link module:engine/model/text~Text a text node} has been inserted,
     * or {@link module:engine/model/element~Element#name name} of inserted element.
     *
     * This way listeners can either listen to a general `insert` event or specific event (for example `insert:paragraph`).
     *
     * @event insert
     * @param {Object} data Additional information about the change.
     * @param {module:engine/model/item~Item} data.item Inserted item.
     * @param {module:engine/model/range~Range} data.range Range spanning over inserted item.
     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface
     * to be used by callback, passed in `DowncastDispatcher` constructor.
     */

    /**
     * Fired for removed nodes.
     *
     * `remove` is a namespace for a class of events. Names of actually called events follow this pattern:
     * `remove:name`. `name` is either `'$text'`, when {@link module:engine/model/text~Text a text node} has been removed,
     * or the {@link module:engine/model/element~Element#name name} of removed element.
     *
     * This way listeners can either listen to a general `remove` event or specific event (for example `remove:paragraph`).
     *
     * @event remove
     * @param {Object} data Additional information about the change.
     * @param {module:engine/model/position~Position} data.position Position from which the node has been removed.
     * @param {Number} data.length Offset size of the removed node.
     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface
     * to be used by callback, passed in `DowncastDispatcher` constructor.
     */

    /**
     * Fired in the following cases:
     *
     * * when an attribute has been added, changed, or removed from a node,
     * * when a node with an attribute is inserted,
     * * when collapsed model selection attribute is converted.
     *
     * `attribute` is a namespace for a class of events. Names of actually called events follow this pattern:
     * `attribute:attributeKey:name`. `attributeKey` is the key of added/changed/removed attribute.
     * `name` is either `'$text'` if change was on {@link module:engine/model/text~Text a text node},
     * or the {@link module:engine/model/element~Element#name name} of element which attribute has changed.
     *
     * This way listeners can either listen to a general `attribute:bold` event or specific event (for example `attribute:src:image`).
     *
     * @event attribute
     * @param {Object} data Additional information about the change.
     * @param {module:engine/model/item~Item|module:engine/model/documentselection~DocumentSelection} data.item Changed item
     * or converted selection.
     * @param {module:engine/model/range~Range} data.range Range spanning over changed item or selection range.
     * @param {String} data.attributeKey Attribute key.
     * @param {*} data.attributeOldValue Attribute value before the change. This is `null` when selection attribute is converted.
     * @param {*} data.attributeNewValue New attribute value.
     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface
     * to be used by callback, passed in `DowncastDispatcher` constructor.
     */

    /**
     * Fired for {@link module:engine/model/selection~Selection selection} changes.
     *
     * @event selection
     * @param {module:engine/model/selection~Selection} selection Selection that is converted.
     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface
     * to be used by callback, passed in `DowncastDispatcher` constructor.
     */

    /**
     * Fired when a new marker is added to the model. Also fired when collapsed model selection that is inside marker is converted.
     *
     * `addMarker` is a namespace for a class of events. Names of actually called events follow this pattern:
     * `addMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,
     * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `addMarker:foo` or `addMarker:foo:abc` and
     * `addMarker:foo:bar` events.
     *
     * If the marker range is not collapsed:
     *
     * * the event is fired for each item in the marker range one by one,
     * * `conversionApi.consumable` includes each item of the marker range and the consumable value is same as event name.
     *
     * If the marker range is collapsed:
     *
     * * there is only one event,
     * * `conversionApi.consumable` includes marker range with event name.
     *
     * If selection inside a marker is converted:
     *
     * * there is only one event,
     * * `conversionApi.consumable` includes selection instance with event name.
     *
     * @event addMarker
     * @param {Object} data Additional information about the change.
     * @param {module:engine/model/item~Item|module:engine/model/selection~Selection} data.item Item inside the new marker or
     * the selection that is being converted.
     * @param {module:engine/model/range~Range} [data.range] Range spanning over converted item. Available only in marker conversion, if
     * the marker range was not collapsed.
     * @param {module:engine/model/range~Range} data.markerRange Marker range.
     * @param {String} data.markerName Marker name.
     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface
     * to be used by callback, passed in `DowncastDispatcher` constructor.
     */

    /**
     * Fired when marker is removed from the model.
     *
     * `removeMarker` is a namespace for a class of events. Names of actually called events follow this pattern:
     * `removeMarker:markerName`. By specifying certain marker names, you can make the events even more gradual. For example,
     * if markers are named `foo:abc`, `foo:bar`, then it is possible to listen to `removeMarker:foo` or `removeMarker:foo:abc` and
     * `removeMarker:foo:bar` events.
     *
     * @event removeMarker
     * @param {Object} data Additional information about the change.
     * @param {module:engine/model/range~Range} data.markerRange Marker range.
     * @param {String} data.markerName Marker name.
     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface
     * to be used by callback, passed in `DowncastDispatcher` constructor.
     */

  }]);

  return DowncastDispatcher;
}();


mix(downcastdispatcher_DowncastDispatcher, emittermixin); // Helper function, checks whether change of `marker` at `modelPosition` should be converted. Marker changes are not
// converted if they happen inside an element with custom conversion method.
//
// @param {module:engine/model/position~Position} modelPosition
// @param {module:engine/model/markercollection~Marker} marker
// @param {module:engine/conversion/mapper~Mapper} mapper
// @returns {Boolean}

function shouldMarkerChangeBeConverted(modelPosition, marker, mapper) {
  var range = marker.getRange();
  var ancestors = Array.from(modelPosition.getAncestors());
  ancestors.shift(); // Remove root element. It cannot be passed to `model.Range#containsItem`.

  ancestors.reverse();
  var hasCustomHandling = ancestors.some(function (element) {
    if (range.containsItem(element)) {
      var viewElement = mapper.toViewElement(element);
      return !!viewElement.getCustomProperty('addHighlight');
    }
  });
  return !hasCustomHandling;
}
/**
 * Conversion interface that is registered for given {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}
 * and is passed as one of parameters when {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher dispatcher}
 * fires it's events.
 *
 * @interface module:engine/conversion/downcastdispatcher~DowncastConversionApi
 */

/**
 * The {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} instance.
 *
 * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher} #dispatcher
 */

/**
 * Stores information about what parts of processed model item are still waiting to be handled. After a piece of model item
 * was converted, appropriate consumable value should be {@link module:engine/conversion/modelconsumable~ModelConsumable#consume consumed}.
 *
 * @member {module:engine/conversion/modelconsumable~ModelConsumable} #consumable
 */

/**
 * The {@link module:engine/conversion/mapper~Mapper} instance.
 *
 * @member {module:engine/conversion/mapper~Mapper} #mapper
 */

/**
 * The {@link module:engine/view/downcastwriter~DowncastWriter} instance used to manipulate data during conversion.
 *
 * @member {module:engine/view/downcastwriter~DowncastWriter} #writer
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/selection.js


















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/selection
 */







/**
 * Selection is a set of {@link module:engine/model/range~Range ranges}. It has a direction specified by its
 * {@link module:engine/model/selection~Selection#anchor anchor} and {@link module:engine/model/selection~Selection#focus focus}
 * (it can be {@link module:engine/model/selection~Selection#isBackward forward or backward}).
 * Additionally, selection may have its own attributes (think – whether text typed in in this selection
 * should have those attributes – e.g. whether you type a bolded text).
 *
 * @mixes module:utils/emittermixin~EmitterMixin
 */

var model_selection_Selection = /*#__PURE__*/function () {
  /**
   * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}
   * or creates an empty selection if no arguments were passed.
   *
   *		// Creates empty selection without ranges.
   *		const selection = writer.createSelection();
   *
   *		// Creates selection at the given range.
   *		const range = writer.createRange( start, end );
   *		const selection = writer.createSelection( range );
   *
   *		// Creates selection at the given ranges
   *		const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
   *		const selection = writer.createSelection( ranges );
   *
   *		// Creates selection from the other selection.
   *		// Note: It doesn't copies selection attributes.
   *		const otherSelection = writer.createSelection();
   *		const selection = writer.createSelection( otherSelection );
   *
   *		// Creates selection from the given document selection.
   *		// Note: It doesn't copies selection attributes.
   *		const documentSelection = model.document.selection;
   *		const selection = writer.createSelection( documentSelection );
   *
   *		// Creates selection at the given position.
   *		const position = writer.createPositionFromPath( root, path );
   *		const selection = writer.createSelection( position );
   *
   *		// Creates selection at the given offset in the given element.
   *		const paragraph = writer.createElement( 'paragraph' );
   *		const selection = writer.createSelection( paragraph, offset );
   *
   *		// Creates a range inside an {@link module:engine/model/element~Element element} which starts before the
   *		// first child of that element and ends after the last child of that element.
   *		const selection = writer.createSelection( paragraph, 'in' );
   *
   *		// Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends
   *		// just after the item.
   *		const selection = writer.createSelection( paragraph, 'on' );
   *
   * Selection's constructor allow passing additional options (`'backward'`) as the last argument.
   *
   *		// Creates backward selection.
   *		const selection = writer.createSelection( range, { backward: true } );
   *
   * @param {module:engine/model/selection~Selectable} selectable
   * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.
   * @param {Object} [options]
   * @param {Boolean} [options.backward] Sets this selection instance to be backward.
   */
  function Selection(selectable, placeOrOffset, options) {
    Object(classCallCheck["a" /* default */])(this, Selection);

    /**
     * Specifies whether the last added range was added as a backward or forward range.
     *
     * @private
     * @type {Boolean}
     */
    this._lastRangeBackward = false;
    /**
     * Stores selection ranges.
     *
     * @protected
     * @type {Array.<module:engine/model/range~Range>}
     */

    this._ranges = [];
    /**
     * List of attributes set on current selection.
     *
     * @protected
     * @type {Map.<String,*>}
     */

    this._attrs = new Map();

    if (selectable) {
      this.setTo(selectable, placeOrOffset, options);
    }
  }
  /**
   * Selection anchor. Anchor is the position from which the selection was started. If a user is making a selection
   * by dragging the mouse, the anchor is where the user pressed the mouse button (the beginning of the selection).
   *
   * Anchor and {@link #focus} define the direction of the selection, which is important
   * when expanding/shrinking selection. The focus moves, while the anchor should remain in the same place.
   *
   * Anchor is always set to the {@link module:engine/model/range~Range#start start} or
   * {@link module:engine/model/range~Range#end end} position of the last of selection's ranges. Whether it is
   * the `start` or `end` depends on the specified `options.backward`. See the {@link #setTo `setTo()`} method.
   *
   * May be set to `null` if there are no ranges in the selection.
   *
   * @see #focus
   * @readonly
   * @type {module:engine/model/position~Position|null}
   */


  Object(createClass["a" /* default */])(Selection, [{
    key: "isEqual",

    /**
     * Checks whether this selection is equal to the given selection. Selections are equal if they have the same directions,
     * the same number of ranges and all ranges from one selection equal to ranges from the another selection.
     *
     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} otherSelection
     * Selection to compare with.
     * @returns {Boolean} `true` if selections are equal, `false` otherwise.
     */
    value: function isEqual(otherSelection) {
      if (this.rangeCount != otherSelection.rangeCount) {
        return false;
      } else if (this.rangeCount === 0) {
        return true;
      }

      if (!this.anchor.isEqual(otherSelection.anchor) || !this.focus.isEqual(otherSelection.focus)) {
        return false;
      }

      var _iterator = _createForOfIteratorHelper(this._ranges),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var thisRange = _step.value;
          var found = false;

          var _iterator2 = _createForOfIteratorHelper(otherSelection._ranges),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var otherRange = _step2.value;

              if (thisRange.isEqual(otherRange)) {
                found = true;
                break;
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          if (!found) {
            return false;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return true;
    }
    /**
     * Returns an iterable object that iterates over copies of selection ranges.
     *
     * @returns {Iterable.<module:engine/model/range~Range>}
     */

  }, {
    key: "getRanges",
    value: /*#__PURE__*/regeneratorRuntime.mark(function getRanges() {
      var _iterator3, _step3, range;

      return regeneratorRuntime.wrap(function getRanges$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _iterator3 = _createForOfIteratorHelper(this._ranges);
              _context.prev = 1;

              _iterator3.s();

            case 3:
              if ((_step3 = _iterator3.n()).done) {
                _context.next = 9;
                break;
              }

              range = _step3.value;
              _context.next = 7;
              return new model_range_Range(range.start, range.end);

            case 7:
              _context.next = 3;
              break;

            case 9:
              _context.next = 14;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](1);

              _iterator3.e(_context.t0);

            case 14:
              _context.prev = 14;

              _iterator3.f();

              return _context.finish(14);

            case 17:
            case "end":
              return _context.stop();
          }
        }
      }, getRanges, this, [[1, 11, 14, 17]]);
    })
    /**
     * Returns a copy of the first range in the selection.
     * First range is the one which {@link module:engine/model/range~Range#start start} position
     * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges
     * (not to confuse with the first range added to the selection).
     *
     * Returns `null` if there are no ranges in selection.
     *
     * @returns {module:engine/model/range~Range|null}
     */

  }, {
    key: "getFirstRange",
    value: function getFirstRange() {
      var first = null;

      var _iterator4 = _createForOfIteratorHelper(this._ranges),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var range = _step4.value;

          if (!first || range.start.isBefore(first.start)) {
            first = range;
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      return first ? new model_range_Range(first.start, first.end) : null;
    }
    /**
     * Returns a copy of the last range in the selection.
     * Last range is the one which {@link module:engine/model/range~Range#end end} position
     * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most
     * recently added to the selection).
     *
     * Returns `null` if there are no ranges in selection.
     *
     * @returns {module:engine/model/range~Range|null}
     */

  }, {
    key: "getLastRange",
    value: function getLastRange() {
      var last = null;

      var _iterator5 = _createForOfIteratorHelper(this._ranges),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var range = _step5.value;

          if (!last || range.end.isAfter(last.end)) {
            last = range;
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return last ? new model_range_Range(last.start, last.end) : null;
    }
    /**
     * Returns the first position in the selection.
     * First position is the position that {@link module:engine/model/position~Position#isBefore is before}
     * any other position in the selection.
     *
     * Returns `null` if there are no ranges in selection.
     *
     * @returns {module:engine/model/position~Position|null}
     */

  }, {
    key: "getFirstPosition",
    value: function getFirstPosition() {
      var first = this.getFirstRange();
      return first ? first.start.clone() : null;
    }
    /**
     * Returns the last position in the selection.
     * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}
     * any other position in the selection.
     *
     * Returns `null` if there are no ranges in selection.
     *
     * @returns {module:engine/model/position~Position|null}
     */

  }, {
    key: "getLastPosition",
    value: function getLastPosition() {
      var lastRange = this.getLastRange();
      return lastRange ? lastRange.end.clone() : null;
    }
    /**
     * Sets this selection's ranges and direction to the specified location based on the given
     * {@link module:engine/model/selection~Selectable selectable}.
     *
     *		// Removes all selection's ranges.
     *		selection.setTo( null );
     *
     *		// Sets selection to the given range.
     *		const range = writer.createRange( start, end );
     *		selection.setTo( range );
     *
     *		// Sets selection to given ranges.
     *		const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
     *		selection.setTo( ranges );
     *
     *		// Sets selection to other selection.
     *		// Note: It doesn't copies selection attributes.
     *		const otherSelection = writer.createSelection();
     *		selection.setTo( otherSelection );
     *
     *		// Sets selection to the given document selection.
     *		// Note: It doesn't copies selection attributes.
     *		const documentSelection = new DocumentSelection( doc );
     *		selection.setTo( documentSelection );
     *
     *		// Sets collapsed selection at the given position.
     *		const position = writer.createPositionFromPath( root, path );
     *		selection.setTo( position );
     *
     *		// Sets collapsed selection at the position of the given node and an offset.
     *		selection.setTo( paragraph, offset );
     *
     * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of
    	 * that element and ends after the last child of that element.
     *
     *		selection.setTo( paragraph, 'in' );
     *
     * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.
     *
     *		selection.setTo( paragraph, 'on' );
     *
     * `Selection#setTo()`' method allow passing additional options (`backward`) as the last argument.
     *
     *		// Sets backward selection.
     *		const selection = writer.createSelection( range, { backward: true } );
     *
     * @param {module:engine/model/selection~Selectable} selectable
     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.
     * @param {Object} [options]
     * @param {Boolean} [options.backward] Sets this selection instance to be backward.
     */

  }, {
    key: "setTo",
    value: function setTo(selectable, placeOrOffset, options) {
      if (selectable === null) {
        this._setRanges([]);
      } else if (selectable instanceof Selection) {
        this._setRanges(selectable.getRanges(), selectable.isBackward);
      } else if (selectable && typeof selectable.getRanges == 'function') {
        // We assume that the selectable is a DocumentSelection.
        // It can't be imported here, because it would lead to circular imports.
        this._setRanges(selectable.getRanges(), selectable.isBackward);
      } else if (selectable instanceof model_range_Range) {
        this._setRanges([selectable], !!placeOrOffset && !!placeOrOffset.backward);
      } else if (selectable instanceof model_position_Position) {
        this._setRanges([new model_range_Range(selectable)]);
      } else if (selectable instanceof model_node_Node) {
        var backward = !!options && !!options.backward;
        var range;

        if (placeOrOffset == 'in') {
          range = model_range_Range._createIn(selectable);
        } else if (placeOrOffset == 'on') {
          range = model_range_Range._createOn(selectable);
        } else if (placeOrOffset !== undefined) {
          range = new model_range_Range(model_position_Position._createAt(selectable, placeOrOffset));
        } else {
          /**
           * selection.setTo requires the second parameter when the first parameter is a node.
           *
           * @error model-selection-setTo-required-second-parameter
           */
          throw new ckeditorerror["b" /* default */]('model-selection-setTo-required-second-parameter: ' + 'selection.setTo requires the second parameter when the first parameter is a node.', [this, selectable]);
        }

        this._setRanges([range], backward);
      } else if (isIterable(selectable)) {
        // We assume that the selectable is an iterable of ranges.
        this._setRanges(selectable, placeOrOffset && !!placeOrOffset.backward);
      } else {
        /**
         * Cannot set the selection to the given place.
         *
         * Invalid parameters were specified when setting the selection. Common issues:
         *
         * * A {@link module:engine/model/textproxy~TextProxy} instance was passed instead of
         * a real {@link module:engine/model/text~Text}.
         * * View nodes were passed instead of model nodes.
         * * `null`/`undefined` was passed.
         *
         * @error model-selection-setTo-not-selectable
         */
        throw new ckeditorerror["b" /* default */]('model-selection-setTo-not-selectable: Cannot set the selection to the given place.', [this, selectable]);
      }
    }
    /**
     * Replaces all ranges that were added to the selection with given array of ranges. Last range of the array
     * is treated like the last added range and is used to set {@link module:engine/model/selection~Selection#anchor} and
     * {@link module:engine/model/selection~Selection#focus}. Accepts a flag describing in which direction the selection is made.
     *
     * @protected
     * @fires change:range
     * @param {Iterable.<module:engine/model/range~Range>} newRanges Ranges to set.
     * @param {Boolean} [isLastBackward=false] Flag describing if last added range was selected forward - from start to end (`false`)
     * or backward - from end to start (`true`).
     */

  }, {
    key: "_setRanges",
    value: function _setRanges(newRanges) {
      var _this = this;

      var isLastBackward = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      newRanges = Array.from(newRanges); // Check whether there is any range in new ranges set that is different than all already added ranges.

      var anyNewRange = newRanges.some(function (newRange) {
        if (!(newRange instanceof model_range_Range)) {
          /**
           * Selection range set to an object that is not an instance of {@link module:engine/model/range~Range}.
           *
           * Only {@link module:engine/model/range~Range} instances can be used to set a selection.
           * Common mistakes leading to this error are:
           *
           * * using DOM `Range` object,
           * * incorrect CKEditor 5 installation with multiple `ckeditor5-engine` packages having different versions.
           *
           * @error model-selection-set-ranges-not-range
           */
          throw new ckeditorerror["b" /* default */]('model-selection-set-ranges-not-range: ' + 'Selection range set to an object that is not an instance of model.Range.', [_this, newRanges]);
        }

        return _this._ranges.every(function (oldRange) {
          return !oldRange.isEqual(newRange);
        });
      }); // Don't do anything if nothing changed.

      if (newRanges.length === this._ranges.length && !anyNewRange) {
        return;
      }

      this._removeAllRanges();

      var _iterator6 = _createForOfIteratorHelper(newRanges),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var range = _step6.value;

          this._pushRange(range);
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      this._lastRangeBackward = !!isLastBackward;
      this.fire('change:range', {
        directChange: true
      });
    }
    /**
     * Moves {@link module:engine/model/selection~Selection#focus} to the specified location.
     *
     * The location can be specified in the same form as
     * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.
     *
     * @fires change:range
     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition
     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when
     * first parameter is a {@link module:engine/model/item~Item model item}.
     */

  }, {
    key: "setFocus",
    value: function setFocus(itemOrPosition, offset) {
      if (this.anchor === null) {
        /**
         * Cannot set selection focus if there are no ranges in selection.
         *
         * @error model-selection-setFocus-no-ranges
         */
        throw new ckeditorerror["b" /* default */]('model-selection-setFocus-no-ranges: Cannot set selection focus if there are no ranges in selection.', [this, itemOrPosition]);
      }

      var newFocus = model_position_Position._createAt(itemOrPosition, offset);

      if (newFocus.compareWith(this.focus) == 'same') {
        return;
      }

      var anchor = this.anchor;

      if (this._ranges.length) {
        this._popRange();
      }

      if (newFocus.compareWith(anchor) == 'before') {
        this._pushRange(new model_range_Range(newFocus, anchor));

        this._lastRangeBackward = true;
      } else {
        this._pushRange(new model_range_Range(anchor, newFocus));

        this._lastRangeBackward = false;
      }

      this.fire('change:range', {
        directChange: true
      });
    }
    /**
     * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.
     *
     * @param {String} key Key of attribute to look for.
     * @returns {*} Attribute value or `undefined`.
     */

  }, {
    key: "getAttribute",
    value: function getAttribute(key) {
      return this._attrs.get(key);
    }
    /**
     * Returns iterable that iterates over this selection's attributes.
     *
     * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
     * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
     *
     * @returns {Iterable.<*>}
     */

  }, {
    key: "getAttributes",
    value: function getAttributes() {
      return this._attrs.entries();
    }
    /**
     * Returns iterable that iterates over this selection's attribute keys.
     *
     * @returns {Iterable.<String>}
     */

  }, {
    key: "getAttributeKeys",
    value: function getAttributeKeys() {
      return this._attrs.keys();
    }
    /**
     * Checks if the selection has an attribute for given key.
     *
     * @param {String} key Key of attribute to check.
     * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.
     */

  }, {
    key: "hasAttribute",
    value: function hasAttribute(key) {
      return this._attrs.has(key);
    }
    /**
     * Removes an attribute with given key from the selection.
     *
     * If given attribute was set on the selection, fires the {@link #event:change:range} event with
     * removed attribute key.
     *
     * @fires change:attribute
     * @param {String} key Key of attribute to remove.
     */

  }, {
    key: "removeAttribute",
    value: function removeAttribute(key) {
      if (this.hasAttribute(key)) {
        this._attrs.delete(key);

        this.fire('change:attribute', {
          attributeKeys: [key],
          directChange: true
        });
      }
    }
    /**
     * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.
     *
     * If the attribute value has changed, fires the {@link #event:change:range} event with
     * the attribute key.
     *
     * @fires change:attribute
     * @param {String} key Key of attribute to set.
     * @param {*} value Attribute value.
     */

  }, {
    key: "setAttribute",
    value: function setAttribute(key, value) {
      if (this.getAttribute(key) !== value) {
        this._attrs.set(key, value);

        this.fire('change:attribute', {
          attributeKeys: [key],
          directChange: true
        });
      }
    }
    /**
     * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only
     * one range in the selection, and that range contains exactly one element.
     * Returns `null` if there is no selected element.
     *
     * @returns {module:engine/model/element~Element|null}
     */

  }, {
    key: "getSelectedElement",
    value: function getSelectedElement() {
      if (this.rangeCount !== 1) {
        return null;
      }

      return this.getFirstRange().getContainedElement();
    }
    /**
     * Checks whether this object is of the given.
     *
     *		selection.is( 'selection' ); // -> true
     *		selection.is( 'model:selection' ); // -> true
     *
     *		selection.is( 'view:selection' ); // -> false
     *		selection.is( 'range' ); // -> false
     *
     * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.
     *
     * @param {String} type
     * @returns {Boolean}
     */

  }, {
    key: "is",
    value: function is(type) {
      return type === 'selection' || type === 'model:selection';
    }
    /**
     * Gets elements of type {@link module:engine/model/schema~Schema#isBlock "block"} touched by the selection.
     *
     * This method's result can be used for example to apply block styling to all blocks covered by this selection.
     *
     * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements
     * but will not return blocks nested in other blocks.
     *
     * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):
     *
     *		<paragraph>[a</paragraph>
     *		<blockQuote>
     *			<paragraph>b</paragraph>
     *		</blockQuote>
     *		<paragraph>c]d</paragraph>
     *
     * In this case the paragraph will also be returned, despite the collapsed selection:
     *
     *		<paragraph>[]a</paragraph>
     *
     * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:
     *
     *		[<blockA></blockA>
     *		<blockB>
     *			<blockC></blockC>
     *			<blockD></blockD>
     *		</blockB>
     *		<blockE></blockE>]
     *
     * If the selection is inside a block all the inner blocks (A & B) are returned:
     *
     * 		<block>
     *			<blockA>[a</blockA>
     * 			<blockB>b]</blockB>
     * 		</block>
     *
     * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective
     * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.
     *
     *		<paragraph>[a</paragraph>
     *		<paragraph>b</paragraph>
     *		<paragraph>]c</paragraph> // this block will not be returned
     *
     * @returns {Iterable.<module:engine/model/element~Element>}
     */

  }, {
    key: "getSelectedBlocks",
    value: /*#__PURE__*/regeneratorRuntime.mark(function getSelectedBlocks() {
      var visited, _iterator7, _step7, range, startBlock, _iterator8, _step8, value, block, endBlock;

      return regeneratorRuntime.wrap(function getSelectedBlocks$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              visited = new WeakSet();
              _iterator7 = _createForOfIteratorHelper(this.getRanges());
              _context2.prev = 2;

              _iterator7.s();

            case 4:
              if ((_step7 = _iterator7.n()).done) {
                _context2.next = 35;
                break;
              }

              range = _step7.value;
              // Get start block of range in case of a collapsed range.
              startBlock = getParentBlock(range.start, visited);

              if (!(startBlock && isTopBlockInRange(startBlock, range))) {
                _context2.next = 10;
                break;
              }

              _context2.next = 10;
              return startBlock;

            case 10:
              _iterator8 = _createForOfIteratorHelper(range.getWalker());
              _context2.prev = 11;

              _iterator8.s();

            case 13:
              if ((_step8 = _iterator8.n()).done) {
                _context2.next = 21;
                break;
              }

              value = _step8.value;
              block = value.item;

              if (!(value.type == 'elementEnd' && isUnvisitedTopBlock(block, visited, range))) {
                _context2.next = 19;
                break;
              }

              _context2.next = 19;
              return block;

            case 19:
              _context2.next = 13;
              break;

            case 21:
              _context2.next = 26;
              break;

            case 23:
              _context2.prev = 23;
              _context2.t0 = _context2["catch"](11);

              _iterator8.e(_context2.t0);

            case 26:
              _context2.prev = 26;

              _iterator8.f();

              return _context2.finish(26);

            case 29:
              endBlock = getParentBlock(range.end, visited); // #984. Don't return the end block if the range ends right at its beginning.

              if (!(endBlock && !range.end.isTouching(model_position_Position._createAt(endBlock, 0)) && isTopBlockInRange(endBlock, range))) {
                _context2.next = 33;
                break;
              }

              _context2.next = 33;
              return endBlock;

            case 33:
              _context2.next = 4;
              break;

            case 35:
              _context2.next = 40;
              break;

            case 37:
              _context2.prev = 37;
              _context2.t1 = _context2["catch"](2);

              _iterator7.e(_context2.t1);

            case 40:
              _context2.prev = 40;

              _iterator7.f();

              return _context2.finish(40);

            case 43:
            case "end":
              return _context2.stop();
          }
        }
      }, getSelectedBlocks, this, [[2, 37, 40, 43], [11, 23, 26, 29]]);
    })
    /**
     * Checks whether the selection contains the entire content of the given element. This means that selection must start
     * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position
     * touching the element's end.
     *
     * By default, this method will check whether the entire content of the selection's current root is selected.
     * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.
     *
     * @param {module:engine/model/element~Element} [element=this.anchor.root]
     * @returns {Boolean}
     */

  }, {
    key: "containsEntireContent",
    value: function containsEntireContent() {
      var element = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.anchor.root;

      var limitStartPosition = model_position_Position._createAt(element, 0);

      var limitEndPosition = model_position_Position._createAt(element, 'end');

      return limitStartPosition.isTouching(this.getFirstPosition()) && limitEndPosition.isTouching(this.getLastPosition());
    }
    /**
     * Adds given range to internal {@link #_ranges ranges array}. Throws an error
     * if given range is intersecting with any range that is already stored in this selection.
     *
     * @protected
     * @param {module:engine/model/range~Range} range Range to add.
     */

  }, {
    key: "_pushRange",
    value: function _pushRange(range) {
      this._checkRange(range);

      this._ranges.push(new model_range_Range(range.start, range.end));
    }
    /**
     * Checks if given range intersects with ranges that are already in the selection. Throws an error if it does.
     *
     * @protected
     * @param {module:engine/model/range~Range} range Range to check.
     */

  }, {
    key: "_checkRange",
    value: function _checkRange(range) {
      for (var i = 0; i < this._ranges.length; i++) {
        if (range.isIntersecting(this._ranges[i])) {
          /**
           * Trying to add a range that intersects with another range in the selection.
           *
           * @error model-selection-range-intersects
           * @param {module:engine/model/range~Range} addedRange Range that was added to the selection.
           * @param {module:engine/model/range~Range} intersectingRange Range in the selection that intersects with `addedRange`.
           */
          throw new ckeditorerror["b" /* default */]('model-selection-range-intersects: Trying to add a range that intersects with another range in the selection.', [this, range], {
            addedRange: range,
            intersectingRange: this._ranges[i]
          });
        }
      }
    }
    /**
     * Deletes ranges from internal range array. Uses {@link #_popRange _popRange} to
     * ensure proper ranges removal.
     *
     * @protected
     */

  }, {
    key: "_removeAllRanges",
    value: function _removeAllRanges() {
      while (this._ranges.length > 0) {
        this._popRange();
      }
    }
    /**
     * Removes most recently added range from the selection.
     *
     * @protected
     */

  }, {
    key: "_popRange",
    value: function _popRange() {
      this._ranges.pop();
    }
    /**
     * Fired when selection range(s) changed.
     *
     * @event change:range
     * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set
     * to `true` which indicates that the selection change was caused by a direct use of selection's API.
     * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its position
     * was directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was
     * changed because the structure of the model has been changed (which means an indirect change).
     * The indirect change does not occur in case of normal (detached) selections because they are "static" (as "not live")
     * which mean that they are not updated once the document changes.
     */

    /**
     * Fired when selection attribute changed.
     *
     * @event change:attribute
     * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set
     * to `true` which indicates that the selection change was caused by a direct use of selection's API.
     * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its attributes
     * were directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was
     * changed in the model and its attributes were refreshed (which means an indirect change).
     * The indirect change does not occur in case of normal (detached) selections because they are "static" (as "not live")
     * which mean that they are not updated once the document changes.
     * @param {Array.<String>} attributeKeys Array containing keys of attributes that changed.
     */

  }, {
    key: "anchor",
    get: function get() {
      if (this._ranges.length > 0) {
        var range = this._ranges[this._ranges.length - 1];
        return this._lastRangeBackward ? range.end : range.start;
      }

      return null;
    }
    /**
     * Selection focus. Focus is the position where the selection ends. If a user is making a selection
     * by dragging the mouse, the focus is where the mouse cursor is.
     *
     * May be set to `null` if there are no ranges in the selection.
     *
     * @see #anchor
     * @readonly
     * @type {module:engine/model/position~Position|null}
     */

  }, {
    key: "focus",
    get: function get() {
      if (this._ranges.length > 0) {
        var range = this._ranges[this._ranges.length - 1];
        return this._lastRangeBackward ? range.start : range.end;
      }

      return null;
    }
    /**
     * Whether the selection is collapsed. Selection is collapsed when there is exactly one range in it
     * and it is collapsed.
     *
     * @readonly
     * @type {Boolean}
     */

  }, {
    key: "isCollapsed",
    get: function get() {
      var length = this._ranges.length;

      if (length === 1) {
        return this._ranges[0].isCollapsed;
      } else {
        return false;
      }
    }
    /**
     * Returns the number of ranges in the selection.
     *
     * @readonly
     * @type {Number}
     */

  }, {
    key: "rangeCount",
    get: function get() {
      return this._ranges.length;
    }
    /**
     * Specifies whether the selection's {@link #focus} precedes the selection's {@link #anchor}.
     *
     * @readonly
     * @type {Boolean}
     */

  }, {
    key: "isBackward",
    get: function get() {
      return !this.isCollapsed && this._lastRangeBackward;
    }
  }]);

  return Selection;
}();


mix(model_selection_Selection, emittermixin); // Checks whether the given element extends $block in the schema and has a parent (is not a root).
// Marks it as already visited.

function isUnvisitedBlock(element, visited) {
  if (visited.has(element)) {
    return false;
  }

  visited.add(element);
  return element.root.document.model.schema.isBlock(element) && element.parent;
} // Checks if the given element is a $block was not previously visited and is a top block in a range.


function isUnvisitedTopBlock(element, visited, range) {
  return isUnvisitedBlock(element, visited) && isTopBlockInRange(element, range);
} // Finds the lowest element in position's ancestors which is a block.
// It will search until first ancestor that is a limit element.
// Marks all ancestors as already visited to not include any of them later on.


function getParentBlock(position, visited) {
  var element = position.parent;
  var schema = element.root.document.model.schema;
  var ancestors = position.parent.getAncestors({
    parentFirst: true,
    includeSelf: true
  });
  var hasParentLimit = false;
  var block = ancestors.find(function (element) {
    // Stop searching after first parent node that is limit element.
    if (hasParentLimit) {
      return false;
    }

    hasParentLimit = schema.isLimit(element);
    return !hasParentLimit && isUnvisitedBlock(element, visited);
  }); // Mark all ancestors of this position's parent, because find() might've stopped early and
  // the found block may be a child of another block.

  ancestors.forEach(function (element) {
    return visited.add(element);
  });
  return block;
} // Checks if the blocks is not nested in other block inside a range.
//
// @param {module:engine/model/element~Element} block Block to check.
// @param {module:engine/model/range~Range} range Range to check.


function isTopBlockInRange(block, range) {
  var parentBlock = findAncestorBlock(block);

  if (!parentBlock) {
    return true;
  } // Add loose flag to check as parentRange can be equal to range.


  var isParentInRange = range.containsRange(model_range_Range._createOn(parentBlock), true);
  return !isParentInRange;
} // Returns first ancestor block of a node.
//
// @param {module:engine/model/node~Node} node
// @returns {module:engine/model/node~Node|undefined}


function findAncestorBlock(node) {
  var schema = node.root.document.model.schema;
  var parent = node.parent;

  while (parent) {
    if (schema.isBlock(parent)) {
      return parent;
    }

    parent = parent.parent;
  }
}
/**
 * An entity that is used to set selection.
 *
 * See also {@link module:engine/model/selection~Selection#setTo}
 *
 * @typedef {
 *     module:engine/model/selection~Selection|
 *     module:engine/model/documentselection~DocumentSelection|
 *     module:engine/model/position~Position|
 *     module:engine/model/range~Range|
 *     module:engine/model/node~Node|
 *     Iterable.<module:engine/model/range~Range>|
 *     null
 * } module:engine/model/selection~Selectable
 */
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.starts-with.js
var es_string_starts_with = __webpack_require__("2ca0");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/liverange.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/liverange
 */



/**
 * `LiveRange` is a type of {@link module:engine/model/range~Range Range}
 * that updates itself as {@link module:engine/model/document~Document document}
 * is changed through operations. It may be used as a bookmark.
 *
 * **Note:** Be very careful when dealing with `LiveRange`. Each `LiveRange` instance bind events that might
 * have to be unbound. Use {@link module:engine/model/liverange~LiveRange#detach detach} whenever you don't need `LiveRange` anymore.
 */

var liverange_LiveRange = /*#__PURE__*/function (_Range) {
  Object(inherits["a" /* default */])(LiveRange, _Range);

  var _super = Object(createSuper["a" /* default */])(LiveRange);

  /**
   * Creates a live range.
   *
   * @see module:engine/model/range~Range
   */
  function LiveRange(start, end) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, LiveRange);

    _this = _super.call(this, start, end);
    bindWithDocument.call(Object(assertThisInitialized["a" /* default */])(_this));
    return _this;
  }
  /**
   * Unbinds all events previously bound by `LiveRange`. Use it whenever you don't need `LiveRange` instance
   * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
   * referring to it).
   */


  Object(createClass["a" /* default */])(LiveRange, [{
    key: "detach",
    value: function detach() {
      this.stopListening();
    }
    /**
     * Checks whether this object is of the given.
     *
     *		liveRange.is( 'range' ); // -> true
     *		liveRange.is( 'model:range' ); // -> true
     *		liveRange.is( 'liveRange' ); // -> true
     *		liveRange.is( 'model:liveRange' ); // -> true
     *
     *		liveRange.is( 'view:range' ); // -> false
     *		liveRange.is( 'documentSelection' ); // -> false
     *
     * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.
     *
     * @param {String} type
     * @returns {Boolean}
     */

  }, {
    key: "is",
    value: function is(type) {
      return type === 'liveRange' || type === 'model:liveRange' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
      type == 'range' || type === 'model:range';
    }
    /**
     * Creates a {@link module:engine/model/range~Range range instance} that is equal to this live range.
     *
     * @returns {module:engine/model/range~Range}
     */

  }, {
    key: "toRange",
    value: function toRange() {
      return new model_range_Range(this.start, this.end);
    }
    /**
     * Creates a `LiveRange` instance that is equal to the given range.
     *
     * @param {module:engine/model/range~Range} range
     * @returns {module:engine/model/liverange~LiveRange}
     */

  }], [{
    key: "fromRange",
    value: function fromRange(range) {
      return new LiveRange(range.start, range.end);
    }
    /**
     * @see module:engine/model/range~Range._createIn
     * @static
     * @protected
     * @method module:engine/model/liverange~LiveRange._createIn
     * @param {module:engine/model/element~Element} element
     * @returns {module:engine/model/liverange~LiveRange}
     */

    /**
     * @see module:engine/model/range~Range._createOn
     * @static
     * @protected
     * @method module:engine/model/liverange~LiveRange._createOn
     * @param {module:engine/model/element~Element} element
     * @returns {module:engine/model/liverange~LiveRange}
     */

    /**
     * @see module:engine/model/range~Range._createFromPositionAndShift
     * @static
     * @protected
     * @method module:engine/model/liverange~LiveRange._createFromPositionAndShift
     * @param {module:engine/model/position~Position} position
     * @param {Number} shift
     * @returns {module:engine/model/liverange~LiveRange}
     */

    /**
     * Fired when `LiveRange` instance boundaries have changed due to changes in the
     * {@link module:engine/model/document~Document document}.
     *
     * @event change:range
     * @param {module:engine/model/range~Range} oldRange Range with start and end position equal to start and end position of this live
     * range before it got changed.
     * @param {Object} data Object with additional information about the change.
     * @param {module:engine/model/position~Position|null} data.deletionPosition Source position for remove and merge changes.
     * Available if the range was moved to the graveyard root, `null` otherwise.
     */

    /**
     * Fired when `LiveRange` instance boundaries have not changed after a change in {@link module:engine/model/document~Document document}
     * but the change took place inside the range, effectively changing its content.
     *
     * @event change:content
     * @param {module:engine/model/range~Range} range Range with start and end position equal to start and end position of
     * change range.
     * @param {Object} data Object with additional information about the change.
     * @param {null} data.deletionPosition Due to the nature of this event, this property is always set to `null`. It is passed
     * for compatibility with the {@link module:engine/model/liverange~LiveRange#event:change:range} event.
     */

  }]);

  return LiveRange;
}(model_range_Range); // Binds this `LiveRange` to the {@link module:engine/model/document~Document document}
// that owns this range's {@link module:engine/model/range~Range#root root}.
//
// @private




function bindWithDocument() {
  var _this2 = this;

  this.listenTo(this.root.document.model, 'applyOperation', function (event, args) {
    var operation = args[0];

    if (!operation.isDocumentOperation) {
      return;
    }

    liverange_transform.call(_this2, operation);
  }, {
    priority: 'low'
  });
} // Updates this range accordingly to the updates applied to the model. Bases on change events.
//
// @private
// @param {module:engine/model/operation/operation~Operation} operation Executed operation.


function liverange_transform(operation) {
  // Transform the range by the operation. Join the result ranges if needed.
  var ranges = this.getTransformedByOperation(operation);

  var result = model_range_Range._createFromRanges(ranges);

  var boundariesChanged = !result.isEqual(this);
  var contentChanged = doesOperationChangeRangeContent(this, operation);
  var deletionPosition = null;

  if (boundariesChanged) {
    // If range boundaries have changed, fire `change:range` event.
    //
    if (result.root.rootName == '$graveyard') {
      // If the range was moved to the graveyard root, set `deletionPosition`.
      if (operation.type == 'remove') {
        deletionPosition = operation.sourcePosition;
      } else {
        // Merge operation.
        deletionPosition = operation.deletionPosition;
      }
    }

    var oldRange = this.toRange();
    this.start = result.start;
    this.end = result.end;
    this.fire('change:range', oldRange, {
      deletionPosition: deletionPosition
    });
  } else if (contentChanged) {
    // If range boundaries have not changed, but there was change inside the range, fire `change:content` event.
    this.fire('change:content', this.toRange(), {
      deletionPosition: deletionPosition
    });
  }
} // Checks whether given operation changes something inside the range (even if it does not change boundaries).
//
// @private
// @param {module:engine/model/range~Range} range Range to check.
// @param {module:engine/model/operation/operation~Operation} operation Executed operation.
// @returns {Boolean}


function doesOperationChangeRangeContent(range, operation) {
  switch (operation.type) {
    case 'insert':
      return range.containsPosition(operation.position);

    case 'move':
    case 'remove':
    case 'reinsert':
    case 'merge':
      return range.containsPosition(operation.sourcePosition) || range.start.isEqual(operation.sourcePosition) || range.containsPosition(operation.targetPosition);

    case 'split':
      return range.containsPosition(operation.splitPosition) || range.containsPosition(operation.insertionPosition);
  }

  return false;
}

mix(liverange_LiveRange, emittermixin);
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/documentselection.js

























/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/documentselection
 */










var storePrefix = 'selection:';
/**
 * `DocumentSelection` is a special selection which is used as the
 * {@link module:engine/model/document~Document#selection document's selection}.
 * There can be only one instance of `DocumentSelection` per document.
 *
 * Document selection can only be changed by using the {@link module:engine/model/writer~Writer} instance
 * inside the {@link module:engine/model/model~Model#change `change()`} block, as it provides a secure way to modify model.
 *
 * `DocumentSelection` is automatically updated upon changes in the {@link module:engine/model/document~Document document}
 * to always contain valid ranges. Its attributes are inherited from the text unless set explicitly.
 *
 * Differences between {@link module:engine/model/selection~Selection} and `DocumentSelection` are:
 * * there is always a range in `DocumentSelection` - even if no ranges were added there is a "default range"
 * present in the selection,
 * * ranges added to this selection updates automatically when the document changes,
 * * attributes of `DocumentSelection` are updated automatically according to selection ranges.
 *
 * Since `DocumentSelection` uses {@link module:engine/model/liverange~LiveRange live ranges}
 * and is updated when {@link module:engine/model/document~Document document}
 * changes, it cannot be set on {@link module:engine/model/node~Node nodes}
 * that are inside {@link module:engine/model/documentfragment~DocumentFragment document fragment}.
 * If you need to represent a selection in document fragment,
 * use {@link module:engine/model/selection~Selection Selection class} instead.
 *
 * @mixes module:utils/emittermixin~EmitterMixin
 */

var model_documentselection_DocumentSelection = /*#__PURE__*/function () {
  /**
   * Creates an empty live selection for given {@link module:engine/model/document~Document}.
   *
   * @param {module:engine/model/document~Document} doc Document which owns this selection.
   */
  function DocumentSelection(doc) {
    Object(classCallCheck["a" /* default */])(this, DocumentSelection);

    /**
     * Selection used internally by that class (`DocumentSelection` is a proxy to that selection).
     *
     * @protected
     */
    this._selection = new documentselection_LiveSelection(doc);

    this._selection.delegate('change:range').to(this);

    this._selection.delegate('change:attribute').to(this);

    this._selection.delegate('change:marker').to(this);
  }
  /**
   * Returns whether the selection is collapsed. Selection is collapsed when there is exactly one range which is
   * collapsed.
   *
   * @readonly
   * @type {Boolean}
   */


  Object(createClass["a" /* default */])(DocumentSelection, [{
    key: "getRanges",

    /**
     * Returns an iterable that iterates over copies of selection ranges.
     *
     * @returns {Iterable.<module:engine/model/range~Range>}
     */
    value: function getRanges() {
      return this._selection.getRanges();
    }
    /**
     * Returns the first position in the selection.
     * First position is the position that {@link module:engine/model/position~Position#isBefore is before}
     * any other position in the selection.
     *
     * Returns `null` if there are no ranges in selection.
     *
     * @returns {module:engine/model/position~Position|null}
     */

  }, {
    key: "getFirstPosition",
    value: function getFirstPosition() {
      return this._selection.getFirstPosition();
    }
    /**
     * Returns the last position in the selection.
     * Last position is the position that {@link module:engine/model/position~Position#isAfter is after}
     * any other position in the selection.
     *
     * Returns `null` if there are no ranges in selection.
     *
     * @returns {module:engine/model/position~Position|null}
     */

  }, {
    key: "getLastPosition",
    value: function getLastPosition() {
      return this._selection.getLastPosition();
    }
    /**
     * Returns a copy of the first range in the selection.
     * First range is the one which {@link module:engine/model/range~Range#start start} position
     * {@link module:engine/model/position~Position#isBefore is before} start position of all other ranges
     * (not to confuse with the first range added to the selection).
     *
     * Returns `null` if there are no ranges in selection.
     *
     * @returns {module:engine/model/range~Range|null}
     */

  }, {
    key: "getFirstRange",
    value: function getFirstRange() {
      return this._selection.getFirstRange();
    }
    /**
     * Returns a copy of the last range in the selection.
     * Last range is the one which {@link module:engine/model/range~Range#end end} position
     * {@link module:engine/model/position~Position#isAfter is after} end position of all other ranges (not to confuse with the range most
     * recently added to the selection).
     *
     * Returns `null` if there are no ranges in selection.
     *
     * @returns {module:engine/model/range~Range|null}
     */

  }, {
    key: "getLastRange",
    value: function getLastRange() {
      return this._selection.getLastRange();
    }
    /**
     * Gets elements of type {@link module:engine/model/schema~Schema#isBlock "block"} touched by the selection.
     *
     * This method's result can be used for example to apply block styling to all blocks covered by this selection.
     *
     * **Note:** `getSelectedBlocks()` returns blocks that are nested in other non-block elements
     * but will not return blocks nested in other blocks.
     *
     * In this case the function will return exactly all 3 paragraphs (note: `<blockQuote>` is not a block itself):
     *
     *		<paragraph>[a</paragraph>
     *		<blockQuote>
     *			<paragraph>b</paragraph>
     *		</blockQuote>
     *		<paragraph>c]d</paragraph>
     *
     * In this case the paragraph will also be returned, despite the collapsed selection:
     *
     *		<paragraph>[]a</paragraph>
     *
     * In such a scenario, however, only blocks A, B & E will be returned as blocks C & D are nested in block B:
     *
     *		[<blockA></blockA>
     *		<blockB>
     *			<blockC></blockC>
     *			<blockD></blockD>
     *		</blockB>
     *		<blockE></blockE>]
     *
     * If the selection is inside a block all the inner blocks (A & B) are returned:
     *
     * 		<block>
     *			<blockA>[a</blockA>
     * 			<blockB>b]</blockB>
     * 		</block>
     *
     * **Special case**: If a selection ends at the beginning of a block, that block is not returned as from user perspective
     * this block wasn't selected. See [#984](https://github.com/ckeditor/ckeditor5-engine/issues/984) for more details.
     *
     *		<paragraph>[a</paragraph>
     *		<paragraph>b</paragraph>
     *		<paragraph>]c</paragraph> // this block will not be returned
     *
     * @returns {Iterable.<module:engine/model/element~Element>}
     */

  }, {
    key: "getSelectedBlocks",
    value: function getSelectedBlocks() {
      return this._selection.getSelectedBlocks();
    }
    /**
     * Returns the selected element. {@link module:engine/model/element~Element Element} is considered as selected if there is only
     * one range in the selection, and that range contains exactly one element.
     * Returns `null` if there is no selected element.
     *
     * @returns {module:engine/model/element~Element|null}
     */

  }, {
    key: "getSelectedElement",
    value: function getSelectedElement() {
      return this._selection.getSelectedElement();
    }
    /**
     * Checks whether the selection contains the entire content of the given element. This means that selection must start
     * at a position {@link module:engine/model/position~Position#isTouching touching} the element's start and ends at position
     * touching the element's end.
     *
     * By default, this method will check whether the entire content of the selection's current root is selected.
     * Useful to check if e.g. the user has just pressed <kbd>Ctrl</kbd> + <kbd>A</kbd>.
     *
     * @param {module:engine/model/element~Element} [element=this.anchor.root]
     * @returns {Boolean}
     */

  }, {
    key: "containsEntireContent",
    value: function containsEntireContent(element) {
      return this._selection.containsEntireContent(element);
    }
    /**
     * Unbinds all events previously bound by document selection.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this._selection.destroy();
    }
    /**
     * Returns iterable that iterates over this selection's attribute keys.
     *
     * @returns {Iterable.<String>}
     */

  }, {
    key: "getAttributeKeys",
    value: function getAttributeKeys() {
      return this._selection.getAttributeKeys();
    }
    /**
     * Returns iterable that iterates over this selection's attributes.
     *
     * Attributes are returned as arrays containing two items. First one is attribute key and second is attribute value.
     * This format is accepted by native `Map` object and also can be passed in `Node` constructor.
     *
     * @returns {Iterable.<*>}
     */

  }, {
    key: "getAttributes",
    value: function getAttributes() {
      return this._selection.getAttributes();
    }
    /**
     * Gets an attribute value for given key or `undefined` if that attribute is not set on the selection.
     *
     * @param {String} key Key of attribute to look for.
     * @returns {*} Attribute value or `undefined`.
     */

  }, {
    key: "getAttribute",
    value: function getAttribute(key) {
      return this._selection.getAttribute(key);
    }
    /**
     * Checks if the selection has an attribute for given key.
     *
     * @param {String} key Key of attribute to check.
     * @returns {Boolean} `true` if attribute with given key is set on selection, `false` otherwise.
     */

  }, {
    key: "hasAttribute",
    value: function hasAttribute(key) {
      return this._selection.hasAttribute(key);
    }
    /**
     * Refreshes selection attributes and markers according to the current position in the model.
     */

  }, {
    key: "refresh",
    value: function refresh() {
      this._selection._updateMarkers();

      this._selection._updateAttributes(false);
    }
    /**
     * Checks whether this object is of the given type.
     *
     *		selection.is( 'selection' ); // -> true
     *		selection.is( 'documentSelection' ); // -> true
     *		selection.is( 'model:selection' ); // -> true
     *		selection.is( 'model:documentSelection' ); // -> true
     *
     *		selection.is( 'view:selection' ); // -> false
     *		selection.is( 'element' ); // -> false
     *		selection.is( 'node' ); // -> false
     *
     * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.
     *
     * @param {String} type
     * @returns {Boolean}
     */

  }, {
    key: "is",
    value: function is(type) {
      return type === 'selection' || type == 'model:selection' || type == 'documentSelection' || type == 'model:documentSelection';
    }
    /**
     * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.
     * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionFocus} method.
     *
     * The location can be specified in the same form as
     * {@link module:engine/model/writer~Writer#createPositionAt writer.createPositionAt()} parameters.
     *
     * @see module:engine/model/writer~Writer#setSelectionFocus
     * @protected
     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition
     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when
     * first parameter is a {@link module:engine/model/item~Item model item}.
     */

  }, {
    key: "_setFocus",
    value: function _setFocus(itemOrPosition, offset) {
      this._selection.setFocus(itemOrPosition, offset);
    }
    /**
     * Sets this selection's ranges and direction to the specified location based on the given
     * {@link module:engine/model/selection~Selectable selectable}.
     * Should be used only within the {@link module:engine/model/writer~Writer#setSelection} method.
     *
     * @see module:engine/model/writer~Writer#setSelection
     * @protected
     * @param {module:engine/model/selection~Selectable} selectable
     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.
     * @param {Object} [options]
     * @param {Boolean} [options.backward] Sets this selection instance to be backward.
     */

  }, {
    key: "_setTo",
    value: function _setTo(selectable, placeOrOffset, options) {
      this._selection.setTo(selectable, placeOrOffset, options);
    }
    /**
     * Sets attribute on the selection. If attribute with the same key already is set, it's value is overwritten.
     * Should be used only within the {@link module:engine/model/writer~Writer#setSelectionAttribute} method.
     *
     * @see module:engine/model/writer~Writer#setSelectionAttribute
     * @protected
     * @param {String} key Key of the attribute to set.
     * @param {*} value Attribute value.
     */

  }, {
    key: "_setAttribute",
    value: function _setAttribute(key, value) {
      this._selection.setAttribute(key, value);
    }
    /**
     * Removes an attribute with given key from the selection.
     * If the given attribute was set on the selection, fires the {@link module:engine/model/selection~Selection#event:change:range}
     * event with removed attribute key.
     * Should be used only within the {@link module:engine/model/writer~Writer#removeSelectionAttribute} method.
     *
     * @see module:engine/model/writer~Writer#removeSelectionAttribute
     * @protected
     * @param {String} key Key of the attribute to remove.
     */

  }, {
    key: "_removeAttribute",
    value: function _removeAttribute(key) {
      this._selection.removeAttribute(key);
    }
    /**
     * Returns an iterable that iterates through all selection attributes stored in current selection's parent.
     *
     * @protected
     * @returns {Iterable.<*>}
     */

  }, {
    key: "_getStoredAttributes",
    value: function _getStoredAttributes() {
      return this._selection._getStoredAttributes();
    }
    /**
     * Temporarily changes the gravity of the selection from the left to the right.
     *
     * The gravity defines from which direction the selection inherits its attributes. If it's the default left
     * gravity, the selection (after being moved by the the user) inherits attributes from its left hand side.
     * This method allows to temporarily override this behavior by forcing the gravity to the right.
     *
     * It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry
     * of the process.
     *
     * @see module:engine/model/writer~Writer#overrideSelectionGravity
     * @protected
     * @returns {String} The unique id which allows restoring the gravity.
     */

  }, {
    key: "_overrideGravity",
    value: function _overrideGravity() {
      return this._selection.overrideGravity();
    }
    /**
     * Restores the {@link ~DocumentSelection#_overrideGravity overridden gravity}.
     *
     * Restoring the gravity is only possible using the unique identifier returned by
     * {@link ~DocumentSelection#_overrideGravity}. Note that the gravity remains overridden as long as won't be restored
     * the same number of times it was overridden.
     *
     * @see module:engine/model/writer~Writer#restoreSelectionGravity
     * @protected
     * @param {String} uid The unique id returned by {@link #_overrideGravity}.
     */

  }, {
    key: "_restoreGravity",
    value: function _restoreGravity(uid) {
      this._selection.restoreGravity(uid);
    }
    /**
     * Generates and returns an attribute key for selection attributes store, basing on original attribute key.
     *
     * @protected
     * @param {String} key Attribute key to convert.
     * @returns {String} Converted attribute key, applicable for selection store.
     */

  }, {
    key: "isCollapsed",
    get: function get() {
      return this._selection.isCollapsed;
    }
    /**
     * Selection anchor. Anchor may be described as a position where the most recent part of the selection starts.
     * Together with {@link #focus} they define the direction of selection, which is important
     * when expanding/shrinking selection. Anchor is always {@link module:engine/model/range~Range#start start} or
     * {@link module:engine/model/range~Range#end end} position of the most recently added range.
     *
     * Is set to `null` if there are no ranges in selection.
     *
     * @see #focus
     * @readonly
     * @type {module:engine/model/position~Position|null}
     */

  }, {
    key: "anchor",
    get: function get() {
      return this._selection.anchor;
    }
    /**
     * Selection focus. Focus is a position where the selection ends.
     *
     * Is set to `null` if there are no ranges in selection.
     *
     * @see #anchor
     * @readonly
     * @type {module:engine/model/position~Position|null}
     */

  }, {
    key: "focus",
    get: function get() {
      return this._selection.focus;
    }
    /**
     * Returns number of ranges in selection.
     *
     * @readonly
     * @type {Number}
     */

  }, {
    key: "rangeCount",
    get: function get() {
      return this._selection.rangeCount;
    }
    /**
     * Describes whether `Documentselection` has own range(s) set, or if it is defaulted to
     * {@link module:engine/model/document~Document#_getDefaultRange document's default range}.
     *
     * @readonly
     * @type {Boolean}
     */

  }, {
    key: "hasOwnRange",
    get: function get() {
      return this._selection.hasOwnRange;
    }
    /**
     * Specifies whether the {@link #focus}
     * precedes {@link #anchor}.
     *
     * @readonly
     * @type {Boolean}
     */

  }, {
    key: "isBackward",
    get: function get() {
      return this._selection.isBackward;
    }
    /**
     * Describes whether the gravity is overridden (using {@link module:engine/model/writer~Writer#overrideSelectionGravity}) or not.
     *
     * Note that the gravity remains overridden as long as will not be restored the same number of times as it was overridden.
     *
     * @readonly
     * @returns {Boolean}
     */

  }, {
    key: "isGravityOverridden",
    get: function get() {
      return this._selection.isGravityOverridden;
    }
    /**
     * A collection of selection markers.
     * Marker is a selection marker when selection range is inside the marker range.
     *
     * @readonly
     * @type {module:utils/collection~Collection.<module:engine/model/markercollection~Marker>}
     */

  }, {
    key: "markers",
    get: function get() {
      return this._selection.markers;
    }
    /**
     * Used for the compatibility with the {@link module:engine/model/selection~Selection#isEqual} method.
     *
     * @protected
     */

  }, {
    key: "_ranges",
    get: function get() {
      return this._selection._ranges;
    }
  }], [{
    key: "_getStoreAttributeKey",
    value: function _getStoreAttributeKey(key) {
      return storePrefix + key;
    }
    /**
     * Checks whether the given attribute key is an attribute stored on an element.
     *
     * @protected
     * @param {String} key
     * @returns {Boolean}
     */

  }, {
    key: "_isStoreAttributeKey",
    value: function _isStoreAttributeKey(key) {
      return key.startsWith(storePrefix);
    }
  }]);

  return DocumentSelection;
}();


mix(model_documentselection_DocumentSelection, emittermixin);
/**
 * Fired when selection range(s) changed.
 *
 * @event change:range
 * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set
 * to `true` which indicates that the selection change was caused by a direct use of selection's API.
 * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its position
 * was directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was
 * changed because the structure of the model has been changed (which means an indirect change).
 * The indirect change does not occur in case of normal (detached) selections because they are "static" (as "not live")
 * which mean that they are not updated once the document changes.
 */

/**
 * Fired when selection attribute changed.
 *
 * @event change:attribute
 * @param {Boolean} directChange In case of {@link module:engine/model/selection~Selection} class it is always set
 * to `true` which indicates that the selection change was caused by a direct use of selection's API.
 * The {@link module:engine/model/documentselection~DocumentSelection}, however, may change because its attributes
 * were directly changed through the {@link module:engine/model/writer~Writer writer} or because its position was
 * changed in the model and its attributes were refreshed (which means an indirect change).
 * The indirect change does not occur in case of normal (detached) selections because they are "static" (as "not live")
 * which mean that they are not updated once the document changes.
 * @param {Array.<String>} attributeKeys Array containing keys of attributes that changed.
 */

/**
 * Fired when selection marker(s) changed.
 *
 * @event change:marker
 * @param {Boolean} directChange This is always set to `false` in case of `change:marker` event as there is no possibility
 * to change markers directly through {@link module:engine/model/documentselection~DocumentSelection} API.
 * See also {@link module:engine/model/documentselection~DocumentSelection#event:change:range} and
 * {@link module:engine/model/documentselection~DocumentSelection#event:change:attribute}.
 * @param {Array.<module:engine/model/markercollection~Marker>} oldMarkers Markers in which the selection was before the change.
 */
// `LiveSelection` is used internally by {@link module:engine/model/documentselection~DocumentSelection} and shouldn't be used directly.
//
// LiveSelection` is automatically updated upon changes in the {@link module:engine/model/document~Document document}
// to always contain valid ranges. Its attributes are inherited from the text unless set explicitly.
//
// Differences between {@link module:engine/model/selection~Selection} and `LiveSelection` are:
// * there is always a range in `LiveSelection` - even if no ranges were added there is a "default range"
// present in the selection,
// * ranges added to this selection updates automatically when the document changes,
// * attributes of `LiveSelection` are updated automatically according to selection ranges.
//
// @extends module:engine/model/selection~Selection
//

var documentselection_LiveSelection = /*#__PURE__*/function (_Selection) {
  Object(inherits["a" /* default */])(LiveSelection, _Selection);

  var _super = Object(createSuper["a" /* default */])(LiveSelection);

  // Creates an empty live selection for given {@link module:engine/model/document~Document}.
  // @param {module:engine/model/document~Document} doc Document which owns this selection.
  function LiveSelection(doc) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, LiveSelection);

    _this = _super.call(this); // List of selection markers.
    // Marker is a selection marker when selection range is inside the marker range.
    //
    // @type {module:utils/collection~Collection}

    _this.markers = new collection_Collection({
      idProperty: 'name'
    }); // Document which owns this selection.
    //
    // @protected
    // @member {module:engine/model/model~Model}

    _this._model = doc.model; // Document which owns this selection.
    //
    // @protected
    // @member {module:engine/model/document~Document}

    _this._document = doc; // Keeps mapping of attribute name to priority with which the attribute got modified (added/changed/removed)
    // last time. Possible values of priority are: `'low'` and `'normal'`.
    //
    // Priorities are used by internal `LiveSelection` mechanisms. All attributes set using `LiveSelection`
    // attributes API are set with `'normal'` priority.
    //
    // @private
    // @member {Map} module:engine/model/liveselection~LiveSelection#_attributePriority

    _this._attributePriority = new Map(); // Contains data required to fix ranges which have been moved to the graveyard.
    // @private
    // @member {Array} module:engine/model/liveselection~LiveSelection#_fixGraveyardRangesData

    _this._fixGraveyardRangesData = []; // Flag that informs whether the selection ranges have changed. It is changed on true when `LiveRange#change:range` event is fired.
    // @private
    // @member {Array} module:engine/model/liveselection~LiveSelection#_hasChangedRange

    _this._hasChangedRange = false; // Each overriding gravity adds an UID to the set and each removal removes it.
    // Gravity is overridden when there's at least one UID in the set.
    // Gravity is restored when the set is empty.
    // This is to prevent conflicts when gravity is overridden by more than one feature at the same time.
    // @private
    // @type {Set}

    _this._overriddenGravityRegister = new Set(); // Ensure selection is correct after each operation.

    _this.listenTo(_this._model, 'applyOperation', function (evt, args) {
      var operation = args[0];

      if (!operation.isDocumentOperation || operation.type == 'marker' || operation.type == 'rename' || operation.type == 'noop') {
        return;
      }

      while (_this._fixGraveyardRangesData.length) {
        var _this$_fixGraveyardRa = _this._fixGraveyardRangesData.shift(),
            liveRange = _this$_fixGraveyardRa.liveRange,
            sourcePosition = _this$_fixGraveyardRa.sourcePosition;

        _this._fixGraveyardSelection(liveRange, sourcePosition);
      }

      if (_this._hasChangedRange) {
        _this._hasChangedRange = false;

        _this.fire('change:range', {
          directChange: false
        });
      }
    }, {
      priority: 'lowest'
    }); // Ensure selection is correct and up to date after each range change.


    _this.on('change:range', function () {
      var _iterator = _createForOfIteratorHelper(_this.getRanges()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var range = _step.value;

          if (!_this._document._validateSelectionRange(range)) {
            /**
             * Range from {@link module:engine/model/documentselection~DocumentSelection document selection}
             * starts or ends at incorrect position.
             *
             * @error document-selection-wrong-position
             * @param {module:engine/model/range~Range} range
             */
            throw new ckeditorerror["b" /* default */]('document-selection-wrong-position: Range from document selection starts or ends at incorrect position.', Object(assertThisInitialized["a" /* default */])(_this), {
              range: range
            });
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }); // Update markers data stored by the selection after each marker change.


    _this.listenTo(_this._model.markers, 'update', function () {
      return _this._updateMarkers();
    }); // Ensure selection is up to date after each change block.


    _this.listenTo(_this._document, 'change', function (evt, batch) {
      clearAttributesStoredInElement(_this._model, batch);
    });

    return _this;
  }

  Object(createClass["a" /* default */])(LiveSelection, [{
    key: "destroy",
    // Unbinds all events previously bound by live selection.
    value: function destroy() {
      for (var i = 0; i < this._ranges.length; i++) {
        this._ranges[i].detach();
      }

      this.stopListening();
    }
  }, {
    key: "getRanges",
    value: /*#__PURE__*/regeneratorRuntime.mark(function getRanges() {
      return regeneratorRuntime.wrap(function getRanges$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (!this._ranges.length) {
                _context.next = 4;
                break;
              }

              return _context.delegateYield(get_get(Object(getPrototypeOf["a" /* default */])(LiveSelection.prototype), "getRanges", this).call(this), "t0", 2);

            case 2:
              _context.next = 6;
              break;

            case 4:
              _context.next = 6;
              return this._document._getDefaultRange();

            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, getRanges, this);
    })
  }, {
    key: "getFirstRange",
    value: function getFirstRange() {
      return get_get(Object(getPrototypeOf["a" /* default */])(LiveSelection.prototype), "getFirstRange", this).call(this) || this._document._getDefaultRange();
    }
  }, {
    key: "getLastRange",
    value: function getLastRange() {
      return get_get(Object(getPrototypeOf["a" /* default */])(LiveSelection.prototype), "getLastRange", this).call(this) || this._document._getDefaultRange();
    }
  }, {
    key: "setTo",
    value: function setTo(selectable, optionsOrPlaceOrOffset, options) {
      get_get(Object(getPrototypeOf["a" /* default */])(LiveSelection.prototype), "setTo", this).call(this, selectable, optionsOrPlaceOrOffset, options);

      this._updateAttributes(true);

      this._updateMarkers();
    }
  }, {
    key: "setFocus",
    value: function setFocus(itemOrPosition, offset) {
      get_get(Object(getPrototypeOf["a" /* default */])(LiveSelection.prototype), "setFocus", this).call(this, itemOrPosition, offset);

      this._updateAttributes(true);

      this._updateMarkers();
    }
  }, {
    key: "setAttribute",
    value: function setAttribute(key, value) {
      if (this._setAttribute(key, value)) {
        // Fire event with exact data.
        var attributeKeys = [key];
        this.fire('change:attribute', {
          attributeKeys: attributeKeys,
          directChange: true
        });
      }
    }
  }, {
    key: "removeAttribute",
    value: function removeAttribute(key) {
      if (this._removeAttribute(key)) {
        // Fire event with exact data.
        var attributeKeys = [key];
        this.fire('change:attribute', {
          attributeKeys: attributeKeys,
          directChange: true
        });
      }
    }
  }, {
    key: "overrideGravity",
    value: function overrideGravity() {
      var overrideUid = uid_uid(); // Remember that another overriding has been requested. It will need to be removed
      // before the gravity is to be restored.

      this._overriddenGravityRegister.add(overrideUid);

      if (this._overriddenGravityRegister.size === 1) {
        this._updateAttributes(true);
      }

      return overrideUid;
    }
  }, {
    key: "restoreGravity",
    value: function restoreGravity(uid) {
      if (!this._overriddenGravityRegister.has(uid)) {
        /**
         * Restoring gravity for an unknown UID is not possible. Make sure you are using a correct
         * UID obtained from the {@link module:engine/model/writer~Writer#overrideSelectionGravity} to restore.
         *
         * @error document-selection-gravity-wrong-restore
         * @param {String} uid The unique identifier returned by
         * {@link module:engine/model/documentselection~DocumentSelection#_overrideGravity}.
         */
        throw new ckeditorerror["b" /* default */]('document-selection-gravity-wrong-restore: Attempting to restore the selection gravity for an unknown UID.', this, {
          uid: uid
        });
      }

      this._overriddenGravityRegister.delete(uid); // Restore gravity only when all overriding have been restored.


      if (!this.isGravityOverridden) {
        this._updateAttributes(true);
      }
    }
  }, {
    key: "_popRange",
    value: function _popRange() {
      this._ranges.pop().detach();
    }
  }, {
    key: "_pushRange",
    value: function _pushRange(range) {
      var liveRange = this._prepareRange(range); // `undefined` is returned when given `range` is in graveyard root.


      if (liveRange) {
        this._ranges.push(liveRange);
      }
    } // Prepares given range to be added to selection. Checks if it is correct,
    // converts it to {@link module:engine/model/liverange~LiveRange LiveRange}
    // and sets listeners listening to the range's change event.
    //
    // @private
    // @param {module:engine/model/range~Range} range

  }, {
    key: "_prepareRange",
    value: function _prepareRange(range) {
      var _this2 = this;

      this._checkRange(range);

      if (range.root == this._document.graveyard) {
        // @if CK_DEBUG // console.warn( 'Trying to add a Range that is in the graveyard root. Range rejected.' );
        return;
      }

      var liveRange = liverange_LiveRange.fromRange(range);
      liveRange.on('change:range', function (evt, oldRange, data) {
        _this2._hasChangedRange = true; // If `LiveRange` is in whole moved to the graveyard, save necessary data. It will be fixed on `Model#applyOperation` event.

        if (liveRange.root == _this2._document.graveyard) {
          _this2._fixGraveyardRangesData.push({
            liveRange: liveRange,
            sourcePosition: data.deletionPosition
          });
        }
      });
      return liveRange;
    }
  }, {
    key: "_updateMarkers",
    value: function _updateMarkers() {
      var markers = [];
      var changed = false;

      var _iterator2 = _createForOfIteratorHelper(this._model.markers),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _marker2 = _step2.value;

          var markerRange = _marker2.getRange();

          var _iterator3 = _createForOfIteratorHelper(this.getRanges()),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var selectionRange = _step3.value;

              if (markerRange.containsRange(selectionRange, !selectionRange.isCollapsed)) {
                markers.push(_marker2);
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var oldMarkers = Array.from(this.markers);

      for (var _i = 0, _markers = markers; _i < _markers.length; _i++) {
        var marker = _markers[_i];

        if (!this.markers.has(marker)) {
          this.markers.add(marker);
          changed = true;
        }
      }

      for (var _i2 = 0, _Array$from = Array.from(this.markers); _i2 < _Array$from.length; _i2++) {
        var _marker = _Array$from[_i2];

        if (!markers.includes(_marker)) {
          this.markers.remove(_marker);
          changed = true;
        }
      }

      if (changed) {
        this.fire('change:marker', {
          oldMarkers: oldMarkers,
          directChange: false
        });
      }
    } // Updates this selection attributes according to its ranges and the {@link module:engine/model/document~Document model document}.
    //
    // @protected
    // @param {Boolean} clearAll
    // @fires change:attribute

  }, {
    key: "_updateAttributes",
    value: function _updateAttributes(clearAll) {
      var newAttributes = toMap(this._getSurroundingAttributes());
      var oldAttributes = toMap(this.getAttributes());

      if (clearAll) {
        // If `clearAll` remove all attributes and reset priorities.
        this._attributePriority = new Map();
        this._attrs = new Map();
      } else {
        // If not, remove only attributes added with `low` priority.
        var _iterator4 = _createForOfIteratorHelper(this._attributePriority),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var _step4$value = _slicedToArray(_step4.value, 2),
                key = _step4$value[0],
                priority = _step4$value[1];

            if (priority == 'low') {
              this._attrs.delete(key);

              this._attributePriority.delete(key);
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      }

      this._setAttributesTo(newAttributes); // Let's evaluate which attributes really changed.


      var changed = []; // First, loop through all attributes that are set on selection right now.
      // Check which of them are different than old attributes.

      var _iterator5 = _createForOfIteratorHelper(this.getAttributes()),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _step5$value = _slicedToArray(_step5.value, 2),
              newKey = _step5$value[0],
              newValue = _step5$value[1];

          if (!oldAttributes.has(newKey) || oldAttributes.get(newKey) !== newValue) {
            changed.push(newKey);
          }
        } // Then, check which of old attributes got removed.

      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      var _iterator6 = _createForOfIteratorHelper(oldAttributes),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var _step6$value = _slicedToArray(_step6.value, 1),
              oldKey = _step6$value[0];

          if (!this.hasAttribute(oldKey)) {
            changed.push(oldKey);
          }
        } // Fire event with exact data (fire only if anything changed).

      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      if (changed.length > 0) {
        this.fire('change:attribute', {
          attributeKeys: changed,
          directChange: false
        });
      }
    } // Internal method for setting `LiveSelection` attribute. Supports attribute priorities (through `directChange`
    // parameter).
    //
    // @private
    // @param {String} key Attribute key.
    // @param {*} value Attribute value.
    // @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change
    // is caused by `Batch` API.
    // @returns {Boolean} Whether value has changed.

  }, {
    key: "_setAttribute",
    value: function _setAttribute(key, value) {
      var directChange = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
      var priority = directChange ? 'normal' : 'low';

      if (priority == 'low' && this._attributePriority.get(key) == 'normal') {
        // Priority too low.
        return false;
      }

      var oldValue = get_get(Object(getPrototypeOf["a" /* default */])(LiveSelection.prototype), "getAttribute", this).call(this, key); // Don't do anything if value has not changed.


      if (oldValue === value) {
        return false;
      }

      this._attrs.set(key, value); // Update priorities map.


      this._attributePriority.set(key, priority);

      return true;
    } // Internal method for removing `LiveSelection` attribute. Supports attribute priorities (through `directChange`
    // parameter).
    //
    // NOTE: Even if attribute is not present in the selection but is provided to this method, it's priority will
    // be changed according to `directChange` parameter.
    //
    // @private
    // @param {String} key Attribute key.
    // @param {Boolean} [directChange=true] `true` if the change is caused by `Selection` API, `false` if change
    // is caused by `Batch` API.
    // @returns {Boolean} Whether attribute was removed. May not be true if such attributes didn't exist or the
    // existing attribute had higher priority.

  }, {
    key: "_removeAttribute",
    value: function _removeAttribute(key) {
      var directChange = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      var priority = directChange ? 'normal' : 'low';

      if (priority == 'low' && this._attributePriority.get(key) == 'normal') {
        // Priority too low.
        return false;
      } // Update priorities map.


      this._attributePriority.set(key, priority); // Don't do anything if value has not changed.


      if (!get_get(Object(getPrototypeOf["a" /* default */])(LiveSelection.prototype), "hasAttribute", this).call(this, key)) {
        return false;
      }

      this._attrs.delete(key);

      return true;
    } // Internal method for setting multiple `LiveSelection` attributes. Supports attribute priorities (through
    // `directChange` parameter).
    //
    // @private
    // @param {Map.<String,*>} attrs Iterable object containing attributes to be set.
    // @returns {Set.<String>} Changed attribute keys.

  }, {
    key: "_setAttributesTo",
    value: function _setAttributesTo(attrs) {
      var changed = new Set();

      var _iterator7 = _createForOfIteratorHelper(this.getAttributes()),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var _step7$value = _slicedToArray(_step7.value, 2),
              oldKey = _step7$value[0],
              oldValue = _step7$value[1];

          // Do not remove attribute if attribute with same key and value is about to be set.
          if (attrs.get(oldKey) === oldValue) {
            continue;
          } // All rest attributes will be removed so changed attributes won't change .


          this._removeAttribute(oldKey, false);
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }

      var _iterator8 = _createForOfIteratorHelper(attrs),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var _step8$value = _slicedToArray(_step8.value, 2),
              key = _step8$value[0],
              value = _step8$value[1];

          // Attribute may not be set because of attributes or because same key/value is already added.
          var gotAdded = this._setAttribute(key, value, false);

          if (gotAdded) {
            changed.add(key);
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }

      return changed;
    } // Returns an iterable that iterates through all selection attributes stored in current selection's parent.
    //
    // @protected
    // @returns {Iterable.<*>}

  }, {
    key: "_getStoredAttributes",
    value: /*#__PURE__*/regeneratorRuntime.mark(function _getStoredAttributes() {
      var selectionParent, _iterator9, _step9, key, realKey;

      return regeneratorRuntime.wrap(function _getStoredAttributes$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              selectionParent = this.getFirstPosition().parent;

              if (!(this.isCollapsed && selectionParent.isEmpty)) {
                _context2.next = 21;
                break;
              }

              _iterator9 = _createForOfIteratorHelper(selectionParent.getAttributeKeys());
              _context2.prev = 3;

              _iterator9.s();

            case 5:
              if ((_step9 = _iterator9.n()).done) {
                _context2.next = 13;
                break;
              }

              key = _step9.value;

              if (!key.startsWith(storePrefix)) {
                _context2.next = 11;
                break;
              }

              realKey = key.substr(storePrefix.length);
              _context2.next = 11;
              return [realKey, selectionParent.getAttribute(key)];

            case 11:
              _context2.next = 5;
              break;

            case 13:
              _context2.next = 18;
              break;

            case 15:
              _context2.prev = 15;
              _context2.t0 = _context2["catch"](3);

              _iterator9.e(_context2.t0);

            case 18:
              _context2.prev = 18;

              _iterator9.f();

              return _context2.finish(18);

            case 21:
            case "end":
              return _context2.stop();
          }
        }
      }, _getStoredAttributes, this, [[3, 15, 18, 21]]);
    }) // Checks model text nodes that are closest to the selection's first position and returns attributes of first
    // found element. If there are no text nodes in selection's first position parent, it returns selection
    // attributes stored in that parent.
    //
    // @private
    // @returns {Iterable.<*>} Collection of attributes.

  }, {
    key: "_getSurroundingAttributes",
    value: function _getSurroundingAttributes() {
      var position = this.getFirstPosition();
      var schema = this._model.schema;
      var attrs = null;

      if (!this.isCollapsed) {
        // 1. If selection is a range...
        var range = this.getFirstRange(); // ...look for a first character node in that range and take attributes from it.

        var _iterator10 = _createForOfIteratorHelper(range),
            _step10;

        try {
          for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
            var value = _step10.value;

            // If the item is an object, we don't want to get attributes from its children.
            if (value.item.is('element') && schema.isObject(value.item)) {
              break;
            }

            if (value.type == 'text') {
              attrs = value.item.getAttributes();
              break;
            }
          }
        } catch (err) {
          _iterator10.e(err);
        } finally {
          _iterator10.f();
        }
      } else {
        // 2. If the selection is a caret or the range does not contain a character node...
        var nodeBefore = position.textNode ? position.textNode : position.nodeBefore;
        var nodeAfter = position.textNode ? position.textNode : position.nodeAfter; // When gravity is overridden then don't take node before into consideration.

        if (!this.isGravityOverridden) {
          // ...look at the node before caret and take attributes from it if it is a character node.
          attrs = getAttrsIfCharacter(nodeBefore);
        } // 3. If not, look at the node after caret...


        if (!attrs) {
          attrs = getAttrsIfCharacter(nodeAfter);
        } // 4. If not, try to find the first character on the left, that is in the same node.
        // When gravity is overridden then don't take node before into consideration.


        if (!this.isGravityOverridden && !attrs) {
          var node = nodeBefore;

          while (node && !attrs) {
            node = node.previousSibling;
            attrs = getAttrsIfCharacter(node);
          }
        } // 5. If not found, try to find the first character on the right, that is in the same node.


        if (!attrs) {
          var _node = nodeAfter;

          while (_node && !attrs) {
            _node = _node.nextSibling;
            attrs = getAttrsIfCharacter(_node);
          }
        } // 6. If not found, selection should retrieve attributes from parent.


        if (!attrs) {
          attrs = this._getStoredAttributes();
        }
      }

      return attrs;
    } // Fixes a selection range after it ends up in graveyard root.
    //
    // @private
    // @param {module:engine/model/liverange~LiveRange} liveRange The range from selection, that ended up in the graveyard root.
    // @param {module:engine/model/position~Position} removedRangeStart Start position of a range which was removed.

  }, {
    key: "_fixGraveyardSelection",
    value: function _fixGraveyardSelection(liveRange, removedRangeStart) {
      // The start of the removed range is the closest position to the `liveRange` - the original selection range.
      // This is a good candidate for a fixed selection range.
      var positionCandidate = removedRangeStart.clone(); // Find a range that is a correct selection range and is closest to the start of removed range.

      var selectionRange = this._model.schema.getNearestSelectionRange(positionCandidate); // Remove the old selection range before preparing and adding new selection range. This order is important,
      // because new range, in some cases, may intersect with old range (it depends on `getNearestSelectionRange()` result).


      var index = this._ranges.indexOf(liveRange);

      this._ranges.splice(index, 1);

      liveRange.detach(); // If nearest valid selection range has been found - add it in the place of old range.
      // If range is equal to any other selection ranges then it is probably due to contents
      // of a multi-range selection being removed. See ckeditor/ckeditor5#6501.

      if (selectionRange && !isRangeCollidingWithSelection(selectionRange, this)) {
        // Check the range, convert it to live range, bind events, etc.
        var newRange = this._prepareRange(selectionRange); // Add new range in the place of old range.


        this._ranges.splice(index, 0, newRange);
      } // If nearest valid selection range cannot be found or is intersecting with other selection ranges removing the old range is fine.

    }
  }, {
    key: "isCollapsed",
    get: function get() {
      var length = this._ranges.length;
      return length === 0 ? this._document._getDefaultRange().isCollapsed : get_get(Object(getPrototypeOf["a" /* default */])(LiveSelection.prototype), "isCollapsed", this);
    }
  }, {
    key: "anchor",
    get: function get() {
      return get_get(Object(getPrototypeOf["a" /* default */])(LiveSelection.prototype), "anchor", this) || this._document._getDefaultRange().start;
    }
  }, {
    key: "focus",
    get: function get() {
      return get_get(Object(getPrototypeOf["a" /* default */])(LiveSelection.prototype), "focus", this) || this._document._getDefaultRange().end;
    }
  }, {
    key: "rangeCount",
    get: function get() {
      return this._ranges.length ? this._ranges.length : 1;
    } // Describes whether `LiveSelection` has own range(s) set, or if it is defaulted to
    // {@link module:engine/model/document~Document#_getDefaultRange document's default range}.
    //
    // @readonly
    // @type {Boolean}

  }, {
    key: "hasOwnRange",
    get: function get() {
      return this._ranges.length > 0;
    } // When set to `true` then selection attributes on node before the caret won't be taken
    // into consideration while updating selection attributes.
    //
    // @protected
    // @type {Boolean}

  }, {
    key: "isGravityOverridden",
    get: function get() {
      return !!this._overriddenGravityRegister.size;
    }
  }]);

  return LiveSelection;
}(model_selection_Selection); // Helper function for {@link module:engine/model/liveselection~LiveSelection#_updateAttributes}.
//
// It takes model item, checks whether it is a text node (or text proxy) and, if so, returns it's attributes. If not, returns `null`.
//
// @param {module:engine/model/item~Item|null}  node
// @returns {Boolean}


function getAttrsIfCharacter(node) {
  if (node instanceof model_textproxy_TextProxy || node instanceof model_text_Text) {
    return node.getAttributes();
  }

  return null;
} // Removes selection attributes from element which is not empty anymore.
//
// @param {module:engine/model/model~Model} model
// @param {module:engine/model/batch~Batch} batch


function clearAttributesStoredInElement(model, batch) {
  var differ = model.document.differ;

  var _iterator11 = _createForOfIteratorHelper(differ.getChanges()),
      _step11;

  try {
    var _loop = function _loop() {
      var entry = _step11.value;

      if (entry.type != 'insert') {
        return "continue";
      }

      var changeParent = entry.position.parent;
      var isNoLongerEmpty = entry.length === changeParent.maxOffset;

      if (isNoLongerEmpty) {
        model.enqueueChange(batch, function (writer) {
          var storedAttributes = Array.from(changeParent.getAttributeKeys()).filter(function (key) {
            return key.startsWith(storePrefix);
          });

          var _iterator12 = _createForOfIteratorHelper(storedAttributes),
              _step12;

          try {
            for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
              var key = _step12.value;
              writer.removeAttribute(key, changeParent);
            }
          } catch (err) {
            _iterator12.e(err);
          } finally {
            _iterator12.f();
          }
        });
      }
    };

    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }
  } catch (err) {
    _iterator11.e(err);
  } finally {
    _iterator11.f();
  }
} // Checks if range collides with any of selection ranges.


function isRangeCollidingWithSelection(range, selection) {
  return !selection._ranges.every(function (selectionRange) {
    return !range.isEqual(selectionRange);
  });
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/conversion/conversionhelpers.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/conversion/conversionhelpers
 */

/**
 * Base class for conversion helpers.
 */
var conversionhelpers_ConversionHelpers = /*#__PURE__*/function () {
  /**
   * Creates a conversion helpers instance.
   *
   * @param {Array.<module:engine/conversion/downcastdispatcher~DowncastDispatcher|
   * module:engine/conversion/upcastdispatcher~UpcastDispatcher>} dispatchers
   */
  function ConversionHelpers(dispatchers) {
    Object(classCallCheck["a" /* default */])(this, ConversionHelpers);

    this._dispatchers = dispatchers;
  }
  /**
   * Registers a conversion helper.
   *
   * **Note**: See full usage example in the `{@link module:engine/conversion/conversion~Conversion#for conversion.for()}`
   * method description.
   *
   * @param {Function} conversionHelper The function to be called on event.
   * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers|module:engine/conversion/upcasthelpers~UpcastHelpers}
   */


  Object(createClass["a" /* default */])(ConversionHelpers, [{
    key: "add",
    value: function add(conversionHelper) {
      var _iterator = _createForOfIteratorHelper(this._dispatchers),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var dispatcher = _step.value;
          conversionHelper(dispatcher);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return this;
    }
  }]);

  return ConversionHelpers;
}();


// CONCATENATED MODULE: ./node_modules/lodash-es/cloneDeep.js


/** Used to compose bitmasks for cloning. */
var cloneDeep_CLONE_DEEP_FLAG = 1,
    cloneDeep_CLONE_SYMBOLS_FLAG = 4;

/**
 * This method is like `_.clone` except that it recursively clones `value`.
 *
 * @static
 * @memberOf _
 * @since 1.0.0
 * @category Lang
 * @param {*} value The value to recursively clone.
 * @returns {*} Returns the deep cloned value.
 * @see _.clone
 * @example
 *
 * var objects = [{ 'a': 1 }, { 'b': 2 }];
 *
 * var deep = _.cloneDeep(objects);
 * console.log(deep[0] === objects[0]);
 * // => false
 */
function cloneDeep(value) {
  return _baseClone(value, cloneDeep_CLONE_DEEP_FLAG | cloneDeep_CLONE_SYMBOLS_FLAG);
}

/* harmony default export */ var lodash_es_cloneDeep = (cloneDeep);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/conversion/downcasthelpers.js













/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Contains downcast (model-to-view) converters for {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}.
 *
 * @module engine/conversion/downcasthelpers
 */








/**
 * Downcast conversion helper functions.
 *
 * @extends module:engine/conversion/conversionhelpers~ConversionHelpers
 */

var downcasthelpers_DowncastHelpers = /*#__PURE__*/function (_ConversionHelpers) {
  Object(inherits["a" /* default */])(DowncastHelpers, _ConversionHelpers);

  var _super = Object(createSuper["a" /* default */])(DowncastHelpers);

  function DowncastHelpers() {
    Object(classCallCheck["a" /* default */])(this, DowncastHelpers);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(DowncastHelpers, [{
    key: "elementToElement",

    /**
     * Model element to view element conversion helper.
     *
     * This conversion results in creating a view element. For example, model `<paragraph>Foo</paragraph>` becomes `<p>Foo</p>` in the view.
     *
     *		editor.conversion.for( 'downcast' ).elementToElement( {
     *			model: 'paragraph',
     *			view: 'p'
     *		} );
     *
     *		editor.conversion.for( 'downcast' ).elementToElement( {
     *			model: 'paragraph',
     *			view: 'div',
     *			converterPriority: 'high'
     *		} );
     *
     *		editor.conversion.for( 'downcast' ).elementToElement( {
     *			model: 'fancyParagraph',
     *			view: {
     *				name: 'p',
     *				classes: 'fancy'
     *			}
     *		} );
     *
     *		editor.conversion.for( 'downcast' ).elementToElement( {
     *			model: 'heading',
     *			view: ( modelElement, viewWriter ) => {
     *				return viewWriter.createContainerElement( 'h' + modelElement.getAttribute( 'level' ) )
     *			}
     *		} );
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * @method #elementToElement
     * @param {Object} config Conversion configuration.
     * @param {String} config.model The name of the model element to convert.
     * @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function
     * that takes the model element and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}
     * as parameters and returns a view container element.
     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}
     */
    value: function elementToElement(config) {
      return this.add(downcastElementToElement(config));
    }
    /**
     * Model attribute to view element conversion helper.
     *
     * This conversion results in wrapping view nodes with a view attribute element. For example, a model text node with
     * `"Foo"` as data and the `bold` attribute becomes `<strong>Foo</strong>` in the view.
     *
     *		editor.conversion.for( 'downcast' ).attributeToElement( {
     *			model: 'bold',
     *			view: 'strong'
     *		} );
     *
     *		editor.conversion.for( 'downcast' ).attributeToElement( {
     *			model: 'bold',
     *			view: 'b',
     *			converterPriority: 'high'
     *		} );
     *
     *		editor.conversion.for( 'downcast' ).attributeToElement( {
     *			model: 'invert',
     *			view: {
     *				name: 'span',
     *				classes: [ 'font-light', 'bg-dark' ]
     *			}
     *		} );
     *
     *		editor.conversion.for( 'downcast' ).attributeToElement( {
     *			model: {
     *				key: 'fontSize',
     *				values: [ 'big', 'small' ]
     *			},
     *			view: {
     *				big: {
     *					name: 'span',
     *					styles: {
     *						'font-size': '1.2em'
     *					}
     *				},
     *				small: {
     *					name: 'span',
     *					styles: {
     *						'font-size': '0.8em'
     *					}
     *				}
     *			}
     *		} );
     *
     *		editor.conversion.for( 'downcast' ).attributeToElement( {
     *			model: 'bold',
     *			view: ( modelAttributeValue, viewWriter ) => {
     *				return viewWriter.createAttributeElement( 'span', {
     *					style: 'font-weight:' + modelAttributeValue
     *				} );
     *			}
     *		} );
     *
     *		editor.conversion.for( 'downcast' ).attributeToElement( {
     *			model: {
     *				key: 'color',
     *				name: '$text'
     *			},
     *			view: ( modelAttributeValue, viewWriter ) => {
     *				return viewWriter.createAttributeElement( 'span', {
     *					style: 'color:' + modelAttributeValue
     *				} );
     *			}
     *		} );
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * @method #attributeToElement
     * @param {Object} config Conversion configuration.
     * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array
     * of `String`s with possible values if the model attribute is an enumerable.
     * @param {module:engine/view/elementdefinition~ElementDefinition|Function|Object} config.view A view element definition or a function
     * that takes the model attribute value and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}
     * as parameters and returns a view attribute element. If `config.model.values` is
     * given, `config.view` should be an object assigning values from `config.model.values` to view element definitions or functions.
     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.
     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}
     */

  }, {
    key: "attributeToElement",
    value: function attributeToElement(config) {
      return this.add(downcastAttributeToElement(config));
    }
    /**
     * Model attribute to view attribute conversion helper.
     *
     * This conversion results in adding an attribute to a view node, basing on an attribute from a model node. For example,
     * `<image src='foo.jpg'></image>` is converted to `<img src='foo.jpg'></img>`.
     *
     *		editor.conversion.for( 'downcast' ).attributeToAttribute( {
     *			model: 'source',
     *			view: 'src'
     *		} );
     *
     *		editor.conversion.for( 'downcast' ).attributeToAttribute( {
     *			model: 'source',
     *			view: 'href',
     *			converterPriority: 'high'
     *		} );
     *
     *		editor.conversion.for( 'downcast' ).attributeToAttribute( {
     *			model: {
     *				name: 'image',
     *				key: 'source'
     *			},
     *			view: 'src'
     *		} );
     *
     *		editor.conversion.for( 'downcast' ).attributeToAttribute( {
     *			model: {
     *				name: 'styled',
     *				values: [ 'dark', 'light' ]
     *			},
     *			view: {
     *				dark: {
     *					key: 'class',
     *					value: [ 'styled', 'styled-dark' ]
     *				},
     *				light: {
     *					key: 'class',
     *					value: [ 'styled', 'styled-light' ]
     *				}
     *			}
     *		} );
     *
     *		editor.conversion.for( 'downcast' ).attributeToAttribute( {
     *			model: 'styled',
     *			view: modelAttributeValue => ( { key: 'class', value: 'styled-' + modelAttributeValue } )
     *		} );
     *
     * **Note**: Downcasting to a style property requires providing `value` as an object:
     *
     *		editor.conversion.for( 'downcast' ).attributeToAttribute( {
     *			model: 'lineHeight',
     *			view: modelAttributeValue => ( {
     *				key: 'style',
     *				value: {
     *					'line-height': modelAttributeValue,
     *					'border-bottom': '1px dotted #ba2'
     *				}
     *			} )
     *		} );
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * @method #attributeToAttribute
     * @param {Object} config Conversion configuration.
     * @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing
     * the attribute key, possible values and, optionally, an element name to convert from.
     * @param {String|Object|Function} config.view A view attribute key, or a `{ key, value }` object or a function that takes
     * the model attribute value and returns a `{ key, value }` object. If `key` is `'class'`, `value` can be a `String` or an
     * array of `String`s. If `key` is `'style'`, `value` is an object with key-value pairs. In other cases, `value` is a `String`.
     * If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to
     * `{ key, value }` objects or a functions.
     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.
     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}
     */

  }, {
    key: "attributeToAttribute",
    value: function attributeToAttribute(config) {
      return this.add(downcastAttributeToAttribute(config));
    }
    /**
     * Model marker to view element conversion helper.
     *
     * This conversion results in creating a view element on the boundaries of the converted marker. If the converted marker
     * is collapsed, only one element is created. For example, model marker set like this: `<paragraph>F[oo b]ar</paragraph>`
     * becomes `<p>F<span data-marker="search"></span>oo b<span data-marker="search"></span>ar</p>` in the view.
     *
     *		editor.conversion.for( 'downcast' ).markerToElement( {
     *			model: 'search',
     *			view: 'marker-search'
     *		} );
     *
     *		editor.conversion.for( 'downcast' ).markerToElement( {
     *			model: 'search',
     *			view: 'search-result',
     *			converterPriority: 'high'
     *		} );
     *
     *		editor.conversion.for( 'downcast' ).markerToElement( {
     *			model: 'search',
     *			view: {
     *				name: 'span',
     *				attributes: {
     *					'data-marker': 'search'
     *				}
     *			}
     *		} );
     *
     *		editor.conversion.for( 'downcast' ).markerToElement( {
     *			model: 'search',
     *			view: ( markerData, viewWriter ) => {
     *				return viewWriter.createUIElement( 'span', {
     *					'data-marker': 'search',
     *					'data-start': markerData.isOpening
     *				} );
     *			}
     *		} );
     *
     * If a function is passed as the `config.view` parameter, it will be used to generate both boundary elements. The function
     * receives the `data` object as a parameter and should return an instance of the
     * {@link module:engine/view/uielement~UIElement view UI element}. The `data` object and
     * {@link module:engine/conversion/downcastdispatcher~DowncastConversionApi `conversionApi`} are passed from
     * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}. Additionally,
     * the `data.isOpening` parameter is passed, which is set to `true` for the marker start boundary element, and `false` to
     * the marker end boundary element.
     *
     * This kind of conversion is useful for saving data into the database, so it should be used in the data conversion pipeline.
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * @method #markerToElement
     * @param {Object} config Conversion configuration.
     * @param {String} config.model The name of the model marker (or model marker group) to convert.
     * @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function
     * that takes the model marker data as a parameter and returns a view UI element.
     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.
     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}
     */

  }, {
    key: "markerToElement",
    value: function markerToElement(config) {
      return this.add(downcastMarkerToElement(config));
    }
    /**
     * Model marker to highlight conversion helper.
     *
     * This conversion results in creating a highlight on view nodes. For this kind of conversion,
     * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} should be provided.
     *
     * For text nodes, a `<span>` {@link module:engine/view/attributeelement~AttributeElement} is created and it wraps all text nodes
     * in the converted marker range. For example, a model marker set like this: `<paragraph>F[oo b]ar</paragraph>` becomes
     * `<p>F<span class="comment">oo b</span>ar</p>` in the view.
     *
     * {@link module:engine/view/containerelement~ContainerElement} may provide a custom way of handling highlight. Most often,
     * the element itself is given classes and attributes described in the highlight descriptor (instead of being wrapped in `<span>`).
     * For example, a model marker set like this: `[<image src="foo.jpg"></image>]` becomes `<img src="foo.jpg" class="comment"></img>`
     * in the view.
     *
     * For container elements, the conversion is two-step. While the converter processes the highlight descriptor and passes it
     * to a container element, it is the container element instance itself that applies values from the highlight descriptor.
     * So, in a sense, the converter takes care of stating what should be applied on what, while the element decides how to apply that.
     *
     *		editor.conversion.for( 'downcast' ).markerToHighlight( { model: 'comment', view: { classes: 'comment' } } );
     *
     *		editor.conversion.for( 'downcast' ).markerToHighlight( {
     *			model: 'comment',
     *			view: { classes: 'new-comment' },
     *			converterPriority: 'high'
     *		} );
     *
     *		editor.conversion.for( 'downcast' ).markerToHighlight( {
     *			model: 'comment',
     *			view: data => {
     *				// Assuming that the marker name is in a form of comment:commentType.
     *				const commentType = data.markerName.split( ':' )[ 1 ];
     *
     *				return {
     *					classes: [ 'comment', 'comment-' + commentType ]
     *				};
     *			}
     *		} );
     *
     * If a function is passed as the `config.view` parameter, it will be used to generate the highlight descriptor. The function
     * receives the `data` object as a parameter and should return a
     * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor}.
     * The `data` object properties are passed from {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker}.
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * @method #markerToHighlight
     * @param {Object} config Conversion configuration.
     * @param {String} config.model The name of the model marker (or model marker group) to convert.
     * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor
     * that will be used for highlighting or a function that takes the model marker data as a parameter and returns a highlight descriptor.
     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.
     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers}
     */

  }, {
    key: "markerToHighlight",
    value: function markerToHighlight(config) {
      return this.add(downcastMarkerToHighlight(config));
    }
  }]);

  return DowncastHelpers;
}(conversionhelpers_ConversionHelpers);
/**
 * Function factory that creates a default downcast converter for text insertion changes.
 *
 * The converter automatically consumes the corresponding value from the consumables list and stops the event (see
 * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).
 *
 *		modelDispatcher.on( 'insert:$text', insertText() );
 *
 * @returns {Function} Insert text event converter.
 */



function downcasthelpers_insertText() {
  return function (evt, data, conversionApi) {
    if (!conversionApi.consumable.consume(data.item, 'insert')) {
      return;
    }

    var viewWriter = conversionApi.writer;
    var viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
    var viewText = viewWriter.createText(data.item.data);
    viewWriter.insert(viewPosition, viewText);
  };
}
/**
 * Function factory that creates a default downcast converter for node remove changes.
 *
 *		modelDispatcher.on( 'remove', remove() );
 *
 * @returns {Function} Remove event converter.
 */

function downcasthelpers_remove() {
  return function (evt, data, conversionApi) {
    // Find view range start position by mapping model position at which the remove happened.
    var viewStart = conversionApi.mapper.toViewPosition(data.position);
    var modelEnd = data.position.getShiftedBy(data.length);
    var viewEnd = conversionApi.mapper.toViewPosition(modelEnd, {
      isPhantom: true
    });
    var viewRange = conversionApi.writer.createRange(viewStart, viewEnd); // Trim the range to remove in case some UI elements are on the view range boundaries.

    var removed = conversionApi.writer.remove(viewRange.getTrimmed()); // After the range is removed, unbind all view elements from the model.
    // Range inside view document fragment is used to unbind deeply.

    var _iterator = _createForOfIteratorHelper(conversionApi.writer.createRangeIn(removed).getItems()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var child = _step.value;
        conversionApi.mapper.unbindViewElement(child);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  };
}
/**
 * Creates a `<span>` {@link module:engine/view/attributeelement~AttributeElement view attribute element} from the information
 * provided by the {@link module:engine/conversion/downcasthelpers~HighlightDescriptor highlight descriptor} object. If a priority
 * is not provided in the descriptor, the default priority will be used.
 *
 * @param {module:engine/view/downcastwriter~DowncastWriter} writer
 * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor
 * @returns {module:engine/view/attributeelement~AttributeElement}
 */

function createViewElementFromHighlightDescriptor(writer, descriptor) {
  var viewElement = writer.createAttributeElement('span', descriptor.attributes);

  if (descriptor.classes) {
    viewElement._addClass(descriptor.classes);
  }

  if (descriptor.priority) {
    viewElement._priority = descriptor.priority;
  }

  viewElement._id = descriptor.id;
  return viewElement;
}
/**
 * Function factory that creates a converter which converts a non-collapsed {@link module:engine/model/selection~Selection model selection}
 * to a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate
 * value from the `consumable` object and maps model positions from the selection to view positions.
 *
 *		modelDispatcher.on( 'selection', convertRangeSelection() );
 *
 * @returns {Function} Selection converter.
 */

function convertRangeSelection() {
  return function (evt, data, conversionApi) {
    var selection = data.selection;

    if (selection.isCollapsed) {
      return;
    }

    if (!conversionApi.consumable.consume(selection, 'selection')) {
      return;
    }

    var viewRanges = [];

    var _iterator2 = _createForOfIteratorHelper(selection.getRanges()),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var range = _step2.value;
        var viewRange = conversionApi.mapper.toViewRange(range);
        viewRanges.push(viewRange);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    conversionApi.writer.setSelection(viewRanges, {
      backward: selection.isBackward
    });
  };
}
/**
 * Function factory that creates a converter which converts a collapsed {@link module:engine/model/selection~Selection model selection} to
 * a {@link module:engine/view/documentselection~DocumentSelection view selection}. The converter consumes appropriate
 * value from the `consumable` object, maps the model selection position to the view position and breaks
 * {@link module:engine/view/attributeelement~AttributeElement attribute elements} at the selection position.
 *
 *		modelDispatcher.on( 'selection', convertCollapsedSelection() );
 *
 * An example of the view state before and after converting the collapsed selection:
 *
 *		   <p><strong>f^oo<strong>bar</p>
 *		-> <p><strong>f</strong>^<strong>oo</strong>bar</p>
 *
 * By breaking attribute elements like `<strong>`, the selection is in a correct element. Then, when the selection attribute is
 * converted, broken attributes might be merged again, or the position where the selection is may be wrapped
 * with different, appropriate attribute elements.
 *
 * See also {@link module:engine/conversion/downcasthelpers~clearAttributes} which does a clean-up
 * by merging attributes.
 *
 * @returns {Function} Selection converter.
 */

function convertCollapsedSelection() {
  return function (evt, data, conversionApi) {
    var selection = data.selection;

    if (!selection.isCollapsed) {
      return;
    }

    if (!conversionApi.consumable.consume(selection, 'selection')) {
      return;
    }

    var viewWriter = conversionApi.writer;
    var modelPosition = selection.getFirstPosition();
    var viewPosition = conversionApi.mapper.toViewPosition(modelPosition);
    var brokenPosition = viewWriter.breakAttributes(viewPosition);
    viewWriter.setSelection(brokenPosition);
  };
}
/**
 * Function factory that creates a converter which clears artifacts after the previous
 * {@link module:engine/model/selection~Selection model selection} conversion. It removes all empty
 * {@link module:engine/view/attributeelement~AttributeElement view attribute elements} and merges sibling attributes at all start and end
 * positions of all ranges.
 *
 *		   <p><strong>^</strong></p>
 *		-> <p>^</p>
 *
 *		   <p><strong>foo</strong>^<strong>bar</strong>bar</p>
 *		-> <p><strong>foo^bar<strong>bar</p>
 *
 *		   <p><strong>foo</strong><em>^</em><strong>bar</strong>bar</p>
 *		-> <p><strong>foo^bar<strong>bar</p>
 *
 * This listener should be assigned before any converter for the new selection:
 *
 *		modelDispatcher.on( 'selection', clearAttributes() );
 *
 * See {@link module:engine/conversion/downcasthelpers~convertCollapsedSelection}
 * which does the opposite by breaking attributes in the selection position.
 *
 * @returns {Function} Selection converter.
 */

function downcasthelpers_clearAttributes() {
  return function (evt, data, conversionApi) {
    var viewWriter = conversionApi.writer;
    var viewSelection = viewWriter.document.selection;

    var _iterator3 = _createForOfIteratorHelper(viewSelection.getRanges()),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var range = _step3.value;

        // Not collapsed selection should not have artifacts.
        if (range.isCollapsed) {
          // Position might be in the node removed by the view writer.
          if (range.end.parent.isAttached()) {
            conversionApi.writer.mergeAttributes(range.start);
          }
        }
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    viewWriter.setSelection(null);
  };
}
/**
 * Function factory that creates a converter which converts set/change/remove attribute changes from the model to the view.
 * It can also be used to convert selection attributes. In that case, an empty attribute element will be created and the
 * selection will be put inside it.
 *
 * Attributes from the model are converted to a view element that will be wrapping these view nodes that are bound to
 * model elements having the given attribute. This is useful for attributes like `bold` that may be set on text nodes in the model
 * but are represented as an element in the view:
 *
 *		[paragraph]              MODEL ====> VIEW        <p>
 *			|- a {bold: true}                             |- <b>
 *			|- b {bold: true}                             |   |- ab
 *			|- c                                          |- c
 *
 * Passed `Function` will be provided with the attribute value and then all the parameters of the
 * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute `attribute` event}.
 * It is expected that the function returns an {@link module:engine/view/element~Element}.
 * The result of the function will be the wrapping element.
 * When the provided `Function` does not return any element, no conversion will take place.
 *
 * The converter automatically consumes the corresponding value from the consumables list and stops the event (see
 * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).
 *
 *		modelDispatcher.on( 'attribute:bold', wrap( ( modelAttributeValue, viewWriter ) => {
 *			return viewWriter.createAttributeElement( 'strong' );
 *		} );
 *
 * @protected
 * @param {Function} elementCreator Function returning a view element that will be used for wrapping.
 * @returns {Function} Set/change attribute converter.
 */

function downcasthelpers_wrap(elementCreator) {
  return function (evt, data, conversionApi) {
    // Recreate current wrapping node. It will be used to unwrap view range if the attribute value has changed
    // or the attribute was removed.
    var oldViewElement = elementCreator(data.attributeOldValue, conversionApi.writer); // Create node to wrap with.

    var newViewElement = elementCreator(data.attributeNewValue, conversionApi.writer);

    if (!oldViewElement && !newViewElement) {
      return;
    }

    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }

    var viewWriter = conversionApi.writer;
    var viewSelection = viewWriter.document.selection;

    if (data.item instanceof model_selection_Selection || data.item instanceof model_documentselection_DocumentSelection) {
      // Selection attribute conversion.
      viewWriter.wrap(viewSelection.getFirstRange(), newViewElement);
    } else {
      // Node attribute conversion.
      var viewRange = conversionApi.mapper.toViewRange(data.range); // First, unwrap the range from current wrapper.

      if (data.attributeOldValue !== null && oldViewElement) {
        viewRange = viewWriter.unwrap(viewRange, oldViewElement);
      }

      if (data.attributeNewValue !== null && newViewElement) {
        viewWriter.wrap(viewRange, newViewElement);
      }
    }
  };
}
/**
 * Function factory that creates a converter which converts node insertion changes from the model to the view.
 * The function passed will be provided with all the parameters of the dispatcher's
 * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert `insert` event}.
 * It is expected that the function returns an {@link module:engine/view/element~Element}.
 * The result of the function will be inserted into the view.
 *
 * The converter automatically consumes the corresponding value from the consumables list, stops the event (see
 * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}) and binds the model and view elements.
 *
 *		downcastDispatcher.on(
 *			'insert:myElem',
 *			insertElement( ( modelItem, viewWriter ) => {
 *				const text = viewWriter.createText( 'myText' );
 *				const myElem = viewWriter.createElement( 'myElem', { myAttr: 'my-' + modelItem.getAttribute( 'myAttr' ) }, text );
 *
 *				// Do something fancy with `myElem` using `modelItem` or other parameters.
 *
 *				return myElem;
 *			}
 *		) );
 *
 * @protected
 * @param {Function} elementCreator Function returning a view element, which will be inserted.
 * @returns {Function} Insert element event converter.
 */

function downcasthelpers_insertElement(elementCreator) {
  return function (evt, data, conversionApi) {
    var viewElement = elementCreator(data.item, conversionApi.writer);

    if (!viewElement) {
      return;
    }

    if (!conversionApi.consumable.consume(data.item, 'insert')) {
      return;
    }

    var viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
    conversionApi.mapper.bindElements(data.item, viewElement);
    conversionApi.writer.insert(viewPosition, viewElement);
  };
}
/**
 * Function factory that creates a converter which converts marker adding change to the
 * {@link module:engine/view/uielement~UIElement view UI element}.
 *
 * The view UI element that will be added to the view depends on the passed parameter. See {@link ~insertElement}.
 * In case of a non-collapsed range, the UI element will not wrap nodes but separate elements will be placed at the beginning
 * and at the end of the range.
 *
 * This converter binds created UI elements with the marker name using {@link module:engine/conversion/mapper~Mapper#bindElementToMarker}.
 *
 * @protected
 * @param {module:engine/view/uielement~UIElement|Function} elementCreator A view UI element or a function returning the view element
 * that will be inserted.
 * @returns {Function} Insert element event converter.
 */

function insertUIElement(elementCreator) {
  return function (evt, data, conversionApi) {
    // Create two view elements. One will be inserted at the beginning of marker, one at the end.
    // If marker is collapsed, only "opening" element will be inserted.
    data.isOpening = true;
    var viewStartElement = elementCreator(data, conversionApi.writer);
    data.isOpening = false;
    var viewEndElement = elementCreator(data, conversionApi.writer);

    if (!viewStartElement || !viewEndElement) {
      return;
    }

    var markerRange = data.markerRange; // Marker that is collapsed has consumable build differently that non-collapsed one.
    // For more information see `addMarker` event description.
    // If marker's range is collapsed - check if it can be consumed.

    if (markerRange.isCollapsed && !conversionApi.consumable.consume(markerRange, evt.name)) {
      return;
    } // If marker's range is not collapsed - consume all items inside.


    var _iterator4 = _createForOfIteratorHelper(markerRange),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var value = _step4.value;

        if (!conversionApi.consumable.consume(value.item, evt.name)) {
          return;
        }
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }

    var mapper = conversionApi.mapper;
    var viewWriter = conversionApi.writer; // Add "opening" element.

    viewWriter.insert(mapper.toViewPosition(markerRange.start), viewStartElement);
    conversionApi.mapper.bindElementToMarker(viewStartElement, data.markerName); // Add "closing" element only if range is not collapsed.

    if (!markerRange.isCollapsed) {
      viewWriter.insert(mapper.toViewPosition(markerRange.end), viewEndElement);
      conversionApi.mapper.bindElementToMarker(viewEndElement, data.markerName);
    }

    evt.stop();
  };
} // Function factory that returns a default downcast converter for removing a {@link module:engine/view/uielement~UIElement UI element}
// basing on marker remove change.
//
// This converter unbinds elements from the marker name.
//
// @returns {Function} Removed UI element converter.

function removeUIElement() {
  return function (evt, data, conversionApi) {
    var elements = conversionApi.mapper.markerNameToElements(data.markerName);

    if (!elements) {
      return;
    }

    var _iterator5 = _createForOfIteratorHelper(elements),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var element = _step5.value;
        conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);
        conversionApi.writer.clear(conversionApi.writer.createRangeOn(element), element);
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }

    conversionApi.writer.clearClonedElementsGroup(data.markerName);
    evt.stop();
  };
} // Function factory that creates a converter which converts set/change/remove attribute changes from the model to the view.
//
// Attributes from the model are converted to the view element attributes in the view. You may provide a custom function to generate
// a key-value attribute pair to add/change/remove. If not provided, model attributes will be converted to view element
// attributes on a one-to-one basis.
//
// *Note:** The provided attribute creator should always return the same `key` for a given attribute from the model.
//
// The converter automatically consumes the corresponding value from the consumables list and stops the event (see
// {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher}).
//
//		modelDispatcher.on( 'attribute:customAttr:myElem', changeAttribute( ( value, data ) => {
//			// Change attribute key from `customAttr` to `class` in the view.
//			const key = 'class';
//			let value = data.attributeNewValue;
//
//			// Force attribute value to 'empty' if the model element is empty.
//			if ( data.item.childCount === 0 ) {
//				value = 'empty';
//			}
//
//			// Return the key-value pair.
//			return { key, value };
//		} ) );
//
// @param {Function} [attributeCreator] Function returning an object with two properties: `key` and `value`, which
// represent the attribute key and attribute value to be set on a {@link module:engine/view/element~Element view element}.
// The function is passed the model attribute value as the first parameter and additional data about the change as the second parameter.
// @returns {Function} Set/change attribute converter.


function changeAttribute(attributeCreator) {
  return function (evt, data, conversionApi) {
    var oldAttribute = attributeCreator(data.attributeOldValue, data);
    var newAttribute = attributeCreator(data.attributeNewValue, data);

    if (!oldAttribute && !newAttribute) {
      return;
    }

    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }

    var viewElement = conversionApi.mapper.toViewElement(data.item);
    var viewWriter = conversionApi.writer; // If model item cannot be mapped to a view element, it means item is not an `Element` instance but a `TextProxy` node.
    // Only elements can have attributes in a view so do not proceed for anything else (#1587).

    if (!viewElement) {
      /**
       * This error occurs when a {@link module:engine/model/textproxy~TextProxy text node's} attribute is to be downcasted
       * by {@link module:engine/conversion/conversion~Conversion#attributeToAttribute `Attribute to Attribute converter`}.
       * In most cases it is caused by converters misconfiguration when only "generic" converter is defined:
       *
       *		editor.conversion.for( 'downcast' ).attributeToAttribute( {
       *			model: 'attribute-name',
       *			view: 'attribute-name'
       *		} ) );
       *
       * and given attribute is used on text node, for example:
       *
       *		model.change( writer => {
       *			writer.insertText( 'Foo', { 'attribute-name': 'bar' }, parent, 0 );
       *		} );
       *
       * In such cases, to convert the same attribute for both {@link module:engine/model/element~Element}
       * and {@link module:engine/model/textproxy~TextProxy `Text`} nodes, text specific
       * {@link module:engine/conversion/conversion~Conversion#attributeToElement `Attribute to Element converter`}
       * with higher {@link module:utils/priorities~PriorityString priority} must also be defined:
       *
       *		editor.conversion.for( 'downcast' ).attributeToElement( {
       *			model: {
       *				key: 'attribute-name',
       *				name: '$text'
       *			},
       *			view: ( value, writer ) => {
       *				return writer.createAttributeElement( 'span', { 'attribute-name': value } );
       *			},
       *			converterPriority: 'high'
       *		} ) );
       *
       * @error conversion-attribute-to-attribute-on-text
       */
      throw new ckeditorerror["b" /* default */]('conversion-attribute-to-attribute-on-text: ' + 'Trying to convert text node\'s attribute with attribute-to-attribute converter.', [data, conversionApi]);
    } // First remove the old attribute if there was one.


    if (data.attributeOldValue !== null && oldAttribute) {
      if (oldAttribute.key == 'class') {
        var classes = Array.isArray(oldAttribute.value) ? oldAttribute.value : [oldAttribute.value];

        var _iterator6 = _createForOfIteratorHelper(classes),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var className = _step6.value;
            viewWriter.removeClass(className, viewElement);
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
      } else if (oldAttribute.key == 'style') {
        var keys = Object.keys(oldAttribute.value);

        for (var _i = 0, _keys = keys; _i < _keys.length; _i++) {
          var key = _keys[_i];
          viewWriter.removeStyle(key, viewElement);
        }
      } else {
        viewWriter.removeAttribute(oldAttribute.key, viewElement);
      }
    } // Then set the new attribute.


    if (data.attributeNewValue !== null && newAttribute) {
      if (newAttribute.key == 'class') {
        var _classes = Array.isArray(newAttribute.value) ? newAttribute.value : [newAttribute.value];

        var _iterator7 = _createForOfIteratorHelper(_classes),
            _step7;

        try {
          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
            var _className = _step7.value;
            viewWriter.addClass(_className, viewElement);
          }
        } catch (err) {
          _iterator7.e(err);
        } finally {
          _iterator7.f();
        }
      } else if (newAttribute.key == 'style') {
        var _keys2 = Object.keys(newAttribute.value);

        for (var _i2 = 0, _keys3 = _keys2; _i2 < _keys3.length; _i2++) {
          var _key = _keys3[_i2];
          viewWriter.setStyle(_key, newAttribute.value[_key], viewElement);
        }
      } else {
        viewWriter.setAttribute(newAttribute.key, newAttribute.value, viewElement);
      }
    }
  };
} // Function factory that creates a converter which converts the text inside marker's range. The converter wraps the text with
// {@link module:engine/view/attributeelement~AttributeElement} created from the provided descriptor.
// See {link module:engine/conversion/downcasthelpers~createViewElementFromHighlightDescriptor}.
//
// It can also be used to convert the selection that is inside a marker. In that case, an empty attribute element will be
// created and the selection will be put inside it.
//
// If the highlight descriptor does not provide the `priority` property, `10` will be used.
//
// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.
//
// This converter binds the created {@link module:engine/view/attributeelement~AttributeElement attribute elemens} with the marker name
// using the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.
//
// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor
// @returns {Function}


function highlightText(highlightDescriptor) {
  return function (evt, data, conversionApi) {
    if (!data.item) {
      return;
    }

    if (!(data.item instanceof model_selection_Selection || data.item instanceof model_documentselection_DocumentSelection) && !data.item.is('textProxy')) {
      return;
    }

    var descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);

    if (!descriptor) {
      return;
    }

    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }

    var viewWriter = conversionApi.writer;
    var viewElement = createViewElementFromHighlightDescriptor(viewWriter, descriptor);
    var viewSelection = viewWriter.document.selection;

    if (data.item instanceof model_selection_Selection || data.item instanceof model_documentselection_DocumentSelection) {
      viewWriter.wrap(viewSelection.getFirstRange(), viewElement, viewSelection);
    } else {
      var viewRange = conversionApi.mapper.toViewRange(data.range);
      var rangeAfterWrap = viewWriter.wrap(viewRange, viewElement);

      var _iterator8 = _createForOfIteratorHelper(rangeAfterWrap.getItems()),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var element = _step8.value;

          if (element.is('attributeElement') && element.isSimilar(viewElement)) {
            conversionApi.mapper.bindElementToMarker(element, data.markerName); // One attribute element is enough, because all of them are bound together by the view writer.
            // Mapper uses this binding to get all the elements no matter how many of them are registered in the mapper.

            break;
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
    }
  };
} // Converter function factory. It creates a function which applies the marker's highlight to an element inside the marker's range.
//
// The converter checks if an element has the `addHighlight` function stored as a
// {@link module:engine/view/element~Element#_setCustomProperty custom property} and, if so, uses it to apply the highlight.
// In such case the converter will consume all element's children, assuming that they were handled by the element itself.
//
// When the `addHighlight` custom property is not present, the element is not converted in any special way.
// This means that converters will proceed to convert the element's child nodes.
//
// If the highlight descriptor does not provide the `priority` property, `10` will be used.
//
// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.
//
// This converter binds altered {@link module:engine/view/containerelement~ContainerElement container elements} with the marker name using
// the {@link module:engine/conversion/mapper~Mapper#bindElementToMarker} method.
//
// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor
// @returns {Function}


function highlightElement(highlightDescriptor) {
  return function (evt, data, conversionApi) {
    if (!data.item) {
      return;
    }

    if (!(data.item instanceof model_element_Element)) {
      return;
    }

    var descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);

    if (!descriptor) {
      return;
    }

    if (!conversionApi.consumable.test(data.item, evt.name)) {
      return;
    }

    var viewElement = conversionApi.mapper.toViewElement(data.item);

    if (viewElement && viewElement.getCustomProperty('addHighlight')) {
      // Consume element itself.
      conversionApi.consumable.consume(data.item, evt.name); // Consume all children nodes.

      var _iterator9 = _createForOfIteratorHelper(model_range_Range._createIn(data.item)),
          _step9;

      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var value = _step9.value;
          conversionApi.consumable.consume(value.item, evt.name);
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }

      viewElement.getCustomProperty('addHighlight')(viewElement, descriptor, conversionApi.writer);
      conversionApi.mapper.bindElementToMarker(viewElement, data.markerName);
    }
  };
} // Function factory that creates a converter which converts the removing model marker to the view.
//
// Both text nodes and elements are handled by this converter but they are handled a bit differently.
//
// Text nodes are unwrapped using the {@link module:engine/view/attributeelement~AttributeElement attribute element} created from the
// provided highlight descriptor. See {link module:engine/conversion/downcasthelpers~HighlightDescriptor}.
//
// For elements, the converter checks if an element has the `removeHighlight` function stored as a
// {@link module:engine/view/element~Element#_setCustomProperty custom property}. If so, it uses it to remove the highlight.
// In such case, the children of that element will not be converted.
//
// When `removeHighlight` is not present, the element is not converted in any special way.
// The converter will proceed to convert the element's child nodes instead.
//
// If the highlight descriptor does not provide the `priority` property, `10` will be used.
//
// If the highlight descriptor does not provide the `id` property, the name of the marker will be used.
//
// This converter unbinds elements from the marker name.
//
// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} highlightDescriptor
// @returns {Function}


function downcasthelpers_removeHighlight(highlightDescriptor) {
  return function (evt, data, conversionApi) {
    // This conversion makes sense only for non-collapsed range.
    if (data.markerRange.isCollapsed) {
      return;
    }

    var descriptor = prepareDescriptor(highlightDescriptor, data, conversionApi);

    if (!descriptor) {
      return;
    } // View element that will be used to unwrap `AttributeElement`s.


    var viewHighlightElement = createViewElementFromHighlightDescriptor(conversionApi.writer, descriptor); // Get all elements bound with given marker name.

    var elements = conversionApi.mapper.markerNameToElements(data.markerName);

    if (!elements) {
      return;
    }

    var _iterator10 = _createForOfIteratorHelper(elements),
        _step10;

    try {
      for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
        var element = _step10.value;
        conversionApi.mapper.unbindElementFromMarkerName(element, data.markerName);

        if (element.is('attributeElement')) {
          conversionApi.writer.unwrap(conversionApi.writer.createRangeOn(element), viewHighlightElement);
        } else {
          // if element.is( 'containerElement' ).
          element.getCustomProperty('removeHighlight')(element, descriptor.id, conversionApi.writer);
        }
      }
    } catch (err) {
      _iterator10.e(err);
    } finally {
      _iterator10.f();
    }

    conversionApi.writer.clearClonedElementsGroup(data.markerName);
    evt.stop();
  };
} // Model element to view element conversion helper.
//
// See {@link ~DowncastHelpers#elementToElement `.elementToElement()` downcast helper} for examples.
//
// @param {Object} config Conversion configuration.
// @param {String} config.model The name of the model element to convert.
// @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function
// that takes the model element and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}
// as parameters and returns a view container element.
// @returns {Function} Conversion helper.


function downcastElementToElement(config) {
  config = lodash_es_cloneDeep(config);
  config.view = normalizeToElementConfig(config.view, 'container');
  return function (dispatcher) {
    dispatcher.on('insert:' + config.model, downcasthelpers_insertElement(config.view), {
      priority: config.converterPriority || 'normal'
    });
  };
} // Model attribute to view element conversion helper.
//
// See {@link ~DowncastHelpers#attributeToElement `.attributeToElement()` downcast helper} for examples.
//
// @param {Object} config Conversion configuration.
// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values }` object. `values` is an array
// of `String`s with possible values if the model attribute is an enumerable.
// @param {module:engine/view/elementdefinition~ElementDefinition|Function|Object} config.view A view element definition or a function
// that takes the model attribute value and {@link module:engine/view/downcastwriter~DowncastWriter view downcast writer}
// as parameters and returns a view attribute element. If `config.model.values` is
// given, `config.view` should be an object assigning values from `config.model.values` to view element definitions or functions.
// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.
// @returns {Function} Conversion helper.


function downcastAttributeToElement(config) {
  config = lodash_es_cloneDeep(config);
  var modelKey = config.model.key ? config.model.key : config.model;
  var eventName = 'attribute:' + modelKey;

  if (config.model.name) {
    eventName += ':' + config.model.name;
  }

  if (config.model.values) {
    var _iterator11 = _createForOfIteratorHelper(config.model.values),
        _step11;

    try {
      for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
        var modelValue = _step11.value;
        config.view[modelValue] = normalizeToElementConfig(config.view[modelValue], 'attribute');
      }
    } catch (err) {
      _iterator11.e(err);
    } finally {
      _iterator11.f();
    }
  } else {
    config.view = normalizeToElementConfig(config.view, 'attribute');
  }

  var elementCreator = getFromAttributeCreator(config);
  return function (dispatcher) {
    dispatcher.on(eventName, downcasthelpers_wrap(elementCreator), {
      priority: config.converterPriority || 'normal'
    });
  };
} // Model attribute to view attribute conversion helper.
//
// See {@link ~DowncastHelpers#attributeToAttribute `.attributeToAttribute()` downcast helper} for examples.
//
// @param {Object} config Conversion configuration.
// @param {String|Object} config.model The key of the attribute to convert from or a `{ key, values, [ name ] }` object describing
// the attribute key, possible values and, optionally, an element name to convert from.
// @param {String|Object|Function} config.view A view attribute key, or a `{ key, value }` object or a function that takes
// the model attribute value and returns a `{ key, value }` object. If `key` is `'class'`, `value` can be a `String` or an
// array of `String`s. If `key` is `'style'`, `value` is an object with key-value pairs. In other cases, `value` is a `String`.
// If `config.model.values` is set, `config.view` should be an object assigning values from `config.model.values` to
// `{ key, value }` objects or a functions.
// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.
// @returns {Function} Conversion helper.


function downcastAttributeToAttribute(config) {
  config = lodash_es_cloneDeep(config);
  var modelKey = config.model.key ? config.model.key : config.model;
  var eventName = 'attribute:' + modelKey;

  if (config.model.name) {
    eventName += ':' + config.model.name;
  }

  if (config.model.values) {
    var _iterator12 = _createForOfIteratorHelper(config.model.values),
        _step12;

    try {
      for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
        var modelValue = _step12.value;
        config.view[modelValue] = normalizeToAttributeConfig(config.view[modelValue]);
      }
    } catch (err) {
      _iterator12.e(err);
    } finally {
      _iterator12.f();
    }
  } else {
    config.view = normalizeToAttributeConfig(config.view);
  }

  var elementCreator = getFromAttributeCreator(config);
  return function (dispatcher) {
    dispatcher.on(eventName, changeAttribute(elementCreator), {
      priority: config.converterPriority || 'normal'
    });
  };
} // Model marker to view element conversion helper.
//
// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.
//
// @param {Object} config Conversion configuration.
// @param {String} config.model The name of the model marker (or model marker group) to convert.
// @param {module:engine/view/elementdefinition~ElementDefinition|Function} config.view A view element definition or a function
// that takes the model marker data as a parameter and returns a view UI element.
// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.
// @returns {Function} Conversion helper.


function downcastMarkerToElement(config) {
  config = lodash_es_cloneDeep(config);
  config.view = normalizeToElementConfig(config.view, 'ui');
  return function (dispatcher) {
    dispatcher.on('addMarker:' + config.model, insertUIElement(config.view), {
      priority: config.converterPriority || 'normal'
    });
    dispatcher.on('removeMarker:' + config.model, removeUIElement(config.view), {
      priority: config.converterPriority || 'normal'
    });
  };
} // Model marker to highlight conversion helper.
//
// See {@link ~DowncastHelpers#markerToElement `.markerToElement()` downcast helper} for examples.
//
// @param {Object} config Conversion configuration.
// @param {String} config.model The name of the model marker (or model marker group) to convert.
// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor|Function} config.view A highlight descriptor
// that will be used for highlighting or a function that takes the model marker data as a parameter and returns a highlight descriptor.
// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.
// @returns {Function} Conversion helper.


function downcastMarkerToHighlight(config) {
  return function (dispatcher) {
    dispatcher.on('addMarker:' + config.model, highlightText(config.view), {
      priority: config.converterPriority || 'normal'
    });
    dispatcher.on('addMarker:' + config.model, highlightElement(config.view), {
      priority: config.converterPriority || 'normal'
    });
    dispatcher.on('removeMarker:' + config.model, downcasthelpers_removeHighlight(config.view), {
      priority: config.converterPriority || 'normal'
    });
  };
} // Takes `config.view`, and if it is an {@link module:engine/view/elementdefinition~ElementDefinition}, converts it
// to a function (because lower level converters accept only element creator functions).
//
// @param {module:engine/view/elementdefinition~ElementDefinition|Function} view View configuration.
// @param {'container'|'attribute'|'ui'} viewElementType View element type to create.
// @returns {Function} Element creator function to use in lower level converters.


function normalizeToElementConfig(view, viewElementType) {
  if (typeof view == 'function') {
    // If `view` is already a function, don't do anything.
    return view;
  }

  return function (modelData, viewWriter) {
    return createViewElementFromDefinition(view, viewWriter, viewElementType);
  };
} // Creates a view element instance from the provided {@link module:engine/view/elementdefinition~ElementDefinition} and class.
//
// @param {module:engine/view/elementdefinition~ElementDefinition} viewElementDefinition
// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter
// @param {'container'|'attribute'|'ui'} viewElementType
// @returns {module:engine/view/element~Element}


function createViewElementFromDefinition(viewElementDefinition, viewWriter, viewElementType) {
  if (typeof viewElementDefinition == 'string') {
    // If `viewElementDefinition` is given as a `String`, normalize it to an object with `name` property.
    viewElementDefinition = {
      name: viewElementDefinition
    };
  }

  var element;
  var attributes = Object.assign({}, viewElementDefinition.attributes);

  if (viewElementType == 'container') {
    element = viewWriter.createContainerElement(viewElementDefinition.name, attributes);
  } else if (viewElementType == 'attribute') {
    var options = {
      priority: viewElementDefinition.priority || attributeelement_AttributeElement.DEFAULT_PRIORITY
    };
    element = viewWriter.createAttributeElement(viewElementDefinition.name, attributes, options);
  } else {
    // 'ui'.
    element = viewWriter.createUIElement(viewElementDefinition.name, attributes);
  }

  if (viewElementDefinition.styles) {
    var keys = Object.keys(viewElementDefinition.styles);

    for (var _i3 = 0, _keys4 = keys; _i3 < _keys4.length; _i3++) {
      var key = _keys4[_i3];
      viewWriter.setStyle(key, viewElementDefinition.styles[key], element);
    }
  }

  if (viewElementDefinition.classes) {
    var classes = viewElementDefinition.classes;

    if (typeof classes == 'string') {
      viewWriter.addClass(classes, element);
    } else {
      var _iterator13 = _createForOfIteratorHelper(classes),
          _step13;

      try {
        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
          var className = _step13.value;
          viewWriter.addClass(className, element);
        }
      } catch (err) {
        _iterator13.e(err);
      } finally {
        _iterator13.f();
      }
    }
  }

  return element;
}

function getFromAttributeCreator(config) {
  if (config.model.values) {
    return function (modelAttributeValue, viewWriter) {
      var view = config.view[modelAttributeValue];

      if (view) {
        return view(modelAttributeValue, viewWriter);
      }

      return null;
    };
  } else {
    return config.view;
  }
} // Takes the configuration, adds default parameters if they do not exist and normalizes other parameters to be used in downcast converters
// for generating a view attribute.
//
// @param {Object} view View configuration.


function normalizeToAttributeConfig(view) {
  if (typeof view == 'string') {
    return function (modelAttributeValue) {
      return {
        key: view,
        value: modelAttributeValue
      };
    };
  } else if (Object(esm_typeof["a" /* default */])(view) == 'object') {
    // { key, value, ... }
    if (view.value) {
      return function () {
        return view;
      };
    } // { key, ... }
    else {
        return function (modelAttributeValue) {
          return {
            key: view.key,
            value: modelAttributeValue
          };
        };
      }
  } else {
    // function.
    return view;
  }
} // Helper function for `highlight`. Prepares the actual descriptor object using value passed to the converter.


function prepareDescriptor(highlightDescriptor, data, conversionApi) {
  // If passed descriptor is a creator function, call it. If not, just use passed value.
  var descriptor = typeof highlightDescriptor == 'function' ? highlightDescriptor(data, conversionApi) : highlightDescriptor;

  if (!descriptor) {
    return null;
  } // Apply default descriptor priority.


  if (!descriptor.priority) {
    descriptor.priority = 10;
  } // Default descriptor id is marker name.


  if (!descriptor.id) {
    descriptor.id = data.markerName;
  }

  return descriptor;
}
/**
 * An object describing how the marker highlight should be represented in the view.
 *
 * Each text node contained in a highlighted range will be wrapped in a `<span>`
 * {@link module:engine/view/attributeelement~AttributeElement view attribute element} with CSS class(es), attributes and a priority
 * described by this object.
 *
 * Additionally, each {@link module:engine/view/containerelement~ContainerElement container element} can handle displaying the highlight
 * separately by providing the `addHighlight` and `removeHighlight` custom properties. In this case:
 *
 *  * The `HighlightDescriptor` object is passed to the `addHighlight` function upon conversion and should be used to apply the highlight to
 *  the element.
 *  * The descriptor `id` is passed to the `removeHighlight` function upon conversion and should be used to remove the highlight with the
 *  given ID from the element.
 *
 * @typedef {Object} module:engine/conversion/downcasthelpers~HighlightDescriptor
 *
 * @property {String|Array.<String>} classes A CSS class or an array of classes to set. If the descriptor is used to
 * create an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these classes will be set
 * on that attribute element. If the descriptor is applied to an element, usually these classes will be set on that element, however,
 * this depends on how the element converts the descriptor.
 *
 * @property {String} [id] Descriptor identifier. If not provided, it defaults to the converted marker's name.
 *
 * @property {Number} [priority] Descriptor priority. If not provided, it defaults to `10`. If the descriptor is used to create
 * an {@link module:engine/view/attributeelement~AttributeElement attribute element}, it will be that element's
 * {@link module:engine/view/attributeelement~AttributeElement#priority priority}. If the descriptor is applied to an element,
 * the priority will be used to determine which descriptor is more important.
 *
 * @property {Object} [attributes] Attributes to set. If the descriptor is used to create
 * an {@link module:engine/view/attributeelement~AttributeElement attribute element} over text nodes, these attributes will be set on that
 * attribute element. If the descriptor is applied to an element, usually these attributes will be set on that element, however,
 * this depends on how the element converts the descriptor.
 */
// CONCATENATED MODULE: ./node_modules/@vue/babel-preset-app/node_modules/@babel/runtime/helpers/esm/defineProperty.js
function defineProperty_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcasthelpers.js














/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */





/**
 * Contains {@link module:engine/view/view view} to {@link module:engine/model/model model} converters for
 * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}.
 *
 * @module engine/conversion/upcasthelpers
 */

/**
 * Upcast conversion helper functions.
 *
 * @extends module:engine/conversion/conversionhelpers~ConversionHelpers
 */

var upcasthelpers_UpcastHelpers = /*#__PURE__*/function (_ConversionHelpers) {
  Object(inherits["a" /* default */])(UpcastHelpers, _ConversionHelpers);

  var _super = Object(createSuper["a" /* default */])(UpcastHelpers);

  function UpcastHelpers() {
    Object(classCallCheck["a" /* default */])(this, UpcastHelpers);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(UpcastHelpers, [{
    key: "elementToElement",

    /**
     * View element to model element conversion helper.
     *
     * This conversion results in creating a model element. For example,
     * view `<p>Foo</p>` becomes `<paragraph>Foo</paragraph>` in the model.
     *
     * Keep in mind that the element will be inserted only if it is allowed
     * by {@link module:engine/model/schema~Schema schema} configuration.
     *
     *		editor.conversion.for( 'upcast' ).elementToElement( {
     *			view: 'p',
     *			model: 'paragraph'
     *		} );
     *
     *		editor.conversion.for( 'upcast' ).elementToElement( {
     *			view: 'p',
     *			model: 'paragraph',
     *			converterPriority: 'high'
     *		} );
     *
     *		editor.conversion.for( 'upcast' ).elementToElement( {
     *			view: {
     *				name: 'p',
     *				classes: 'fancy'
     *			},
     *			model: 'fancyParagraph'
     *		} );
     *
     *		editor.conversion.for( 'upcast' ).elementToElement( {
     * 			view: {
     *				name: 'p',
     *				classes: 'heading'
     * 			},
     * 			model: ( viewElement, modelWriter ) => {
     * 				return modelWriter.createElement( 'heading', { level: viewElement.getAttribute( 'data-level' ) } );
     * 			}
     * 		} );
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * @method #elementToElement
     * @param {Object} config Conversion configuration.
     * @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not
     * set, the converter will fire for every view element.
     * @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element
     * instance or a function that takes a view element and returns a model element. The model element will be inserted in the model.
     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.
     * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}
     */
    value: function elementToElement(config) {
      return this.add(upcastElementToElement(config));
    }
    /**
     * View element to model attribute conversion helper.
     *
     * This conversion results in setting an attribute on a model node. For example, view `<strong>Foo</strong>` becomes
     * `Foo` {@link module:engine/model/text~Text model text node} with `bold` attribute set to `true`.
     *
     * This helper is meant to set a model attribute on all the elements that are inside the converted element:
     *
     *		<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold="true">Foo</$text></paragraph>
     *
     * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).
     * Even though `<strong>` is over `<p>` element, `bold="true"` was added to the text. See
     * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute} for comparison.
     *
     * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.
     *
     *		editor.conversion.for( 'upcast' ).elementToAttribute( {
     *			view: 'strong',
     *			model: 'bold'
     *		} );
     *
     *		editor.conversion.for( 'upcast' ).elementToAttribute( {
     *			view: 'strong',
     *			model: 'bold',
     *			converterPriority: 'high'
     *		} );
     *
     *		editor.conversion.for( 'upcast' ).elementToAttribute( {
     *			view: {
     *				name: 'span',
     *				classes: 'bold'
     *			},
     *			model: 'bold'
     *		} );
     *
     *		editor.conversion.for( 'upcast' ).elementToAttribute( {
     *			view: {
     *				name: 'span',
     *				classes: [ 'styled', 'styled-dark' ]
     *			},
     *			model: {
     *				key: 'styled',
     *				value: 'dark'
     *			}
     *		} );
     *
     * 		editor.conversion.for( 'upcast' ).elementToAttribute( {
     *			view: {
     *				name: 'span',
     *				styles: {
     *					'font-size': /[\s\S]+/
     *				}
     *			},
     *			model: {
     *				key: 'fontSize',
     *				value: viewElement => {
     *					const fontSize = viewElement.getStyle( 'font-size' );
     *					const value = fontSize.substr( 0, fontSize.length - 2 );
     *
     *					if ( value <= 10 ) {
     *						return 'small';
     *					} else if ( value > 12 ) {
     *						return 'big';
     *					}
     *
     *					return null;
     *				}
     *			}
     *		} );
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * @method #elementToAttribute
     * @param {Object} config Conversion configuration.
     * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.
     * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing
     * the model attribute. `value` property may be set as a function that takes a view element and returns the value.
     * If `String` is given, the model attribute value will be set to `true`.
     * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.
     * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}
     */

  }, {
    key: "elementToAttribute",
    value: function elementToAttribute(config) {
      return this.add(upcastElementToAttribute(config));
    }
    /**
     * View attribute to model attribute conversion helper.
     *
     * This conversion results in setting an attribute on a model node. For example, view `<img src="foo.jpg"></img>` becomes
     * `<image source="foo.jpg"></image>` in the model.
     *
     * This helper is meant to convert view attributes from view elements which got converted to the model, so the view attribute
     * is set only on the corresponding model node:
     *
     *		<div class="dark"><div>foo</div></div>    -->    <div dark="true"><div>foo</div></div>
     *
     * Above, `class="dark"` attribute is added only to the `<div>` elements that has it. This is in contrary to
     * {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute} which sets attributes for
     * all the children in the model:
     *
     *		<strong>Foo</strong>   -->   <strong><p>Foo</p></strong>   -->   <paragraph><$text bold="true">Foo</$text></paragraph>
     *
     * Above is a sample of HTML code, that goes through autoparagraphing (first step) and then is converted (second step).
     * Even though `<strong>` is over `<p>` element, `bold="true"` was added to the text.
     *
     * Keep in mind that the attribute will be set only if it is allowed by {@link module:engine/model/schema~Schema schema} configuration.
     *
     *		editor.conversion.for( 'upcast' ).attributeToAttribute( {
     *			view: 'src',
     *			model: 'source'
     *		} );
     *
     *		editor.conversion.for( 'upcast' ).attributeToAttribute( {
     *			view: { key: 'src' },
     *			model: 'source'
     *		} );
     *
     *		editor.conversion.for( 'upcast' ).attributeToAttribute( {
     *			view: { key: 'src' },
     *			model: 'source',
     *			converterPriority: 'normal'
     *		} );
     *
     *		editor.conversion.for( 'upcast' ).attributeToAttribute( {
     *			view: {
     *				key: 'data-style',
     *				value: /[\s\S]+/
     *			},
     *			model: 'styled'
     *		} );
     *
     *		editor.conversion.for( 'upcast' ).attributeToAttribute( {
     *			view: {
     *				name: 'img',
     *				key: 'class',
     *				value: 'styled-dark'
     *			},
     *			model: {
     *				key: 'styled',
     *				value: 'dark'
     *			}
     *		} );
     *
     *		editor.conversion.for( 'upcast' ).attributeToAttribute( {
     *			view: {
     *				key: 'class',
     *				value: /styled-[\S]+/
     *			},
     *			model: {
     *				key: 'styled'
     *				value: viewElement => {
     *					const regexp = /styled-([\S]+)/;
     *					const match = viewElement.getAttribute( 'class' ).match( regexp );
     *
     *					return match[ 1 ];
     *				}
     *			}
     *		} );
     *
     * Converting styles works a bit differently as it requires `view.styles` to be an object and by default
     * a model attribute will be set to `true` by such a converter. You can set the model attribute to any value by providing the `value`
     * callback that returns the desired value.
     *
     *		// Default conversion of font-weight style will result in setting bold attribute to true.
     *		editor.conversion.for( 'upcast' ).attributeToAttribute( {
     *			view: {
     *				styles: {
     *					'font-weight': 'bold'
     *				}
     *			},
     *			model: 'bold'
     *		} );
     *
     *		// This converter will pass any style value to the `lineHeight` model attribute.
     *		editor.conversion.for( 'upcast' ).attributeToAttribute( {
     *			view: {
     *				styles: {
     *					'line-height': /[\s\S]+/
     *				}
     *			},
     *			model: {
     *				key: 'lineHeight',
     *				value: viewElement => viewElement.getStyle( 'line-height' )
     *			}
     *		} );
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * @method #attributeToAttribute
     * @param {Object} config Conversion configuration.
     * @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,
     * attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,
     * specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`
     * property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,
     * a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.
     * @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing
     * the model attribute. `value` property may be set as a function that takes a view element and returns the value.
     * If `String` is given, the model attribute value will be same as view attribute value.
     * @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.
     * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}
     */

  }, {
    key: "attributeToAttribute",
    value: function attributeToAttribute(config) {
      return this.add(upcastAttributeToAttribute(config));
    }
    /**
     * View element to model marker conversion helper.
     *
     * This conversion results in creating a model marker. For example, if the marker was stored in a view as an element:
     * `<p>Fo<span data-marker="comment" data-comment-id="7"></span>o</p><p>B<span data-marker="comment" data-comment-id="7"></span>ar</p>`,
     * after the conversion is done, the marker will be available in
     * {@link module:engine/model/model~Model#markers model document markers}.
     *
     *		editor.conversion.for( 'upcast' ).elementToMarker( {
     *			view: 'marker-search',
     *			model: 'search'
     *		} );
     *
     *		editor.conversion.for( 'upcast' ).elementToMarker( {
     *			view: 'marker-search',
     *			model: 'search',
     *			converterPriority: 'high'
     *		} );
     *
     *		editor.conversion.for( 'upcast' ).elementToMarker( {
     *			view: 'marker-search',
     *			model: viewElement => 'comment:' + viewElement.getAttribute( 'data-comment-id' )
     *		} );
     *
     *		editor.conversion.for( 'upcast' ).elementToMarker( {
     *			view: {
     *				name: 'span',
     *				attributes: {
     *					'data-marker': 'search'
     *				}
     *			},
     *			model: 'search'
     *		} );
     *
     * See {@link module:engine/conversion/conversion~Conversion#for `conversion.for()`} to learn how to add a converter
     * to the conversion process.
     *
     * @method #elementToMarker
     * @param {Object} config Conversion configuration.
     * @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.
     * @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns
     * a model marker name.
     * @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.
     * @returns {module:engine/conversion/upcasthelpers~UpcastHelpers}
     */

  }, {
    key: "elementToMarker",
    value: function elementToMarker(config) {
      return this.add(upcastElementToMarker(config));
    }
  }]);

  return UpcastHelpers;
}(conversionhelpers_ConversionHelpers);
/**
 * Function factory, creates a converter that converts {@link module:engine/view/documentfragment~DocumentFragment view document fragment}
 * or all children of {@link module:engine/view/element~Element} into
 * {@link module:engine/model/documentfragment~DocumentFragment model document fragment}.
 * This is the "entry-point" converter for upcast (view to model conversion). This converter starts the conversion of all children
 * of passed view document fragment. Those children {@link module:engine/view/node~Node view nodes} are then handled by other converters.
 *
 * This also a "default", last resort converter for all view elements that has not been converted by other converters.
 * When a view element is being converted to the model but it does not have converter specified, that view element
 * will be converted to {@link module:engine/model/documentfragment~DocumentFragment model document fragment} and returned.
 *
 * @returns {Function} Universal converter for view {@link module:engine/view/documentfragment~DocumentFragment fragments} and
 * {@link module:engine/view/element~Element elements} that returns
 * {@link module:engine/model/documentfragment~DocumentFragment model fragment} with children of converted view item.
 */



function convertToModelFragment() {
  return function (evt, data, conversionApi) {
    // Second argument in `consumable.consume` is discarded for ViewDocumentFragment but is needed for ViewElement.
    if (!data.modelRange && conversionApi.consumable.consume(data.viewItem, {
      name: true
    })) {
      var _conversionApi$conver = conversionApi.convertChildren(data.viewItem, data.modelCursor),
          modelRange = _conversionApi$conver.modelRange,
          modelCursor = _conversionApi$conver.modelCursor;

      data.modelRange = modelRange;
      data.modelCursor = modelCursor;
    }
  };
}
/**
 * Function factory, creates a converter that converts {@link module:engine/view/text~Text} to {@link module:engine/model/text~Text}.
 *
 * @returns {Function} {@link module:engine/view/text~Text View text} converter.
 */

function convertText() {
  return function (evt, data, conversionApi) {
    if (conversionApi.schema.checkChild(data.modelCursor, '$text')) {
      if (conversionApi.consumable.consume(data.viewItem)) {
        var text = conversionApi.writer.createText(data.viewItem.data);
        conversionApi.writer.insert(text, data.modelCursor);
        data.modelRange = model_range_Range._createFromPositionAndShift(data.modelCursor, text.offsetSize);
        data.modelCursor = data.modelRange.end;
      }
    }
  };
}
/**
 * Function factory, creates a callback function which converts a {@link module:engine/view/selection~Selection
 * view selection} taken from the {@link module:engine/view/document~Document#event:selectionChange} event
 * and sets in on the {@link module:engine/model/document~Document#selection model}.
 *
 * **Note**: because there is no view selection change dispatcher nor any other advanced view selection to model
 * conversion mechanism, the callback should be set directly on view document.
 *
 *		view.document.on( 'selectionChange', convertSelectionChange( modelDocument, mapper ) );
 *
 * @param {module:engine/model/model~Model} model Data model.
 * @param {module:engine/conversion/mapper~Mapper} mapper Conversion mapper.
 * @returns {Function} {@link module:engine/view/document~Document#event:selectionChange} callback function.
 */

function convertSelectionChange(model, mapper) {
  return function (evt, data) {
    var viewSelection = data.newSelection;
    var modelSelection = new model_selection_Selection();
    var ranges = [];

    var _iterator = _createForOfIteratorHelper(viewSelection.getRanges()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var viewRange = _step.value;
        ranges.push(mapper.toModelRange(viewRange));
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    modelSelection.setTo(ranges, {
      backward: viewSelection.isBackward
    });

    if (!modelSelection.isEqual(model.document.selection)) {
      model.change(function (writer) {
        writer.setSelection(modelSelection);
      });
    }
  };
} // View element to model element conversion helper.
//
// See {@link ~UpcastHelpers#elementToElement `.elementToElement()` upcast helper} for examples.
//
// @param {Object} config Conversion configuration.
// @param {module:engine/view/matcher~MatcherPattern} [config.view] Pattern matching all view elements which should be converted. If not
// set, the converter will fire for every view element.
// @param {String|module:engine/model/element~Element|Function} config.model Name of the model element, a model element
// instance or a function that takes a view element and returns a model element. The model element will be inserted in the model.
// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.
// @returns {Function} Conversion helper.

function upcastElementToElement(config) {
  config = lodash_es_cloneDeep(config);
  var converter = prepareToElementConverter(config);
  var elementName = getViewElementNameFromConfig(config.view);
  var eventName = elementName ? 'element:' + elementName : 'element';
  return function (dispatcher) {
    dispatcher.on(eventName, converter, {
      priority: config.converterPriority || 'normal'
    });
  };
} // View element to model attribute conversion helper.
//
// See {@link ~UpcastHelpers#elementToAttribute `.elementToAttribute()` upcast helper} for examples.
//
// @param {Object} config Conversion configuration.
// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.
// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing
// the model attribute. `value` property may be set as a function that takes a view element and returns the value.
// If `String` is given, the model attribute value will be set to `true`.
// @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.
// @returns {Function} Conversion helper.


function upcastElementToAttribute(config) {
  config = lodash_es_cloneDeep(config);
  normalizeModelAttributeConfig(config);
  var converter = prepareToAttributeConverter(config, false);
  var elementName = getViewElementNameFromConfig(config.view);
  var eventName = elementName ? 'element:' + elementName : 'element';
  return function (dispatcher) {
    dispatcher.on(eventName, converter, {
      priority: config.converterPriority || 'low'
    });
  };
} // View attribute to model attribute conversion helper.
//
// See {@link ~UpcastHelpers#attributeToAttribute `.attributeToAttribute()` upcast helper} for examples.
//
// @param {Object} config Conversion configuration.
// @param {String|Object} config.view Specifies which view attribute will be converted. If a `String` is passed,
// attributes with given key will be converted. If an `Object` is passed, it must have a required `key` property,
// specifying view attribute key, and may have an optional `value` property, specifying view attribute value and optional `name`
// property specifying a view element name from/on which the attribute should be converted. `value` can be given as a `String`,
// a `RegExp` or a function callback, that takes view attribute value as the only parameter and returns `Boolean`.
// @param {String|Object} config.model Model attribute key or an object with `key` and `value` properties, describing
// the model attribute. `value` property may be set as a function that takes a view element and returns the value.
// If `String` is given, the model attribute value will be same as view attribute value.
// @param {module:utils/priorities~PriorityString} [config.converterPriority='low'] Converter priority.
// @returns {Function} Conversion helper.


function upcastAttributeToAttribute(config) {
  config = lodash_es_cloneDeep(config);
  var viewKey = null;

  if (typeof config.view == 'string' || config.view.key) {
    viewKey = normalizeViewAttributeKeyValueConfig(config);
  }

  normalizeModelAttributeConfig(config, viewKey);
  var converter = prepareToAttributeConverter(config, true);
  return function (dispatcher) {
    dispatcher.on('element', converter, {
      priority: config.converterPriority || 'low'
    });
  };
} // View element to model marker conversion helper.
//
// See {@link ~UpcastHelpers#elementToMarker `.elementToMarker()` upcast helper} for examples.
//
// @param {Object} config Conversion configuration.
// @param {module:engine/view/matcher~MatcherPattern} config.view Pattern matching all view elements which should be converted.
// @param {String|Function} config.model Name of the model marker, or a function that takes a view element and returns
// a model marker name.
// @param {module:utils/priorities~PriorityString} [config.converterPriority='normal'] Converter priority.
// @returns {Function} Conversion helper.


function upcastElementToMarker(config) {
  config = lodash_es_cloneDeep(config);
  normalizeToMarkerConfig(config);
  return upcastElementToElement(config);
} // Helper function for from-view-element conversion. Checks if `config.view` directly specifies converted view element's name
// and if so, returns it.
//
// @param {Object} config Conversion view config.
// @returns {String|null} View element name or `null` if name is not directly set.


function getViewElementNameFromConfig(viewConfig) {
  if (typeof viewConfig == 'string') {
    return viewConfig;
  }

  if (Object(esm_typeof["a" /* default */])(viewConfig) == 'object' && typeof viewConfig.name == 'string') {
    return viewConfig.name;
  }

  return null;
} // Helper for to-model-element conversion. Takes a config object and returns a proper converter function.
//
// @param {Object} config Conversion configuration.
// @returns {Function} View to model converter.


function prepareToElementConverter(config) {
  var matcher = config.view ? new matcher_Matcher(config.view) : null;
  return function (evt, data, conversionApi) {
    var match = {}; // If `config.view` has not been passed do not try matching. In this case, the converter should fire for all elements.

    if (matcher) {
      // This will be usually just one pattern but we support matchers with many patterns too.
      var matcherResult = matcher.match(data.viewItem); // If there is no match, this callback should not do anything.

      if (!matcherResult) {
        return;
      }

      match = matcherResult.match;
    } // Force consuming element's name.


    match.name = true; // Create model element basing on config.

    var modelElement = getModelElement(config.model, data.viewItem, conversionApi.writer); // Do not convert if element building function returned falsy value.

    if (!modelElement) {
      return;
    } // When element was already consumed then skip it.


    if (!conversionApi.consumable.test(data.viewItem, match)) {
      return;
    } // Find allowed parent for element that we are going to insert.
    // If current parent does not allow to insert element but one of the ancestors does
    // then split nodes to allowed parent.


    var splitResult = conversionApi.splitToAllowedParent(modelElement, data.modelCursor); // When there is no split result it means that we can't insert element to model tree, so let's skip it.

    if (!splitResult) {
      return;
    } // Insert element on allowed position.


    conversionApi.writer.insert(modelElement, splitResult.position); // Convert children and insert to element.

    conversionApi.convertChildren(data.viewItem, conversionApi.writer.createPositionAt(modelElement, 0)); // Consume appropriate value from consumable values list.

    conversionApi.consumable.consume(data.viewItem, match);
    var parts = conversionApi.getSplitParts(modelElement); // Set conversion result range.

    data.modelRange = new model_range_Range(conversionApi.writer.createPositionBefore(modelElement), conversionApi.writer.createPositionAfter(parts[parts.length - 1])); // Now we need to check where the `modelCursor` should be.

    if (splitResult.cursorParent) {
      // If we split parent to insert our element then we want to continue conversion in the new part of the split parent.
      //
      // before: <allowed><notAllowed>foo[]</notAllowed></allowed>
      // after:  <allowed><notAllowed>foo</notAllowed><converted></converted><notAllowed>[]</notAllowed></allowed>
      data.modelCursor = conversionApi.writer.createPositionAt(splitResult.cursorParent, 0);
    } else {
      // Otherwise just continue after inserted element.
      data.modelCursor = data.modelRange.end;
    }
  };
} // Helper function for upcasting-to-element converter. Takes the model configuration, the converted view element
// and a writer instance and returns a model element instance to be inserted in the model.
//
// @param {String|Function|module:engine/model/element~Element} model Model conversion configuration.
// @param {module:engine/view/node~Node} input The converted view node.
// @param {module:engine/model/writer~Writer} writer A writer instance to use to create the model element.


function getModelElement(model, input, writer) {
  if (model instanceof Function) {
    return model(input, writer);
  } else {
    return writer.createElement(model);
  }
} // Helper function view-attribute-to-model-attribute helper. Normalizes `config.view` which was set as `String` or
// as an `Object` with `key`, `value` and `name` properties. Normalized `config.view` has is compatible with
// {@link module:engine/view/matcher~MatcherPattern}.
//
// @param {Object} config Conversion config.
// @returns {String} Key of the converted view attribute.


function normalizeViewAttributeKeyValueConfig(config) {
  if (typeof config.view == 'string') {
    config.view = {
      key: config.view
    };
  }

  var key = config.view.key;
  var normalized;

  if (key == 'class' || key == 'style') {
    var keyName = key == 'class' ? 'classes' : 'styles';
    normalized = defineProperty_defineProperty({}, keyName, config.view.value);
  } else {
    var value = typeof config.view.value == 'undefined' ? /[\s\S]*/ : config.view.value;
    normalized = {
      attributes: defineProperty_defineProperty({}, key, value)
    };
  }

  if (config.view.name) {
    normalized.name = config.view.name;
  }

  config.view = normalized;
  return key;
} // Helper function that normalizes `config.model` in from-model-attribute conversion. `config.model` can be set
// as a `String`, an `Object` with only `key` property or an `Object` with `key` and `value` properties. Normalized
// `config.model` is an `Object` with `key` and `value` properties.
//
// @param {Object} config Conversion config.
// @param {String} viewAttributeKeyToCopy Key of the converted view attribute. If it is set, model attribute value
// will be equal to view attribute value.


function normalizeModelAttributeConfig(config) {
  var viewAttributeKeyToCopy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
  var defaultModelValue = viewAttributeKeyToCopy === null ? true : function (viewElement) {
    return viewElement.getAttribute(viewAttributeKeyToCopy);
  };
  var key = Object(esm_typeof["a" /* default */])(config.model) != 'object' ? config.model : config.model.key;
  var value = Object(esm_typeof["a" /* default */])(config.model) != 'object' || typeof config.model.value == 'undefined' ? defaultModelValue : config.model.value;
  config.model = {
    key: key,
    value: value
  };
} // Helper for to-model-attribute conversion. Takes the model attribute name and conversion configuration and returns
// a proper converter function.
//
// @param {String} modelAttributeKey The key of the model attribute to set on a model node.
// @param {Object|Array.<Object>} config Conversion configuration. It is possible to provide multiple configurations in an array.
// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set
// on all elements in the range.


function prepareToAttributeConverter(config, shallow) {
  var matcher = new matcher_Matcher(config.view);
  return function (evt, data, conversionApi) {
    var match = matcher.match(data.viewItem); // If there is no match, this callback should not do anything.

    if (!match) {
      return;
    }

    var modelKey = config.model.key;
    var modelValue = typeof config.model.value == 'function' ? config.model.value(data.viewItem) : config.model.value; // Do not convert if attribute building function returned falsy value.

    if (modelValue === null) {
      return;
    }

    if (onlyViewNameIsDefined(config.view, data.viewItem)) {
      match.match.name = true;
    } else {
      // Do not test or consume `name` consumable.
      delete match.match.name;
    } // Try to consume appropriate values from consumable values list.


    if (!conversionApi.consumable.test(data.viewItem, match.match)) {
      return;
    } // Since we are converting to attribute we need an range on which we will set the attribute.
    // If the range is not created yet, we will create it.


    if (!data.modelRange) {
      // Convert children and set conversion result as a current data.
      data = Object.assign(data, conversionApi.convertChildren(data.viewItem, data.modelCursor));
    } // Set attribute on current `output`. `Schema` is checked inside this helper function.


    var attributeWasSet = setAttributeOn(data.modelRange, {
      key: modelKey,
      value: modelValue
    }, shallow, conversionApi);

    if (attributeWasSet) {
      conversionApi.consumable.consume(data.viewItem, match.match);
    }
  };
} // Helper function that checks if element name should be consumed in attribute converters.
//
// @param {Object} config Conversion view config.
// @returns {Boolean}


function onlyViewNameIsDefined(viewConfig, viewItem) {
  // https://github.com/ckeditor/ckeditor5-engine/issues/1786
  var configToTest = typeof viewConfig == 'function' ? viewConfig(viewItem) : viewConfig;

  if (Object(esm_typeof["a" /* default */])(configToTest) == 'object' && !getViewElementNameFromConfig(configToTest)) {
    return false;
  }

  return !configToTest.classes && !configToTest.attributes && !configToTest.styles;
} // Helper function for to-model-attribute converter. Sets model attribute on given range. Checks {@link module:engine/model/schema~Schema}
// to ensure proper model structure.
//
// @param {module:engine/model/range~Range} modelRange Model range on which attribute should be set.
// @param {Object} modelAttribute Model attribute to set.
// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion API.
// @param {Boolean} shallow If set to `true` the attribute will be set only on top-level nodes. Otherwise, it will be set
// on all elements in the range.
// @returns {Boolean} `true` if attribute was set on at least one node from given `modelRange`.


function setAttributeOn(modelRange, modelAttribute, shallow, conversionApi) {
  var result = false; // Set attribute on each item in range according to Schema.

  for (var _i = 0, _Array$from = Array.from(modelRange.getItems({
    shallow: shallow
  })); _i < _Array$from.length; _i++) {
    var node = _Array$from[_i];

    if (conversionApi.schema.checkAttribute(node, modelAttribute.key)) {
      conversionApi.writer.setAttribute(modelAttribute.key, modelAttribute.value, node);
      result = true;
    }
  }

  return result;
} // Helper function for upcasting-to-marker conversion. Takes the config in a format requested by `upcastElementToMarker()`
// function and converts it to a format that is supported by `_upcastElementToElement()` function.
//
// @param {Object} config Conversion configuration.


function normalizeToMarkerConfig(config) {
  var oldModel = config.model;

  config.model = function (viewElement, modelWriter) {
    var markerName = typeof oldModel == 'string' ? oldModel : oldModel(viewElement);
    return modelWriter.createElement('$marker', {
      'data-name': markerName
    });
  };
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/controller/editingcontroller.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/controller/editingcontroller
 */







 // @if CK_DEBUG_ENGINE // const { dumpTrees, initDocumentDumping } = require( '../dev-utils/utils' );

/**
 * Controller for the editing pipeline. The editing pipeline controls {@link ~EditingController#model model} rendering,
 * including selection handling. It also creates the {@link ~EditingController#view view} which builds a
 * browser-independent virtualization over the DOM elements. The editing controller also attaches default converters.
 *
 * @mixes module:utils/observablemixin~ObservableMixin
 */

var editingcontroller_EditingController = /*#__PURE__*/function () {
  /**
   * Creates an editing controller instance.
   *
   * @param {module:engine/model/model~Model} model Editing model.
   * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.
   */
  function EditingController(model, stylesProcessor) {
    var _this = this;

    Object(classCallCheck["a" /* default */])(this, EditingController);

    /**
     * Editor model.
     *
     * @readonly
     * @member {module:engine/model/model~Model}
     */
    this.model = model;
    /**
     * Editing view controller.
     *
     * @readonly
     * @member {module:engine/view/view~View}
     */

    this.view = new view_View(stylesProcessor);
    /**
     * Mapper which describes the model-view binding.
     *
     * @readonly
     * @member {module:engine/conversion/mapper~Mapper}
     */

    this.mapper = new mapper_Mapper();
    /**
     * Downcast dispatcher that converts changes from the model to {@link #view the editing view}.
     *
     * @readonly
     * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher} #downcastDispatcher
     */

    this.downcastDispatcher = new downcastdispatcher_DowncastDispatcher({
      mapper: this.mapper
    });
    var doc = this.model.document;
    var selection = doc.selection;
    var markers = this.model.markers; // When plugins listen on model changes (on selection change, post fixers, etc) and change the view as a result of
    // model's change, they might trigger view rendering before the conversion is completed (e.g. before the selection
    // is converted). We disable rendering for the length of the outermost model change() block to prevent that.
    //
    // See https://github.com/ckeditor/ckeditor5-engine/issues/1528

    this.listenTo(this.model, '_beforeChanges', function () {
      _this.view._disableRendering(true);
    }, {
      priority: 'highest'
    });
    this.listenTo(this.model, '_afterChanges', function () {
      _this.view._disableRendering(false);
    }, {
      priority: 'lowest'
    }); // Whenever model document is changed, convert those changes to the view (using model.Document#differ).
    // Do it on 'low' priority, so changes are converted after other listeners did their job.
    // Also convert model selection.

    this.listenTo(doc, 'change', function () {
      _this.view.change(function (writer) {
        _this.downcastDispatcher.convertChanges(doc.differ, markers, writer);

        _this.downcastDispatcher.convertSelection(selection, markers, writer);
      });
    }, {
      priority: 'low'
    }); // Convert selection from the view to the model when it changes in the view.

    this.listenTo(this.view.document, 'selectionChange', convertSelectionChange(this.model, this.mapper)); // Attach default model converters.

    this.downcastDispatcher.on('insert:$text', downcasthelpers_insertText(), {
      priority: 'lowest'
    });
    this.downcastDispatcher.on('remove', downcasthelpers_remove(), {
      priority: 'low'
    }); // Attach default model selection converters.

    this.downcastDispatcher.on('selection', downcasthelpers_clearAttributes(), {
      priority: 'low'
    });
    this.downcastDispatcher.on('selection', convertRangeSelection(), {
      priority: 'low'
    });
    this.downcastDispatcher.on('selection', convertCollapsedSelection(), {
      priority: 'low'
    }); // Binds {@link module:engine/view/document~Document#roots view roots collection} to
    // {@link module:engine/model/document~Document#roots model roots collection} so creating
    // model root automatically creates corresponding view root.

    this.view.document.roots.bindTo(this.model.document.roots).using(function (root) {
      // $graveyard is a special root that has no reflection in the view.
      if (root.rootName == '$graveyard') {
        return null;
      }

      var viewRoot = new rooteditableelement_RootEditableElement(_this.view.document, root.name);
      viewRoot.rootName = root.rootName;

      _this.mapper.bindElements(root, viewRoot);

      return viewRoot;
    }); // @if CK_DEBUG_ENGINE // initDocumentDumping( this.model.document );
    // @if CK_DEBUG_ENGINE // initDocumentDumping( this.view.document );
    // @if CK_DEBUG_ENGINE // dumpTrees( this.model.document, this.model.document.version );
    // @if CK_DEBUG_ENGINE // dumpTrees( this.view.document, this.model.document.version );
    // @if CK_DEBUG_ENGINE // this.model.document.on( 'change', () => {
    // @if CK_DEBUG_ENGINE //	dumpTrees( this.view.document, this.model.document.version );
    // @if CK_DEBUG_ENGINE // }, { priority: 'lowest' } );
  }
  /**
   * Removes all event listeners attached to the `EditingController`. Destroys all objects created
   * by `EditingController` that need to be destroyed.
   */


  Object(createClass["a" /* default */])(EditingController, [{
    key: "destroy",
    value: function destroy() {
      this.view.destroy();
      this.stopListening();
    }
  }]);

  return EditingController;
}();


mix(editingcontroller_EditingController, observablemixin);
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-core/src/commandcollection.js













/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module core/commandcollection
 */

/**
 * Collection of commands. Its instance is available in {@link module:core/editor/editor~Editor#commands `editor.commands`}.
 */

var commandcollection_CommandCollection = /*#__PURE__*/function () {
  /**
   * Creates collection instance.
   */
  function CommandCollection() {
    Object(classCallCheck["a" /* default */])(this, CommandCollection);

    /**
     * Command map.
     *
     * @private
     * @member {Map}
     */
    this._commands = new Map();
  }
  /**
   * Registers a new command.
   *
   * @param {String} commandName The name of the command.
   * @param {module:core/command~Command} command
   */


  Object(createClass["a" /* default */])(CommandCollection, [{
    key: "add",
    value: function add(commandName, command) {
      this._commands.set(commandName, command);
    }
    /**
     * Retrieves a command from the collection.
     *
     * @param {String} commandName The name of the command.
     * @returns {module:core/command~Command}
     */

  }, {
    key: "get",
    value: function get(commandName) {
      return this._commands.get(commandName);
    }
    /**
     * Executes a command.
     *
     * @param {String} commandName The name of the command.
     * @param {*} [...commandParams] Command parameters.
     */

  }, {
    key: "execute",
    value: function execute(commandName) {
      var command = this.get(commandName);

      if (!command) {
        /**
         * Command does not exist.
         *
         * @error commandcollection-command-not-found
         * @param {String} commandName Name of the command.
         */
        throw new ckeditorerror["b" /* default */]('commandcollection-command-not-found: Command does not exist.', this, {
          commandName: commandName
        });
      }

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      command.execute.apply(command, args);
    }
    /**
     * Returns iterator of command names.
     *
     * @returns {Iterable.<String>}
     */

  }, {
    key: "names",
    value: /*#__PURE__*/regeneratorRuntime.mark(function names() {
      return regeneratorRuntime.wrap(function names$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              return _context.delegateYield(this._commands.keys(), "t0", 1);

            case 1:
            case "end":
              return _context.stop();
          }
        }
      }, names, this);
    })
    /**
     * Returns iterator of command instances.
     *
     * @returns {Iterable.<module:core/command~Command>}
     */

  }, {
    key: "commands",
    value: /*#__PURE__*/regeneratorRuntime.mark(function commands() {
      return regeneratorRuntime.wrap(function commands$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              return _context2.delegateYield(this._commands.values(), "t0", 1);

            case 1:
            case "end":
              return _context2.stop();
          }
        }
      }, commands, this);
    })
    /**
     * Iterable interface.
     *
     * Returns `[ commandName, commandInstance ]` pairs.
     *
     * @returns {Iterable.<Array>}
     */

  }, {
    key: Symbol.iterator,
    value: function value() {
      return this._commands[Symbol.iterator]();
    }
    /**
     * Destroys all collection commands.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      var _iterator = _createForOfIteratorHelper(this.commands()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var command = _step.value;
          command.destroy();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }]);

  return CommandCollection;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/conversion/viewconsumable.js











/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/conversion/viewconsumable
 */


/**
 * Class used for handling consumption of view {@link module:engine/view/element~Element elements},
 * {@link module:engine/view/text~Text text nodes} and {@link module:engine/view/documentfragment~DocumentFragment document fragments}.
 * Element's name and its parts (attributes, classes and styles) can be consumed separately. Consuming an element's name
 * does not consume its attributes, classes and styles.
 * To add items for consumption use {@link module:engine/conversion/viewconsumable~ViewConsumable#add add method}.
 * To test items use {@link module:engine/conversion/viewconsumable~ViewConsumable#test test method}.
 * To consume items use {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consume method}.
 * To revert already consumed items use {@link module:engine/conversion/viewconsumable~ViewConsumable#revert revert method}.
 *
 *		viewConsumable.add( element, { name: true } ); // Adds element's name as ready to be consumed.
 *		viewConsumable.add( textNode ); // Adds text node for consumption.
 *		viewConsumable.add( docFragment ); // Adds document fragment for consumption.
 *		viewConsumable.test( element, { name: true }  ); // Tests if element's name can be consumed.
 *		viewConsumable.test( textNode ); // Tests if text node can be consumed.
 *		viewConsumable.test( docFragment ); // Tests if document fragment can be consumed.
 *		viewConsumable.consume( element, { name: true }  ); // Consume element's name.
 *		viewConsumable.consume( textNode ); // Consume text node.
 *		viewConsumable.consume( docFragment ); // Consume document fragment.
 *		viewConsumable.revert( element, { name: true }  ); // Revert already consumed element's name.
 *		viewConsumable.revert( textNode ); // Revert already consumed text node.
 *		viewConsumable.revert( docFragment ); // Revert already consumed document fragment.
 */

var viewconsumable_ViewConsumable = /*#__PURE__*/function () {
  /**
   * Creates new ViewConsumable.
   */
  function ViewConsumable() {
    Object(classCallCheck["a" /* default */])(this, ViewConsumable);

    /**
     * Map of consumable elements. If {@link module:engine/view/element~Element element} is used as a key,
     * {@link module:engine/conversion/viewconsumable~ViewElementConsumables ViewElementConsumables} instance is stored as value.
     * For {@link module:engine/view/text~Text text nodes} and
     * {@link module:engine/view/documentfragment~DocumentFragment document fragments} boolean value is stored as value.
     *
     * @protected
     * @member {Map.<module:engine/conversion/viewconsumable~ViewElementConsumables|Boolean>}
    */
    this._consumables = new Map();
  }
  /**
   * Adds {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
   * {@link module:engine/view/documentfragment~DocumentFragment document fragment} as ready to be consumed.
   *
   *		viewConsumable.add( p, { name: true } ); // Adds element's name to consume.
   *		viewConsumable.add( p, { attributes: 'name' } ); // Adds element's attribute.
   *		viewConsumable.add( p, { classes: 'foobar' } ); // Adds element's class.
   *		viewConsumable.add( p, { styles: 'color' } ); // Adds element's style
   *		viewConsumable.add( p, { attributes: 'name', styles: 'color' } ); // Adds attribute and style.
   *		viewConsumable.add( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be provided.
   *		viewConsumable.add( textNode ); // Adds text node to consume.
   *		viewConsumable.add( docFragment ); // Adds document fragment to consume.
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
   * attribute is provided - it should be handled separately by providing actual style/class.
   *
   *		viewConsumable.add( p, { attributes: 'style' } ); // This call will throw an exception.
   *		viewConsumable.add( p, { styles: 'color' } ); // This is properly handled style.
   *
   * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element
   * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
   * @param {Boolean} consumables.name If set to true element's name will be included.
   * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.
   * @param {String|Array.<String>} consumables.classes Class name or array of class names.
   * @param {String|Array.<String>} consumables.styles Style name or array of style names.
   */


  Object(createClass["a" /* default */])(ViewConsumable, [{
    key: "add",
    value: function add(element, consumables) {
      var elementConsumables; // For text nodes and document fragments just mark them as consumable.

      if (element.is('text') || element.is('documentFragment')) {
        this._consumables.set(element, true);

        return;
      } // For elements create new ViewElementConsumables or update already existing one.


      if (!this._consumables.has(element)) {
        elementConsumables = new viewconsumable_ViewElementConsumables(element);

        this._consumables.set(element, elementConsumables);
      } else {
        elementConsumables = this._consumables.get(element);
      }

      elementConsumables.add(consumables);
    }
    /**
     * Tests if {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
     * {@link module:engine/view/documentfragment~DocumentFragment document fragment} can be consumed.
     * It returns `true` when all items included in method's call can be consumed. Returns `false` when
     * first already consumed item is found and `null` when first non-consumable item is found.
     *
     *		viewConsumable.test( p, { name: true } ); // Tests element's name.
     *		viewConsumable.test( p, { attributes: 'name' } ); // Tests attribute.
     *		viewConsumable.test( p, { classes: 'foobar' } ); // Tests class.
     *		viewConsumable.test( p, { styles: 'color' } ); // Tests style.
     *		viewConsumable.test( p, { attributes: 'name', styles: 'color' } ); // Tests attribute and style.
     *		viewConsumable.test( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be tested.
     *		viewConsumable.test( textNode ); // Tests text node.
     *		viewConsumable.test( docFragment ); // Tests document fragment.
     *
     * Testing classes and styles as attribute will test if all added classes/styles can be consumed.
     *
     *		viewConsumable.test( p, { attributes: 'class' } ); // Tests if all added classes can be consumed.
     *		viewConsumable.test( p, { attributes: 'style' } ); // Tests if all added styles can be consumed.
     *
     * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element
     * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
     * @param {Boolean} consumables.name If set to true element's name will be included.
     * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.
     * @param {String|Array.<String>} consumables.classes Class name or array of class names.
     * @param {String|Array.<String>} consumables.styles Style name or array of style names.
     * @returns {Boolean|null} Returns `true` when all items included in method's call can be consumed. Returns `false`
     * when first already consumed item is found and `null` when first non-consumable item is found.
     */

  }, {
    key: "test",
    value: function test(element, consumables) {
      var elementConsumables = this._consumables.get(element);

      if (elementConsumables === undefined) {
        return null;
      } // For text nodes and document fragments return stored boolean value.


      if (element.is('text') || element.is('documentFragment')) {
        return elementConsumables;
      } // For elements test consumables object.


      return elementConsumables.test(consumables);
    }
    /**
     * Consumes {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
     * {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
     * It returns `true` when all items included in method's call can be consumed, otherwise returns `false`.
     *
     *		viewConsumable.consume( p, { name: true } ); // Consumes element's name.
     *		viewConsumable.consume( p, { attributes: 'name' } ); // Consumes element's attribute.
     *		viewConsumable.consume( p, { classes: 'foobar' } ); // Consumes element's class.
     *		viewConsumable.consume( p, { styles: 'color' } ); // Consumes element's style.
     *		viewConsumable.consume( p, { attributes: 'name', styles: 'color' } ); // Consumes attribute and style.
     *		viewConsumable.consume( p, { classes: [ 'baz', 'bar' ] } ); // Multiple consumables can be consumed.
     *		viewConsumable.consume( textNode ); // Consumes text node.
     *		viewConsumable.consume( docFragment ); // Consumes document fragment.
     *
     * Consuming classes and styles as attribute will test if all added classes/styles can be consumed.
     *
     *		viewConsumable.consume( p, { attributes: 'class' } ); // Consume only if all added classes can be consumed.
     *		viewConsumable.consume( p, { attributes: 'style' } ); // Consume only if all added styles can be consumed.
     *
     * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element
     * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
     * @param {Boolean} consumables.name If set to true element's name will be included.
     * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.
     * @param {String|Array.<String>} consumables.classes Class name or array of class names.
     * @param {String|Array.<String>} consumables.styles Style name or array of style names.
     * @returns {Boolean} Returns `true` when all items included in method's call can be consumed,
     * otherwise returns `false`.
     */

  }, {
    key: "consume",
    value: function consume(element, consumables) {
      if (this.test(element, consumables)) {
        if (element.is('text') || element.is('documentFragment')) {
          // For text nodes and document fragments set value to false.
          this._consumables.set(element, false);
        } else {
          // For elements - consume consumables object.
          this._consumables.get(element).consume(consumables);
        }

        return true;
      }

      return false;
    }
    /**
     * Reverts {@link module:engine/view/element~Element view element}, {@link module:engine/view/text~Text text node} or
     * {@link module:engine/view/documentfragment~DocumentFragment document fragment} so they can be consumed once again.
     * Method does not revert items that were never previously added for consumption, even if they are included in
     * method's call.
     *
     *		viewConsumable.revert( p, { name: true } ); // Reverts element's name.
     *		viewConsumable.revert( p, { attributes: 'name' } ); // Reverts element's attribute.
     *		viewConsumable.revert( p, { classes: 'foobar' } ); // Reverts element's class.
     *		viewConsumable.revert( p, { styles: 'color' } ); // Reverts element's style.
     *		viewConsumable.revert( p, { attributes: 'name', styles: 'color' } ); // Reverts attribute and style.
     *		viewConsumable.revert( p, { classes: [ 'baz', 'bar' ] } ); // Multiple names can be reverted.
     *		viewConsumable.revert( textNode ); // Reverts text node.
     *		viewConsumable.revert( docFragment ); // Reverts document fragment.
     *
     * Reverting classes and styles as attribute will revert all classes/styles that were previously added for
     * consumption.
     *
     *		viewConsumable.revert( p, { attributes: 'class' } ); // Reverts all classes added for consumption.
     *		viewConsumable.revert( p, { attributes: 'style' } ); // Reverts all styles added for consumption.
     *
     * @param {module:engine/view/element~Element|module:engine/view/text~Text|module:engine/view/documentfragment~DocumentFragment} element
     * @param {Object} [consumables] Used only if first parameter is {@link module:engine/view/element~Element view element} instance.
     * @param {Boolean} consumables.name If set to true element's name will be included.
     * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names.
     * @param {String|Array.<String>} consumables.classes Class name or array of class names.
     * @param {String|Array.<String>} consumables.styles Style name or array of style names.
     */

  }, {
    key: "revert",
    value: function revert(element, consumables) {
      var elementConsumables = this._consumables.get(element);

      if (elementConsumables !== undefined) {
        if (element.is('text') || element.is('documentFragment')) {
          // For text nodes and document fragments - set consumable to true.
          this._consumables.set(element, true);
        } else {
          // For elements - revert items from consumables object.
          elementConsumables.revert(consumables);
        }
      }
    }
    /**
     * Creates consumable object from {@link module:engine/view/element~Element view element}. Consumable object will include
     * element's name and all its attributes, classes and styles.
     *
     * @static
     * @param {module:engine/view/element~Element} element
     * @returns {Object} consumables
     */

  }], [{
    key: "consumablesFromElement",
    value: function consumablesFromElement(element) {
      var consumables = {
        element: element,
        name: true,
        attributes: [],
        classes: [],
        styles: []
      };
      var attributes = element.getAttributeKeys();

      var _iterator = _createForOfIteratorHelper(attributes),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var attribute = _step.value;

          // Skip classes and styles - will be added separately.
          if (attribute == 'style' || attribute == 'class') {
            continue;
          }

          consumables.attributes.push(attribute);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var classes = element.getClassNames();

      var _iterator2 = _createForOfIteratorHelper(classes),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var className = _step2.value;
          consumables.classes.push(className);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var styles = element.getStyleNames();

      var _iterator3 = _createForOfIteratorHelper(styles),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var style = _step3.value;
          consumables.styles.push(style);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      return consumables;
    }
    /**
     * Creates {@link module:engine/conversion/viewconsumable~ViewConsumable ViewConsumable} instance from
     * {@link module:engine/view/node~Node node} or {@link module:engine/view/documentfragment~DocumentFragment document fragment}.
     * Instance will contain all elements, child nodes, attributes, styles and classes added for consumption.
     *
     * @static
     * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} from View node or document fragment
     * from which `ViewConsumable` will be created.
     * @param {module:engine/conversion/viewconsumable~ViewConsumable} [instance] If provided, given `ViewConsumable` instance will be used
     * to add all consumables. It will be returned instead of a new instance.
     */

  }, {
    key: "createFrom",
    value: function createFrom(from, instance) {
      if (!instance) {
        instance = new ViewConsumable(from);
      }

      if (from.is('text')) {
        instance.add(from);
        return instance;
      } // Add `from` itself, if it is an element.


      if (from.is('element')) {
        instance.add(from, ViewConsumable.consumablesFromElement(from));
      }

      if (from.is('documentFragment')) {
        instance.add(from);
      }

      var _iterator4 = _createForOfIteratorHelper(from.getChildren()),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var child = _step4.value;
          instance = ViewConsumable.createFrom(child, instance);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      return instance;
    }
  }]);

  return ViewConsumable;
}();
/**
 * This is a private helper-class for {@link module:engine/conversion/viewconsumable~ViewConsumable}.
 * It represents and manipulates consumable parts of a single {@link module:engine/view/element~Element}.
 *
 * @private
 */




var viewconsumable_ViewElementConsumables = /*#__PURE__*/function () {
  /**
   * Creates ViewElementConsumables instance.
   *
   * @param {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment} from View node or document fragment
   * from which `ViewElementConsumables` is being created.
   */
  function ViewElementConsumables(from) {
    Object(classCallCheck["a" /* default */])(this, ViewElementConsumables);

    /**
     * @readonly
     * @member {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment}
     */
    this.element = from;
    /**
     * Flag indicating if name of the element can be consumed.
     *
     * @private
     * @member {Boolean}
     */

    this._canConsumeName = null;
    /**
     * Contains maps of element's consumables: attributes, classes and styles.
     *
     * @private
     * @member {Object}
     */

    this._consumables = {
      attributes: new Map(),
      styles: new Map(),
      classes: new Map()
    };
  }
  /**
   * Adds consumable parts of the {@link module:engine/view/element~Element view element}.
   * Element's name itself can be marked to be consumed (when element's name is consumed its attributes, classes and
   * styles still could be consumed):
   *
   *		consumables.add( { name: true } );
   *
   * Attributes classes and styles:
   *
   *		consumables.add( { attributes: 'title', classes: 'foo', styles: 'color' } );
   *		consumables.add( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
   *
   * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
   * attribute is provided - it should be handled separately by providing `style` and `class` in consumables object.
   *
   * @param {Object} consumables Object describing which parts of the element can be consumed.
   * @param {Boolean} consumables.name If set to `true` element's name will be added as consumable.
   * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to add as consumable.
   * @param {String|Array.<String>} consumables.classes Class name or array of class names to add as consumable.
   * @param {String|Array.<String>} consumables.styles Style name or array of style names to add as consumable.
   */


  Object(createClass["a" /* default */])(ViewElementConsumables, [{
    key: "add",
    value: function add(consumables) {
      if (consumables.name) {
        this._canConsumeName = true;
      }

      for (var type in this._consumables) {
        if (type in consumables) {
          this._add(type, consumables[type]);
        }
      }
    }
    /**
     * Tests if parts of the {@link module:engine/view/node~Node view node} can be consumed.
     *
     * Element's name can be tested:
     *
     *		consumables.test( { name: true } );
     *
     * Attributes classes and styles:
     *
     *		consumables.test( { attributes: 'title', classes: 'foo', styles: 'color' } );
     *		consumables.test( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
     *
     * @param {Object} consumables Object describing which parts of the element should be tested.
     * @param {Boolean} consumables.name If set to `true` element's name will be tested.
     * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to test.
     * @param {String|Array.<String>} consumables.classes Class name or array of class names to test.
     * @param {String|Array.<String>} consumables.styles Style name or array of style names to test.
     * @returns {Boolean|null} `true` when all tested items can be consumed, `null` when even one of the items
     * was never marked for consumption and `false` when even one of the items was already consumed.
     */

  }, {
    key: "test",
    value: function test(consumables) {
      // Check if name can be consumed.
      if (consumables.name && !this._canConsumeName) {
        return this._canConsumeName;
      }

      for (var type in this._consumables) {
        if (type in consumables) {
          var value = this._test(type, consumables[type]);

          if (value !== true) {
            return value;
          }
        }
      } // Return true only if all can be consumed.


      return true;
    }
    /**
     * Consumes parts of {@link module:engine/view/element~Element view element}. This function does not check if consumable item
     * is already consumed - it consumes all consumable items provided.
     * Element's name can be consumed:
     *
     *		consumables.consume( { name: true } );
     *
     * Attributes classes and styles:
     *
     *		consumables.consume( { attributes: 'title', classes: 'foo', styles: 'color' } );
     *		consumables.consume( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
     *
     * @param {Object} consumables Object describing which parts of the element should be consumed.
     * @param {Boolean} consumables.name If set to `true` element's name will be consumed.
     * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to consume.
     * @param {String|Array.<String>} consumables.classes Class name or array of class names to consume.
     * @param {String|Array.<String>} consumables.styles Style name or array of style names to consume.
     */

  }, {
    key: "consume",
    value: function consume(consumables) {
      if (consumables.name) {
        this._canConsumeName = false;
      }

      for (var type in this._consumables) {
        if (type in consumables) {
          this._consume(type, consumables[type]);
        }
      }
    }
    /**
     * Revert already consumed parts of {@link module:engine/view/element~Element view Element}, so they can be consumed once again.
     * Element's name can be reverted:
     *
     *		consumables.revert( { name: true } );
     *
     * Attributes classes and styles:
     *
     *		consumables.revert( { attributes: 'title', classes: 'foo', styles: 'color' } );
     *		consumables.revert( { attributes: [ 'title', 'name' ], classes: [ 'foo', 'bar' ] );
     *
     * @param {Object} consumables Object describing which parts of the element should be reverted.
     * @param {Boolean} consumables.name If set to `true` element's name will be reverted.
     * @param {String|Array.<String>} consumables.attributes Attribute name or array of attribute names to revert.
     * @param {String|Array.<String>} consumables.classes Class name or array of class names to revert.
     * @param {String|Array.<String>} consumables.styles Style name or array of style names to revert.
     */

  }, {
    key: "revert",
    value: function revert(consumables) {
      if (consumables.name) {
        this._canConsumeName = true;
      }

      for (var type in this._consumables) {
        if (type in consumables) {
          this._revert(type, consumables[type]);
        }
      }
    }
    /**
     * Helper method that adds consumables of a given type: attribute, class or style.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `viewconsumable-invalid-attribute` when `class` or `style`
     * type is provided - it should be handled separately by providing actual style/class type.
     *
     * @private
     * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.
     * @param {String|Array.<String>} item Consumable item or array of items.
     */

  }, {
    key: "_add",
    value: function _add(type, item) {
      var items = lodash_es_isArray(item) ? item : [item];
      var consumables = this._consumables[type];

      var _iterator5 = _createForOfIteratorHelper(items),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var name = _step5.value;

          if (type === 'attributes' && (name === 'class' || name === 'style')) {
            /**
             * Class and style attributes should be handled separately in
             * {@link module:engine/conversion/viewconsumable~ViewConsumable#add `ViewConsumable#add()`}.
             *
             * What you have done is trying to use:
             *
             *		consumables.add( { attributes: [ 'class', 'style' ] } );
             *
             * While each class and style should be registered separately:
             *
             *		consumables.add( { classes: 'some-class', styles: 'font-weight' } );
             *
             * @error viewconsumable-invalid-attribute
             */
            throw new ckeditorerror["b" /* default */]('viewconsumable-invalid-attribute: Classes and styles should be handled separately.', this);
          }

          consumables.set(name, true);

          if (type === 'styles') {
            var _iterator6 = _createForOfIteratorHelper(this.element.document.stylesProcessor.getRelatedStyles(name)),
                _step6;

            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var alsoName = _step6.value;
                consumables.set(alsoName, true);
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
    /**
     * Helper method that tests consumables of a given type: attribute, class or style.
     *
     * @private
     * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.
     * @param {String|Array.<String>} item Consumable item or array of items.
     * @returns {Boolean|null} Returns `true` if all items can be consumed, `null` when one of the items cannot be
     * consumed and `false` when one of the items is already consumed.
     */

  }, {
    key: "_test",
    value: function _test(type, item) {
      var items = lodash_es_isArray(item) ? item : [item];
      var consumables = this._consumables[type];

      var _iterator7 = _createForOfIteratorHelper(items),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var name = _step7.value;

          if (type === 'attributes' && (name === 'class' || name === 'style')) {
            var consumableName = name == 'class' ? 'classes' : 'styles'; // Check all classes/styles if class/style attribute is tested.

            var value = this._test(consumableName, _toConsumableArray(this._consumables[consumableName].keys()));

            if (value !== true) {
              return value;
            }
          } else {
            var _value = consumables.get(name); // Return null if attribute is not found.


            if (_value === undefined) {
              return null;
            }

            if (!_value) {
              return false;
            }
          }
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }

      return true;
    }
    /**
     * Helper method that consumes items of a given type: attribute, class or style.
     *
     * @private
     * @param {String} type Type of the consumable item: `attributes`, `classes` or `styles`.
     * @param {String|Array.<String>} item Consumable item or array of items.
     */

  }, {
    key: "_consume",
    value: function _consume(type, item) {
      var items = lodash_es_isArray(item) ? item : [item];
      var consumables = this._consumables[type];

      var _iterator8 = _createForOfIteratorHelper(items),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var name = _step8.value;

          if (type === 'attributes' && (name === 'class' || name === 'style')) {
            var consumableName = name == 'class' ? 'classes' : 'styles'; // If class or style is provided for consumption - consume them all.

            this._consume(consumableName, _toConsumableArray(this._consumables[consumableName].keys()));
          } else {
            consumables.set(name, false);

            if (type == 'styles') {
              var _iterator9 = _createForOfIteratorHelper(this.element.document.stylesProcessor.getRelatedStyles(name)),
                  _step9;

              try {
                for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
                  var toConsume = _step9.value;
                  consumables.set(toConsume, false);
                }
              } catch (err) {
                _iterator9.e(err);
              } finally {
                _iterator9.f();
              }
            }
          }
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
    }
    /**
     * Helper method that reverts items of a given type: attribute, class or style.
     *
     * @private
     * @param {String} type Type of the consumable item: `attributes`, `classes` or , `styles`.
     * @param {String|Array.<String>} item Consumable item or array of items.
     */

  }, {
    key: "_revert",
    value: function _revert(type, item) {
      var items = lodash_es_isArray(item) ? item : [item];
      var consumables = this._consumables[type];

      var _iterator10 = _createForOfIteratorHelper(items),
          _step10;

      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var name = _step10.value;

          if (type === 'attributes' && (name === 'class' || name === 'style')) {
            var consumableName = name == 'class' ? 'classes' : 'styles'; // If class or style is provided for reverting - revert them all.

            this._revert(consumableName, _toConsumableArray(this._consumables[consumableName].keys()));
          } else {
            var value = consumables.get(name);

            if (value === false) {
              consumables.set(name, true);
            }
          }
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }
    }
  }]);

  return ViewElementConsumables;
}();
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.ends-with.js
var es_string_ends_with = __webpack_require__("8a79");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/schema.js































var schema_marked = /*#__PURE__*/regeneratorRuntime.mark(combineWalkers),
    _marked2 = /*#__PURE__*/regeneratorRuntime.mark(convertToMinimalFlatRanges);

/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/schema
 */








/**
 * The model's schema. It defines allowed and disallowed structures of nodes as well as nodes' attributes.
 * The schema is usually defined by features and based on them the editing framework and features
 * make decisions how to change and process the model.
 *
 * The instance of schema is available in {@link module:engine/model/model~Model#schema `editor.model.schema`}.
 *
 * Read more about the schema in:
 *
 * * {@glink framework/guides/architecture/editing-engine#schema Schema} section of the
 * {@glink framework/guides/architecture/editing-engine Introduction to the Editing engine architecture}.
 * * {@glink framework/guides/deep-dive/schema Schema deep dive} guide.
 *
 * @mixes module:utils/observablemixin~ObservableMixin
 */

var schema_Schema = /*#__PURE__*/function () {
  /**
   * Creates schema instance.
   */
  function Schema() {
    var _this = this;

    Object(classCallCheck["a" /* default */])(this, Schema);

    this._sourceDefinitions = {};
    /**
     * A dictionary containing attribute properties.
     *
     * @private
     * @member {Object.<String,String>}
     */

    this._attributeProperties = {};
    this.decorate('checkChild');
    this.decorate('checkAttribute');
    this.on('checkAttribute', function (evt, args) {
      args[0] = new schema_SchemaContext(args[0]);
    }, {
      priority: 'highest'
    });
    this.on('checkChild', function (evt, args) {
      args[0] = new schema_SchemaContext(args[0]);
      args[1] = _this.getDefinition(args[1]);
    }, {
      priority: 'highest'
    });
  }
  /**
   * Registers schema item. Can only be called once for every item name.
   *
   *		schema.register( 'paragraph', {
   *			inheritAllFrom: '$block'
   *		} );
   *
   * @param {String} itemName
   * @param {module:engine/model/schema~SchemaItemDefinition} definition
   */


  Object(createClass["a" /* default */])(Schema, [{
    key: "register",
    value: function register(itemName, definition) {
      if (this._sourceDefinitions[itemName]) {
        /**
         * A single item cannot be registered twice in the schema.
         *
         * This situation may happen when:
         *
         * * Two or more plugins called {@link #register `register()`} with the same name. This will usually mean that
         * there is a collision between plugins which try to use the same element in the model. Unfortunately,
         * the only way to solve this is by modifying one of these plugins to use a unique model element name.
         * * A single plugin was loaded twice. This happens when it is installed by npm/yarn in two versions
         * and usually means one or more of the following issues:
         *     * a version mismatch (two of your dependencies require two different versions of this plugin),
         *     * incorrect imports (this plugin is somehow imported twice in a way which confuses webpack),
         *     * mess in `node_modules/` (`rm -rf node_modules/` may help).
         *
         * **Note:** Check the logged `itemName` to better understand which plugin was duplicated/conflicting.
         *
         * @param itemName The name of the model element that is being registered twice.
         * @error schema-cannot-register-item-twice
         */
        throw new ckeditorerror["b" /* default */]('schema-cannot-register-item-twice: A single item cannot be registered twice in the schema.', this, {
          itemName: itemName
        });
      }

      this._sourceDefinitions[itemName] = [Object.assign({}, definition)];

      this._clearCache();
    }
    /**
     * Extends a {@link #register registered} item's definition.
     *
     * Extending properties such as `allowIn` will add more items to the existing properties,
     * while redefining properties such as `isBlock` will override the previously defined ones.
     *
     *		schema.register( 'foo', {
     *			allowIn: '$root',
     *			isBlock: true;
     *		} );
     *		schema.extend( 'foo', {
     *			allowIn: 'blockQuote',
     *			isBlock: false
     *		} );
     *
     *		schema.getDefinition( 'foo' );
     *		//	{
     *		//		allowIn: [ '$root', 'blockQuote' ],
     *		// 		isBlock: false
     *		//	}
     *
     * @param {String} itemName
     * @param {module:engine/model/schema~SchemaItemDefinition} definition
     */

  }, {
    key: "extend",
    value: function extend(itemName, definition) {
      if (!this._sourceDefinitions[itemName]) {
        /**
         * Cannot extend an item which was not registered yet.
         *
         * This error happens when a plugin tries to extend the schema definition of an item which was not
         * {@link #register registered} yet.
         *
         * @param itemName The name of the model element which is being extended.
         * @error schema-cannot-extend-missing-item
         */
        throw new ckeditorerror["b" /* default */]('schema-cannot-extend-missing-item: Cannot extend an item which was not registered yet.', this, {
          itemName: itemName
        });
      }

      this._sourceDefinitions[itemName].push(Object.assign({}, definition));

      this._clearCache();
    }
    /**
     * Returns data of all registered items.
     *
     * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,
     * checking a list of all block elements, etc).
     * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})
     * in other cases.
     *
     * @returns {Object.<String,module:engine/model/schema~SchemaCompiledItemDefinition>}
     */

  }, {
    key: "getDefinitions",
    value: function getDefinitions() {
      if (!this._compiledDefinitions) {
        this._compile();
      }

      return this._compiledDefinitions;
    }
    /**
     * Returns a definition of the given item or `undefined` if an item is not registered.
     *
     * This method should normally be used for reflection purposes (e.g. defining a clone of a certain element,
     * checking a list of all block elements, etc).
     * Use specific methods (such as {@link #checkChild `checkChild()`} or {@link #isLimit `isLimit()`})
     * in other cases.
     *
     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item
     * @returns {module:engine/model/schema~SchemaCompiledItemDefinition}
     */

  }, {
    key: "getDefinition",
    value: function getDefinition(item) {
      var itemName;

      if (typeof item == 'string') {
        itemName = item;
      } else if (item.is && (item.is('text') || item.is('textProxy'))) {
        itemName = '$text';
      } // Element or module:engine/model/schema~SchemaContextItem.
      else {
          itemName = item.name;
        }

      return this.getDefinitions()[itemName];
    }
    /**
     * Returns `true` if the given item is registered in the schema.
     *
     *		schema.isRegistered( 'paragraph' ); // -> true
     *		schema.isRegistered( editor.model.document.getRoot() ); // -> true
     *		schema.isRegistered( 'foo' ); // -> false
     *
     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item
     */

  }, {
    key: "isRegistered",
    value: function isRegistered(item) {
      return !!this.getDefinition(item);
    }
    /**
     * Returns `true` if the given item is defined to be
     * a block by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isBlock` property.
     *
     *		schema.isBlock( 'paragraph' ); // -> true
     *		schema.isBlock( '$root' ); // -> false
     *
     *		const paragraphElement = writer.createElement( 'paragraph' );
     *		schema.isBlock( paragraphElement ); // -> true
     *
     * See the {@glink framework/guides/deep-dive/schema#block-elements Block elements} section of the Schema deep dive}
     * guide for more details.
     *
     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item
     */

  }, {
    key: "isBlock",
    value: function isBlock(item) {
      var def = this.getDefinition(item);
      return !!(def && def.isBlock);
    }
    /**
     * Returns `true` if the given item should be treated as a limit element.
     *
     * It considers an item to be a limit element if its
     * {@link module:engine/model/schema~SchemaItemDefinition}'s
     * {@link module:engine/model/schema~SchemaItemDefinition#isLimit `isLimit`} or
     * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property
     * was set to `true`.
     *
     *		schema.isLimit( 'paragraph' ); // -> false
     *		schema.isLimit( '$root' ); // -> true
     *		schema.isLimit( editor.model.document.getRoot() ); // -> true
     *		schema.isLimit( 'image' ); // -> true
     *
     * See the {@glink framework/guides/deep-dive/schema#limit-elements Limit elements} section of the Schema deep dive}
     * guide for more details.
     *
     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item
     */

  }, {
    key: "isLimit",
    value: function isLimit(item) {
      var def = this.getDefinition(item);

      if (!def) {
        return false;
      }

      return !!(def.isLimit || def.isObject);
    }
    /**
     * Returns `true` if the given item should be treated as an object element.
     *
     * It considers an item to be an object element if its
     * {@link module:engine/model/schema~SchemaItemDefinition}'s
     * {@link module:engine/model/schema~SchemaItemDefinition#isObject `isObject`} property
     * was set to `true`.
     *
     *		schema.isObject( 'paragraph' ); // -> false
     *		schema.isObject( 'image' ); // -> true
     *
     *		const imageElement = writer.createElement( 'image' );
     *		schema.isObject( imageElement ); // -> true
     *
     * See the {@glink framework/guides/deep-dive/schema#object-elements Object elements} section of the Schema deep dive}
     * guide for more details.
     *
     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item
     */

  }, {
    key: "isObject",
    value: function isObject(item) {
      var def = this.getDefinition(item);
      return !!(def && def.isObject);
    }
    /**
     * Returns `true` if the given item is defined to be
     * an inline element by the {@link module:engine/model/schema~SchemaItemDefinition}'s `isInline` property.
     *
     *		schema.isInline( 'paragraph' ); // -> false
     *		schema.isInline( 'softBreak' ); // -> true
     *
     *		const text = writer.createText('foo' );
     *		schema.isInline( text ); // -> true
     *
     * See the {@glink framework/guides/deep-dive/schema#inline-elements Inline elements} section of the Schema deep dive}
     * guide for more details.
     *
     * @param {module:engine/model/item~Item|module:engine/model/schema~SchemaContextItem|String} item
     */

  }, {
    key: "isInline",
    value: function isInline(item) {
      var def = this.getDefinition(item);
      return !!(def && def.isInline);
    }
    /**
     * Checks whether the given node (`child`) can be a child of the given context.
     *
     *		schema.checkChild( model.document.getRoot(), paragraph ); // -> false
     *
     *		schema.register( 'paragraph', {
     *			allowIn: '$root'
     *		} );
     *		schema.checkChild( model.document.getRoot(), paragraph ); // -> true
     *
     * Note: When verifying whether the given node can be a child of the given context, the
     * schema also verifies the entire context &mdash; from its root to its last element. Therefore, it is possible
     * for `checkChild()` to return `false` even though the context's last element can contain the checked child.
     * It happens if one of the context's elements does not allow its child.
     *
     * @fires checkChild
     * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the child will be checked.
     * @param {module:engine/model/node~Node|String} def The child to check.
     */

  }, {
    key: "checkChild",
    value: function checkChild(context, def) {
      // Note: context and child are already normalized here to a SchemaContext and SchemaCompiledItemDefinition.
      if (!def) {
        return false;
      }

      return this._checkContextMatch(def, context);
    }
    /**
     * Checks whether the given attribute can be applied in the given context (on the last
     * item of the context).
     *
     *		schema.checkAttribute( textNode, 'bold' ); // -> false
     *
     *		schema.extend( '$text', {
     *			allowAttributes: 'bold'
     *		} );
     *		schema.checkAttribute( textNode, 'bold' ); // -> true
     *
     * @fires checkAttribute
     * @param {module:engine/model/schema~SchemaContextDefinition} context The context in which the attribute will be checked.
     * @param {String} attributeName
     */

  }, {
    key: "checkAttribute",
    value: function checkAttribute(context, attributeName) {
      var def = this.getDefinition(context.last);

      if (!def) {
        return false;
      }

      return def.allowAttributes.includes(attributeName);
    }
    /**
     * Checks whether the given element (`elementToMerge`) can be merged with the specified base element (`positionOrBaseElement`).
     *
     * In other words &mdash; whether `elementToMerge`'s children {@link #checkChild are allowed} in the `positionOrBaseElement`.
     *
     * This check ensures that elements merged with {@link module:engine/model/writer~Writer#merge `Writer#merge()`}
     * will be valid.
     *
     * Instead of elements, you can pass the instance of the {@link module:engine/model/position~Position} class as the
     * `positionOrBaseElement`. It means that the elements before and after the position will be checked whether they can be merged.
     *
     * @param {module:engine/model/position~Position|module:engine/model/element~Element} positionOrBaseElement The position or base
     * element to which the `elementToMerge` will be merged.
     * @param {module:engine/model/element~Element} elementToMerge The element to merge. Required if `positionOrBaseElement` is an element.
     * @returns {Boolean}
     */

  }, {
    key: "checkMerge",
    value: function checkMerge(positionOrBaseElement) {
      var elementToMerge = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (positionOrBaseElement instanceof model_position_Position) {
        var nodeBefore = positionOrBaseElement.nodeBefore;
        var nodeAfter = positionOrBaseElement.nodeAfter;

        if (!(nodeBefore instanceof model_element_Element)) {
          /**
           * The node before the merge position must be an element.
           *
           * @error schema-check-merge-no-element-before
           */
          throw new ckeditorerror["b" /* default */]('schema-check-merge-no-element-before: The node before the merge position must be an element.', this);
        }

        if (!(nodeAfter instanceof model_element_Element)) {
          /**
           * The node after the merge position must be an element.
           *
           * @error schema-check-merge-no-element-after
           */
          throw new ckeditorerror["b" /* default */]('schema-check-merge-no-element-after: The node after the merge position must be an element.', this);
        }

        return this.checkMerge(nodeBefore, nodeAfter);
      }

      var _iterator = _createForOfIteratorHelper(elementToMerge.getChildren()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var child = _step.value;

          if (!this.checkChild(positionOrBaseElement, child)) {
            return false;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return true;
    }
    /**
     * Allows registering a callback to the {@link #checkChild} method calls.
     *
     * Callbacks allow you to implement rules which are not otherwise possible to achieve
     * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.
     * For example, by using this method you can disallow elements in specific contexts.
     *
     * This method is a shorthand for using the {@link #event:checkChild} event. For even better control,
     * you can use that event instead.
     *
     * Example:
     *
     *		// Disallow heading1 directly inside a blockQuote.
     *		schema.addChildCheck( ( context, childDefinition ) => {
     *			if ( context.endsWith( 'blockQuote' ) && childDefinition.name == 'heading1' ) {
     *				return false;
     *			}
     *		} );
     *
     * Which translates to:
     *
     *		schema.on( 'checkChild', ( evt, args ) => {
     *			const context = args[ 0 ];
     *			const childDefinition = args[ 1 ];
     *
     *			if ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {
     *				// Prevent next listeners from being called.
     *				evt.stop();
     *				// Set the checkChild()'s return value.
     *				evt.return = false;
     *			}
     *		}, { priority: 'high' } );
     *
     * @param {Function} callback The callback to be called. It is called with two parameters:
     * {@link module:engine/model/schema~SchemaContext} (context) instance and
     * {@link module:engine/model/schema~SchemaCompiledItemDefinition} (child-to-check definition).
     * The callback may return `true/false` to override `checkChild()`'s return value. If it does not return
     * a boolean value, the default algorithm (or other callbacks) will define `checkChild()`'s return value.
     */

  }, {
    key: "addChildCheck",
    value: function addChildCheck(callback) {
      this.on('checkChild', function (evt, _ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            ctx = _ref2[0],
            childDef = _ref2[1];

        // checkChild() was called with a non-registered child.
        // In 99% cases such check should return false, so not to overcomplicate all callbacks
        // don't even execute them.
        if (!childDef) {
          return;
        }

        var retValue = callback(ctx, childDef);

        if (typeof retValue == 'boolean') {
          evt.stop();
          evt.return = retValue;
        }
      }, {
        priority: 'high'
      });
    }
    /**
     * Allows registering a callback to the {@link #checkAttribute} method calls.
     *
     * Callbacks allow you to implement rules which are not otherwise possible to achieve
     * by using the declarative API of {@link module:engine/model/schema~SchemaItemDefinition}.
     * For example, by using this method you can disallow attribute if node to which it is applied
     * is contained within some other element (e.g. you want to disallow `bold` on `$text` within `heading1`).
     *
     * This method is a shorthand for using the {@link #event:checkAttribute} event. For even better control,
     * you can use that event instead.
     *
     * Example:
     *
     *		// Disallow bold on $text inside heading1.
     *		schema.addAttributeCheck( ( context, attributeName ) => {
     *			if ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {
     *				return false;
     *			}
     *		} );
     *
     * Which translates to:
     *
     *		schema.on( 'checkAttribute', ( evt, args ) => {
     *			const context = args[ 0 ];
     *			const attributeName = args[ 1 ];
     *
     *			if ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {
     *				// Prevent next listeners from being called.
     *				evt.stop();
     *				// Set the checkAttribute()'s return value.
     *				evt.return = false;
     *			}
     *		}, { priority: 'high' } );
     *
     * @param {Function} callback The callback to be called. It is called with two parameters:
     * {@link module:engine/model/schema~SchemaContext} (context) instance and attribute name.
     * The callback may return `true/false` to override `checkAttribute()`'s return value. If it does not return
     * a boolean value, the default algorithm (or other callbacks) will define `checkAttribute()`'s return value.
     */

  }, {
    key: "addAttributeCheck",
    value: function addAttributeCheck(callback) {
      this.on('checkAttribute', function (evt, _ref3) {
        var _ref4 = _slicedToArray(_ref3, 2),
            ctx = _ref4[0],
            attributeName = _ref4[1];

        var retValue = callback(ctx, attributeName);

        if (typeof retValue == 'boolean') {
          evt.stop();
          evt.return = retValue;
        }
      }, {
        priority: 'high'
      });
    }
    /**
     * This method allows assigning additional metadata to the model attributes. For example,
     * {@link module:engine/model/schema~AttributeProperties `AttributeProperties#isFormatting` property} is
     * used to mark formatting attributes (like `bold` or `italic`).
     *
     *		// Mark bold as a formatting attribute.
     *		schema.setAttributeProperties( 'bold', {
     *			isFormatting: true
     *		} );
     *
     *		// Override code not to be considered a formatting markup.
     *		schema.setAttributeProperties( 'code', {
     *			isFormatting: false
     *		} );
     *
     * Properties are not limited to members defined in the
     * {@link module:engine/model/schema~AttributeProperties `AttributeProperties` type} and you can also use custom properties:
     *
     *		schema.setAttributeProperties( 'blockQuote', {
     *			customProperty: 'value'
     *		} );
     *
     * Subsequent calls with the same attribute will extend its custom properties:
     *
     *		schema.setAttributeProperties( 'blockQuote', {
     *			one: 1
     *		} );
     *
     *		schema.setAttributeProperties( 'blockQuote', {
     *			two: 2
     *		} );
     *
     *		console.log( schema.getAttributeProperties( 'blockQuote' ) );
     *		// Logs: { one: 1, two: 2 }
     *
     * @param {String} attributeName A name of the attribute to receive the properties.
     * @param {module:engine/model/schema~AttributeProperties} properties A dictionary of properties.
     */

  }, {
    key: "setAttributeProperties",
    value: function setAttributeProperties(attributeName, properties) {
      this._attributeProperties[attributeName] = Object.assign(this.getAttributeProperties(attributeName), properties);
    }
    /**
     * Returns properties associated with a given model attribute. See {@link #setAttributeProperties `setAttributeProperties()`}.
     *
     * @param {String} attributeName A name of the attribute.
     * @returns {module:engine/model/schema~AttributeProperties}
     */

  }, {
    key: "getAttributeProperties",
    value: function getAttributeProperties(attributeName) {
      return this._attributeProperties[attributeName] || {};
    }
    /**
     * Returns the lowest {@link module:engine/model/schema~Schema#isLimit limit element} containing the entire
     * selection/range/position or the root otherwise.
     *
     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection|
     * module:engine/model/range~Range|module:engine/model/position~Position} selectionOrRangeOrPosition
     * The selection/range/position to check.
     * @returns {module:engine/model/element~Element} The lowest limit element containing
     * the entire `selectionOrRangeOrPosition`.
     */

  }, {
    key: "getLimitElement",
    value: function getLimitElement(selectionOrRangeOrPosition) {
      var element;

      if (selectionOrRangeOrPosition instanceof model_position_Position) {
        element = selectionOrRangeOrPosition.parent;
      } else {
        var ranges = selectionOrRangeOrPosition instanceof model_range_Range ? [selectionOrRangeOrPosition] : Array.from(selectionOrRangeOrPosition.getRanges()); // Find the common ancestor for all selection's ranges.

        element = ranges.reduce(function (element, range) {
          var rangeCommonAncestor = range.getCommonAncestor();

          if (!element) {
            return rangeCommonAncestor;
          }

          return element.getCommonAncestor(rangeCommonAncestor, {
            includeSelf: true
          });
        }, null);
      }

      while (!this.isLimit(element)) {
        if (element.parent) {
          element = element.parent;
        } else {
          break;
        }
      }

      return element;
    }
    /**
     * Checks whether the attribute is allowed in selection:
     *
     * * if the selection is not collapsed, then checks if the attribute is allowed on any of nodes in that range,
     * * if the selection is collapsed, then checks if on the selection position there's a text with the
     * specified attribute allowed.
     *
     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection
     * Selection which will be checked.
     * @param {String} attribute The name of the attribute to check.
     * @returns {Boolean}
     */

  }, {
    key: "checkAttributeInSelection",
    value: function checkAttributeInSelection(selection, attribute) {
      if (selection.isCollapsed) {
        var firstPosition = selection.getFirstPosition();

        var _context = [].concat(_toConsumableArray(firstPosition.getAncestors()), [new model_text_Text('', selection.getAttributes())]); // Check whether schema allows for a text with the attribute in the selection.


        return this.checkAttribute(_context, attribute);
      } else {
        var ranges = selection.getRanges(); // For all ranges, check nodes in them until you find a node that is allowed to have the attribute.

        var _iterator2 = _createForOfIteratorHelper(ranges),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var range = _step2.value;

            var _iterator3 = _createForOfIteratorHelper(range),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var value = _step3.value;

                if (this.checkAttribute(value.item, attribute)) {
                  // If we found a node that is allowed to have the attribute, return true.
                  return true;
                }
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } // If we haven't found such node, return false.


      return false;
    }
    /**
     * Transforms the given set of ranges into a set of ranges where the given attribute is allowed (and can be applied).
     *
     * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be validated.
     * @param {String} attribute The name of the attribute to check.
     * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.
     */

  }, {
    key: "getValidRanges",
    value: /*#__PURE__*/regeneratorRuntime.mark(function getValidRanges(ranges, attribute) {
      var _iterator4, _step4, range;

      return regeneratorRuntime.wrap(function getValidRanges$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              ranges = convertToMinimalFlatRanges(ranges);
              _iterator4 = _createForOfIteratorHelper(ranges);
              _context2.prev = 2;

              _iterator4.s();

            case 4:
              if ((_step4 = _iterator4.n()).done) {
                _context2.next = 9;
                break;
              }

              range = _step4.value;
              return _context2.delegateYield(this._getValidRangesForRange(range, attribute), "t0", 7);

            case 7:
              _context2.next = 4;
              break;

            case 9:
              _context2.next = 14;
              break;

            case 11:
              _context2.prev = 11;
              _context2.t1 = _context2["catch"](2);

              _iterator4.e(_context2.t1);

            case 14:
              _context2.prev = 14;

              _iterator4.f();

              return _context2.finish(14);

            case 17:
            case "end":
              return _context2.stop();
          }
        }
      }, getValidRanges, this, [[2, 11, 14, 17]]);
    })
    /**
     * Basing on given `position`, finds and returns a {@link module:engine/model/range~Range range} which is
     * nearest to that `position` and is a correct range for selection.
     *
     * The correct selection range might be collapsed when it is located in a position where the text node can be placed.
     * Non-collapsed range is returned when selection can be placed around element marked as an "object" in
     * the {@link module:engine/model/schema~Schema schema}.
     *
     * Direction of searching for the nearest correct selection range can be specified as:
     *
     * * `both` - searching will be performed in both ways,
     * * `forward` - searching will be performed only forward,
     * * `backward` - searching will be performed only backward.
     *
     * When valid selection range cannot be found, `null` is returned.
     *
     * @param {module:engine/model/position~Position} position Reference position where new selection range should be looked for.
     * @param {'both'|'forward'|'backward'} [direction='both'] Search direction.
     * @returns {module:engine/model/range~Range|null} Nearest selection range or `null` if one cannot be found.
     */

  }, {
    key: "getNearestSelectionRange",
    value: function getNearestSelectionRange(position) {
      var _this2 = this;

      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'both';

      // Return collapsed range if provided position is valid.
      if (this.checkChild(position, '$text')) {
        return new model_range_Range(position);
      }

      var backwardWalker, forwardWalker; // Never leave a limit element.

      var limitElement = position.getAncestors().reverse().find(function (item) {
        return _this2.isLimit(item);
      }) || position.root;

      if (direction == 'both' || direction == 'backward') {
        backwardWalker = new model_treewalker_TreeWalker({
          boundaries: model_range_Range._createIn(limitElement),
          startPosition: position,
          direction: 'backward'
        });
      }

      if (direction == 'both' || direction == 'forward') {
        forwardWalker = new model_treewalker_TreeWalker({
          boundaries: model_range_Range._createIn(limitElement),
          startPosition: position
        });
      }

      var _iterator5 = _createForOfIteratorHelper(combineWalkers(backwardWalker, forwardWalker)),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var data = _step5.value;
          var type = data.walker == backwardWalker ? 'elementEnd' : 'elementStart';
          var value = data.value;

          if (value.type == type && this.isObject(value.item)) {
            return model_range_Range._createOn(value.item);
          }

          if (this.checkChild(value.nextPosition, '$text')) {
            return new model_range_Range(value.nextPosition);
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return null;
    }
    /**
     * Tries to find position ancestors that allow to insert a given node.
     * It starts searching from the given position and goes node by node to the top of the model tree
     * as long as a {@link module:engine/model/schema~Schema#isLimit limit element}, an
     * {@link module:engine/model/schema~Schema#isObject object element} or a topmost ancestor is not reached.
     *
     * @param {module:engine/model/position~Position} position The position that the search will start from.
     * @param {module:engine/model/node~Node|String} node The node for which an allowed parent should be found or its name.
     * @returns {module:engine/model/element~Element|null} element Allowed parent or null if nothing was found.
     */

  }, {
    key: "findAllowedParent",
    value: function findAllowedParent(position, node) {
      var parent = position.parent;

      while (parent) {
        if (this.checkChild(parent, node)) {
          return parent;
        } // Do not split limit elements.


        if (this.isLimit(parent)) {
          return null;
        }

        parent = parent.parent;
      }

      return null;
    }
    /**
     * Removes attributes disallowed by the schema.
     *
     * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes that will be filtered.
     * @param {module:engine/model/writer~Writer} writer
     */

  }, {
    key: "removeDisallowedAttributes",
    value: function removeDisallowedAttributes(nodes, writer) {
      var _iterator6 = _createForOfIteratorHelper(nodes),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var node = _step6.value;

          // When node is a `Text` it has no children, so just filter it out.
          if (node.is('text')) {
            removeDisallowedAttributeFromNode(this, node, writer);
          } // In a case of `Element` iterates through positions between nodes inside this element
          // and filter out node before the current position, or position parent when position
          // is at start of an element. Using positions prevent from omitting merged nodes
          // see https://github.com/ckeditor/ckeditor5-engine/issues/1789.
          else {
              var rangeInNode = model_range_Range._createIn(node);

              var positionsInRange = rangeInNode.getPositions();

              var _iterator7 = _createForOfIteratorHelper(positionsInRange),
                  _step7;

              try {
                for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
                  var position = _step7.value;
                  var item = position.nodeBefore || position.parent;
                  removeDisallowedAttributeFromNode(this, item, writer);
                }
              } catch (err) {
                _iterator7.e(err);
              } finally {
                _iterator7.f();
              }
            }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }
    }
    /**
     * Creates an instance of the schema context.
     *
     * @param {module:engine/model/schema~SchemaContextDefinition} context
     * @returns {module:engine/model/schema~SchemaContext}
     */

  }, {
    key: "createContext",
    value: function createContext(context) {
      return new schema_SchemaContext(context);
    }
    /**
     * @private
     */

  }, {
    key: "_clearCache",
    value: function _clearCache() {
      this._compiledDefinitions = null;
    }
    /**
     * @private
     */

  }, {
    key: "_compile",
    value: function _compile() {
      var compiledDefinitions = {};
      var sourceRules = this._sourceDefinitions;
      var itemNames = Object.keys(sourceRules);

      for (var _i = 0, _itemNames = itemNames; _i < _itemNames.length; _i++) {
        var itemName = _itemNames[_i];
        compiledDefinitions[itemName] = compileBaseItemRule(sourceRules[itemName], itemName);
      }

      for (var _i2 = 0, _itemNames2 = itemNames; _i2 < _itemNames2.length; _i2++) {
        var _itemName = _itemNames2[_i2];
        compileAllowContentOf(compiledDefinitions, _itemName);
      }

      for (var _i3 = 0, _itemNames3 = itemNames; _i3 < _itemNames3.length; _i3++) {
        var _itemName2 = _itemNames3[_i3];
        compileAllowWhere(compiledDefinitions, _itemName2);
      }

      for (var _i4 = 0, _itemNames4 = itemNames; _i4 < _itemNames4.length; _i4++) {
        var _itemName3 = _itemNames4[_i4];
        compileAllowAttributesOf(compiledDefinitions, _itemName3);
        compileInheritPropertiesFrom(compiledDefinitions, _itemName3);
      }

      for (var _i5 = 0, _itemNames5 = itemNames; _i5 < _itemNames5.length; _i5++) {
        var _itemName4 = _itemNames5[_i5];
        cleanUpAllowIn(compiledDefinitions, _itemName4);
        cleanUpAllowAttributes(compiledDefinitions, _itemName4);
      }

      this._compiledDefinitions = compiledDefinitions;
    }
    /**
     * @private
     * @param {module:engine/model/schema~SchemaCompiledItemDefinition} def
     * @param {module:engine/model/schema~SchemaContext} context
     * @param {Number} contextItemIndex
     */

  }, {
    key: "_checkContextMatch",
    value: function _checkContextMatch(def, context) {
      var contextItemIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : context.length - 1;
      var contextItem = context.getItem(contextItemIndex);

      if (def.allowIn.includes(contextItem.name)) {
        if (contextItemIndex == 0) {
          return true;
        } else {
          var parentRule = this.getDefinition(contextItem);
          return this._checkContextMatch(parentRule, context, contextItemIndex - 1);
        }
      } else {
        return false;
      }
    }
    /**
     * Takes a flat range and an attribute name. Traverses the range recursively and deeply to find and return all ranges
     * inside the given range on which the attribute can be applied.
     *
     * This is a helper function for {@link ~Schema#getValidRanges}.
     *
     * @private
     * @param {module:engine/model/range~Range} range The range to process.
     * @param {String} attribute The name of the attribute to check.
     * @returns {Iterable.<module:engine/model/range~Range>} Ranges in which the attribute is allowed.
     */

  }, {
    key: "_getValidRangesForRange",
    value: /*#__PURE__*/regeneratorRuntime.mark(function _getValidRangesForRange(range, attribute) {
      var start, end, _iterator8, _step8, item;

      return regeneratorRuntime.wrap(function _getValidRangesForRange$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              start = range.start;
              end = range.start;
              _iterator8 = _createForOfIteratorHelper(range.getItems({
                shallow: true
              }));
              _context3.prev = 3;

              _iterator8.s();

            case 5:
              if ((_step8 = _iterator8.n()).done) {
                _context3.next = 17;
                break;
              }

              item = _step8.value;

              if (!item.is('element')) {
                _context3.next = 9;
                break;
              }

              return _context3.delegateYield(this._getValidRangesForRange(model_range_Range._createIn(item), attribute), "t0", 9);

            case 9:
              if (this.checkAttribute(item, attribute)) {
                _context3.next = 14;
                break;
              }

              if (start.isEqual(end)) {
                _context3.next = 13;
                break;
              }

              _context3.next = 13;
              return new model_range_Range(start, end);

            case 13:
              start = model_position_Position._createAfter(item);

            case 14:
              end = model_position_Position._createAfter(item);

            case 15:
              _context3.next = 5;
              break;

            case 17:
              _context3.next = 22;
              break;

            case 19:
              _context3.prev = 19;
              _context3.t1 = _context3["catch"](3);

              _iterator8.e(_context3.t1);

            case 22:
              _context3.prev = 22;

              _iterator8.f();

              return _context3.finish(22);

            case 25:
              if (start.isEqual(end)) {
                _context3.next = 28;
                break;
              }

              _context3.next = 28;
              return new model_range_Range(start, end);

            case 28:
            case "end":
              return _context3.stop();
          }
        }
      }, _getValidRangesForRange, this, [[3, 19, 22, 25]]);
    })
  }]);

  return Schema;
}();


mix(schema_Schema, observablemixin);
/**
 * Event fired when the {@link #checkChild} method is called. It allows plugging in
 * additional behavior, for example implementing rules which cannot be defined using the declarative
 * {@link module:engine/model/schema~SchemaItemDefinition} interface.
 *
 * **Note:** The {@link #addChildCheck} method is a more handy way to register callbacks. Internally,
 * it registers a listener to this event but comes with a simpler API and it is the recommended choice
 * in most of the cases.
 *
 * The {@link #checkChild} method fires an event because it is
 * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can
 * use this event in various ways, but the most important use case is overriding standard behavior of the
 * `checkChild()` method. Let's see a typical listener template:
 *
 *		schema.on( 'checkChild', ( evt, args ) => {
 *			const context = args[ 0 ];
 *			const childDefinition = args[ 1 ];
 *		}, { priority: 'high' } );
 *
 * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback
 * parameter contains arguments passed to `checkChild( context, child )`. However, the `context` parameter is already
 * normalized to a {@link module:engine/model/schema~SchemaContext} instance and `child` to a
 * {@link module:engine/model/schema~SchemaCompiledItemDefinition} instance, so you do not have to worry about
 * the various ways how `context` and `child` may be passed to `checkChild()`.
 *
 * **Note:** `childDefinition` may be `undefined` if `checkChild()` was called with a non-registered element.
 *
 * So, in order to implement a rule "disallow `heading1` in `blockQuote`", you can add such a listener:
 *
 *		schema.on( 'checkChild', ( evt, args ) => {
 *			const context = args[ 0 ];
 *			const childDefinition = args[ 1 ];
 *
 *			if ( context.endsWith( 'blockQuote' ) && childDefinition && childDefinition.name == 'heading1' ) {
 *				// Prevent next listeners from being called.
 *				evt.stop();
 *				// Set the checkChild()'s return value.
 *				evt.return = false;
 *			}
 *		}, { priority: 'high' } );
 *
 * Allowing elements in specific contexts will be a far less common use case, because it is normally handled by the
 * `allowIn` rule from {@link module:engine/model/schema~SchemaItemDefinition}. But if you have a complex scenario
 * where `listItem` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:
 *
 *		schema.on( 'checkChild', ( evt, args ) => {
 *			const context = args[ 0 ];
 *			const childDefinition = args[ 1 ];
 *
 *			if ( context.endsWith( 'bar foo' ) && childDefinition.name == 'listItem' ) {
 *				// Prevent next listeners from being called.
 *				evt.stop();
 *				// Set the checkChild()'s return value.
 *				evt.return = true;
 *			}
 *		}, { priority: 'high' } );
 *
 * @event checkChild
 * @param {Array} args The `checkChild()`'s arguments.
 */

/**
 * Event fired when the {@link #checkAttribute} method is called. It allows plugging in
 * additional behavior, for example implementing rules which cannot be defined using the declarative
 * {@link module:engine/model/schema~SchemaItemDefinition} interface.
 *
 * **Note:** The {@link #addAttributeCheck} method is a more handy way to register callbacks. Internally,
 * it registers a listener to this event but comes with a simpler API and it is the recommended choice
 * in most of the cases.
 *
 * The {@link #checkAttribute} method fires an event because it is
 * {@link module:utils/observablemixin~ObservableMixin#decorate decorated} with it. Thanks to that you can
 * use this event in various ways, but the most important use case is overriding the standard behavior of the
 * `checkAttribute()` method. Let's see a typical listener template:
 *
 *		schema.on( 'checkAttribute', ( evt, args ) => {
 *			const context = args[ 0 ];
 *			const attributeName = args[ 1 ];
 *		}, { priority: 'high' } );
 *
 * The listener is added with a `high` priority to be executed before the default method is really called. The `args` callback
 * parameter contains arguments passed to `checkAttribute( context, attributeName )`. However, the `context` parameter is already
 * normalized to a {@link module:engine/model/schema~SchemaContext} instance, so you do not have to worry about
 * the various ways how `context` may be passed to `checkAttribute()`.
 *
 * So, in order to implement a rule "disallow `bold` in a text which is in a `heading1`, you can add such a listener:
 *
 *		schema.on( 'checkAttribute', ( evt, args ) => {
 *			const context = args[ 0 ];
 *			const attributeName = args[ 1 ];
 *
 *			if ( context.endsWith( 'heading1 $text' ) && attributeName == 'bold' ) {
 *				// Prevent next listeners from being called.
 *				evt.stop();
 *				// Set the checkAttribute()'s return value.
 *				evt.return = false;
 *			}
 *		}, { priority: 'high' } );
 *
 * Allowing attributes in specific contexts will be a far less common use case, because it is normally handled by the
 * `allowAttributes` rule from {@link module:engine/model/schema~SchemaItemDefinition}. But if you have a complex scenario
 * where `bold` should be allowed only in element `foo` which must be in element `bar`, then this would be the way:
 *
 *		schema.on( 'checkAttribute', ( evt, args ) => {
 *			const context = args[ 0 ];
 *			const attributeName = args[ 1 ];
 *
 *			if ( context.endsWith( 'bar foo $text' ) && attributeName == 'bold' ) {
 *				// Prevent next listeners from being called.
 *				evt.stop();
 *				// Set the checkAttribute()'s return value.
 *				evt.return = true;
 *			}
 *		}, { priority: 'high' } );
 *
 * @event checkAttribute
 * @param {Array} args The `checkAttribute()`'s arguments.
 */

/**
 * A definition of a {@link module:engine/model/schema~Schema schema} item.
 *
 * You can define the following rules:
 *
 * * {@link ~SchemaItemDefinition#allowIn `allowIn`} &ndash; Defines in which other items this item will be allowed.
 * * {@link ~SchemaItemDefinition#allowAttributes `allowAttributes`} &ndash; Defines allowed attributes of the given item.
 * * {@link ~SchemaItemDefinition#allowContentOf `allowContentOf`} &ndash; Inherits "allowed children" from other items.
 * * {@link ~SchemaItemDefinition#allowWhere `allowWhere`} &ndash; Inherits "allowed in" from other items.
 * * {@link ~SchemaItemDefinition#allowAttributesOf `allowAttributesOf`} &ndash; Inherits attributes from other items.
 * * {@link ~SchemaItemDefinition#inheritTypesFrom `inheritTypesFrom`} &ndash; Inherits `is*` properties of other items.
 * * {@link ~SchemaItemDefinition#inheritAllFrom `inheritAllFrom`} &ndash;
 * A shorthand for `allowContentOf`, `allowWhere`, `allowAttributesOf`, `inheritTypesFrom`.
 *
 * # The `is*` properties
 *
 * There are a couple commonly used `is*` properties. Their role is to assign additional semantics to schema items.
 * You can define more properties but you will also need to implement support for them in the existing editor features.
 *
 * * {@link ~SchemaItemDefinition#isBlock `isBlock`} &ndash; Whether this item is paragraph-like.
 * Generally speaking, content is usually made out of blocks like paragraphs, list items, images, headings, etc.
 * * {@link ~SchemaItemDefinition#isInline `isInline`} &ndash; Whether an item is "text-like" and should be treated as an inline node.
 * Examples of inline elements: `$text`, `softBreak` (`<br>`), etc.
 * * {@link ~SchemaItemDefinition#isLimit `isLimit`} &ndash; It can be understood as whether this element
 * should not be split by <kbd>Enter</kbd>. Examples of limit elements: `$root`, table cell, image caption, etc.
 * In other words, all actions that happen inside a limit element are limited to its content.
 * All objects are treated as limit elements, too.
 * * {@link ~SchemaItemDefinition#isObject `isObject`} &ndash; Whether an item is "self-contained" and should be treated as a whole.
 * Examples of object elements: `image`, `table`, `video`, etc. An object is also a limit, so
 * {@link module:engine/model/schema~Schema#isLimit `isLimit()`} returns `true` for object elements automatically.
 *
 * Read more about the meaning of these types in the
 * {@glink framework/guides/deep-dive/schema#defining-additional-semantics dedicated section of the Schema deep dive} guide.
 *
 * # Generic items
 *
 * There are three basic generic items: `$root`, `$block` and `$text`.
 * They are defined as follows:
 *
 *		this.schema.register( '$root', {
 *			isLimit: true
 *		} );
 *		this.schema.register( '$block', {
 *			allowIn: '$root',
 *			isBlock: true
 *		} );
 *		this.schema.register( '$text', {
 *			allowIn: '$block',
 *			isInline: true
 *		} );
 *
 * They reflect typical editor content that is contained within one root, consists of several blocks
 * (paragraphs, lists items, headings, images) which, in turn, may contain text inside.
 *
 * By inheriting from the generic items you can define new items which will get extended by other editor features.
 * Read more about generic types in the {@glink framework/guides/deep-dive/schema Schema deep dive} guide.
 *
 * # Example definitions
 *
 * Allow `paragraph` in roots and block quotes:
 *
 *		schema.register( 'paragraph', {
 *			allowIn: [ '$root', 'blockQuote' ],
 *			isBlock: true
 *		} );
 *
 * Allow `paragraph` everywhere where `$block` is allowed (i.e. in `$root`):
 *
 *		schema.register( 'paragraph', {
 *			allowWhere: '$block',
 *			isBlock: true
 *		} );
 *
 * Make `image` a block object, which is allowed everywhere where `$block` is.
 * Also, allow `src` and `alt` attributes in it:
 *
 *		schema.register( 'image', {
 *			allowWhere: '$block',
 *			allowAttributes: [ 'src', 'alt' ],
 *			isBlock: true,
 *			isObject: true
 *		} );
 *
 * Make `caption` allowed in `image` and make it allow all the content of `$block`s (usually, `$text`).
 * Also, mark it as a limit element so it cannot be split:
 *
 *		schema.register( 'caption', {
 *			allowIn: 'image',
 *			allowContentOf: '$block',
 *			isLimit: true
 *		} );
 *
 * Make `listItem` inherit all from `$block` but also allow additional attributes:
 *
 *		schema.register( 'listItem', {
 *			inheritAllFrom: '$block',
 *			allowAttributes: [ 'listType', 'listIndent' ]
 *		} );
 *
 * Which translates to:
 *
 *		schema.register( 'listItem', {
 *			allowWhere: '$block',
 *			allowContentOf: '$block',
 *			allowAttributesOf: '$block',
 *			inheritTypesFrom: '$block',
 *			allowAttributes: [ 'listType', 'listIndent' ]
 *		} );
 *
 * # Tips
 *
 * * Check schema definitions of existing features to see how they are defined.
 * * If you want to publish your feature so other developers can use it, try to use
 * generic items as much as possible.
 * * Keep your model clean. Limit it to the actual data and store information in a normalized way.
 * * Remember about defining the `is*` properties. They do not affect the allowed structures, but they can
 * affect how the editor features treat your elements.
 *
 * @typedef {Object} module:engine/model/schema~SchemaItemDefinition
 *
 * @property {String|Array.<String>} allowIn Defines in which other items this item will be allowed.
 * @property {String|Array.<String>} allowAttributes Defines allowed attributes of the given item.
 * @property {String|Array.<String>} allowContentOf Inherits "allowed children" from other items.
 * @property {String|Array.<String>} allowWhere Inherits "allowed in" from other items.
 * @property {String|Array.<String>} allowAttributesOf Inherits attributes from other items.
 * @property {String|Array.<String>} inheritTypesFrom Inherits `is*` properties of other items.
 * @property {String} inheritAllFrom A shorthand for `allowContentOf`, `allowWhere`, `allowAttributesOf`, `inheritTypesFrom`.
 *
 * @property {Boolean} isBlock
 * Whether this item is paragraph-like. Generally speaking, content is usually made out of blocks
 * like paragraphs, list items, images, headings, etc. All these elements are marked as blocks. A block
 * should not allow another block inside. Note: There is also the `$block` generic item which has `isBlock` set to `true`.
 * Most block type items will inherit from `$block` (through `inheritAllFrom`).
 *
 * Read more about the block elements in the
 * {@glink framework/guides/deep-dive/schema#block-elements Block elements} section of the Schema deep dive} guide.
 *
 * @property {Boolean} isInline
 * Whether an item is "text-like" and should be treated as an inline node. Examples of inline elements:
 * `$text`, `softBreak` (`<br>`), etc.
 *
 * Read more about the inline elements in the
 * {@glink framework/guides/deep-dive/schema#inline-elements Inline elements} section of the Schema deep dive} guide.
 *
 * @property {Boolean} isLimit
 * It can be understood as whether this element should not be split by <kbd>Enter</kbd>.
 * Examples of limit elements: `$root`, table cell, image caption, etc. In other words, all actions that happen inside
 * a limit element are limited to its content.
 *
 * Read more about the limit elements in the
 * {@glink framework/guides/deep-dive/schema#limit-elements Limit elements} section of the Schema deep dive} guide.
 *
 * @property {Boolean} isObject
 * Whether an item is "self-contained" and should be treated as a whole. Examples of object elements:
 * `image`, `table`, `video`, etc.
 *
 * **Note:** An object is also a limit, so
 * {@link module:engine/model/schema~Schema#isLimit `isLimit()`} returns `true` for object elements automatically.
 *
 * Read more about the object elements in the
 * {@glink framework/guides/deep-dive/schema#object-elements Object elements} section of the Schema deep dive} guide.
 */

/**
 * A simplified version of {@link module:engine/model/schema~SchemaItemDefinition} after
 * compilation by the {@link module:engine/model/schema~Schema schema}.
 * Rules fed to the schema by {@link module:engine/model/schema~Schema#register}
 * and {@link module:engine/model/schema~Schema#extend} methods are defined in the
 * {@link module:engine/model/schema~SchemaItemDefinition} format.
 * Later on, they are compiled to `SchemaCompiledItemDefinition` so when you use e.g.
 * the {@link module:engine/model/schema~Schema#getDefinition} method you get the compiled version.
 *
 * The compiled version contains only the following properties:
 *
 * * The `name` property,
 * * The `is*` properties,
 * * The `allowIn` array,
 * * The `allowAttributes` array.
 *
 * @typedef {Object} module:engine/model/schema~SchemaCompiledItemDefinition
 */

/**
 * A schema context &mdash; a list of ancestors of a given position in the document.
 *
 * Considering such position:
 *
 *		<$root>
 *			<blockQuote>
 *				<paragraph>
 *					^
 *				</paragraph>
 *			</blockQuote>
 *		</$root>
 *
 * The context of this position is its {@link module:engine/model/position~Position#getAncestors lists of ancestors}:
 *
 *		[ rootElement, blockQuoteElement, paragraphElement ]
 *
 * Contexts are used in the {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`} and
 * {@link module:engine/model/schema~Schema#event:checkAttribute `Schema#checkAttribute`} events as a definition
 * of a place in the document where the check occurs. The context instances are created based on the first arguments
 * of the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`} and
 * {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} methods so when
 * using these methods you need to use {@link module:engine/model/schema~SchemaContextDefinition}s.
 */

var schema_SchemaContext = /*#__PURE__*/function () {
  /**
   * Creates an instance of the context.
   *
   * @param {module:engine/model/schema~SchemaContextDefinition} context
   */
  function SchemaContext(context) {
    Object(classCallCheck["a" /* default */])(this, SchemaContext);

    if (context instanceof SchemaContext) {
      return context;
    }

    if (typeof context == 'string') {
      context = [context];
    } else if (!Array.isArray(context)) {
      // `context` is item or position.
      // Position#getAncestors() doesn't accept any parameters but it works just fine here.
      context = context.getAncestors({
        includeSelf: true
      });
    }

    if (context[0] && typeof context[0] != 'string' && context[0].is('documentFragment')) {
      context.shift();
    }

    this._items = context.map(mapContextItem);
  }
  /**
   * The number of items.
   *
   * @type {Number}
   */


  Object(createClass["a" /* default */])(SchemaContext, [{
    key: Symbol.iterator,

    /**
     * Iterable interface.
     *
     * Iterates over all context items.
     *
     * @returns {Iterable.<module:engine/model/schema~SchemaContextItem>}
     */
    value: function value() {
      return this._items[Symbol.iterator]();
    }
    /**
     * Returns a new schema context instance with an additional item.
     *
     * Item can be added as:
     *
     * 		const context = new SchemaContext( [ '$root' ] );
     *
     * 		// An element.
     * 		const fooElement = writer.createElement( 'fooElement' );
     * 		const newContext = context.push( fooElement ); // [ '$root', 'fooElement' ]
     *
     * 		// A text node.
     * 		const text = writer.createText( 'foobar' );
     * 		const newContext = context.push( text ); // [ '$root', '$text' ]
     *
     * 		// A string (element name).
     * 		const newContext = context.push( 'barElement' ); // [ '$root', 'barElement' ]
     *
     * **Note** {@link module:engine/model/node~Node} that is already in the model tree will be added as the only item
     * (without ancestors).
     *
     * @param {String|module:engine/model/node~Node|Array<String|module:engine/model/node~Node>} item An item that will be added
     * to the current context.
     * @returns {module:engine/model/schema~SchemaContext} A new schema context instance with an additional item.
     */

  }, {
    key: "push",
    value: function push(item) {
      var ctx = new SchemaContext([item]);
      ctx._items = [].concat(_toConsumableArray(this._items), _toConsumableArray(ctx._items));
      return ctx;
    }
    /**
     * Gets an item on the given index.
     *
     * @returns {module:engine/model/schema~SchemaContextItem}
     */

  }, {
    key: "getItem",
    value: function getItem(index) {
      return this._items[index];
    }
    /**
     * Returns the names of items.
     *
     * @returns {Iterable.<String>}
     */

  }, {
    key: "getNames",
    value: /*#__PURE__*/regeneratorRuntime.mark(function getNames() {
      return regeneratorRuntime.wrap(function getNames$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.delegateYield(this._items.map(function (item) {
                return item.name;
              }), "t0", 1);

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      }, getNames, this);
    })
    /**
     * Checks whether the context ends with the given nodes.
     *
     *		const ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );
     *
     *		ctx.endsWith( '$text' ); // -> true
     *		ctx.endsWith( 'paragraph $text' ); // -> true
     *		ctx.endsWith( '$root' ); // -> false
     *		ctx.endsWith( 'paragraph' ); // -> false
     *
     * @param {String} query
     * @returns {Boolean}
     */

  }, {
    key: "endsWith",
    value: function endsWith(query) {
      return Array.from(this.getNames()).join(' ').endsWith(query);
    }
    /**
     * Checks whether the context starts with the given nodes.
     *
     *		const ctx = new SchemaContext( [ rootElement, paragraphElement, textNode ] );
     *
     *		ctx.endsWith( '$root' ); // -> true
     *		ctx.endsWith( '$root paragraph' ); // -> true
     *		ctx.endsWith( '$text' ); // -> false
     *		ctx.endsWith( 'paragraph' ); // -> false
     *
     * @param {String} query
     * @returns {Boolean}
     */

  }, {
    key: "startsWith",
    value: function startsWith(query) {
      return Array.from(this.getNames()).join(' ').startsWith(query);
    }
  }, {
    key: "length",
    get: function get() {
      return this._items.length;
    }
    /**
     * The last item (the lowest node).
     *
     * @type {module:engine/model/schema~SchemaContextItem}
     */

  }, {
    key: "last",
    get: function get() {
      return this._items[this._items.length - 1];
    }
  }]);

  return SchemaContext;
}();
/**
 * The definition of a {@link module:engine/model/schema~SchemaContext schema context}.
 *
 * Contexts can be created in multiple ways:
 *
 * * By defining a **node** – in this cases this node and all its ancestors will be used.
 * * By defining a **position** in the document – in this case all its ancestors will be used.
 * * By defining an **array of nodes** – in this case this array defines the entire context.
 * * By defining a **name of node** - in this case node will be "mocked". It is not recommended because context
 * will be unrealistic (e.g. attributes of these nodes are not specified). However, at times this may be the only
 * way to define the context (e.g. when checking some hypothetical situation).
 * * By defining an **array of node names** (potentially, mixed with real nodes) – The same as **name of node**
 * but it is possible to create a path.
 * * By defining a {@link module:engine/model/schema~SchemaContext} instance - in this case the same instance as provided
 * will be return.
 *
 * Examples of context definitions passed to the {@link module:engine/model/schema~Schema#checkChild `Schema#checkChild()`}
 * method:
 *
 *		// Assuming that we have a $root > blockQuote > paragraph structure, the following code
 *		// will check node 'foo' in the following context:
 *		// [ rootElement, blockQuoteElement, paragraphElement ]
 *		const contextDefinition = paragraphElement;
 * 		const childToCheck = 'foo';
 *		schema.checkChild( contextDefinition, childToCheck );
 *
 *		// Also check in [ rootElement, blockQuoteElement, paragraphElement ].
 *		schema.checkChild( model.createPositionAt( paragraphElement, 0 ), 'foo' );
 *
 *		// Check in [ rootElement, paragraphElement ].
 *		schema.checkChild( [ rootElement, paragraphElement ], 'foo' );
 *
 *		// Check only fakeParagraphElement.
 *		schema.checkChild( 'paragraph', 'foo' );
 *
 *		// Check in [ fakeRootElement, fakeBarElement, paragraphElement ].
 *		schema.checkChild( [ '$root', 'bar', paragraphElement ], 'foo' );
 *
 * All these `checkChild()` calls will fire {@link module:engine/model/schema~Schema#event:checkChild `Schema#checkChild`}
 * events in which `args[ 0 ]` is an instance of the context. Therefore, you can write a listener like this:
 *
 *		schema.on( 'checkChild', ( evt, args ) => {
 *			const ctx = args[ 0 ];
 *
 *			console.log( Array.from( ctx.getNames() ) );
 *		} );
 *
 * Which will log the following:
 *
 *		[ '$root', 'blockQuote', 'paragraph' ]
 *		[ '$root', 'paragraph' ]
 *		[ '$root', 'bar', 'paragraph' ]
 *
 * Note: When using the {@link module:engine/model/schema~Schema#checkAttribute `Schema#checkAttribute()`} method
 * you may want to check whether a text node may have an attribute. A {@link module:engine/model/text~Text} is a
 * correct way to define a context so you can do this:
 *
 *		schema.checkAttribute( textNode, 'bold' );
 *
 * But sometimes you want to check whether a text at a given position might've had some attribute,
 * in which case you can create a context by missing an array of elements with a `'$text'` string:
 *
 *		// Check in [ rootElement, paragraphElement, textNode ].
 *		schema.checkChild( [ ...positionInParagraph.getAncestors(), '$text' ], 'bold' );
 *
 * @typedef {module:engine/model/node~Node|module:engine/model/position~Position|module:engine/model/schema~SchemaContext|
 * String|Array.<String|module:engine/model/node~Node>} module:engine/model/schema~SchemaContextDefinition
 */

/**
 * An item of the {@link module:engine/model/schema~SchemaContext schema context}.
 *
 * It contains 3 properties:
 *
 * * `name` – the name of this item,
 * * `* getAttributeKeys()` – a generator of keys of item attributes,
 * * `getAttribute( keyName )` – a method to get attribute values.
 *
 * The context item interface is a highly simplified version of {@link module:engine/model/node~Node} and its role
 * is to expose only the information which schema checks are able to provide (which is the name of the node and
 * node's attributes).
 *
 *		schema.on( 'checkChild', ( evt, args ) => {
 *			const ctx = args[ 0 ];
 *			const firstItem = ctx.getItem( 0 );
 *
 *			console.log( firstItem.name ); // -> '$root'
 *			console.log( firstItem.getAttribute( 'foo' ) ); // -> 'bar'
 *			console.log( Array.from( firstItem.getAttributeKeys() ) ); // -> [ 'foo', 'faa' ]
 *		} );
 *
 * @typedef {Object} module:engine/model/schema~SchemaContextItem
 */

/**
 * A structure containing additional metadata describing the attribute.
 *
 * See {@link module:engine/model/schema~Schema#setAttributeProperties `Schema#setAttributeProperties()`} for usage examples.
 *
 * @typedef {Object} module:engine/model/schema~AttributeProperties
 * @property {Boolean} [isFormatting] Indicates that the attribute should be considered as a visual formatting, like `bold`, `italic` or
 * `fontSize` rather than semantic attribute (such as `src`, `listType`, etc.). For example, it is used by the "Remove format" feature.
 * @property {Boolean} [copyOnEnter] Indicates that given text attribute should be copied to the next block when enter is pressed.
 */

function compileBaseItemRule(sourceItemRules, itemName) {
  var itemRule = {
    name: itemName,
    allowIn: [],
    allowContentOf: [],
    allowWhere: [],
    allowAttributes: [],
    allowAttributesOf: [],
    inheritTypesFrom: []
  };
  copyTypes(sourceItemRules, itemRule);
  copyProperty(sourceItemRules, itemRule, 'allowIn');
  copyProperty(sourceItemRules, itemRule, 'allowContentOf');
  copyProperty(sourceItemRules, itemRule, 'allowWhere');
  copyProperty(sourceItemRules, itemRule, 'allowAttributes');
  copyProperty(sourceItemRules, itemRule, 'allowAttributesOf');
  copyProperty(sourceItemRules, itemRule, 'inheritTypesFrom');
  makeInheritAllWork(sourceItemRules, itemRule);
  return itemRule;
}

function compileAllowContentOf(compiledDefinitions, itemName) {
  var _iterator9 = _createForOfIteratorHelper(compiledDefinitions[itemName].allowContentOf),
      _step9;

  try {
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      var allowContentOfItemName = _step9.value;

      // The allowContentOf property may point to an unregistered element.
      if (compiledDefinitions[allowContentOfItemName]) {
        var allowedChildren = getAllowedChildren(compiledDefinitions, allowContentOfItemName);
        allowedChildren.forEach(function (allowedItem) {
          allowedItem.allowIn.push(itemName);
        });
      }
    }
  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }

  delete compiledDefinitions[itemName].allowContentOf;
}

function compileAllowWhere(compiledDefinitions, itemName) {
  var _iterator10 = _createForOfIteratorHelper(compiledDefinitions[itemName].allowWhere),
      _step10;

  try {
    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
      var allowWhereItemName = _step10.value;
      var inheritFrom = compiledDefinitions[allowWhereItemName]; // The allowWhere property may point to an unregistered element.

      if (inheritFrom) {
        var _compiledDefinitions$;

        var allowedIn = inheritFrom.allowIn;

        (_compiledDefinitions$ = compiledDefinitions[itemName].allowIn).push.apply(_compiledDefinitions$, _toConsumableArray(allowedIn));
      }
    }
  } catch (err) {
    _iterator10.e(err);
  } finally {
    _iterator10.f();
  }

  delete compiledDefinitions[itemName].allowWhere;
}

function compileAllowAttributesOf(compiledDefinitions, itemName) {
  var _iterator11 = _createForOfIteratorHelper(compiledDefinitions[itemName].allowAttributesOf),
      _step11;

  try {
    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
      var allowAttributeOfItem = _step11.value;
      var inheritFrom = compiledDefinitions[allowAttributeOfItem];

      if (inheritFrom) {
        var _compiledDefinitions$2;

        var inheritAttributes = inheritFrom.allowAttributes;

        (_compiledDefinitions$2 = compiledDefinitions[itemName].allowAttributes).push.apply(_compiledDefinitions$2, _toConsumableArray(inheritAttributes));
      }
    }
  } catch (err) {
    _iterator11.e(err);
  } finally {
    _iterator11.f();
  }

  delete compiledDefinitions[itemName].allowAttributesOf;
}

function compileInheritPropertiesFrom(compiledDefinitions, itemName) {
  var item = compiledDefinitions[itemName];

  var _iterator12 = _createForOfIteratorHelper(item.inheritTypesFrom),
      _step12;

  try {
    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
      var inheritPropertiesOfItem = _step12.value;
      var inheritFrom = compiledDefinitions[inheritPropertiesOfItem];

      if (inheritFrom) {
        var typeNames = Object.keys(inheritFrom).filter(function (name) {
          return name.startsWith('is');
        });

        var _iterator13 = _createForOfIteratorHelper(typeNames),
            _step13;

        try {
          for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
            var name = _step13.value;

            if (!(name in item)) {
              item[name] = inheritFrom[name];
            }
          }
        } catch (err) {
          _iterator13.e(err);
        } finally {
          _iterator13.f();
        }
      }
    }
  } catch (err) {
    _iterator12.e(err);
  } finally {
    _iterator12.f();
  }

  delete item.inheritTypesFrom;
} // Remove items which weren't registered (because it may break some checks or we'd need to complicate them).
// Make sure allowIn doesn't contain repeated values.


function cleanUpAllowIn(compiledDefinitions, itemName) {
  var itemRule = compiledDefinitions[itemName];
  var existingItems = itemRule.allowIn.filter(function (itemToCheck) {
    return compiledDefinitions[itemToCheck];
  });
  itemRule.allowIn = Array.from(new Set(existingItems));
}

function cleanUpAllowAttributes(compiledDefinitions, itemName) {
  var itemRule = compiledDefinitions[itemName];
  itemRule.allowAttributes = Array.from(new Set(itemRule.allowAttributes));
}

function copyTypes(sourceItemRules, itemRule) {
  var _iterator14 = _createForOfIteratorHelper(sourceItemRules),
      _step14;

  try {
    for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
      var sourceItemRule = _step14.value;
      var typeNames = Object.keys(sourceItemRule).filter(function (name) {
        return name.startsWith('is');
      });

      var _iterator15 = _createForOfIteratorHelper(typeNames),
          _step15;

      try {
        for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
          var name = _step15.value;
          itemRule[name] = sourceItemRule[name];
        }
      } catch (err) {
        _iterator15.e(err);
      } finally {
        _iterator15.f();
      }
    }
  } catch (err) {
    _iterator14.e(err);
  } finally {
    _iterator14.f();
  }
}

function copyProperty(sourceItemRules, itemRule, propertyName) {
  var _iterator16 = _createForOfIteratorHelper(sourceItemRules),
      _step16;

  try {
    for (_iterator16.s(); !(_step16 = _iterator16.n()).done;) {
      var sourceItemRule = _step16.value;

      if (typeof sourceItemRule[propertyName] == 'string') {
        itemRule[propertyName].push(sourceItemRule[propertyName]);
      } else if (Array.isArray(sourceItemRule[propertyName])) {
        var _itemRule$propertyNam;

        (_itemRule$propertyNam = itemRule[propertyName]).push.apply(_itemRule$propertyNam, _toConsumableArray(sourceItemRule[propertyName]));
      }
    }
  } catch (err) {
    _iterator16.e(err);
  } finally {
    _iterator16.f();
  }
}

function makeInheritAllWork(sourceItemRules, itemRule) {
  var _iterator17 = _createForOfIteratorHelper(sourceItemRules),
      _step17;

  try {
    for (_iterator17.s(); !(_step17 = _iterator17.n()).done;) {
      var sourceItemRule = _step17.value;
      var inheritFrom = sourceItemRule.inheritAllFrom;

      if (inheritFrom) {
        itemRule.allowContentOf.push(inheritFrom);
        itemRule.allowWhere.push(inheritFrom);
        itemRule.allowAttributesOf.push(inheritFrom);
        itemRule.inheritTypesFrom.push(inheritFrom);
      }
    }
  } catch (err) {
    _iterator17.e(err);
  } finally {
    _iterator17.f();
  }
}

function getAllowedChildren(compiledDefinitions, itemName) {
  var itemRule = compiledDefinitions[itemName];
  return getValues(compiledDefinitions).filter(function (def) {
    return def.allowIn.includes(itemRule.name);
  });
}

function getValues(obj) {
  return Object.keys(obj).map(function (key) {
    return obj[key];
  });
}

function mapContextItem(ctxItem) {
  if (typeof ctxItem == 'string') {
    return {
      name: ctxItem,
      getAttributeKeys: /*#__PURE__*/regeneratorRuntime.mark(function getAttributeKeys() {
        return regeneratorRuntime.wrap(function getAttributeKeys$(_context5) {
          while (1) {
            switch (_context5.prev = _context5.next) {
              case 0:
              case "end":
                return _context5.stop();
            }
          }
        }, getAttributeKeys);
      }),
      getAttribute: function getAttribute() {}
    };
  } else {
    return {
      // '$text' means text nodes and text proxies.
      name: ctxItem.is('element') ? ctxItem.name : '$text',
      getAttributeKeys: /*#__PURE__*/regeneratorRuntime.mark(function getAttributeKeys() {
        return regeneratorRuntime.wrap(function getAttributeKeys$(_context6) {
          while (1) {
            switch (_context6.prev = _context6.next) {
              case 0:
                return _context6.delegateYield(ctxItem.getAttributeKeys(), "t0", 1);

              case 1:
              case "end":
                return _context6.stop();
            }
          }
        }, getAttributeKeys);
      }),
      getAttribute: function getAttribute(key) {
        return ctxItem.getAttribute(key);
      }
    };
  }
} // Generator function returning values from provided walkers, switching between them at each iteration. If only one walker
// is provided it will return data only from that walker.
//
// @param {module:engine/module/treewalker~TreeWalker} [backward] Walker iterating in backward direction.
// @param {module:engine/module/treewalker~TreeWalker} [forward] Walker iterating in forward direction.
// @returns {Iterable.<Object>} Object returned at each iteration contains `value` and `walker` (informing which walker returned
// given value) fields.


function combineWalkers(backward, forward) {
  var done, step, _step18;

  return regeneratorRuntime.wrap(function combineWalkers$(_context7) {
    while (1) {
      switch (_context7.prev = _context7.next) {
        case 0:
          done = false;

        case 1:
          if (done) {
            _context7.next = 17;
            break;
          }

          done = true;

          if (!backward) {
            _context7.next = 9;
            break;
          }

          step = backward.next();

          if (step.done) {
            _context7.next = 9;
            break;
          }

          done = false;
          _context7.next = 9;
          return {
            walker: backward,
            value: step.value
          };

        case 9:
          if (!forward) {
            _context7.next = 15;
            break;
          }

          _step18 = forward.next();

          if (_step18.done) {
            _context7.next = 15;
            break;
          }

          done = false;
          _context7.next = 15;
          return {
            walker: forward,
            value: _step18.value
          };

        case 15:
          _context7.next = 1;
          break;

        case 17:
        case "end":
          return _context7.stop();
      }
    }
  }, schema_marked);
} // Takes an array of non-intersecting ranges. For each of them gets minimal flat ranges covering that range and returns
// all those minimal flat ranges.
//
// @param {Array.<module:engine/model/range~Range>} ranges Ranges to process.
// @returns {Iterable.<module:engine/model/range~Range>} Minimal flat ranges of given `ranges`.


function convertToMinimalFlatRanges(ranges) {
  var _iterator18, _step19, range;

  return regeneratorRuntime.wrap(function convertToMinimalFlatRanges$(_context8) {
    while (1) {
      switch (_context8.prev = _context8.next) {
        case 0:
          _iterator18 = _createForOfIteratorHelper(ranges);
          _context8.prev = 1;

          _iterator18.s();

        case 3:
          if ((_step19 = _iterator18.n()).done) {
            _context8.next = 8;
            break;
          }

          range = _step19.value;
          return _context8.delegateYield(range.getMinimalFlatRanges(), "t0", 6);

        case 6:
          _context8.next = 3;
          break;

        case 8:
          _context8.next = 13;
          break;

        case 10:
          _context8.prev = 10;
          _context8.t1 = _context8["catch"](1);

          _iterator18.e(_context8.t1);

        case 13:
          _context8.prev = 13;

          _iterator18.f();

          return _context8.finish(13);

        case 16:
        case "end":
          return _context8.stop();
      }
    }
  }, _marked2, null, [[1, 10, 13, 16]]);
}

function removeDisallowedAttributeFromNode(schema, node, writer) {
  var _iterator19 = _createForOfIteratorHelper(node.getAttributeKeys()),
      _step20;

  try {
    for (_iterator19.s(); !(_step20 = _iterator19.n()).done;) {
      var attribute = _step20.value;

      if (!schema.checkAttribute(node, attribute)) {
        writer.removeAttribute(attribute, node);
      }
    }
  } catch (err) {
    _iterator19.e(err);
  } finally {
    _iterator19.f();
  }
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/conversion/upcastdispatcher.js

















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/conversion/upcastdispatcher
 */







/**
 * `UpcastDispatcher` is a central point of {@link module:engine/view/view view} conversion, which is a process of
 * converting given {@link module:engine/view/documentfragment~DocumentFragment view document fragment} or
 * {@link module:engine/view/element~Element} into another structure.
 * In default application, {@link module:engine/view/view view} is converted to {@link module:engine/model/model}.
 *
 * During conversion process, for all {@link module:engine/view/node~Node view nodes} from the converted view document fragment,
 * `UpcastDispatcher` fires corresponding events. Special callbacks called "converters" should listen to
 * `UpcastDispatcher` for those events.
 *
 * Each callback, as the second argument, is passed a special object `data` that has `viewItem`, `modelCursor` and
 * `modelRange` properties. `viewItem` property contains {@link module:engine/view/node~Node view node} or
 * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}
 * that is converted at the moment and might be handled by the callback. `modelRange` property should be used to save the result
 * of conversion and is always a {@link module:engine/model/range~Range} when conversion result is correct.
 * `modelCursor` property is a {@link module:engine/model/position~Position position} on which conversion result will be inserted
 * and is a context according to {@link module:engine/model/schema~Schema schema} will be checked before the conversion.
 * See also {@link ~UpcastDispatcher#convert}. It is also shared by reference by all callbacks listening to given event.
 *
 * The third parameter passed to a callback is an instance of {@link ~UpcastDispatcher}
 * which provides additional tools for converters.
 *
 * Examples of providing callbacks for `UpcastDispatcher`:
 *
 *		// Converter for links (<a>).
 *		editor.data.upcastDispatcher.on( 'element:a', ( evt, data, conversionApi ) => {
 *			if ( conversionApi.consumable.consume( data.viewItem, { name: true, attributes: [ 'href' ] } ) ) {
 *				// <a> element is inline and is represented by an attribute in the model.
 *				// This is why we need to convert only children.
 *				const { modelRange } = conversionApi.convertChildren( data.viewItem, data.modelCursor );
 *
 *				for ( let item of modelRange.getItems() ) {
 *					if ( conversionApi.schema.checkAttribute( item, 'linkHref' ) ) {
 *						conversionApi.writer.setAttribute( 'linkHref', data.viewItem.getAttribute( 'href' ), item );
 *					}
 *				}
 *			}
 *		} );
 *
 *		// Convert <p>'s font-size style.
 *		// Note: You should use a low-priority observer in order to ensure that
 *		// it's executed after the element-to-element converter.
 *		editor.data.upcastDispatcher.on( 'element:p', ( evt, data, conversionApi ) => {
 *			const { consumable, schema, writer } = conversionApi;
 *
 *			if ( !consumable.consume( data.viewItem, { style: 'font-size' } ) ) {
 *				return;
 *			}
 *
 *			const fontSize = data.viewItem.getStyle( 'font-size' );
 *
 *			// Don't go for the model element after data.modelCursor because it might happen
 *			// that a single view element was converted to multiple model elements. Get all of them.
 *			for ( const item of data.modelRange.getItems( { shallow: true } ) ) {
 *				if ( schema.checkAttribute( item, 'fontSize' ) ) {
 *					writer.setAttribute( 'fontSize', fontSize, item );
 *				}
 *			}
 *		}, { priority: 'low' } );
 *
 *		// Convert all elements which have no custom converter into paragraph (autoparagraphing).
 *  	editor.data.upcastDispatcher.on( 'element', ( evt, data, conversionApi ) => {
 *  	 	// When element is already consumed by higher priority converters then do nothing.
 *  	 	if ( conversionApi.consumable.test( data.viewItem, { name: data.viewItem.name } ) ) {
 *  	 			const paragraph = conversionApi.writer.createElement( 'paragraph' );
 *
 *  	 			// Find allowed parent for paragraph that we are going to insert. If current parent does not allow
 *  	 			// to insert paragraph but one of the ancestors does then split nodes to allowed parent.
 *  	 			const splitResult = conversionApi.splitToAllowedParent( paragraph, data.modelCursor );
 *
 *  	 			// When there is no split result it means that we can't insert paragraph in this position.
 *  	 			if ( splitResult ) {
 *  	 				// Insert paragraph in allowed position.
 *  	 				conversionApi.writer.insert( paragraph, splitResult.position );
 *
 *  	 				// Convert children to paragraph.
 *  	 				const { modelRange } = conversionApi.convertChildren(
 *  	 					data.viewItem,
 *  	 					conversionApi.writer.createPositionAt( paragraph, 0 )
 *  	 				);
 *
 * 						// Set as conversion result, attribute converters may use this property.
 *  	 				data.modelRange = conversionApi.writer.createRange(
 *  	 					conversionApi.writer.createPositionBefore( paragraph ),
 *  	 					modelRange.end
 *  	 				);
 *
 *  	 				// Continue conversion inside paragraph.
 *  	 				data.modelCursor = data.modelRange.end;
 *  	 			}
 *  	 		}
 *  	 	}
 *  	 }, { priority: 'low' } );
 *
 * Before each conversion process, `UpcastDispatcher` fires {@link ~UpcastDispatcher#event:viewCleanup}
 * event which can be used to prepare tree view for conversion.
 *
 * @mixes module:utils/emittermixin~EmitterMixin
 * @fires viewCleanup
 * @fires element
 * @fires text
 * @fires documentFragment
 */

var upcastdispatcher_UpcastDispatcher = /*#__PURE__*/function () {
  /**
   * Creates a `UpcastDispatcher` that operates using passed API.
   *
   * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi
   * @param {Object} [conversionApi] Additional properties for interface that will be passed to events fired
   * by `UpcastDispatcher`.
   */
  function UpcastDispatcher() {
    var conversionApi = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    Object(classCallCheck["a" /* default */])(this, UpcastDispatcher);

    /**
     * List of the elements that were created during splitting.
     *
     * After conversion process the list is cleared.
     *
     * @private
     * @type {Map.<module:engine/model/element~Element,Array.<module:engine/model/element~Element>>}
     */
    this._splitParts = new Map();
    /**
     * Position in the temporary structure where the converted content is inserted. The structure reflect the context of
     * the target position where the content will be inserted. This property is build based on the context parameter of the
     * convert method.
     *
     * @private
     * @type {module:engine/model/position~Position|null}
     */

    this._modelCursor = null;
    /**
     * Interface passed by dispatcher to the events callbacks.
     *
     * @member {module:engine/conversion/upcastdispatcher~UpcastConversionApi}
     */

    this.conversionApi = Object.assign({}, conversionApi); // `convertItem`, `convertChildren` and `splitToAllowedParent` are bound to this `UpcastDispatcher`
    // instance and set on `conversionApi`. This way only a part of `UpcastDispatcher` API is exposed.

    this.conversionApi.convertItem = this._convertItem.bind(this);
    this.conversionApi.convertChildren = this._convertChildren.bind(this);
    this.conversionApi.splitToAllowedParent = this._splitToAllowedParent.bind(this);
    this.conversionApi.getSplitParts = this._getSplitParts.bind(this);
  }
  /**
   * Starts the conversion process. The entry point for the conversion.
   *
   * @fires element
   * @fires text
   * @fires documentFragment
   * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element} viewItem
   * Part of the view to be converted.
   * @param {module:engine/model/writer~Writer} writer Instance of model writer.
   * @param {module:engine/model/schema~SchemaContextDefinition} [context=['$root']] Elements will be converted according to this context.
   * @returns {module:engine/model/documentfragment~DocumentFragment} Model data that is a result of the conversion process
   * wrapped in `DocumentFragment`. Converted marker elements will be set as that document fragment's
   * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.
   */


  Object(createClass["a" /* default */])(UpcastDispatcher, [{
    key: "convert",
    value: function convert(viewItem, writer) {
      var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ['$root'];
      this.fire('viewCleanup', viewItem); // Create context tree and set position in the top element.
      // Items will be converted according to this position.

      this._modelCursor = createContextTree(context, writer); // Store writer in conversion as a conversion API
      // to be sure that conversion process will use the same batch.

      this.conversionApi.writer = writer; // Create consumable values list for conversion process.

      this.conversionApi.consumable = viewconsumable_ViewConsumable.createFrom(viewItem); // Custom data stored by converter for conversion process.

      this.conversionApi.store = {}; // Do the conversion.

      var _this$_convertItem = this._convertItem(viewItem, this._modelCursor),
          modelRange = _this$_convertItem.modelRange; // Conversion result is always a document fragment so let's create it.


      var documentFragment = writer.createDocumentFragment(); // When there is a conversion result.

      if (modelRange) {
        // Remove all empty elements that were create while splitting.
        this._removeEmptyElements(); // Move all items that were converted in context tree to the document fragment.


        for (var _i = 0, _Array$from = Array.from(this._modelCursor.parent.getChildren()); _i < _Array$from.length; _i++) {
          var item = _Array$from[_i];
          writer.append(item, documentFragment);
        } // Extract temporary markers elements from model and set as static markers collection.


        documentFragment.markers = extractMarkersFromModelFragment(documentFragment, writer);
      } // Clear context position.


      this._modelCursor = null; // Clear split elements lists.

      this._splitParts.clear(); // Clear conversion API.


      this.conversionApi.writer = null;
      this.conversionApi.store = null; // Return fragment as conversion result.

      return documentFragment;
    }
    /**
     * @private
     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertItem
     */

  }, {
    key: "_convertItem",
    value: function _convertItem(viewItem, modelCursor) {
      var data = Object.assign({
        viewItem: viewItem,
        modelCursor: modelCursor,
        modelRange: null
      });

      if (viewItem.is('element')) {
        this.fire('element:' + viewItem.name, data, this.conversionApi);
      } else if (viewItem.is('text')) {
        this.fire('text', data, this.conversionApi);
      } else {
        this.fire('documentFragment', data, this.conversionApi);
      } // Handle incorrect conversion result.


      if (data.modelRange && !(data.modelRange instanceof model_range_Range)) {
        /**
         * Incorrect conversion result was dropped.
         *
         * {@link module:engine/model/range~Range Model range} should be a conversion result.
         *
         * @error view-conversion-dispatcher-incorrect-result
         */
        throw new ckeditorerror["b" /* default */]('view-conversion-dispatcher-incorrect-result: Incorrect conversion result was dropped.', this);
      }

      return {
        modelRange: data.modelRange,
        modelCursor: data.modelCursor
      };
    }
    /**
     * @private
     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#convertChildren
     */

  }, {
    key: "_convertChildren",
    value: function _convertChildren(viewItem, modelCursor) {
      var modelRange = new model_range_Range(modelCursor);
      var nextModelCursor = modelCursor;

      for (var _i2 = 0, _Array$from2 = Array.from(viewItem.getChildren()); _i2 < _Array$from2.length; _i2++) {
        var viewChild = _Array$from2[_i2];

        var result = this._convertItem(viewChild, nextModelCursor);

        if (result.modelRange instanceof model_range_Range) {
          modelRange.end = result.modelRange.end;
          nextModelCursor = result.modelCursor;
        }
      }

      return {
        modelRange: modelRange,
        modelCursor: nextModelCursor
      };
    }
    /**
     * @private
     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#splitToAllowedParent
     */

  }, {
    key: "_splitToAllowedParent",
    value: function _splitToAllowedParent(node, modelCursor) {
      // Try to find allowed parent.
      var allowedParent = this.conversionApi.schema.findAllowedParent(modelCursor, node); // When there is no parent that allows to insert node then return `null`.

      if (!allowedParent) {
        return null;
      } // When current position parent allows to insert node then return this position.


      if (allowedParent === modelCursor.parent) {
        return {
          position: modelCursor
        };
      } // When allowed parent is in context tree.


      if (this._modelCursor.parent.getAncestors().includes(allowedParent)) {
        return null;
      } // Split element to allowed parent.


      var splitResult = this.conversionApi.writer.split(modelCursor, allowedParent); // Using the range returned by `model.Writer#split`, we will pair original elements with their split parts.
      //
      // The range returned from the writer spans "over the split" or, precisely saying, from the end of the original element (the one
      // that got split) to the beginning of the other part of that element:
      //
      // <limit><a><b><c>X[]Y</c></b><a></limit> ->
      // <limit><a><b><c>X[</c></b></a><a><b><c>]Y</c></b></a>
      //
      // After the split there cannot be any full node between the positions in `splitRange`. The positions are touching.
      // Also, because of how splitting works, it is easy to notice, that "closing tags" are in the reverse order than "opening tags".
      // Also, since we split all those elements, each of them has to have the other part.
      //
      // With those observations in mind, we will pair the original elements with their split parts by saving "closing tags" and matching
      // them with "opening tags" in the reverse order. For that we can use a stack.

      var stack = [];

      var _iterator = _createForOfIteratorHelper(splitResult.range.getWalker()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var treeWalkerValue = _step.value;

          if (treeWalkerValue.type == 'elementEnd') {
            stack.push(treeWalkerValue.item);
          } else {
            // There should not be any text nodes after the element is split, so the only other value is `elementStart`.
            var originalPart = stack.pop();
            var splitPart = treeWalkerValue.item;

            this._registerSplitPair(originalPart, splitPart);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return {
        position: splitResult.position,
        cursorParent: splitResult.range.end.parent
      };
    }
    /**
     * Registers that `splitPart` element is a split part of the `originalPart` element.
     *
     * Data set by this method is used by {@link #_getSplitParts} and {@link #_removeEmptyElements}.
     *
     * @private
     * @param {module:engine/model/element~Element} originalPart
     * @param {module:engine/model/element~Element} splitPart
     */

  }, {
    key: "_registerSplitPair",
    value: function _registerSplitPair(originalPart, splitPart) {
      if (!this._splitParts.has(originalPart)) {
        this._splitParts.set(originalPart, [originalPart]);
      }

      var list = this._splitParts.get(originalPart);

      this._splitParts.set(splitPart, list);

      list.push(splitPart);
    }
    /**
     * @private
     * @see module:engine/conversion/upcastdispatcher~UpcastConversionApi#getSplitParts
     */

  }, {
    key: "_getSplitParts",
    value: function _getSplitParts(element) {
      var parts;

      if (!this._splitParts.has(element)) {
        parts = [element];
      } else {
        parts = this._splitParts.get(element);
      }

      return parts;
    }
    /**
     * Checks if there are any empty elements created while splitting and removes them.
     *
     * This method works recursively to re-check empty elements again after at least one element was removed in the initial call,
     * as some elements might have become empty after other empty elements were removed from them.
     *
     * @private
     */

  }, {
    key: "_removeEmptyElements",
    value: function _removeEmptyElements() {
      var anyRemoved = false;

      var _iterator2 = _createForOfIteratorHelper(this._splitParts.keys()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var element = _step2.value;

          if (element.isEmpty) {
            this.conversionApi.writer.remove(element);

            this._splitParts.delete(element);

            anyRemoved = true;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      if (anyRemoved) {
        this._removeEmptyElements();
      }
    }
    /**
     * Fired before the first conversion event, at the beginning of upcast (view to model conversion) process.
     *
     * @event viewCleanup
     * @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/element~Element}
     * viewItem Part of the view to be converted.
     */

    /**
     * Fired when {@link module:engine/view/element~Element} is converted.
     *
     * `element` is a namespace event for a class of events. Names of actually called events follow this pattern:
     * `element:<elementName>` where `elementName` is the name of converted element. This way listeners may listen to
     * all elements conversion or to conversion of specific elements.
     *
     * @event element
     * @param {Object} data Conversion data. Keep in mind that this object is shared by reference between all
     * callbacks that will be called. This means that callbacks can override values if needed, and those values will
     * be available in other callbacks.
     * @param {module:engine/view/item~Item} data.viewItem Converted item.
     * @param {module:engine/model/position~Position} data.modelCursor Position where a converter should start changes.
     * Change this value for the next converter to tell where the conversion should continue.
     * @param {module:engine/model/range~Range} data.modelRange The current state of conversion result. Every change to
     * converted element should be reflected by setting or modifying this property.
     * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion utilities to be used by callback.
     */

    /**
     * Fired when {@link module:engine/view/text~Text} is converted.
     *
     * @event text
     * @see #event:element
     */

    /**
     * Fired when {@link module:engine/view/documentfragment~DocumentFragment} is converted.
     *
     * @event documentFragment
     * @see #event:element
     */

  }]);

  return UpcastDispatcher;
}();


mix(upcastdispatcher_UpcastDispatcher, emittermixin); // Traverses given model item and searches elements which marks marker range. Found element is removed from
// DocumentFragment but path of this element is stored in a Map which is then returned.
//
// @param {module:engine/view/documentfragment~DocumentFragment|module:engine/view/node~Node} modelItem Fragment of model.
// @returns {Map<String, module:engine/model/range~Range>} List of static markers.

function extractMarkersFromModelFragment(modelItem, writer) {
  var markerElements = new Set();
  var markers = new Map(); // Create ModelTreeWalker.

  var range = model_range_Range._createIn(modelItem).getItems(); // Walk through DocumentFragment and collect marker elements.


  var _iterator3 = _createForOfIteratorHelper(range),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var item = _step3.value;

      // Check if current element is a marker.
      if (item.name == '$marker') {
        markerElements.add(item);
      }
    } // Walk through collected marker elements store its path and remove its from the DocumentFragment.

  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  var _iterator4 = _createForOfIteratorHelper(markerElements),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var markerElement = _step4.value;
      var markerName = markerElement.getAttribute('data-name');
      var currentPosition = writer.createPositionBefore(markerElement); // When marker of given name is not stored it means that we have found the beginning of the range.

      if (!markers.has(markerName)) {
        markers.set(markerName, new model_range_Range(currentPosition.clone())); // Otherwise is means that we have found end of the marker range.
      } else {
        markers.get(markerName).end = currentPosition.clone();
      } // Remove marker element from DocumentFragment.


      writer.remove(markerElement);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return markers;
} // Creates model fragment according to given context and returns position in the bottom (the deepest) element.


function createContextTree(contextDefinition, writer) {
  var position;

  var _iterator5 = _createForOfIteratorHelper(new schema_SchemaContext(contextDefinition)),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var item = _step5.value;
      var attributes = {};

      var _iterator6 = _createForOfIteratorHelper(item.getAttributeKeys()),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var key = _step6.value;
          attributes[key] = item.getAttribute(key);
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      var current = writer.createElement(item.name, attributes);

      if (position) {
        writer.append(current, position);
      }

      position = model_position_Position._createAt(current, 0);
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  return position;
}
/**
 * Conversion interface that is registered for given {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}
 * and is passed as one of parameters when {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher dispatcher}
 * fires it's events.
 *
 * @interface module:engine/conversion/upcastdispatcher~UpcastConversionApi
 */

/**
 * Starts conversion of given item by firing an appropriate event.
 *
 * Every fired event is passed (as first parameter) an object with `modelRange` property. Every event may set and/or
 * modify that property. When all callbacks are done, the final value of `modelRange` property is returned by this method.
 * The `modelRange` must be {@link module:engine/model/range~Range model range} or `null` (as set by default).
 *
 * @method #convertItem
 * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element
 * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text
 * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment
 * @param {module:engine/view/item~Item} viewItem Item to convert.
 * @param {module:engine/model/position~Position} modelCursor Position of conversion.
 * @returns {Object} result Conversion result.
 * @returns {module:engine/model/range~Range|null} result.modelRange Model range containing result of item conversion,
 * created and modified by callbacks attached to fired event, or `null` if the conversion result was incorrect.
 * @returns {module:engine/model/position~Position} result.modelCursor Position where conversion should be continued.
 */

/**
 * Starts conversion of all children of given item by firing appropriate events for all those children.
 *
 * @method #convertChildren
 * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element
 * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:text
 * @fires module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:documentFragment
 * @param {module:engine/view/item~Item} viewItem Element which children should be converted.
 * @param {module:engine/model/position~Position} modelCursor Position of conversion.
 * @returns {Object} result Conversion result.
 * @returns {module:engine/model/range~Range} result.modelRange Model range containing results of conversion of all children of given item.
 * When no children was converted then range is collapsed.
 * @returns {module:engine/model/position~Position} result.modelCursor Position where conversion should be continued.
 */

/**
 * Checks {@link module:engine/model/schema~Schema schema} to find allowed parent for element that we are going to insert
 * starting from given position. If current parent does not allow to insert element but one of the ancestors does then
 * split nodes to allowed parent.
 *
 * If schema allows to insert node in given position, nothing is split and object with that position is returned.
 *
 * If it was not possible to find allowed parent, `null` is returned, nothing is split.
 *
 * Otherwise, ancestors are split and object with position and the copy of the split element is returned.
 *
 * For instance, if `<image>` is not allowed in `<paragraph>` but is allowed in `$root`:
 *
 *		<paragraph>foo[]bar</paragraph>
 *
 *  	-> split for `<image>` ->
 *
 *  	<paragraph>foo</paragraph>[]<paragraph>bar</paragraph>
 *
 * In the sample above position between `<paragraph>` elements will be returned as `position` and the second `paragraph`
 * as `cursorParent`.
 *
 * @method #splitToAllowedParent
 * @param {module:engine/model/position~Position} position Position on which element is going to be inserted.
 * @param {module:engine/model/node~Node} node Node to insert.
 * @returns {Object|null} Split result. If it was not possible to find allowed position `null` is returned.
 * @returns {module:engine/model/position~Position} position between split elements.
 * @returns {module:engine/model/element~Element} [cursorParent] Element inside which cursor should be placed to
 * continue conversion. When element is not defined it means that there was no split.
 */

/**
 * Returns all the split parts of given `element` that were created during upcasting through using {@link #splitToAllowedParent}.
 * It enables you to easily track those elements and continue processing them after they are split during their children conversion.
 *
 *		<paragraph>Foo<image />bar<image />baz</paragraph> ->
 *		<paragraph>Foo</paragraph><image /><paragraph>bar</paragraph><image /><paragraph>baz</paragraph>
 *
 * For a reference to any of above paragraphs, the function will return all three paragraphs (the original element included),
 * sorted in the order of their creation (the original element is the first one).
 *
 * If given `element` was not split, an array with single element is returned.
 *
 * Example of a usage in a converter code:
 *
 *		const myElement = conversionApi.writer.createElement( 'myElement' );
 *
 *		// Children conversion may split `myElement`.
 *		conversionApi.convertChildren( myElement, modelCursor );
 *
 *		const splitParts = conversionApi.getSplitParts( myElement );
 *		const lastSplitPart = splitParts[ splitParts.length - 1 ];
 *
 *		// Setting `data.modelRange` basing on split parts:
 *		data.modelRange = conversionApi.writer.createRange(
 *			conversionApi.writer.createPositionBefore( myElement ),
 *			conversionApi.writer.createPositionAfter( lastSplitPart )
 *		);
 *
 *		// Setting `data.modelCursor` to continue after the last split element:
 *		data.modelCursor = conversionApi.writer.createPositionAfter( lastSplitPart );
 *
 * **Tip:** if you are unable to get a reference to the original element (for example because the code is split into multiple converters
 * or even classes) but it was already converted, you might want to check first element in `data.modelRange`. This is a common situation
 * if an attribute converter is separated from an element converter.
 *
 * @method #getSplitParts
 * @param {module:engine/model/element~Element} element
 * @returns {Array.<module:engine/model/element~Element>}
 */

/**
 * Stores information about what parts of processed view item are still waiting to be handled. After a piece of view item
 * was converted, appropriate consumable value should be {@link module:engine/conversion/viewconsumable~ViewConsumable#consume consumed}.
 *
 * @member {module:engine/conversion/viewconsumable~ViewConsumable} #consumable
 */

/**
 * Custom data stored by converters for conversion process. Custom properties of this object can be defined and use to
 * pass parameters between converters.
 *
 * The difference between this property and `data` parameter of
 * {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element} is that `data` parameters allows you
 * to pass parameters within a single event and `store` within the whole conversion.
 *
 * @member {Object} #store
 */

/**
 * The model's schema instance.
 *
 * @member {module:engine/model/schema~Schema} #schema
 */

/**
 * The {@link module:engine/model/writer~Writer} instance used to manipulate data during conversion.
 *
 * @member {module:engine/model/writer~Writer} #writer
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/controller/datacontroller.js












/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/controller/datacontroller
 */












/**
 * Controller for the data pipeline. The data pipeline controls how data is retrieved from the document
 * and set inside it. Hence, the controller features two methods which allow to {@link ~DataController#get get}
 * and {@link ~DataController#set set} data of the {@link ~DataController#model model}
 * using given:
 *
 * * {@link module:engine/dataprocessor/dataprocessor~DataProcessor data processor},
 * * downcast converters,
 * * upcast converters.
 *
 * An instance of the data controller is always available in the {@link module:core/editor/editor~Editor#data `editor.data`}
 * property:
 *
 *		editor.data.get( { rootName: 'customRoot' } ); // -> '<p>Hello!</p>'
 *
 * @mixes module:utils/observablemixin~ObservableMixin
 */

var datacontroller_DataController = /*#__PURE__*/function () {
  /**
   * Creates a data controller instance.
   *
   * @param {module:engine/model/model~Model} model Data model.
   * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor The styles processor instance.
   */
  function DataController(model, stylesProcessor) {
    var _this = this;

    Object(classCallCheck["a" /* default */])(this, DataController);

    /**
     * Data model.
     *
     * @readonly
     * @member {module:engine/model/model~Model}
     */
    this.model = model;
    /**
     * Styles processor used during the conversion.
     *
     * @readonly
     * @member {module:engine/view/stylesmap~StylesProcessor}
     */

    this.stylesProcessor = stylesProcessor;
    /**
     * Data processor used during the conversion.
     *
     * @member {module:engine/dataprocessor/dataprocessor~DataProcessor} #processor
     */

    this.processor;
    /**
     * Mapper used for the conversion. It has no permanent bindings, because they are created when getting data and
     * cleared directly after the data are converted. However, the mapper is defined as a class property, because
     * it needs to be passed to the `DowncastDispatcher` as a conversion API.
     *
     * @readonly
     * @member {module:engine/conversion/mapper~Mapper}
     */

    this.mapper = new mapper_Mapper();
    /**
     * Downcast dispatcher used by the {@link #get get method}. Downcast converters should be attached to it.
     *
     * @readonly
     * @member {module:engine/conversion/downcastdispatcher~DowncastDispatcher}
     */

    this.downcastDispatcher = new downcastdispatcher_DowncastDispatcher({
      mapper: this.mapper
    });
    this.downcastDispatcher.on('insert:$text', downcasthelpers_insertText(), {
      priority: 'lowest'
    });
    /**
     * Upcast dispatcher used by the {@link #set set method}. Upcast converters should be attached to it.
     *
     * @readonly
     * @member {module:engine/conversion/upcastdispatcher~UpcastDispatcher}
     */

    this.upcastDispatcher = new upcastdispatcher_UpcastDispatcher({
      schema: model.schema
    });
    /**
     * The view document used by the data controller.
     *
     * @readonly
     * @member {module:engine/view/document~Document}
     */

    this.viewDocument = new document_Document(stylesProcessor);
    /**
     * The view downcast writer just for data conversion purposes, i.e. to modify
     * the {@link #viewDocument}.
     *
     * @private
     * @readonly
     * @member {module:engine/view/downcastwriter~DowncastWriter}
     */

    this._viewWriter = new downcastwriter_DowncastWriter(this.viewDocument); // Define default converters for text and elements.
    //
    // Note that if there is no default converter for the element it will be skipped, for instance `<b>foo</b>` will be
    // converted to nothing. We add `convertToModelFragment` as a last converter so it converts children of that
    // element to the document fragment so `<b>foo</b>` will be converted to `foo` if there is no converter for `<b>`.

    this.upcastDispatcher.on('text', convertText(), {
      priority: 'lowest'
    });
    this.upcastDispatcher.on('element', convertToModelFragment(), {
      priority: 'lowest'
    });
    this.upcastDispatcher.on('documentFragment', convertToModelFragment(), {
      priority: 'lowest'
    });
    this.decorate('init'); // Fire `ready` event when initialisation has completed. Such low level listener gives possibility
    // to plug into initialisation pipeline without interrupting the initialisation flow.

    this.on('init', function () {
      _this.fire('ready');
    }, {
      priority: 'lowest'
    });
  }
  /**
   * Returns the model's data converted by downcast dispatchers attached to {@link #downcastDispatcher} and
   * formatted by the {@link #processor data processor}.
   *
   * @param {Object} [options]
   * @param {String} [options.rootName='main'] Root name.
   * @param {String} [options.trim='empty'] Whether returned data should be trimmed. This option is set to `empty` by default,
   * which means whenever editor content is considered empty, an empty string will be returned. To turn off trimming completely
   * use `'none'`. In such cases exact content will be returned (for example `<p>&nbsp;</p>` for an empty editor).
   * @returns {String} Output data.
   */


  Object(createClass["a" /* default */])(DataController, [{
    key: "get",
    value: function get(options) {
      var _ref = options || {},
          _ref$rootName = _ref.rootName,
          rootName = _ref$rootName === void 0 ? 'main' : _ref$rootName,
          _ref$trim = _ref.trim,
          trim = _ref$trim === void 0 ? 'empty' : _ref$trim;

      if (!this._checkIfRootsExists([rootName])) {
        /**
         * Cannot get data from a non-existing root. This error is thrown when {@link #get DataController#get() method}
         * is called with non-existent root name. For example, if there is an editor instance with only `main` root,
         * calling {@link #get} like:
         *
         *		data.get( { rootName: 'root2' } );
         *
         * will throw this error.
         *
         * @error datacontroller-get-non-existent-root
         */
        throw new ckeditorerror["b" /* default */]('datacontroller-get-non-existent-root: Attempting to get data from a non-existing root.', this);
      }

      var root = this.model.document.getRoot(rootName);

      if (trim === 'empty' && !this.model.hasContent(root, {
        ignoreWhitespaces: true
      })) {
        return '';
      }

      return this.stringify(root);
    }
    /**
     * Returns the content of the given {@link module:engine/model/element~Element model's element} or
     * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast converters
     * attached to {@link #downcastDispatcher} and formatted by the {@link #processor data processor}.
     *
     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment
     * Element whose content will be stringified.
     * @returns {String} Output data.
     */

  }, {
    key: "stringify",
    value: function stringify(modelElementOrFragment) {
      // Model -> view.
      var viewDocumentFragment = this.toView(modelElementOrFragment); // View -> data.

      return this.processor.toData(viewDocumentFragment);
    }
    /**
     * Returns the content of the given {@link module:engine/model/element~Element model element} or
     * {@link module:engine/model/documentfragment~DocumentFragment model document fragment} converted by the downcast
     * converters attached to {@link #downcastDispatcher} to a
     * {@link module:engine/view/documentfragment~DocumentFragment view document fragment}.
     *
     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} modelElementOrFragment
     * Element or document fragment whose content will be converted.
     * @returns {module:engine/view/documentfragment~DocumentFragment} Output view DocumentFragment.
     */

  }, {
    key: "toView",
    value: function toView(modelElementOrFragment) {
      var viewDocument = this.viewDocument;
      var viewWriter = this._viewWriter; // Clear bindings so the call to this method gives correct results.

      this.mapper.clearBindings(); // First, convert elements.

      var modelRange = model_range_Range._createIn(modelElementOrFragment);

      var viewDocumentFragment = new documentfragment_DocumentFragment(viewDocument);
      this.mapper.bindElements(modelElementOrFragment, viewDocumentFragment); // We have no view controller and rendering do DOM in DataController so view.change() block is not used here.

      this.downcastDispatcher.convertInsert(modelRange, viewWriter);

      if (!modelElementOrFragment.is('documentFragment')) {
        // Then, if a document element is converted, convert markers.
        // From all document markers, get those, which "intersect" with the converter element.
        var markers = _getMarkersRelativeToElement(modelElementOrFragment);

        var _iterator = _createForOfIteratorHelper(markers),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
                name = _step$value[0],
                range = _step$value[1];

            this.downcastDispatcher.convertMarkerAdd(name, range, viewWriter);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      return viewDocumentFragment;
    }
    /**
     * Sets initial input data parsed by the {@link #processor data processor} and
     * converted by the {@link #upcastDispatcher view-to-model converters}.
     * Initial data can be set only to document that {@link module:engine/model/document~Document#version} is equal 0.
     *
     * **Note** This method is {@link module:utils/observablemixin~ObservableMixin#decorate decorated} which is
     * used by e.g. collaborative editing plugin that syncs remote data on init.
     *
     * When data is passed as a string it is initialized on a default `main` root:
     *
     *		dataController.init( '<p>Foo</p>' ); // Initializes data on the `main` root.
     *
     * To initialize data on a different root or multiple roots at once, object containing `rootName` - `data` pairs should be passed:
     *
     *		dataController.init( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Initializes data on the `main` and `title` roots.
     *
     * @fires init
     * @param {String|Object.<String,String>} data Input data as a string or an object containing `rootName` - `data`
     * pairs to initialize data on multiple roots at once.
     * @returns {Promise} Promise that is resolved after the data is set on the editor.
     */

  }, {
    key: "init",
    value: function init(data) {
      var _this2 = this;

      if (this.model.document.version) {
        /**
         * Cannot set initial data to not empty {@link module:engine/model/document~Document}.
         * Initial data should be set once, during {@link module:core/editor/editor~Editor} initialization,
         * when the {@link module:engine/model/document~Document#version} is equal 0.
         *
         * @error datacontroller-init-document-not-empty
         */
        throw new ckeditorerror["b" /* default */]('datacontroller-init-document-not-empty: Trying to set initial data to not empty document.', this);
      }

      var initialData = {};

      if (typeof data === 'string') {
        initialData.main = data; // Default root is 'main'. To initiate data on a different root, object should be passed.
      } else {
        initialData = data;
      }

      if (!this._checkIfRootsExists(Object.keys(initialData))) {
        /**
         * Cannot init data on a non-existing root. This error is thrown when {@link #init DataController#init() method}
         * is called with non-existent root name. For example, if there is an editor instance with only `main` root,
         * calling {@link #init} like:
         *
         * 		data.init( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );
         *
         * will throw this error.
         *
         * @error datacontroller-init-non-existent-root
         */
        throw new ckeditorerror["b" /* default */]('datacontroller-init-non-existent-root: Attempting to init data on a non-existing root.', this);
      }

      this.model.enqueueChange('transparent', function (writer) {
        for (var _i = 0, _Object$keys = Object.keys(initialData); _i < _Object$keys.length; _i++) {
          var rootName = _Object$keys[_i];

          var modelRoot = _this2.model.document.getRoot(rootName);

          writer.insert(_this2.parse(initialData[rootName], modelRoot), modelRoot, 0);
        }
      });
      return Promise.resolve();
    }
    /**
     * Sets input data parsed by the {@link #processor data processor} and
     * converted by the {@link #upcastDispatcher view-to-model converters}.
     * This method can be used any time to replace existing editor data by the new one without clearing the
     * {@link module:engine/model/document~Document#history document history}.
     *
     * This method also creates a batch with all the changes applied. If all you need is to parse data, use
     * the {@link #parse} method.
     *
     * When data is passed as a string it is set on a default `main` root:
     *
     *		dataController.set( '<p>Foo</p>' ); // Sets data on the `main` root.
     *
     * To set data on a different root or multiple roots at once, object containing `rootName` - `data` pairs should be passed:
     *
     *		dataController.set( { main: '<p>Foo</p>', title: '<h1>Bar</h1>' } ); // Sets data on the `main` and `title` roots.
     *
     * @param {String|Object.<String,String>} data Input data as a string or an object containing `rootName` - `data`
     * pairs to set data on multiple roots at once.
     */

  }, {
    key: "set",
    value: function set(data) {
      var _this3 = this;

      var newData = {};

      if (typeof data === 'string') {
        newData.main = data; // Default root is 'main'. To set data on a different root, object should be passed.
      } else {
        newData = data;
      }

      if (!this._checkIfRootsExists(Object.keys(newData))) {
        /**
         * Cannot set data on a non-existing root. This error is thrown when {@link #set DataController#set() method}
         * is called with non-existent root name. For example, if there is an editor instance with only `main` root,
         * calling {@link #set} like:
         *
         * 		data.set( { main: '<p>Foo</p>', root2: '<p>Bar</p>' } );
         *
         * will throw this error.
         *
         * @error datacontroller-set-non-existent-root
         */
        throw new ckeditorerror["b" /* default */]('datacontroller-set-non-existent-root: Attempting to set data on a non-existing root.', this);
      }

      this.model.enqueueChange('transparent', function (writer) {
        writer.setSelection(null);
        writer.removeSelectionAttribute(_this3.model.document.selection.getAttributeKeys());

        for (var _i2 = 0, _Object$keys2 = Object.keys(newData); _i2 < _Object$keys2.length; _i2++) {
          var rootName = _Object$keys2[_i2];

          // Save to model.
          var modelRoot = _this3.model.document.getRoot(rootName);

          writer.remove(writer.createRangeIn(modelRoot));
          writer.insert(_this3.parse(newData[rootName], modelRoot), modelRoot, 0);
        }
      });
    }
    /**
     * Returns the data parsed by the {@link #processor data processor} and then converted by upcast converters
     * attached to the {@link #upcastDispatcher}.
     *
     * @see #set
     * @param {String} data Data to parse.
     * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will
     * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.
     * @returns {module:engine/model/documentfragment~DocumentFragment} Parsed data.
     */

  }, {
    key: "parse",
    value: function parse(data) {
      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '$root';
      // data -> view
      var viewDocumentFragment = this.processor.toView(data); // view -> model

      return this.toModel(viewDocumentFragment, context);
    }
    /**
     * Returns the result of the given {@link module:engine/view/element~Element view element} or
     * {@link module:engine/view/documentfragment~DocumentFragment view document fragment} converted by the
     * {@link #upcastDispatcher view-to-model converters}, wrapped by {@link module:engine/model/documentfragment~DocumentFragment}.
     *
     * When marker elements were converted during the conversion process, it will be set as a document fragment's
     * {@link module:engine/model/documentfragment~DocumentFragment#markers static markers map}.
     *
     * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} viewElementOrFragment
     * Element or document fragment whose content will be converted.
     * @param {module:engine/model/schema~SchemaContextDefinition} [context='$root'] Base context in which the view will
     * be converted to the model. See: {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#convert}.
     * @returns {module:engine/model/documentfragment~DocumentFragment} Output document fragment.
     */

  }, {
    key: "toModel",
    value: function toModel(viewElementOrFragment) {
      var _this4 = this;

      var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '$root';
      return this.model.change(function (writer) {
        return _this4.upcastDispatcher.convert(viewElementOrFragment, writer, context);
      });
    }
    /**
     * Adds a style processor normalization rules.
     *
     * You can implement your own rules as well as use one of the available processor rules:
     *
     * * background: {@link module:engine/view/styles/background~addBackgroundRules}
     * * border: {@link module:engine/view/styles/border~addBorderRules}
     * * margin: {@link module:engine/view/styles/margin~addMarginRules}
     * * padding: {@link module:engine/view/styles/padding~addPaddingRules}
     *
     * @param {Function} callback
     */

  }, {
    key: "addStyleProcessorRules",
    value: function addStyleProcessorRules(callback) {
      callback(this.stylesProcessor);
    }
    /**
     * Removes all event listeners set by the DataController.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.stopListening();
    }
    /**
     * Checks if all provided root names are existing editor roots.
     *
     * @private
     * @param {Array.<String>} rootNames Root names to check.
     * @returns {Boolean} Whether all provided root names are existing editor roots.
     */

  }, {
    key: "_checkIfRootsExists",
    value: function _checkIfRootsExists(rootNames) {
      var _iterator2 = _createForOfIteratorHelper(rootNames),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var rootName = _step2.value;

          if (!this.model.document.getRootNames().includes(rootName)) {
            return false;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return true;
    }
    /**
     * Event fired once data initialisation has finished.
     *
     * @event ready
     */

    /**
     * Event fired after {@link #init init() method} has been run. It can be {@link #listenTo listened to} to adjust/modify
     * the initialisation flow. However, if the `init` event is stopped or prevented, the {@link #event:ready ready event}
     * should be fired manually.
     *
     * The `init` event is fired by decorated {@link #init} method.
     * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.
     *
     * @event init
     */

  }]);

  return DataController;
}();


mix(datacontroller_DataController, observablemixin); // Helper function for downcast conversion.
//
// Takes a document element (element that is added to a model document) and checks which markers are inside it
// and which markers are containing it. If the marker is intersecting with element, the intersection is returned.

function _getMarkersRelativeToElement(element) {
  var result = [];
  var doc = element.root.document;

  if (!doc) {
    return [];
  }

  var elementRange = model_range_Range._createIn(element);

  var _iterator3 = _createForOfIteratorHelper(doc.model.markers),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var marker = _step3.value;
      var intersection = elementRange.getIntersection(marker.getRange());

      if (intersection) {
        result.push([marker.name, intersection]);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return result;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/conversion/conversion.js













var conversion_marked = /*#__PURE__*/regeneratorRuntime.mark(_getAllUpcastDefinitions),
    conversion_marked2 = /*#__PURE__*/regeneratorRuntime.mark(_getUpcastDefinition);

/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/conversion/conversion
 */



/**
 * A utility class that helps add converters to upcast and downcast dispatchers.
 *
 * We recommend reading the {@glink framework/guides/architecture/editing-engine Editing engine architecture} guide first to
 * understand the core concepts of the conversion mechanisms.
 *
 * An instance of the conversion manager is available in the
 * {@link module:core/editor/editor~Editor#conversion `editor.conversion`} property
 * and by default has the following groups of dispatchers (i.e. directions of conversion):
 *
 * * `downcast` (editing and data downcasts)
 * * `editingDowncast`
 * * `dataDowncast`
 * * `upcast`
 *
 * # One-way converters
 *
 * To add a converter to a specific group, use the {@link module:engine/conversion/conversion~Conversion#for `for()`}
 * method:
 *
 *		// Add a converter to editing downcast and data downcast.
 *		editor.conversion.for( 'downcast' ).elementToElement( config ) );
 *
 *		// Add a converter to the data pipepline only:
 *		editor.conversion.for( 'dataDowncast' ).elementToElement( dataConversionConfig ) );
 *
 *		// And a slightly different one for the editing pipeline:
 *		editor.conversion.for( 'editingDowncast' ).elementToElement( editingConversionConfig ) );
 *
 * See {@link module:engine/conversion/conversion~Conversion#for `for()`} method documentation to learn more about
 * available conversion helpers and how to use your custom ones.
 *
 * # Two-way converters
 *
 * Besides using one-way converters via the `for()` method, you can also use other methods available in this
 * class to add two-way converters (upcast and downcast):
 *
 * * {@link module:engine/conversion/conversion~Conversion#elementToElement `elementToElement()`} &ndash;
 * Model element to view element and vice versa.
 * * {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement()`} &ndash;
 * Model attribute to view element and vice versa.
 * * {@link module:engine/conversion/conversion~Conversion#attributeToAttribute `attributeToAttribute()`} &ndash;
 * Model attribute to view element and vice versa.
 */

var conversion_Conversion = /*#__PURE__*/function () {
  /**
   * Creates a new conversion instance.
   *
   * @param {module:engine/conversion/downcastdispatcher~DowncastDispatcher|
   * Array.<module:engine/conversion/downcastdispatcher~DowncastDispatcher>} downcastDispatchers
   * @param {module:engine/conversion/upcastdispatcher~UpcastDispatcher|
   * Array.<module:engine/conversion/upcastdispatcher~UpcastDispatcher>} upcastDispatchers
   */
  function Conversion(downcastDispatchers, upcastDispatchers) {
    Object(classCallCheck["a" /* default */])(this, Conversion);

    /**
     * Maps dispatchers group name to ConversionHelpers instances.
     *
     * @private
     * @member {Map.<String,module:engine/conversion/conversionhelpers~ConversionHelpers>}
     */
    this._helpers = new Map(); // Define default 'downcast' & 'upcast' dispatchers groups. Those groups are always available as two-way converters needs them.

    this._downcast = Array.isArray(downcastDispatchers) ? downcastDispatchers : [downcastDispatchers];

    this._createConversionHelpers({
      name: 'downcast',
      dispatchers: this._downcast,
      isDowncast: true
    });

    this._upcast = Array.isArray(upcastDispatchers) ? upcastDispatchers : [upcastDispatchers];

    this._createConversionHelpers({
      name: 'upcast',
      dispatchers: this._upcast,
      isDowncast: false
    });
  }
  /**
   * Define an alias for registered dispatcher.
   *
   *		const conversion = new Conversion(
   *			[ dataDowncastDispatcher, editingDowncastDispatcher ],
   *			upcastDispatcher
   *		);
   *
   *		conversion.addAlias( 'dataDowncast', dataDowncastDispatcher );
   *
   * @param {String} alias An alias of a dispatcher.
   * @param {module:engine/conversion/downcastdispatcher~DowncastDispatcher|
   * module:engine/conversion/upcastdispatcher~UpcastDispatcher} dispatcher Dispatcher which should have an alias.
   */


  Object(createClass["a" /* default */])(Conversion, [{
    key: "addAlias",
    value: function addAlias(alias, dispatcher) {
      var isDowncast = this._downcast.includes(dispatcher);

      var isUpcast = this._upcast.includes(dispatcher);

      if (!isUpcast && !isDowncast) {
        /**
         * Trying to register and alias for a dispatcher that nas not been registered.
         *
         * @error conversion-add-alias-dispatcher-not-registered
         */
        throw new ckeditorerror["b" /* default */]('conversion-add-alias-dispatcher-not-registered: ' + 'Trying to register and alias for a dispatcher that nas not been registered.', this);
      }

      this._createConversionHelpers({
        name: alias,
        dispatchers: [dispatcher],
        isDowncast: isDowncast
      });
    }
    /**
     * Provides a chainable API to assign converters to conversion dispatchers group.
     *
     * If the given group name has not been registered, the
     * {@link module:utils/ckeditorerror~CKEditorError `conversion-for-unknown-group` error} is thrown.
     *
     * You can use conversion helpers available directly in the `for()` chain or your custom ones via
     * the {@link module:engine/conversion/conversionhelpers~ConversionHelpers#add `add()`} method.
     *
     * # Using bulit-in conversion helpers
     *
     * The `for()` chain comes with a set of conversion helpers which you can use like this:
     *
     *		editor.conversion.for( 'downcast' )
     *			.elementToElement( config1 )        // Adds an element-to-element downcast converter.
     *			.attributeToElement( config2 );     // Adds an attribute-to-element downcast converter.
     *
     *		editor.conversion.for( 'upcast' )
     *			.elementToAttribute( config3 );     // Adds an element-to-attribute upcast converter.
     *
     * Refer to the documentation of built-in conversion helpers to learn about their configuration options.
     *
     * * downcast (model-to-view) conversion helpers:
     *
     *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`},
     *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement `attributeToElement()`},
     *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToAttribute `attributeToAttribute()`}.
     *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToElement `markerToElement()`}.
     *	* {@link module:engine/conversion/downcasthelpers~DowncastHelpers#markerToHighlight `markerToHighlight()`}.
     *
     * * upcast (view-to-model) conversion helpers:
     *
     *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToElement `elementToElement()`},
     *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToAttribute `elementToAttribute()`},
     *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#attributeToAttribute `attributeToAttribute()`}.
     *	* {@link module:engine/conversion/upcasthelpers~UpcastHelpers#elementToMarker `elementToMarker()`}.
     *
     * # Using custom conversion helpers
     *
     * If you need to implement a nontypical converter, you can do so by calling:
     *
     *		editor.conversion.for( direction ).add( customHelper );
     *
     * The `.add()` method takes exactly one parameter, which is a function. This function should accept one parameter that
     * is a dispatcher instance. The function should add an actual converter to the passed dispatcher instance.
     *
     * Example:
     *
     *		editor.conversion.for( 'upcast' ).add( dispatcher => {
     *			dispatcher.on( 'element:a',  ( evt, data, conversionApi ) => {
     *				// Do something with a view <a> element.
     *			} );
     *		} );
     *
     * Refer to the documentation of {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher}
     * and {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} to learn how to write
     * custom converters.
     *
     * @param {String} groupName The name of dispatchers group to add the converters to.
     * @returns {module:engine/conversion/downcasthelpers~DowncastHelpers|module:engine/conversion/upcasthelpers~UpcastHelpers}
     */

  }, {
    key: "for",
    value: function _for(groupName) {
      if (!this._helpers.has(groupName)) {
        /**
         * Trying to add a converter to an unknown dispatchers group.
         *
         * @error conversion-for-unknown-group
         */
        throw new ckeditorerror["b" /* default */]('conversion-for-unknown-group: Trying to add a converter to an unknown dispatchers group.', this);
      }

      return this._helpers.get(groupName);
    }
    /**
     * Sets up converters between the model and the view that convert a model element to a view element (and vice versa).
     * For example, the model `<paragraph>Foo</paragraph>` is `<p>Foo</p>` in the view.
     *
     *		// A simple conversion from the `paragraph` model element to the `<p>` view element (and vice versa).
     *		editor.conversion.elementToElement( { model: 'paragraph', view: 'p' } );
     *
     *		// Override other converters by specifying a converter definition with a higher priority.
     *		editor.conversion.elementToElement( { model: 'paragraph', view: 'div', converterPriority: 'high' } );
     *
     *		// View specified as an object instead of a string.
     *		editor.conversion.elementToElement( {
     *			model: 'fancyParagraph',
     *			view: {
     *				name: 'p',
     *				classes: 'fancy'
     *			}
     *		} );
     *
     *		// Use `upcastAlso` to define other view elements that should also be converted to a `paragraph` element.
     *		editor.conversion.elementToElement( {
     *			model: 'paragraph',
     *			view: 'p',
     *			upcastAlso: [
     *				'div',
     *				{
     *					// Any element with the `display: block` style.
     *					styles: {
     *						display: 'block'
     *					}
     *				}
     *			]
     *		} );
     *
     *		// `upcastAlso` set as callback enables a conversion of a wide range of different view elements.
     *		editor.conversion.elementToElement( {
     *			model: 'heading',
     *			view: 'h2',
     *			// Convert "headling-like" paragraphs to headings.
     *			upcastAlso: viewElement => {
     *				const fontSize = viewElement.getStyle( 'font-size' );
     *
     *				if ( !fontSize ) {
     *					return null;
     *				}
     *
     *				const match = fontSize.match( /(\d+)\s*px/ );
     *
     *				if ( !match ) {
     *					return null;
     *				}
     *
     *				const size = Number( match[ 1 ] );
     *
     *				if ( size > 26 ) {
     *					// Returned value can be an object with the matched properties.
     *					// These properties will be "consumed" during the conversion.
     *					// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
     *
     *					return { name: true, styles: [ 'font-size' ] };
     *				}
     *
     *				return null;
     *			}
     *		} );
     *
     * `definition.model` is a `String` with a model element name to convert from or to.
     * See {@link module:engine/conversion/conversion~ConverterDefinition} to learn about other parameters.
     *
     * @param {module:engine/conversion/conversion~ConverterDefinition} definition The converter definition.
     */

  }, {
    key: "elementToElement",
    value: function elementToElement(definition) {
      // Set up downcast converter.
      this.for('downcast').elementToElement(definition); // Set up upcast converter.

      var _iterator = _createForOfIteratorHelper(_getAllUpcastDefinitions(definition)),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _step.value,
              model = _step$value.model,
              view = _step$value.view;
          this.for('upcast').elementToElement({
            model: model,
            view: view,
            converterPriority: definition.converterPriority
          });
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Sets up converters between the model and the view that convert a model attribute to a view element (and vice versa).
     * For example, a model text node with `"Foo"` as data and the `bold` attribute is `<strong>Foo</strong>` in the view.
     *
     *		// A simple conversion from the `bold=true` attribute to the `<strong>` view element (and vice versa).
     *		editor.conversion.attributeToElement( { model: 'bold', view: 'strong' } );
     *
     *		// Override other converters by specifying a converter definition with a higher priority.
     *		editor.conversion.attributeToElement( { model: 'bold', view: 'b', converterPriority: 'high' } );
     *
     *		// View specified as an object instead of a string.
     *		editor.conversion.attributeToElement( {
     *			model: 'bold',
     *			view: {
     *				name: 'span',
     *				classes: 'bold'
     *			}
     *		} );
     *
     *		// Use `config.model.name` to define the conversion only from a given node type, `$text` in this case.
     *		// The same attribute on different elements may then be handled by a different converter.
     *		editor.conversion.attributeToElement( {
     *			model: {
     *				key: 'textDecoration',
     *				values: [ 'underline', 'lineThrough' ],
     *				name: '$text'
     *			},
     *			view: {
     *				underline: {
     *					name: 'span',
     *					styles: {
     *						'text-decoration': 'underline'
     *					}
     *				},
     *				lineThrough: {
     *					name: 'span',
     *					styles: {
     *						'text-decoration': 'line-through'
     *					}
     *				}
     *			}
     *		} );
     *
     *		// Use `upcastAlso` to define other view elements that should also be converted to the `bold` attribute.
     *		editor.conversion.attributeToElement( {
     *			model: 'bold',
     *			view: 'strong',
     *			upcastAlso: [
     *				'b',
     *				{
     *					name: 'span',
     *					classes: 'bold'
     *				},
     *				{
     *					name: 'span',
     *					styles: {
     *						'font-weight': 'bold'
     *					}
     *				},
     *				viewElement => {
     *					const fontWeight = viewElement.getStyle( 'font-weight' );
     *
     *					if ( viewElement.is( 'span' ) && fontWeight && /\d+/.test() && Number( fontWeight ) > 500 ) {
     *						// Returned value can be an object with the matched properties.
     *						// These properties will be "consumed" during the conversion.
     *						// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
     *
     *						return {
     *							name: true,
     *							styles: [ 'font-weight' ]
     *						};
     *					}
     *				}
     *			]
     *		} );
     *
     *		// Conversion from and to a model attribute key whose value is an enum (`fontSize=big|small`).
     *		// `upcastAlso` set as callback enables a conversion of a wide range of different view elements.
     *		editor.conversion.attributeToElement( {
     *			model: {
     *				key: 'fontSize',
     *				values: [ 'big', 'small' ]
     *			},
     *			view: {
     *				big: {
     *					name: 'span',
     *					styles: {
     *						'font-size': '1.2em'
     *					}
     *				},
     *				small: {
     *					name: 'span',
     *					styles: {
     *						'font-size': '0.8em'
     *					}
     *				}
     *			},
     *			upcastAlso: {
     *				big: viewElement => {
     *					const fontSize = viewElement.getStyle( 'font-size' );
     *
     *					if ( !fontSize ) {
     *						return null;
     *					}
     *
     *					const match = fontSize.match( /(\d+)\s*px/ );
     *
     *					if ( !match ) {
     *						return null;
     *					}
     *
     *					const size = Number( match[ 1 ] );
     *
     *					if ( viewElement.is( 'span' ) && size > 10 ) {
     *						// Returned value can be an object with the matched properties.
     *						// These properties will be "consumed" during the conversion.
     *						// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
     *
     *						return { name: true, styles: [ 'font-size' ] };
     *					}
     *
     *					return null;
     *				},
     *				small: viewElement => {
     *					const fontSize = viewElement.getStyle( 'font-size' );
     *
     *					if ( !fontSize ) {
     *						return null;
     *					}
     *
     *					const match = fontSize.match( /(\d+)\s*px/ );
     *
     *					if ( !match ) {
     *						return null;
     *					}
     *
     *					const size = Number( match[ 1 ] );
     *
     *					if ( viewElement.is( 'span' ) && size < 10 ) {
     *						// Returned value can be an object with the matched properties.
     *						// These properties will be "consumed" during the conversion.
     *						// See `engine.view.Matcher~MatcherPattern` and `engine.view.Matcher#match` for more details.
     *
     *						return { name: true, styles: [ 'font-size' ] };
     *					}
     *
     *					return null;
     *				}
     *			}
     *		} );
     *
     * The `definition.model` parameter specifies which model attribute should be converted from or to. It can be a `{ key, value }` object
     * describing the attribute key and value to convert or a `String` specifying just the attribute key (then `value` is set to `true`).
     * See {@link module:engine/conversion/conversion~ConverterDefinition} to learn about other parameters.
     *
     * @param {module:engine/conversion/conversion~ConverterDefinition} definition The converter definition.
     */

  }, {
    key: "attributeToElement",
    value: function attributeToElement(definition) {
      // Set up downcast converter.
      this.for('downcast').attributeToElement(definition); // Set up upcast converter.

      var _iterator2 = _createForOfIteratorHelper(_getAllUpcastDefinitions(definition)),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _step2$value = _step2.value,
              model = _step2$value.model,
              view = _step2$value.view;
          this.for('upcast').elementToAttribute({
            view: view,
            model: model,
            converterPriority: definition.converterPriority
          });
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    /**
     * Sets up converters between the model and the view that convert a model attribute to a view attribute (and vice versa).
     * For example, `<image src='foo.jpg'></image>` is converted to `<img src='foo.jpg'></img>` (the same attribute key and value).
     * This type of converters is intended to be used with {@link module:engine/model/element~Element model element} nodes.
     * To convert text attributes {@link module:engine/conversion/conversion~Conversion#attributeToElement `attributeToElement converter`}
     * should be set up.
     *
     *		// A simple conversion from the `source` model attribute to the `src` view attribute (and vice versa).
     *		editor.conversion.attributeToAttribute( { model: 'source', view: 'src' } );
     *
     *		// Attribute values are strictly specified.
     *		editor.conversion.attributeToAttribute( {
     *			model: {
     *				name: 'image',
     *				key: 'aside',
     *				values: [ 'aside' ]
     *			},
     *			view: {
     *				aside: {
     *					name: 'img',
     *					key: 'class',
     *					value: [ 'aside', 'half-size' ]
     *				}
     *			}
     *		} );
     *
     *		// Set the style attribute.
     *		editor.conversion.attributeToAttribute( {
     *			model: {
     *				name: 'image',
     *				key: 'aside',
     *				values: [ 'aside' ]
     *			},
     *			view: {
     *				aside: {
     *					name: 'img',
     *					key: 'style',
     *					value: {
     *						float: 'right',
     *						width: '50%',
     *						margin: '5px'
     *					}
     *				}
     *			}
     *		} );
     *
     *		// Conversion from and to a model attribute key whose value is an enum (`align=right|center`).
     *		// Use `upcastAlso` to define other view elements that should also be converted to the `align=right` attribute.
     *		editor.conversion.attributeToAttribute( {
     *			model: {
     *				key: 'align',
     *				values: [ 'right', 'center' ]
     *			},
     *			view: {
     *				right: {
     *					key: 'class',
     *					value: 'align-right'
     *				},
     *				center: {
     *					key: 'class',
     *					value: 'align-center'
     *				}
     *			},
     *			upcastAlso: {
     *				right: {
     *					styles: {
     *						'text-align': 'right'
     *					}
     *				},
     *				center: {
     *					styles: {
     *						'text-align': 'center'
     *					}
     *				}
     *			}
     *		} );
     *
     * The `definition.model` parameter specifies which model attribute should be converted from and to.
     * It can be a `{ key, [ values ], [ name ] }` object or a `String`, which will be treated like `{ key: definition.model }`.
     * The `key` property is the model attribute key to convert from and to.
     * The `values` are the possible model attribute values. If `values` is not set, the model attribute value will be the same as the
     * view attribute value.
     * If `name` is set, the conversion will be set up only for model elements with the given name.
     *
     * The `definition.view` parameter specifies which view attribute should be converted from and to.
     * It can be a `{ key, value, [ name ] }` object or a `String`, which will be treated like `{ key: definition.view }`.
     * The `key` property is the view attribute key to convert from and to.
     * The `value` is the view attribute value to convert from and to. If `definition.value` is not set, the view attribute value will be
     * the same as the model attribute value.
     * If `key` is `'class'`, `value` can be a `String` or an array of `String`s.
     * If `key` is `'style'`, `value` is an object with key-value pairs.
     * In other cases, `value` is a `String`.
     * If `name` is set, the conversion will be set up only for model elements with the given name.
     * If `definition.model.values` is set, `definition.view` is an object that assigns values from `definition.model.values`
     * to `{ key, value, [ name ] }` objects.
     *
     * `definition.upcastAlso` specifies which other matching view elements should also be upcast to the given model configuration.
     * If `definition.model.values` is set, `definition.upcastAlso` should be an object assigning values from `definition.model.values`
     * to {@link module:engine/view/matcher~MatcherPattern}s or arrays of {@link module:engine/view/matcher~MatcherPattern}s.
     *
     * **Note:** `definition.model` and `definition.view` form should be mirrored, so the same types of parameters should
     * be given in both parameters.
     *
     * @param {Object} definition The converter definition.
     * @param {String|Object} definition.model The model attribute to convert from and to.
     * @param {String|Object} definition.view The view attribute to convert from and to.
     * @param {module:engine/view/matcher~MatcherPattern|Array.<module:engine/view/matcher~MatcherPattern>} [definition.upcastAlso]
     * Any view element matching `definition.upcastAlso` will also be converted to the given model attribute. `definition.upcastAlso`
     * is used only if `config.model.values` is specified.
     */

  }, {
    key: "attributeToAttribute",
    value: function attributeToAttribute(definition) {
      // Set up downcast converter.
      this.for('downcast').attributeToAttribute(definition); // Set up upcast converter.

      var _iterator3 = _createForOfIteratorHelper(_getAllUpcastDefinitions(definition)),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _step3$value = _step3.value,
              model = _step3$value.model,
              view = _step3$value.view;
          this.for('upcast').attributeToAttribute({
            view: view,
            model: model
          });
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
    /**
     * Creates and caches conversion helpers for given dispatchers group.
     *
     * @private
     * @param {Object} options
     * @param {String} options.name Group name.
     * @param {Array.<module:engine/conversion/downcastdispatcher~DowncastDispatcher|
     * module:engine/conversion/upcastdispatcher~UpcastDispatcher>} options.dispatchers
     * @param {Boolean} options.isDowncast
     */

  }, {
    key: "_createConversionHelpers",
    value: function _createConversionHelpers(_ref) {
      var name = _ref.name,
          dispatchers = _ref.dispatchers,
          isDowncast = _ref.isDowncast;

      if (this._helpers.has(name)) {
        /**
         * Trying to register a group name that has already been registered.
         *
         * @error conversion-group-exists
         */
        throw new ckeditorerror["b" /* default */]('conversion-group-exists: Trying to register a group name that has already been registered.', this);
      }

      var helpers = isDowncast ? new downcasthelpers_DowncastHelpers(dispatchers) : new upcasthelpers_UpcastHelpers(dispatchers);

      this._helpers.set(name, helpers);
    }
  }]);

  return Conversion;
}();
/**
 * Defines how the model should be converted from and to the view.
 *
 * @typedef {Object} module:engine/conversion/conversion~ConverterDefinition
 *
 * @property {*} [model] The model conversion definition. Describes the model element or model attribute to convert. This parameter differs
 * for different functions that accept `ConverterDefinition`. See the description of the function to learn how to set it.
 * @property {module:engine/view/elementdefinition~ElementDefinition|Object} view The definition of the view element to convert from and
 * to. If `model` describes multiple values, `view` is an object that assigns these values (`view` object keys) to view element definitions
 * (`view` object values).
 * @property {module:engine/view/matcher~MatcherPattern|Array.<module:engine/view/matcher~MatcherPattern>} [upcastAlso]
 * Any view element matching `upcastAlso` will also be converted to the model. If `model` describes multiple values, `upcastAlso`
 * is an object that assigns these values (`upcastAlso` object keys) to {@link module:engine/view/matcher~MatcherPattern}s
 * (`upcastAlso` object values).
 * @property {module:utils/priorities~PriorityString} [converterPriority] The converter priority.
 */
// Helper function that creates a joint array out of an item passed in `definition.view` and items passed in
// `definition.upcastAlso`.
//
// @param {module:engine/conversion/conversion~ConverterDefinition} definition
// @returns {Array} Array containing view definitions.




function _getAllUpcastDefinitions(definition) {
  var _iterator4, _step4, value, model, view, upcastAlso;

  return regeneratorRuntime.wrap(function _getAllUpcastDefinitions$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          if (!definition.model.values) {
            _context.next = 22;
            break;
          }

          _iterator4 = _createForOfIteratorHelper(definition.model.values);
          _context.prev = 2;

          _iterator4.s();

        case 4:
          if ((_step4 = _iterator4.n()).done) {
            _context.next = 12;
            break;
          }

          value = _step4.value;
          model = {
            key: definition.model.key,
            value: value
          };
          view = definition.view[value];
          upcastAlso = definition.upcastAlso ? definition.upcastAlso[value] : undefined;
          return _context.delegateYield(_getUpcastDefinition(model, view, upcastAlso), "t0", 10);

        case 10:
          _context.next = 4;
          break;

        case 12:
          _context.next = 17;
          break;

        case 14:
          _context.prev = 14;
          _context.t1 = _context["catch"](2);

          _iterator4.e(_context.t1);

        case 17:
          _context.prev = 17;

          _iterator4.f();

          return _context.finish(17);

        case 20:
          _context.next = 23;
          break;

        case 22:
          return _context.delegateYield(_getUpcastDefinition(definition.model, definition.view, definition.upcastAlso), "t2", 23);

        case 23:
        case "end":
          return _context.stop();
      }
    }
  }, conversion_marked, null, [[2, 14, 17, 20]]);
}

function _getUpcastDefinition(model, view, upcastAlso) {
  var _iterator5, _step5, upcastAlsoItem;

  return regeneratorRuntime.wrap(function _getUpcastDefinition$(_context2) {
    while (1) {
      switch (_context2.prev = _context2.next) {
        case 0:
          _context2.next = 2;
          return {
            model: model,
            view: view
          };

        case 2:
          if (!upcastAlso) {
            _context2.next = 21;
            break;
          }

          upcastAlso = Array.isArray(upcastAlso) ? upcastAlso : [upcastAlso];
          _iterator5 = _createForOfIteratorHelper(upcastAlso);
          _context2.prev = 5;

          _iterator5.s();

        case 7:
          if ((_step5 = _iterator5.n()).done) {
            _context2.next = 13;
            break;
          }

          upcastAlsoItem = _step5.value;
          _context2.next = 11;
          return {
            model: model,
            view: upcastAlsoItem
          };

        case 11:
          _context2.next = 7;
          break;

        case 13:
          _context2.next = 18;
          break;

        case 15:
          _context2.prev = 15;
          _context2.t0 = _context2["catch"](5);

          _iterator5.e(_context2.t0);

        case 18:
          _context2.prev = 18;

          _iterator5.f();

          return _context2.finish(18);

        case 21:
        case "end":
          return _context2.stop();
      }
    }
  }, conversion_marked2, null, [[5, 15, 18, 21]]);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/batch.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/batch
 */

/**
 * A batch instance groups model changes ({@link module:engine/model/operation/operation~Operation operations}). All operations
 * grouped in a single batch can be reverted together, so you can also think about a batch as of a single undo step. If you want
 * to extend a given undo step, you can add more changes to the batch using {@link module:engine/model/model~Model#enqueueChange}:
 *
 *		model.enqueueChange( batch, writer => {
 *			writer.insertText( 'foo', paragraph, 'end' );
 *		} );
 *
 * @see module:engine/model/model~Model#enqueueChange
 * @see module:engine/model/model~Model#change
 */
var batch_Batch = /*#__PURE__*/function () {
  /**
   * Creates a batch instance.
   *
   * @see module:engine/model/model~Model#enqueueChange
   * @see module:engine/model/model~Model#change
   * @param {'transparent'|'default'} [type='default'] The type of the batch.
   */
  function Batch() {
    var type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'default';

    Object(classCallCheck["a" /* default */])(this, Batch);

    /**
     * An array of operations that compose this batch.
     *
     * @readonly
     * @type {Array.<module:engine/model/operation/operation~Operation>}
     */
    this.operations = [];
    /**
     * The type of the batch.
     *
     * It can be one of the following values:
     * * `'default'` &ndash; All "normal" batches. This is the most commonly used type.
     * * `'transparent'` &ndash; A batch that should be ignored by other features, i.e. an initial batch or collaborative editing
     * changes.
     *
     * @readonly
     * @type {'transparent'|'default'}
     */

    this.type = type;
  }
  /**
   * Returns the base version of this batch, which is equal to the base version of the first operation in the batch.
   * If there are no operations in the batch or neither operation has the base version set, it returns `null`.
   *
   * @readonly
   * @type {Number|null}
   */


  Object(createClass["a" /* default */])(Batch, [{
    key: "addOperation",

    /**
     * Adds an operation to the batch instance.
     *
     * @param {module:engine/model/operation/operation~Operation} operation An operation to add.
     * @returns {module:engine/model/operation/operation~Operation} The added operation.
     */
    value: function addOperation(operation) {
      operation.batch = this;
      this.operations.push(operation);
      return operation;
    }
  }, {
    key: "baseVersion",
    get: function get() {
      var _iterator = _createForOfIteratorHelper(this.operations),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var op = _step.value;

          if (op.baseVersion !== null) {
            return op.baseVersion;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return null;
    }
  }]);

  return Batch;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/operation/operation.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/operation/operation
 */

/**
 * Abstract base operation class.
 *
 * @abstract
 */
var operation_Operation = /*#__PURE__*/function () {
  /**
   * Base operation constructor.
   *
   * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  function Operation(baseVersion) {
    Object(classCallCheck["a" /* default */])(this, Operation);

    /**
     * {@link module:engine/model/document~Document#version} on which operation can be applied. If you try to
     * {@link module:engine/model/model~Model#applyOperation apply} operation with different base version than the
     * {@link module:engine/model/document~Document#version document version} the
     * {@link module:utils/ckeditorerror~CKEditorError model-document-applyOperation-wrong-version} error is thrown.
     *
     * @member {Number}
     */
    this.baseVersion = baseVersion;
    /**
     * Defines whether operation is executed on attached or detached {@link module:engine/model/item~Item items}.
     *
     * @readonly
     * @member {Boolean} #isDocumentOperation
     */

    this.isDocumentOperation = this.baseVersion !== null;
    /**
     * {@link module:engine/model/batch~Batch Batch} to which the operation is added or `null` if the operation is not
     * added to any batch yet.
     *
     * @member {module:engine/model/batch~Batch|null} #batch
     */

    this.batch = null;
    /**
     * Operation type.
     *
     * @readonly
     * @member {String} #type
     */

    /**
     * Creates and returns an operation that has the same parameters as this operation.
     *
     * @method #clone
     * @returns {module:engine/model/operation/operation~Operation} Clone of this operation.
     */

    /**
     * Creates and returns a reverse operation. Reverse operation when executed right after
     * the original operation will bring back tree model state to the point before the original
     * operation execution. In other words, it reverses changes done by the original operation.
     *
     * Keep in mind that tree model state may change since executing the original operation,
     * so reverse operation will be "outdated". In that case you will need to transform it by
     * all operations that were executed after the original operation.
     *
     * @method #getReversed
     * @returns {module:engine/model/operation/operation~Operation} Reversed operation.
     */

    /**
     * Executes the operation - modifications described by the operation properties will be applied to the model tree.
     *
     * @protected
     * @method #_execute
     */
  }
  /**
   * Checks whether the operation's parameters are correct and the operation can be correctly executed. Throws
   * an error if operation is not valid.
   *
   * @protected
   * @method #_validate
   */


  Object(createClass["a" /* default */])(Operation, [{
    key: "_validate",
    value: function _validate() {}
    /**
     * Custom toJSON method to solve child-parent circular dependencies.
     *
     * @method #toJSON
     * @returns {Object} Clone of this object with the operation property replaced with string.
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      // This method creates only a shallow copy, all nested objects should be defined separately.
      // See https://github.com/ckeditor/ckeditor5-engine/issues/1477.
      var json = Object.assign({}, this);
      json.__className = this.constructor.className; // Remove reference to the parent `Batch` to avoid circular dependencies.

      delete json.batch; // Only document operations are shared with other clients so it is not necessary to keep this information.

      delete json.isDocumentOperation;
      return json;
    }
    /**
     * Name of the operation class used for serialization.
     *
     * @type {String}
     */

  }], [{
    key: "fromJSON",

    /**
     * Creates Operation object from deserilized object, i.e. from parsed JSON string.
     *
     * @param {Object} json Deserialized JSON object.
     * @param {module:engine/model/document~Document} doc Document on which this operation will be applied.
     * @returns {module:engine/model/operation/operation~Operation}
     */
    value: function fromJSON(json) {
      return new this(json.baseVersion);
    } // @if CK_DEBUG_ENGINE // log() {
    // @if CK_DEBUG_ENGINE // 	console.log( this.toString() );
    // @if CK_DEBUG_ENGINE // }

  }, {
    key: "className",
    get: function get() {
      return 'Operation';
    }
  }]);

  return Operation;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/documentfragment.js
















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module module:engine/model/documentfragment
 */




 // @if CK_DEBUG_ENGINE // const { stringifyMap } = require( '../dev-utils/utils' );

/**
 * DocumentFragment represents a part of model which does not have a common root but it's top-level nodes
 * can be seen as siblings. In other words, it is a detached part of model tree, without a root.
 *
 * DocumentFragment has own {@link module:engine/model/markercollection~MarkerCollection}. Markers from this collection
 * will be set to the {@link module:engine/model/model~Model#markers model markers} by a
 * {@link module:engine/model/writer~Writer#insert} function.
 */

var model_documentfragment_DocumentFragment = /*#__PURE__*/function () {
  /**
   * Creates an empty `DocumentFragment`.
   *
   * **Note:** Constructor of this class shouldn't be used directly in the code.
   * Use the {@link module:engine/model/writer~Writer#createDocumentFragment} method instead.
   *
   * @protected
   * @param {module:engine/model/node~Node|Iterable.<module:engine/model/node~Node>} [children]
   * Nodes to be contained inside the `DocumentFragment`.
   */
  function DocumentFragment(children) {
    Object(classCallCheck["a" /* default */])(this, DocumentFragment);

    /**
     * DocumentFragment static markers map. This is a list of names and {@link module:engine/model/range~Range ranges}
     * which will be set as Markers to {@link module:engine/model/model~Model#markers model markers collection}
     * when DocumentFragment will be inserted to the document.
     *
     * @readonly
     * @member {Map<String,module:engine/model/range~Range>} module:engine/model/documentfragment~DocumentFragment#markers
     */
    this.markers = new Map();
    /**
     * List of nodes contained inside the document fragment.
     *
     * @private
     * @member {module:engine/model/nodelist~NodeList} module:engine/model/documentfragment~DocumentFragment#_children
     */

    this._children = new nodelist_NodeList();

    if (children) {
      this._insertChild(0, children);
    }
  }
  /**
   * Returns an iterator that iterates over all nodes contained inside this document fragment.
   *
   * @returns {Iterable.<module:engine/model/node~Node>}
   */


  Object(createClass["a" /* default */])(DocumentFragment, [{
    key: Symbol.iterator,
    value: function value() {
      return this.getChildren();
    }
    /**
     * Number of this document fragment's children.
     *
     * @readonly
     * @type {Number}
     */

  }, {
    key: "is",

    /**
     * Checks whether this object is of the given type.
     *
     *		docFrag.is( 'documentFragment' ); // -> true
     *		docFrag.is( 'model:documentFragment' ); // -> true
     *
     *		docFrag.is( 'view:documentFragment' ); // -> false
     *		docFrag.is( 'element' ); // -> false
     *		docFrag.is( 'node' ); // -> false
     *
     * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.
     *
     * @param {String} type
     * @returns {Boolean}
     */
    value: function is(type) {
      return type === 'documentFragment' || type === 'model:documentFragment';
    }
    /**
     * Gets the child at the given index. Returns `null` if incorrect index was passed.
     *
     * @param {Number} index Index of child.
     * @returns {module:engine/model/node~Node|null} Child node.
     */

  }, {
    key: "getChild",
    value: function getChild(index) {
      return this._children.getNode(index);
    }
    /**
     * Returns an iterator that iterates over all of this document fragment's children.
     *
     * @returns {Iterable.<module:engine/model/node~Node>}
     */

  }, {
    key: "getChildren",
    value: function getChildren() {
      return this._children[Symbol.iterator]();
    }
    /**
     * Returns an index of the given child node. Returns `null` if given node is not a child of this document fragment.
     *
     * @param {module:engine/model/node~Node} node Child node to look for.
     * @returns {Number|null} Child node's index.
     */

  }, {
    key: "getChildIndex",
    value: function getChildIndex(node) {
      return this._children.getNodeIndex(node);
    }
    /**
     * Returns the starting offset of given child. Starting offset is equal to the sum of
     * {@link module:engine/model/node~Node#offsetSize offset sizes} of all node's siblings that are before it. Returns `null` if
     * given node is not a child of this document fragment.
     *
     * @param {module:engine/model/node~Node} node Child node to look for.
     * @returns {Number|null} Child node's starting offset.
     */

  }, {
    key: "getChildStartOffset",
    value: function getChildStartOffset(node) {
      return this._children.getNodeStartOffset(node);
    }
    /**
     * Returns path to a `DocumentFragment`, which is an empty array. Added for compatibility reasons.
     *
     * @returns {Array}
     */

  }, {
    key: "getPath",
    value: function getPath() {
      return [];
    }
    /**
     * Returns a descendant node by its path relative to this element.
     *
     *		// <this>a<b>c</b></this>
     *		this.getNodeByPath( [ 0 ] );     // -> "a"
     *		this.getNodeByPath( [ 1 ] );     // -> <b>
     *		this.getNodeByPath( [ 1, 0 ] );  // -> "c"
     *
     * @param {Array.<Number>} relativePath Path of the node to find, relative to this element.
     * @returns {module:engine/model/node~Node|module:engine/model/documentfragment~DocumentFragment}
     */

  }, {
    key: "getNodeByPath",
    value: function getNodeByPath(relativePath) {
      var node = this; // eslint-disable-line consistent-this

      var _iterator = _createForOfIteratorHelper(relativePath),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var index = _step.value;
          node = node.getChild(node.offsetToIndex(index));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return node;
    }
    /**
     * Converts offset "position" to index "position".
     *
     * Returns index of a node that occupies given offset. If given offset is too low, returns `0`. If given offset is
     * too high, returns index after last child}.
     *
     *		const textNode = new Text( 'foo' );
     *		const pElement = new Element( 'p' );
     *		const docFrag = new DocumentFragment( [ textNode, pElement ] );
     *		docFrag.offsetToIndex( -1 ); // Returns 0, because offset is too low.
     *		docFrag.offsetToIndex( 0 ); // Returns 0, because offset 0 is taken by `textNode` which is at index 0.
     *		docFrag.offsetToIndex( 1 ); // Returns 0, because `textNode` has `offsetSize` equal to 3, so it occupies offset 1 too.
     *		docFrag.offsetToIndex( 2 ); // Returns 0.
     *		docFrag.offsetToIndex( 3 ); // Returns 1.
     *		docFrag.offsetToIndex( 4 ); // Returns 2. There are no nodes at offset 4, so last available index is returned.
     *
     * @param {Number} offset Offset to look for.
     * @returns {Number} Index of a node that occupies given offset.
     */

  }, {
    key: "offsetToIndex",
    value: function offsetToIndex(offset) {
      return this._children.offsetToIndex(offset);
    }
    /**
     * Converts `DocumentFragment` instance to plain object and returns it.
     * Takes care of converting all of this document fragment's children.
     *
     * @returns {Object} `DocumentFragment` instance converted to plain object.
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = [];

      var _iterator2 = _createForOfIteratorHelper(this._children),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var node = _step2.value;
          json.push(node.toJSON());
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return json;
    }
    /**
     * Creates a `DocumentFragment` instance from given plain object (i.e. parsed JSON string).
     * Converts `DocumentFragment` children to proper nodes.
     *
     * @param {Object} json Plain object to be converted to `DocumentFragment`.
     * @returns {module:engine/model/documentfragment~DocumentFragment} `DocumentFragment` instance created using given plain object.
     */

  }, {
    key: "_appendChild",

    /**
     * {@link #_insertChild Inserts} one or more nodes at the end of this document fragment.
     *
     * @protected
     * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.
     */
    value: function _appendChild(items) {
      this._insertChild(this.childCount, items);
    }
    /**
     * Inserts one or more nodes at the given index and sets {@link module:engine/model/node~Node#parent parent} of these nodes
     * to this document fragment.
     *
     * @protected
     * @param {Number} index Index at which nodes should be inserted.
     * @param {module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>} items Items to be inserted.
     */

  }, {
    key: "_insertChild",
    value: function _insertChild(index, items) {
      var nodes = model_documentfragment_normalize(items);

      var _iterator3 = _createForOfIteratorHelper(nodes),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var node = _step3.value;

          // If node that is being added to this element is already inside another element, first remove it from the old parent.
          if (node.parent !== null) {
            node._remove();
          }

          node.parent = this;
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this._children._insertNodes(index, nodes);
    }
    /**
     * Removes one or more nodes starting at the given index
     * and sets {@link module:engine/model/node~Node#parent parent} of these nodes to `null`.
     *
     * @protected
     * @param {Number} index Index of the first node to remove.
     * @param {Number} [howMany=1] Number of nodes to remove.
     * @returns {Array.<module:engine/model/node~Node>} Array containing removed nodes.
     */

  }, {
    key: "_removeChildren",
    value: function _removeChildren(index) {
      var howMany = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      var nodes = this._children._removeNodes(index, howMany);

      var _iterator4 = _createForOfIteratorHelper(nodes),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var node = _step4.value;
          node.parent = null;
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      return nodes;
    } // @if CK_DEBUG_ENGINE // toString() {
    // @if CK_DEBUG_ENGINE // 	return 'documentFragment';
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // log() {
    // @if CK_DEBUG_ENGINE // 	console.log( 'ModelDocumentFragment: ' + this );
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // printTree() {
    // @if CK_DEBUG_ENGINE //	let string = 'ModelDocumentFragment: [';
    // @if CK_DEBUG_ENGINE //	for ( const child of this.getChildren() ) {
    // @if CK_DEBUG_ENGINE //		string += '\n';
    // @if CK_DEBUG_ENGINE //		if ( child.is( 'text' ) ) {
    // @if CK_DEBUG_ENGINE //			const textAttrs = stringifyMap( child._attrs );
    // @if CK_DEBUG_ENGINE //			string += '\t'.repeat( 1 );
    // @if CK_DEBUG_ENGINE //			if ( textAttrs !== '' ) {
    // @if CK_DEBUG_ENGINE //				string += `<$text${ textAttrs }>` + child.data + '</$text>';
    // @if CK_DEBUG_ENGINE //			} else {
    // @if CK_DEBUG_ENGINE //				string += child.data;
    // @if CK_DEBUG_ENGINE //			}
    // @if CK_DEBUG_ENGINE //		} else {
    // @if CK_DEBUG_ENGINE //			string += child.printTree( 1 );
    // @if CK_DEBUG_ENGINE //		}
    // @if CK_DEBUG_ENGINE //	}
    // @if CK_DEBUG_ENGINE //	string += '\n]';
    // @if CK_DEBUG_ENGINE //	return string;
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // logTree() {
    // @if CK_DEBUG_ENGINE // 	console.log( this.printTree() );
    // @if CK_DEBUG_ENGINE // }

  }, {
    key: "childCount",
    get: function get() {
      return this._children.length;
    }
    /**
     * Sum of {@link module:engine/model/node~Node#offsetSize offset sizes} of all of this document fragment's children.
     *
     * @readonly
     * @type {Number}
     */

  }, {
    key: "maxOffset",
    get: function get() {
      return this._children.maxOffset;
    }
    /**
     * Is `true` if there are no nodes inside this document fragment, `false` otherwise.
     *
     * @readonly
     * @type {Boolean}
     */

  }, {
    key: "isEmpty",
    get: function get() {
      return this.childCount === 0;
    }
    /**
     * Artificial root of `DocumentFragment`. Returns itself. Added for compatibility reasons.
     *
     * @readonly
     * @type {module:engine/model/documentfragment~DocumentFragment}
     */

  }, {
    key: "root",
    get: function get() {
      return this;
    }
    /**
     * Artificial parent of `DocumentFragment`. Returns `null`. Added for compatibility reasons.
     *
     * @readonly
     * @type {null}
     */

  }, {
    key: "parent",
    get: function get() {
      return null;
    }
  }], [{
    key: "fromJSON",
    value: function fromJSON(json) {
      var children = [];

      var _iterator5 = _createForOfIteratorHelper(json),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var child = _step5.value;

          if (child.name) {
            // If child has name property, it is an Element.
            children.push(model_element_Element.fromJSON(child));
          } else {
            // Otherwise, it is a Text node.
            children.push(model_text_Text.fromJSON(child));
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return new DocumentFragment(children);
    }
  }]);

  return DocumentFragment;
}(); // Converts strings to Text and non-iterables to arrays.
//
// @param {String|module:engine/model/item~Item|Iterable.<module:engine/model/item~Item>}
// @returns {Iterable.<module:engine/model/node~Node>}




function model_documentfragment_normalize(nodes) {
  // Separate condition because string is iterable.
  if (typeof nodes == 'string') {
    return [new model_text_Text(nodes)];
  }

  if (!isIterable(nodes)) {
    nodes = [nodes];
  } // Array.from to enable .map() on non-arrays.


  return Array.from(nodes).map(function (node) {
    if (typeof node == 'string') {
      return new model_text_Text(node);
    }

    if (node instanceof model_textproxy_TextProxy) {
      return new model_text_Text(node.data, node.getAttributes());
    }

    return node;
  });
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/operation/utils.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/operation/utils
 */







/**
 * Contains functions used for composing model tree by {@link module:engine/model/operation/operation~Operation operations}.
 * Those functions are built on top of {@link module:engine/model/node~Node node}, and it's child classes', APIs.
 *
 * @protected
 * @namespace utils
 */

/**
 * Inserts given nodes at given position.
 *
 * @protected
 * @function module:engine/model/operation/utils~utils.insert
 * @param {module:engine/model/position~Position} position Position at which nodes should be inserted.
 * @param {module:engine/model/node~NodeSet} nodes Nodes to insert.
 * @returns {module:engine/model/range~Range} Range spanning over inserted elements.
 */

function utils_insert(position, nodes) {
  nodes = _normalizeNodes(nodes); // We have to count offset before inserting nodes because they can get merged and we would get wrong offsets.

  var offset = nodes.reduce(function (sum, node) {
    return sum + node.offsetSize;
  }, 0);
  var parent = position.parent; // Insertion might be in a text node, we should split it if that's the case.

  _splitNodeAtPosition(position);

  var index = position.index; // Insert nodes at given index. After splitting we have a proper index and insertion is between nodes,
  // using basic `Element` API.

  parent._insertChild(index, nodes); // Merge text nodes, if possible. Merging is needed only at points where inserted nodes "touch" "old" nodes.


  _mergeNodesAtIndex(parent, index + nodes.length);

  _mergeNodesAtIndex(parent, index);

  return new model_range_Range(position, position.getShiftedBy(offset));
}
/**
 * Removed nodes in given range. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.
 *
 * @protected
 * @function module:engine/model/operation/utils~utils._remove
 * @param {module:engine/model/range~Range} range Range containing nodes to remove.
 * @returns {Array.<module:engine/model/node~Node>}
 */

function _remove(range) {
  if (!range.isFlat) {
    /**
     * Trying to remove a range which starts and ends in different element.
     *
     * @error operation-utils-remove-range-not-flat
     */
    throw new ckeditorerror["b" /* default */]('operation-utils-remove-range-not-flat: ' + 'Trying to remove a range which starts and ends in different element.', this);
  }

  var parent = range.start.parent; // Range may be inside text nodes, we have to split them if that's the case.

  _splitNodeAtPosition(range.start);

  _splitNodeAtPosition(range.end); // Remove the text nodes using basic `Element` API.


  var removed = parent._removeChildren(range.start.index, range.end.index - range.start.index); // Merge text nodes, if possible. After some nodes were removed, node before and after removed range will be
  // touching at the position equal to the removed range beginning. We check merging possibility there.


  _mergeNodesAtIndex(parent, range.start.index);

  return removed;
}
/**
 * Moves nodes in given range to given target position. Only {@link module:engine/model/range~Range#isFlat flat} ranges are accepted.
 *
 * @protected
 * @function module:engine/model/operation/utils~utils.move
 * @param {module:engine/model/range~Range} sourceRange Range containing nodes to move.
 * @param {module:engine/model/position~Position} targetPosition Position to which nodes should be moved.
 * @returns {module:engine/model/range~Range} Range containing moved nodes.
 */

function _move(sourceRange, targetPosition) {
  if (!sourceRange.isFlat) {
    /**
     * Trying to move a range which starts and ends in different element.
     *
     * @error operation-utils-move-range-not-flat
     */
    throw new ckeditorerror["b" /* default */]('operation-utils-move-range-not-flat: ' + 'Trying to move a range which starts and ends in different element.', this);
  }

  var nodes = _remove(sourceRange); // We have to fix `targetPosition` because model changed after nodes from `sourceRange` got removed and
  // that change might have an impact on `targetPosition`.


  targetPosition = targetPosition._getTransformedByDeletion(sourceRange.start, sourceRange.end.offset - sourceRange.start.offset);
  return utils_insert(targetPosition, nodes);
}
/**
 * Sets given attribute on nodes in given range. The attributes are only set on top-level nodes of the range, not on its children.
 *
 * @protected
 * @function module:engine/model/operation/utils~utils._setAttribute
 * @param {module:engine/model/range~Range} range Range containing nodes that should have the attribute set. Must be a flat range.
 * @param {String} key Key of attribute to set.
 * @param {*} value Attribute value.
 */

function utils_setAttribute(range, key, value) {
  // Range might start or end in text nodes, so we have to split them.
  _splitNodeAtPosition(range.start);

  _splitNodeAtPosition(range.end); // Iterate over all items in the range.


  var _iterator = _createForOfIteratorHelper(range.getItems({
    shallow: true
  })),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var item = _step.value;
      // Iterator will return `TextProxy` instances but we know that those text proxies will
      // always represent full text nodes (this is guaranteed thanks to splitting we did before).
      // So, we can operate on those text proxies' text nodes.
      var node = item.is('textProxy') ? item.textNode : item;

      if (value !== null) {
        node._setAttribute(key, value);
      } else {
        node._removeAttribute(key);
      } // After attributes changing it may happen that some text nodes can be merged. Try to merge with previous node.


      _mergeNodesAtIndex(node.parent, node.index);
    } // Try to merge last changed node with it's previous sibling (not covered by the loop above).

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  _mergeNodesAtIndex(range.end.parent, range.end.index);
}
/**
 * Normalizes given object or an array of objects to an array of {@link module:engine/model/node~Node nodes}. See
 * {@link module:engine/model/node~NodeSet NodeSet} for details on how normalization is performed.
 *
 * @protected
 * @function module:engine/model/operation/utils~utils.normalizeNodes
 * @param {module:engine/model/node~NodeSet} nodes Objects to normalize.
 * @returns {Array.<module:engine/model/node~Node>} Normalized nodes.
 */

function _normalizeNodes(nodes) {
  var normalized = [];

  if (!(nodes instanceof Array)) {
    nodes = [nodes];
  } // Convert instances of classes other than Node.


  for (var i = 0; i < nodes.length; i++) {
    if (typeof nodes[i] == 'string') {
      normalized.push(new model_text_Text(nodes[i]));
    } else if (nodes[i] instanceof model_textproxy_TextProxy) {
      normalized.push(new model_text_Text(nodes[i].data, nodes[i].getAttributes()));
    } else if (nodes[i] instanceof model_documentfragment_DocumentFragment || nodes[i] instanceof nodelist_NodeList) {
      var _iterator2 = _createForOfIteratorHelper(nodes[i]),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var child = _step2.value;
          normalized.push(child);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    } else if (nodes[i] instanceof model_node_Node) {
      normalized.push(nodes[i]);
    } // Skip unrecognized type.

  } // Merge text nodes.


  for (var _i = 1; _i < normalized.length; _i++) {
    var node = normalized[_i];
    var prev = normalized[_i - 1];

    if (node instanceof model_text_Text && prev instanceof model_text_Text && _haveSameAttributes(node, prev)) {
      // Doing this instead changing `prev.data` because `data` is readonly.
      normalized.splice(_i - 1, 2, new model_text_Text(prev.data + node.data, prev.getAttributes()));
      _i--;
    }
  }

  return normalized;
} // Checks if nodes before and after given index in given element are {@link module:engine/model/text~Text text nodes} and
// merges them into one node if they have same attributes.
//
// Merging is done by removing two text nodes and inserting a new text node containing data from both merged text nodes.
//
// @private
// @param {module:engine/model/element~Element} element Parent element of nodes to merge.
// @param {Number} index Index between nodes to merge.

function _mergeNodesAtIndex(element, index) {
  var nodeBefore = element.getChild(index - 1);
  var nodeAfter = element.getChild(index); // Check if both of those nodes are text objects with same attributes.

  if (nodeBefore && nodeAfter && nodeBefore.is('text') && nodeAfter.is('text') && _haveSameAttributes(nodeBefore, nodeAfter)) {
    // Append text of text node after index to the before one.
    var mergedNode = new model_text_Text(nodeBefore.data + nodeAfter.data, nodeBefore.getAttributes()); // Remove separate text nodes.

    element._removeChildren(index - 1, 2); // Insert merged text node.


    element._insertChild(index - 1, mergedNode);
  }
} // Checks if given position is in a text node, and if so, splits the text node in two text nodes, each of them
// containing a part of original text node.
//
// @private
// @param {module:engine/model/position~Position} position Position at which node should be split.


function _splitNodeAtPosition(position) {
  var textNode = position.textNode;
  var element = position.parent;

  if (textNode) {
    var offsetDiff = position.offset - textNode.startOffset;
    var index = textNode.index;

    element._removeChildren(index, 1);

    var firstPart = new model_text_Text(textNode.data.substr(0, offsetDiff), textNode.getAttributes());
    var secondPart = new model_text_Text(textNode.data.substr(offsetDiff), textNode.getAttributes());

    element._insertChild(index, [firstPart, secondPart]);
  }
} // Checks whether two given nodes have same attributes.
//
// @private
// @param {module:engine/model/node~Node} nodeA Node to check.
// @param {module:engine/model/node~Node} nodeB Node to check.
// @returns {Boolean} `true` if nodes have same attributes, `false` otherwise.


function _haveSameAttributes(nodeA, nodeB) {
  var iteratorA = nodeA.getAttributes();
  var iteratorB = nodeB.getAttributes();

  var _iterator3 = _createForOfIteratorHelper(iteratorA),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var attr = _step3.value;

      if (attr[1] !== nodeB.getAttribute(attr[0])) {
        return false;
      }

      iteratorB.next();
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return iteratorB.next().done;
}
/**
 * Value that can be normalized to an array of {@link module:engine/model/node~Node nodes}.
 *
 * Non-arrays are normalized as follows:
 * * {@link module:engine/model/node~Node Node} is left as is,
 * * {@link module:engine/model/textproxy~TextProxy TextProxy} and `String` are normalized to {@link module:engine/model/text~Text Text},
 * * {@link module:engine/model/nodelist~NodeList NodeList} is normalized to an array containing all nodes that are in that node list,
 * * {@link module:engine/model/documentfragment~DocumentFragment DocumentFragment} is normalized to an array containing all of it's
 * * children.
 *
 * Arrays are processed item by item like non-array values and flattened to one array. Normalization always results in
 * a flat array of {@link module:engine/model/node~Node nodes}. Consecutive text nodes (or items normalized to text nodes) will be
 * merged if they have same attributes.
 *
 * @typedef {module:engine/model/node~Node|module:engine/model/textproxy~TextProxy|String|
 * module:engine/model/nodelist~NodeList|module:engine/model/documentfragment~DocumentFragment|Iterable}
 * module:engine/model/node~NodeSet
 */
// CONCATENATED MODULE: ./node_modules/lodash-es/isEqual.js


/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual_isEqual(value, other) {
  return _baseIsEqual(value, other);
}

/* harmony default export */ var lodash_es_isEqual = (isEqual_isEqual);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/operation/attributeoperation.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/operation/attributeoperation
 */





/**
 * Operation to change nodes' attribute.
 *
 * Using this class you can add, remove or change value of the attribute.
 *
 * @extends module:engine/model/operation/operation~Operation
 */

var attributeoperation_AttributeOperation = /*#__PURE__*/function (_Operation) {
  Object(inherits["a" /* default */])(AttributeOperation, _Operation);

  var _super = Object(createSuper["a" /* default */])(AttributeOperation);

  /**
   * Creates an operation that changes, removes or adds attributes.
   *
   * If only `newValue` is set, attribute will be added on a node. Note that all nodes in operation's range must not
   * have an attribute with the same key as the added attribute.
   *
   * If only `oldValue` is set, then attribute with given key will be removed. Note that all nodes in operation's range
   * must have an attribute with that key added.
   *
   * If both `newValue` and `oldValue` are set, then the operation will change the attribute value. Note that all nodes in
   * operation's ranges must already have an attribute with given key and `oldValue` as value
   *
   * @param {module:engine/model/range~Range} range Range on which the operation should be applied. Must be a flat range.
   * @param {String} key Key of an attribute to change or remove.
   * @param {*} oldValue Old value of the attribute with given key or `null`, if attribute was not set before.
   * @param {*} newValue New value of the attribute with given key or `null`, if operation should remove attribute.
   * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  function AttributeOperation(range, key, oldValue, newValue, baseVersion) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, AttributeOperation);

    _this = _super.call(this, baseVersion);
    /**
     * Range on which operation should be applied.
     *
     * @readonly
     * @member {module:engine/model/range~Range}
     */

    _this.range = range.clone();
    /**
     * Key of an attribute to change or remove.
     *
     * @readonly
     * @member {String}
     */

    _this.key = key;
    /**
     * Old value of the attribute with given key or `null`, if attribute was not set before.
     *
     * @readonly
     * @member {*}
     */

    _this.oldValue = oldValue === undefined ? null : oldValue;
    /**
     * New value of the attribute with given key or `null`, if operation should remove attribute.
     *
     * @readonly
     * @member {*}
     */

    _this.newValue = newValue === undefined ? null : newValue;
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(AttributeOperation, [{
    key: "clone",

    /**
     * Creates and returns an operation that has the same parameters as this operation.
     *
     * @returns {module:engine/model/operation/attributeoperation~AttributeOperation} Clone of this operation.
     */
    value: function clone() {
      return new AttributeOperation(this.range, this.key, this.oldValue, this.newValue, this.baseVersion);
    }
    /**
     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
     *
     * @returns {module:engine/model/operation/attributeoperation~AttributeOperation}
     */

  }, {
    key: "getReversed",
    value: function getReversed() {
      return new AttributeOperation(this.range, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = get_get(Object(getPrototypeOf["a" /* default */])(AttributeOperation.prototype), "toJSON", this).call(this);

      json.range = this.range.toJSON();
      return json;
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "_validate",
    value: function _validate() {
      if (!this.range.isFlat) {
        /**
         * The range to change is not flat.
         *
         * @error attribute-operation-range-not-flat
         */
        throw new ckeditorerror["b" /* default */]('attribute-operation-range-not-flat: The range to change is not flat.', this);
      }

      var _iterator = _createForOfIteratorHelper(this.range.getItems({
        shallow: true
      })),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var item = _step.value;

          if (this.oldValue !== null && !lodash_es_isEqual(item.getAttribute(this.key), this.oldValue)) {
            /**
             * Changed node has different attribute value than operation's old attribute value.
             *
             * @error attribute-operation-wrong-old-value
             * @param {module:engine/model/item~Item} item
             * @param {String} key
             * @param {*} value
             */
            throw new ckeditorerror["b" /* default */]('attribute-operation-wrong-old-value: Changed node has different attribute value than operation\'s ' + 'old attribute value.', this, {
              item: item,
              key: this.key,
              value: this.oldValue
            });
          }

          if (this.oldValue === null && this.newValue !== null && item.hasAttribute(this.key)) {
            /**
             * The attribute with given key already exists for the given node.
             *
             * @error attribute-operation-attribute-exists
             * @param {module:engine/model/node~Node} node
             * @param {String} key
             */
            throw new ckeditorerror["b" /* default */]('attribute-operation-attribute-exists: The attribute with given key already exists.', this, {
              node: item,
              key: this.key
            });
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "_execute",
    value: function _execute() {
      // If value to set is same as old value, don't do anything.
      if (!lodash_es_isEqual(this.oldValue, this.newValue)) {
        // Execution.
        utils_setAttribute(this.range, this.key, this.newValue);
      }
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "type",
    get: function get() {
      if (this.oldValue === null) {
        return 'addAttribute';
      } else if (this.newValue === null) {
        return 'removeAttribute';
      } else {
        return 'changeAttribute';
      }
    }
  }], [{
    key: "fromJSON",

    /**
     * Creates `AttributeOperation` object from deserilized object, i.e. from parsed JSON string.
     *
     * @param {Object} json Deserialized JSON object.
     * @param {module:engine/model/document~Document} document Document on which this operation will be applied.
     * @returns {module:engine/model/operation/attributeoperation~AttributeOperation}
     */
    value: function fromJSON(json, document) {
      return new AttributeOperation(model_range_Range.fromJSON(json.range, document), json.key, json.oldValue, json.newValue, json.baseVersion);
    } // @if CK_DEBUG_ENGINE // toString() {
    // @if CK_DEBUG_ENGINE // 	return `AttributeOperation( ${ this.baseVersion } ): ` +
    // @if CK_DEBUG_ENGINE //		`"${ this.key }": ${ JSON.stringify( this.oldValue ) }` +
    // @if CK_DEBUG_ENGINE //		` -> ${ JSON.stringify( this.newValue ) }, ${ this.range }`;
    // @if CK_DEBUG_ENGINE // }

  }, {
    key: "className",
    get: function get() {
      return 'AttributeOperation';
    }
  }]);

  return AttributeOperation;
}(operation_Operation);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/operation/detachoperation.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/operation/detachoperation
 */



 // @if CK_DEBUG_ENGINE // const ModelRange = require( '../range' ).default;

/**
 * Operation to permanently remove node from detached root.
 * Note this operation is only a local operation and won't be send to the other clients.
 *
 * @extends module:engine/model/operation/operation~Operation
 */

var detachoperation_DetachOperation = /*#__PURE__*/function (_Operation) {
  Object(inherits["a" /* default */])(DetachOperation, _Operation);

  var _super = Object(createSuper["a" /* default */])(DetachOperation);

  /**
   * Creates an insert operation.
   *
   * @param {module:engine/model/position~Position} sourcePosition
   * Position before the first {@link module:engine/model/item~Item model item} to move.
   * @param {Number} howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at
   * `sourcePosition` with offset shifted by `howMany`.
   */
  function DetachOperation(sourcePosition, howMany) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, DetachOperation);

    _this = _super.call(this, null);
    /**
     * Position before the first {@link module:engine/model/item~Item model item} to detach.
     *
     * @member {module:engine/model/position~Position} #sourcePosition
     */

    _this.sourcePosition = sourcePosition.clone();
    /**
     * Offset size of moved range.
     *
     * @member {Number} #howMany
     */

    _this.howMany = howMany;
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(DetachOperation, [{
    key: "toJSON",

    /**
     * @inheritDoc
     */
    value: function toJSON() {
      var json = get_get(Object(getPrototypeOf["a" /* default */])(DetachOperation.prototype), "toJSON", this).call(this);

      json.sourcePosition = this.sourcePosition.toJSON();
      return json;
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "_validate",
    value: function _validate() {
      if (this.sourcePosition.root.document) {
        /**
         * Cannot detach document node.
         *
         * @error detach-operation-on-document-node
         */
        throw new ckeditorerror["b" /* default */]('detach-operation-on-document-node: Cannot detach document node.', this);
      }
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "_execute",
    value: function _execute() {
      _remove(model_range_Range._createFromPositionAndShift(this.sourcePosition, this.howMany));
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "type",
    get: function get() {
      return 'detach';
    }
  }], [{
    key: "className",
    get: function get() {
      return 'DetachOperation';
    } // @if CK_DEBUG_ENGINE // toString() {
    // @if CK_DEBUG_ENGINE // const range = ModelRange._createFromPositionAndShift( this.sourcePosition, this.howMany );
    // @if CK_DEBUG_ENGINE //	const nodes = Array.from( range.getItems() );
    // @if CK_DEBUG_ENGINE //	const nodeString = nodes.length > 1 ? `[ ${ nodes.length } ]` : nodes[ 0 ];
    // @if CK_DEBUG_ENGINE //	return `DetachOperation( ${ this.baseVersion } ): ${ nodeString } -> ${ range }`;
    // @if CK_DEBUG_ENGINE // }

  }]);

  return DetachOperation;
}(operation_Operation);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/operation/moveoperation.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/operation/moveoperation
 */





 // @if CK_DEBUG_ENGINE // const ModelRange = require( '../range' ).default;

/**
 * Operation to move a range of {@link module:engine/model/item~Item model items}
 * to given {@link module:engine/model/position~Position target position}.
 *
 * @extends module:engine/model/operation/operation~Operation
 */

var moveoperation_MoveOperation = /*#__PURE__*/function (_Operation) {
  Object(inherits["a" /* default */])(MoveOperation, _Operation);

  var _super = Object(createSuper["a" /* default */])(MoveOperation);

  /**
   * Creates a move operation.
   *
   * @param {module:engine/model/position~Position} sourcePosition
   * Position before the first {@link module:engine/model/item~Item model item} to move.
   * @param {Number} howMany Offset size of moved range. Moved range will start from `sourcePosition` and end at
   * `sourcePosition` with offset shifted by `howMany`.
   * @param {module:engine/model/position~Position} targetPosition Position at which moved nodes will be inserted.
   * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  function MoveOperation(sourcePosition, howMany, targetPosition, baseVersion) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, MoveOperation);

    _this = _super.call(this, baseVersion);
    /**
     * Position before the first {@link module:engine/model/item~Item model item} to move.
     *
     * @member {module:engine/model/position~Position} module:engine/model/operation/moveoperation~MoveOperation#sourcePosition
     */

    _this.sourcePosition = sourcePosition.clone(); // `'toNext'` because `sourcePosition` is a bit like a start of the moved range.

    _this.sourcePosition.stickiness = 'toNext';
    /**
     * Offset size of moved range.
     *
     * @member {Number} module:engine/model/operation/moveoperation~MoveOperation#howMany
     */

    _this.howMany = howMany;
    /**
     * Position at which moved nodes will be inserted.
     *
     * @member {module:engine/model/position~Position} module:engine/model/operation/moveoperation~MoveOperation#targetPosition
     */

    _this.targetPosition = targetPosition.clone();
    _this.targetPosition.stickiness = 'toNone';
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(MoveOperation, [{
    key: "clone",

    /**
     * Creates and returns an operation that has the same parameters as this operation.
     *
     * @returns {module:engine/model/operation/moveoperation~MoveOperation} Clone of this operation.
     */
    value: function clone() {
      return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.baseVersion);
    }
    /**
     * Returns the start position of the moved range after it got moved. This may be different than
     * {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition} in some cases, i.e. when a range is moved
     * inside the same parent but {@link module:engine/model/operation/moveoperation~MoveOperation#targetPosition targetPosition}
     * is after {@link module:engine/model/operation/moveoperation~MoveOperation#sourcePosition sourcePosition}.
     *
     *		 vv              vv
     *		abcdefg ===> adefbcg
     *		     ^          ^
     *		     targetPos	movedRangeStart
     *		     offset 6	offset 4
     *
     * @returns {module:engine/model/position~Position}
     */

  }, {
    key: "getMovedRangeStart",
    value: function getMovedRangeStart() {
      return this.targetPosition._getTransformedByDeletion(this.sourcePosition, this.howMany);
    }
    /**
     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
     *
     * @returns {module:engine/model/operation/moveoperation~MoveOperation}
     */

  }, {
    key: "getReversed",
    value: function getReversed() {
      var newTargetPosition = this.sourcePosition._getTransformedByInsertion(this.targetPosition, this.howMany);

      return new this.constructor(this.getMovedRangeStart(), this.howMany, newTargetPosition, this.baseVersion + 1);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "_validate",
    value: function _validate() {
      var sourceElement = this.sourcePosition.parent;
      var targetElement = this.targetPosition.parent;
      var sourceOffset = this.sourcePosition.offset;
      var targetOffset = this.targetPosition.offset; // Validate whether move operation has correct parameters.
      // Validation is pretty complex but move operation is one of the core ways to manipulate the document state.
      // We expect that many errors might be connected with one of scenarios described below.

      if (sourceOffset + this.howMany > sourceElement.maxOffset) {
        /**
         * The nodes which should be moved do not exist.
         *
         * @error move-operation-nodes-do-not-exist
         */
        throw new ckeditorerror["b" /* default */]('move-operation-nodes-do-not-exist: The nodes which should be moved do not exist.', this);
      } else if (sourceElement === targetElement && sourceOffset < targetOffset && targetOffset < sourceOffset + this.howMany) {
        /**
         * Trying to move a range of nodes into the middle of that range.
         *
         * @error move-operation-range-into-itself
         */
        throw new ckeditorerror["b" /* default */]('move-operation-range-into-itself: Trying to move a range of nodes to the inside of that range.', this);
      } else if (this.sourcePosition.root == this.targetPosition.root) {
        if (compareArrays(this.sourcePosition.getParentPath(), this.targetPosition.getParentPath()) == 'prefix') {
          var i = this.sourcePosition.path.length - 1;

          if (this.targetPosition.path[i] >= sourceOffset && this.targetPosition.path[i] < sourceOffset + this.howMany) {
            /**
             * Trying to move a range of nodes into one of nodes from that range.
             *
             * @error move-operation-node-into-itself
             */
            throw new ckeditorerror["b" /* default */]('move-operation-node-into-itself: Trying to move a range of nodes into one of nodes from that range.', this);
          }
        }
      }
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "_execute",
    value: function _execute() {
      _move(model_range_Range._createFromPositionAndShift(this.sourcePosition, this.howMany), this.targetPosition);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = get_get(Object(getPrototypeOf["a" /* default */])(MoveOperation.prototype), "toJSON", this).call(this);

      json.sourcePosition = this.sourcePosition.toJSON();
      json.targetPosition = this.targetPosition.toJSON();
      return json;
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "type",
    get: function get() {
      if (this.targetPosition.root.rootName == '$graveyard') {
        return 'remove';
      } else if (this.sourcePosition.root.rootName == '$graveyard') {
        return 'reinsert';
      }

      return 'move';
    }
  }], [{
    key: "fromJSON",

    /**
     * Creates `MoveOperation` object from deserilized object, i.e. from parsed JSON string.
     *
     * @param {Object} json Deserialized JSON object.
     * @param {module:engine/model/document~Document} document Document on which this operation will be applied.
     * @returns {module:engine/model/operation/moveoperation~MoveOperation}
     */
    value: function fromJSON(json, document) {
      var sourcePosition = model_position_Position.fromJSON(json.sourcePosition, document);
      var targetPosition = model_position_Position.fromJSON(json.targetPosition, document);
      return new this(sourcePosition, json.howMany, targetPosition, json.baseVersion);
    } // @if CK_DEBUG_ENGINE // toString() {
    // @if CK_DEBUG_ENGINE // 	const range = ModelRange._createFromPositionAndShift( this.sourcePosition, this.howMany );
    // @if CK_DEBUG_ENGINE //	return `MoveOperation( ${ this.baseVersion } ): ${ range } -> ${ this.targetPosition }`;
    // @if CK_DEBUG_ENGINE // }

  }, {
    key: "className",
    get: function get() {
      return 'MoveOperation';
    }
  }]);

  return MoveOperation;
}(operation_Operation);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/operation/insertoperation.js












/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/operation/insertoperation
 */








/**
 * Operation to insert one or more nodes at given position in the model.
 *
 * @extends module:engine/model/operation/operation~Operation
 */

var insertoperation_InsertOperation = /*#__PURE__*/function (_Operation) {
  Object(inherits["a" /* default */])(InsertOperation, _Operation);

  var _super = Object(createSuper["a" /* default */])(InsertOperation);

  /**
   * Creates an insert operation.
   *
   * @param {module:engine/model/position~Position} position Position of insertion.
   * @param {module:engine/model/node~NodeSet} nodes The list of nodes to be inserted.
   * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  function InsertOperation(position, nodes, baseVersion) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, InsertOperation);

    _this = _super.call(this, baseVersion);
    /**
     * Position of insertion.
     *
     * @readonly
     * @member {module:engine/model/position~Position} module:engine/model/operation/insertoperation~InsertOperation#position
     */

    _this.position = position.clone();
    _this.position.stickiness = 'toNone';
    /**
     * List of nodes to insert.
     *
     * @readonly
     * @member {module:engine/model/nodelist~NodeList} module:engine/model/operation/insertoperation~InsertOperation#nodeList
     */

    _this.nodes = new nodelist_NodeList(_normalizeNodes(nodes));
    /**
     * Flag deciding how the operation should be transformed. If set to `true`, nodes might get additional attributes
     * during operational transformation. This happens when the operation insertion position is inside of a range
     * where attributes have changed.
     *
     * @member {Boolean} module:engine/model/operation/insertoperation~InsertOperation#shouldReceiveAttributes
     */

    _this.shouldReceiveAttributes = false;
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(InsertOperation, [{
    key: "clone",

    /**
     * Creates and returns an operation that has the same parameters as this operation.
     *
     * @returns {module:engine/model/operation/insertoperation~InsertOperation} Clone of this operation.
     */
    value: function clone() {
      var nodes = new nodelist_NodeList(_toConsumableArray(this.nodes).map(function (node) {
        return node._clone(true);
      }));
      var insert = new InsertOperation(this.position, nodes, this.baseVersion);
      insert.shouldReceiveAttributes = this.shouldReceiveAttributes;
      return insert;
    }
    /**
     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
     *
     * @returns {module:engine/model/operation/moveoperation~MoveOperation}
     */

  }, {
    key: "getReversed",
    value: function getReversed() {
      var graveyard = this.position.root.document.graveyard;
      var gyPosition = new model_position_Position(graveyard, [0]);
      return new moveoperation_MoveOperation(this.position, this.nodes.maxOffset, gyPosition, this.baseVersion + 1);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "_validate",
    value: function _validate() {
      var targetElement = this.position.parent;

      if (!targetElement || targetElement.maxOffset < this.position.offset) {
        /**
         * Insertion position is invalid.
         *
         * @error insert-operation-position-invalid
         */
        throw new ckeditorerror["b" /* default */]('insert-operation-position-invalid: Insertion position is invalid.', this);
      }
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "_execute",
    value: function _execute() {
      // What happens here is that we want original nodes be passed to writer because we want original nodes
      // to be inserted to the model. But in InsertOperation, we want to keep those nodes as they were added
      // to the operation, not modified. For example, text nodes can get merged or cropped while Elements can
      // get children. It is important that InsertOperation has the copy of original nodes in intact state.
      var originalNodes = this.nodes;
      this.nodes = new nodelist_NodeList(_toConsumableArray(originalNodes).map(function (node) {
        return node._clone(true);
      }));

      utils_insert(this.position, originalNodes);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = get_get(Object(getPrototypeOf["a" /* default */])(InsertOperation.prototype), "toJSON", this).call(this);

      json.position = this.position.toJSON();
      json.nodes = this.nodes.toJSON();
      return json;
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "type",
    get: function get() {
      return 'insert';
    }
    /**
     * Total offset size of inserted nodes.
     *
     * @returns {Number}
     */

  }, {
    key: "howMany",
    get: function get() {
      return this.nodes.maxOffset;
    }
  }], [{
    key: "fromJSON",

    /**
     * Creates `InsertOperation` object from deserilized object, i.e. from parsed JSON string.
     *
     * @param {Object} json Deserialized JSON object.
     * @param {module:engine/model/document~Document} document Document on which this operation will be applied.
     * @returns {module:engine/model/operation/insertoperation~InsertOperation}
     */
    value: function fromJSON(json, document) {
      var children = [];

      var _iterator = _createForOfIteratorHelper(json.nodes),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var child = _step.value;

          if (child.name) {
            // If child has name property, it is an Element.
            children.push(model_element_Element.fromJSON(child));
          } else {
            // Otherwise, it is a Text node.
            children.push(model_text_Text.fromJSON(child));
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var insert = new InsertOperation(model_position_Position.fromJSON(json.position, document), children, json.baseVersion);
      insert.shouldReceiveAttributes = json.shouldReceiveAttributes;
      return insert;
    } // @if CK_DEBUG_ENGINE // toString() {
    // @if CK_DEBUG_ENGINE // 	const nodeString = this.nodes.length > 1 ? `[ ${ this.nodes.length } ]` : this.nodes.getNode( 0 );
    // @if CK_DEBUG_ENGINE //	return `InsertOperation( ${ this.baseVersion } ): ${ nodeString } -> ${ this.position }`;
    // @if CK_DEBUG_ENGINE // }

  }, {
    key: "className",
    get: function get() {
      return 'InsertOperation';
    }
  }]);

  return InsertOperation;
}(operation_Operation);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/operation/markeroperation.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/operation/markeroperation
 */


/**
 * @extends module:engine/model/operation/operation~Operation
 */

var markeroperation_MarkerOperation = /*#__PURE__*/function (_Operation) {
  Object(inherits["a" /* default */])(MarkerOperation, _Operation);

  var _super = Object(createSuper["a" /* default */])(MarkerOperation);

  /**
   * @param {String} name Marker name.
   * @param {module:engine/model/range~Range} oldRange Marker range before the change.
   * @param {module:engine/model/range~Range} newRange Marker range after the change.
   * @param {module:engine/model/markercollection~MarkerCollection} markers Marker collection on which change should be executed.
   * @param {Boolean} affectsData Specifies whether the marker operation affects the data produced by the data pipeline
   * (is persisted in the editor's data).
   * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  function MarkerOperation(name, oldRange, newRange, markers, affectsData, baseVersion) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, MarkerOperation);

    _this = _super.call(this, baseVersion);
    /**
     * Marker name.
     *
     * @readonly
     * @member {String}
     */

    _this.name = name;
    /**
     * Marker range before the change.
     *
     * @readonly
     * @member {module:engine/model/range~Range}
     */

    _this.oldRange = oldRange ? oldRange.clone() : null;
    /**
     * Marker range after the change.
     *
     * @readonly
     * @member {module:engine/model/range~Range}
     */

    _this.newRange = newRange ? newRange.clone() : null;
    /**
     * Specifies whether the marker operation affects the data produced by the data pipeline
     * (is persisted in the editor's data).
     *
     * @readonly
     * @member {Boolean}
     */

    _this.affectsData = affectsData;
    /**
     * Marker collection on which change should be executed.
     *
     * @private
     * @member {module:engine/model/markercollection~MarkerCollection}
     */

    _this._markers = markers;
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(MarkerOperation, [{
    key: "clone",

    /**
     * Creates and returns an operation that has the same parameters as this operation.
     *
     * @returns {module:engine/model/operation/markeroperation~MarkerOperation} Clone of this operation.
     */
    value: function clone() {
      return new MarkerOperation(this.name, this.oldRange, this.newRange, this._markers, this.affectsData, this.baseVersion);
    }
    /**
     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
     *
     * @returns {module:engine/model/operation/markeroperation~MarkerOperation}
     */

  }, {
    key: "getReversed",
    value: function getReversed() {
      return new MarkerOperation(this.name, this.newRange, this.oldRange, this._markers, this.affectsData, this.baseVersion + 1);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "_execute",
    value: function _execute() {
      var type = this.newRange ? '_set' : '_remove';

      this._markers[type](this.name, this.newRange, true, this.affectsData);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = get_get(Object(getPrototypeOf["a" /* default */])(MarkerOperation.prototype), "toJSON", this).call(this);

      if (this.oldRange) {
        json.oldRange = this.oldRange.toJSON();
      }

      if (this.newRange) {
        json.newRange = this.newRange.toJSON();
      }

      delete json._markers;
      return json;
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "type",
    get: function get() {
      return 'marker';
    }
  }], [{
    key: "fromJSON",

    /**
     * Creates `MarkerOperation` object from deserialized object, i.e. from parsed JSON string.
     *
     * @param {Object} json Deserialized JSON object.
     * @param {module:engine/model/document~Document} document Document on which this operation will be applied.
     * @returns {module:engine/model/operation/markeroperation~MarkerOperation}
     */
    value: function fromJSON(json, document) {
      return new MarkerOperation(json.name, json.oldRange ? model_range_Range.fromJSON(json.oldRange, document) : null, json.newRange ? model_range_Range.fromJSON(json.newRange, document) : null, document.model.markers, json.affectsData, json.baseVersion);
    } // @if CK_DEBUG_ENGINE // toString() {
    // @if CK_DEBUG_ENGINE // 	return `MarkerOperation( ${ this.baseVersion } ): ` +
    // @if CK_DEBUG_ENGINE //		`"${ this.name }": ${ this.oldRange } -> ${ this.newRange }`;
    // @if CK_DEBUG_ENGINE // }

  }, {
    key: "className",
    get: function get() {
      return 'MarkerOperation';
    }
  }]);

  return MarkerOperation;
}(operation_Operation);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/operation/renameoperation.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/operation/renameoperation
 */




/**
 * Operation to change element's name.
 *
 * Using this class you can change element's name.
 *
 * @extends module:engine/model/operation/operation~Operation
 */

var renameoperation_RenameOperation = /*#__PURE__*/function (_Operation) {
  Object(inherits["a" /* default */])(RenameOperation, _Operation);

  var _super = Object(createSuper["a" /* default */])(RenameOperation);

  /**
   * Creates an operation that changes element's name.
   *
   * @param {module:engine/model/position~Position} position Position before an element to change.
   * @param {String} oldName Current name of the element.
   * @param {String} newName New name for the element.
   * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  function RenameOperation(position, oldName, newName, baseVersion) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, RenameOperation);

    _this = _super.call(this, baseVersion);
    /**
     * Position before an element to change.
     *
     * @member {module:engine/model/position~Position} module:engine/model/operation/renameoperation~RenameOperation#position
     */

    _this.position = position; // This position sticks to the next node because it is a position before the node that we want to change.

    _this.position.stickiness = 'toNext';
    /**
     * Current name of the element.
     *
     * @member {String} module:engine/model/operation/renameoperation~RenameOperation#oldName
     */

    _this.oldName = oldName;
    /**
     * New name for the element.
     *
     * @member {String} module:engine/model/operation/renameoperation~RenameOperation#newName
     */

    _this.newName = newName;
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(RenameOperation, [{
    key: "clone",

    /**
     * Creates and returns an operation that has the same parameters as this operation.
     *
     * @returns {module:engine/model/operation/renameoperation~RenameOperation} Clone of this operation.
     */
    value: function clone() {
      return new RenameOperation(this.position.clone(), this.oldName, this.newName, this.baseVersion);
    }
    /**
     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
     *
     * @returns {module:engine/model/operation/renameoperation~RenameOperation}
     */

  }, {
    key: "getReversed",
    value: function getReversed() {
      return new RenameOperation(this.position.clone(), this.newName, this.oldName, this.baseVersion + 1);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "_validate",
    value: function _validate() {
      var element = this.position.nodeAfter;

      if (!(element instanceof model_element_Element)) {
        /**
         * Given position is invalid or node after it is not instance of Element.
         *
         * @error rename-operation-wrong-position
         */
        throw new ckeditorerror["b" /* default */]('rename-operation-wrong-position: Given position is invalid or node after it is not an instance of Element.', this);
      } else if (element.name !== this.oldName) {
        /**
         * Element to change has different name than operation's old name.
         *
         * @error rename-operation-wrong-name
         */
        throw new ckeditorerror["b" /* default */]('rename-operation-wrong-name: Element to change has different name than operation\'s old name.', this);
      }
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "_execute",
    value: function _execute() {
      var element = this.position.nodeAfter;
      element.name = this.newName;
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = get_get(Object(getPrototypeOf["a" /* default */])(RenameOperation.prototype), "toJSON", this).call(this);

      json.position = this.position.toJSON();
      return json;
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "type",
    get: function get() {
      return 'rename';
    }
  }], [{
    key: "fromJSON",

    /**
     * Creates `RenameOperation` object from deserialized object, i.e. from parsed JSON string.
     *
     * @param {Object} json Deserialized JSON object.
     * @param {module:engine/model/document~Document} document Document on which this operation will be applied.
     * @returns {module:engine/model/operation/attributeoperation~AttributeOperation}
     */
    value: function fromJSON(json, document) {
      return new RenameOperation(model_position_Position.fromJSON(json.position, document), json.oldName, json.newName, json.baseVersion);
    } // @if CK_DEBUG_ENGINE // toString() {
    // @if CK_DEBUG_ENGINE // 	return `RenameOperation( ${ this.baseVersion } ): ` +
    // @if CK_DEBUG_ENGINE //		`${ this.position }: "${ this.oldName }" -> "${ this.newName }"`;
    // @if CK_DEBUG_ENGINE // }

  }, {
    key: "className",
    get: function get() {
      return 'RenameOperation';
    }
  }]);

  return RenameOperation;
}(operation_Operation);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/operation/rootattributeoperation.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/operation/rootattributeoperation
 */


/**
 * Operation to change root element's attribute. Using this class you can add, remove or change value of the attribute.
 *
 * This operation is needed, because root elements can't be changed through
 * @link module:engine/model/operation/attributeoperation~AttributeOperation}.
 * It is because {@link module:engine/model/operation/attributeoperation~AttributeOperation}
 * requires a range to change and root element can't
 * be a part of range because every {@link module:engine/model/position~Position} has to be inside a root.
 * {@link module:engine/model/position~Position} can't be created before a root element.
 *
 * @extends module:engine/model/operation/operation~Operation
 */

var rootattributeoperation_RootAttributeOperation = /*#__PURE__*/function (_Operation) {
  Object(inherits["a" /* default */])(RootAttributeOperation, _Operation);

  var _super = Object(createSuper["a" /* default */])(RootAttributeOperation);

  /**
   * Creates an operation that changes, removes or adds attributes on root element.
   *
   * @see module:engine/model/operation/attributeoperation~AttributeOperation
   * @param {module:engine/model/rootelement~RootElement} root Root element to change.
   * @param {String} key Key of an attribute to change or remove.
   * @param {*} oldValue Old value of the attribute with given key or `null` if adding a new attribute.
   * @param {*} newValue New value to set for the attribute. If `null`, then the operation just removes the attribute.
   * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  function RootAttributeOperation(root, key, oldValue, newValue, baseVersion) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, RootAttributeOperation);

    _this = _super.call(this, baseVersion);
    /**
     * Root element to change.
     *
     * @readonly
     * @member {module:engine/model/rootelement~RootElement}
     */

    _this.root = root;
    /**
     * Key of an attribute to change or remove.
     *
     * @readonly
     * @member {String}
     */

    _this.key = key;
    /**
     * Old value of the attribute with given key or `null` if adding a new attribute.
     *
     * @readonly
     * @member {*}
     */

    _this.oldValue = oldValue;
    /**
     * New value to set for the attribute. If `null`, then the operation just removes the attribute.
     *
     * @readonly
     * @member {*}
     */

    _this.newValue = newValue;
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(RootAttributeOperation, [{
    key: "clone",

    /**
     * Creates and returns an operation that has the same parameters as this operation.
     *
     * @returns {module:engine/model/operation/rootattributeoperation~RootAttributeOperation} Clone of this operation.
     */
    value: function clone() {
      return new RootAttributeOperation(this.root, this.key, this.oldValue, this.newValue, this.baseVersion);
    }
    /**
     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
     *
     * @returns {module:engine/model/operation/rootattributeoperation~RootAttributeOperation}
     */

  }, {
    key: "getReversed",
    value: function getReversed() {
      return new RootAttributeOperation(this.root, this.key, this.newValue, this.oldValue, this.baseVersion + 1);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "_validate",
    value: function _validate() {
      if (this.root != this.root.root || this.root.is('documentFragment')) {
        /**
         * The element to change is not a root element.
         *
         * @error rootattribute-operation-not-a-root
         * @param {module:engine/model/rootelement~RootElement} root
         * @param {String} key
         * @param {*} value
         */
        throw new ckeditorerror["b" /* default */]('rootattribute-operation-not-a-root: The element to change is not a root element.', this, {
          root: this.root,
          key: this.key
        });
      }

      if (this.oldValue !== null && this.root.getAttribute(this.key) !== this.oldValue) {
        /**
         * The attribute which should be removed does not exists for the given node.
         *
         * @error rootattribute-operation-wrong-old-value
         * @param {module:engine/model/rootelement~RootElement} root
         * @param {String} key
         * @param {*} value
         */
        throw new ckeditorerror["b" /* default */]('rootattribute-operation-wrong-old-value: Changed node has different attribute value than operation\'s ' + 'old attribute value.', this, {
          root: this.root,
          key: this.key
        });
      }

      if (this.oldValue === null && this.newValue !== null && this.root.hasAttribute(this.key)) {
        /**
         * The attribute with given key already exists for the given node.
         *
         * @error rootattribute-operation-attribute-exists
         * @param {module:engine/model/rootelement~RootElement} root
         * @param {String} key
         */
        throw new ckeditorerror["b" /* default */]('rootattribute-operation-attribute-exists: The attribute with given key already exists.', this, {
          root: this.root,
          key: this.key
        });
      }
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "_execute",
    value: function _execute() {
      if (this.newValue !== null) {
        this.root._setAttribute(this.key, this.newValue);
      } else {
        this.root._removeAttribute(this.key);
      }
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = get_get(Object(getPrototypeOf["a" /* default */])(RootAttributeOperation.prototype), "toJSON", this).call(this);

      json.root = this.root.toJSON();
      return json;
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "type",
    get: function get() {
      if (this.oldValue === null) {
        return 'addRootAttribute';
      } else if (this.newValue === null) {
        return 'removeRootAttribute';
      } else {
        return 'changeRootAttribute';
      }
    }
  }], [{
    key: "fromJSON",

    /**
     * Creates RootAttributeOperation object from deserilized object, i.e. from parsed JSON string.
     *
     * @param {Object} json Deserialized JSON object.
     * @param {module:engine/model/document~Document} document Document on which this operation will be applied.
     * @returns {module:engine/model/operation/rootattributeoperation~RootAttributeOperation}
     */
    value: function fromJSON(json, document) {
      if (!document.getRoot(json.root)) {
        /**
         * Cannot create RootAttributeOperation for document. Root with specified name does not exist.
         *
         * @error rootattributeoperation-fromjson-no-root
         * @param {String} rootName
         */
        throw new ckeditorerror["b" /* default */]('rootattribute-operation-fromjson-no-root: Cannot create RootAttributeOperation. Root with specified name does not exist.', this, {
          rootName: json.root
        });
      }

      return new RootAttributeOperation(document.getRoot(json.root), json.key, json.oldValue, json.newValue, json.baseVersion);
    } // @if CK_DEBUG_ENGINE // toString() {
    // @if CK_DEBUG_ENGINE // 	return `RootAttributeOperation( ${ this.baseVersion } ): ` +
    // @if CK_DEBUG_ENGINE //		`"${ this.key }": ${ JSON.stringify( this.oldValue ) }` +
    // @if CK_DEBUG_ENGINE //		` -> ${ JSON.stringify( this.newValue ) }, ${ this.root.rootName }`;
    // @if CK_DEBUG_ENGINE // }

  }, {
    key: "className",
    get: function get() {
      return 'RootAttributeOperation';
    }
  }]);

  return RootAttributeOperation;
}(operation_Operation);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/operation/mergeoperation.js










/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/operation/mergeoperation
 */






/**
 * Operation to merge two {@link module:engine/model/element~Element elements}.
 *
 * The merged element is the parent of {@link ~MergeOperation#sourcePosition} and it is merged into the parent of
 * {@link ~MergeOperation#targetPosition}. All nodes from the merged element are moved to {@link ~MergeOperation#targetPosition}.
 *
 * The merged element is moved to the graveyard at {@link ~MergeOperation#graveyardPosition}.
 *
 * @extends module:engine/model/operation/operation~Operation
 */

var mergeoperation_MergeOperation = /*#__PURE__*/function (_Operation) {
  Object(inherits["a" /* default */])(MergeOperation, _Operation);

  var _super = Object(createSuper["a" /* default */])(MergeOperation);

  /**
   * Creates a merge operation.
   *
   * @param {module:engine/model/position~Position} sourcePosition Position inside the merged element. All nodes from that
   * element after that position will be moved to {@link ~#targetPosition}.
   * @param {Number} howMany Summary offset size of nodes which will be moved from the merged element to the new parent.
   * @param {module:engine/model/position~Position} targetPosition Position which the nodes from the merged elements will be moved to.
   * @param {module:engine/model/position~Position} graveyardPosition Position in graveyard to which the merged element will be moved.
   * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  function MergeOperation(sourcePosition, howMany, targetPosition, graveyardPosition, baseVersion) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, MergeOperation);

    _this = _super.call(this, baseVersion);
    /**
     * Position inside the merged element. All nodes from that element after that position will be moved to {@link ~#targetPosition}.
     *
     * @member {module:engine/model/position~Position} module:engine/model/operation/mergeoperation~MergeOperation#sourcePosition
     */

    _this.sourcePosition = sourcePosition.clone(); // This is, and should always remain, the first position in its parent.

    _this.sourcePosition.stickiness = 'toPrevious';
    /**
     * Summary offset size of nodes which will be moved from the merged element to the new parent.
     *
     * @member {Number} module:engine/model/operation/mergeoperation~MergeOperation#howMany
     */

    _this.howMany = howMany;
    /**
     * Position which the nodes from the merged elements will be moved to.
     *
     * @member {module:engine/model/position~Position} module:engine/model/operation/mergeoperation~MergeOperation#targetPosition
     */

    _this.targetPosition = targetPosition.clone(); // Except of a rare scenario in `MergeOperation` x `MergeOperation` transformation,
    // this is, and should always remain, the last position in its parent.

    _this.targetPosition.stickiness = 'toNext';
    /**
     * Position in graveyard to which the merged element will be moved.
     *
     * @member {module:engine/model/position~Position} module:engine/model/operation/mergeoperation~MergeOperation#graveyardPosition
     */

    _this.graveyardPosition = graveyardPosition.clone();
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(MergeOperation, [{
    key: "clone",

    /**
     * Creates and returns an operation that has the same parameters as this operation.
     *
     * @returns {module:engine/model/operation/mergeoperation~MergeOperation} Clone of this operation.
     */
    value: function clone() {
      return new this.constructor(this.sourcePosition, this.howMany, this.targetPosition, this.graveyardPosition, this.baseVersion);
    }
    /**
     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
     *
     * @returns {module:engine/model/operation/splitoperation~SplitOperation}
     */

  }, {
    key: "getReversed",
    value: function getReversed() {
      // Positions in this method are transformed by this merge operation because the split operation bases on
      // the context after this merge operation happened (because split operation reverses it).
      // So we need to acknowledge that the merge operation happened and those positions changed a little.
      var targetPosition = this.targetPosition._getTransformedByMergeOperation(this);

      var path = this.sourcePosition.path.slice(0, -1);

      var insertionPosition = new model_position_Position(this.sourcePosition.root, path)._getTransformedByMergeOperation(this);

      var split = new splitoperation_SplitOperation(targetPosition, this.howMany, this.graveyardPosition, this.baseVersion + 1);
      split.insertionPosition = insertionPosition;
      return split;
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "_validate",
    value: function _validate() {
      var sourceElement = this.sourcePosition.parent;
      var targetElement = this.targetPosition.parent; // Validate whether merge operation has correct parameters.

      if (!sourceElement.parent) {
        /**
         * Merge source position is invalid. The element to be merged must have a parent node.
         *
         * @error merge-operation-source-position-invalid
         */
        throw new ckeditorerror["b" /* default */]('merge-operation-source-position-invalid: Merge source position is invalid.', this);
      } else if (!targetElement.parent) {
        /**
         * Merge target position is invalid. The element to be merged must have a parent node.
         *
         * @error merge-operation-target-position-invalid
         */
        throw new ckeditorerror["b" /* default */]('merge-operation-target-position-invalid: Merge target position is invalid.', this);
      } else if (this.howMany != sourceElement.maxOffset) {
        /**
         * Merge operation specifies wrong number of nodes to move.
         *
         * @error merge-operation-how-many-invalid
         */
        throw new ckeditorerror["b" /* default */]('merge-operation-how-many-invalid: Merge operation specifies wrong number of nodes to move.', this);
      }
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "_execute",
    value: function _execute() {
      var mergedElement = this.sourcePosition.parent;

      var sourceRange = model_range_Range._createIn(mergedElement);

      _move(sourceRange, this.targetPosition);

      _move(model_range_Range._createOn(mergedElement), this.graveyardPosition);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = get_get(Object(getPrototypeOf["a" /* default */])(MergeOperation.prototype), "toJSON", this).call(this);

      json.sourcePosition = json.sourcePosition.toJSON();
      json.targetPosition = json.targetPosition.toJSON();
      json.graveyardPosition = json.graveyardPosition.toJSON();
      return json;
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "type",
    get: function get() {
      return 'merge';
    }
    /**
     * Position before the merged element (which will be deleted).
     *
     * @readonly
     * @type {module:engine/model/position~Position}
     */

  }, {
    key: "deletionPosition",
    get: function get() {
      return new model_position_Position(this.sourcePosition.root, this.sourcePosition.path.slice(0, -1));
    }
    /**
     * Artificial range that contains all the nodes from the merged element that will be moved to {@link ~MergeOperation#sourcePosition}.
     * The range starts at {@link ~MergeOperation#sourcePosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.
     *
     * @readonly
     * @type {module:engine/model/range~Range}
     */

  }, {
    key: "movedRange",
    get: function get() {
      var end = this.sourcePosition.getShiftedBy(Number.POSITIVE_INFINITY);
      return new model_range_Range(this.sourcePosition, end);
    }
  }], [{
    key: "fromJSON",

    /**
     * Creates `MergeOperation` object from deserilized object, i.e. from parsed JSON string.
     *
     * @param {Object} json Deserialized JSON object.
     * @param {module:engine/model/document~Document} document Document on which this operation will be applied.
     * @returns {module:engine/model/operation/mergeoperation~MergeOperation}
     */
    value: function fromJSON(json, document) {
      var sourcePosition = model_position_Position.fromJSON(json.sourcePosition, document);
      var targetPosition = model_position_Position.fromJSON(json.targetPosition, document);
      var graveyardPosition = model_position_Position.fromJSON(json.graveyardPosition, document);
      return new this(sourcePosition, json.howMany, targetPosition, graveyardPosition, json.baseVersion);
    } // @if CK_DEBUG_ENGINE // toString() {
    // @if CK_DEBUG_ENGINE // 	return `MergeOperation( ${ this.baseVersion } ): ` +
    // @if CK_DEBUG_ENGINE //		`${ this.sourcePosition } -> ${ this.targetPosition }` +
    // @if CK_DEBUG_ENGINE //		` ( ${ this.howMany } ), ${ this.graveyardPosition }`;
    // @if CK_DEBUG_ENGINE // }

  }, {
    key: "className",
    get: function get() {
      return 'MergeOperation';
    }
  }]);

  return MergeOperation;
}(operation_Operation);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/operation/splitoperation.js










/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/operation/splitoperation
 */






/**
 * Operation to split {@link module:engine/model/element~Element an element} at given
 * {@link module:engine/model/operation/splitoperation~SplitOperation#splitPosition split position} into two elements,
 * both containing a part of the element's original content.
 *
 * @extends module:engine/model/operation/operation~Operation
 */

var splitoperation_SplitOperation = /*#__PURE__*/function (_Operation) {
  Object(inherits["a" /* default */])(SplitOperation, _Operation);

  var _super = Object(createSuper["a" /* default */])(SplitOperation);

  /**
   * Creates a split operation.
   *
   * @param {module:engine/model/position~Position} splitPosition Position at which an element should be split.
   * @param {Number} howMany Total offset size of elements that are in the split element after `position`.
   * @param {module:engine/model/position~Position|null} graveyardPosition Position in the graveyard root before the element which
   * should be used as a parent of the nodes after `position`. If it is not set, a copy of the the `position` parent will be used.
   * @param {Number|null} baseVersion Document {@link module:engine/model/document~Document#version} on which operation
   * can be applied or `null` if the operation operates on detached (non-document) tree.
   */
  function SplitOperation(splitPosition, howMany, graveyardPosition, baseVersion) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, SplitOperation);

    _this = _super.call(this, baseVersion);
    /**
     * Position at which an element should be split.
     *
     * @member {module:engine/model/position~Position} module:engine/model/operation/splitoperation~SplitOperation#splitPosition
     */

    _this.splitPosition = splitPosition.clone(); // Keep position sticking to the next node. This way any new content added at the place where the element is split
    // will be left in the original element.

    _this.splitPosition.stickiness = 'toNext';
    /**
     * Total offset size of elements that are in the split element after `position`.
     *
     * @member {Number} module:engine/model/operation/splitoperation~SplitOperation#howMany
     */

    _this.howMany = howMany;
    /**
     * Position at which the clone of split element (or element from graveyard) will be inserted.
     *
     * @member {module:engine/model/position~Position} module:engine/model/operation/splitoperation~SplitOperation#insertionPosition
     */

    _this.insertionPosition = SplitOperation.getInsertionPosition(splitPosition);
    _this.insertionPosition.stickiness = 'toNone';
    /**
     * Position in the graveyard root before the element which should be used as a parent of the nodes after `position`.
     * If it is not set, a copy of the the `position` parent will be used.
     *
     * The default behavior is to clone the split element. Element from graveyard is used during undo.
     *
     * @member {module:engine/model/position~Position|null} #graveyardPosition
     */

    _this.graveyardPosition = graveyardPosition ? graveyardPosition.clone() : null;

    if (_this.graveyardPosition) {
      _this.graveyardPosition.stickiness = 'toNext';
    }

    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(SplitOperation, [{
    key: "clone",

    /**
     * Creates and returns an operation that has the same parameters as this operation.
     *
     * @returns {module:engine/model/operation/splitoperation~SplitOperation} Clone of this operation.
     */
    value: function clone() {
      var split = new this.constructor(this.splitPosition, this.howMany, this.graveyardPosition, this.baseVersion);
      split.insertionPosition = this.insertionPosition;
      return split;
    }
    /**
     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
     *
     * @returns {module:engine/model/operation/mergeoperation~MergeOperation}
     */

  }, {
    key: "getReversed",
    value: function getReversed() {
      var graveyard = this.splitPosition.root.document.graveyard;
      var graveyardPosition = new model_position_Position(graveyard, [0]);
      return new mergeoperation_MergeOperation(this.moveTargetPosition, this.howMany, this.splitPosition, graveyardPosition, this.baseVersion + 1);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "_validate",
    value: function _validate() {
      var element = this.splitPosition.parent;
      var offset = this.splitPosition.offset; // Validate whether split operation has correct parameters.

      if (!element || element.maxOffset < offset) {
        /**
         * Split position is invalid.
         *
         * @error split-operation-position-invalid
         */
        throw new ckeditorerror["b" /* default */]('split-operation-position-invalid: Split position is invalid.', this);
      } else if (!element.parent) {
        /**
         * Cannot split root element.
         *
         * @error split-operation-split-in-root
         */
        throw new ckeditorerror["b" /* default */]('split-operation-split-in-root: Cannot split root element.', this);
      } else if (this.howMany != element.maxOffset - this.splitPosition.offset) {
        /**
         * Split operation specifies wrong number of nodes to move.
         *
         * @error split-operation-how-many-invalid
         */
        throw new ckeditorerror["b" /* default */]('split-operation-how-many-invalid: Split operation specifies wrong number of nodes to move.', this);
      } else if (this.graveyardPosition && !this.graveyardPosition.nodeAfter) {
        /**
         * Graveyard position invalid.
         *
         * @error split-operation-graveyard-position-invalid
         */
        throw new ckeditorerror["b" /* default */]('split-operation-graveyard-position-invalid: Graveyard position invalid.', this);
      }
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "_execute",
    value: function _execute() {
      var splitElement = this.splitPosition.parent;

      if (this.graveyardPosition) {
        _move(model_range_Range._createFromPositionAndShift(this.graveyardPosition, 1), this.insertionPosition);
      } else {
        var newElement = splitElement._clone();

        utils_insert(this.insertionPosition, newElement);
      }

      var sourceRange = new model_range_Range(model_position_Position._createAt(splitElement, this.splitPosition.offset), model_position_Position._createAt(splitElement, splitElement.maxOffset));

      _move(sourceRange, this.moveTargetPosition);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = get_get(Object(getPrototypeOf["a" /* default */])(SplitOperation.prototype), "toJSON", this).call(this);

      json.splitPosition = this.splitPosition.toJSON();
      json.insertionPosition = this.insertionPosition.toJSON();

      if (this.graveyardPosition) {
        json.graveyardPosition = this.graveyardPosition.toJSON();
      }

      return json;
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "type",
    get: function get() {
      return 'split';
    }
    /**
     * Position inside the new clone of a split element.
     *
     * This is a position where nodes that are after the split position will be moved to.
     *
     * @readonly
     * @type {module:engine/model/position~Position}
     */

  }, {
    key: "moveTargetPosition",
    get: function get() {
      var path = this.insertionPosition.path.slice();
      path.push(0);
      return new model_position_Position(this.insertionPosition.root, path);
    }
    /**
     * Artificial range that contains all the nodes from the split element that will be moved to the new element.
     * The range starts at {@link ~#splitPosition} and ends in the same parent, at `POSITIVE_INFINITY` offset.
     *
     * @readonly
     * @type {module:engine/model/range~Range}
     */

  }, {
    key: "movedRange",
    get: function get() {
      var end = this.splitPosition.getShiftedBy(Number.POSITIVE_INFINITY);
      return new model_range_Range(this.splitPosition, end);
    }
  }], [{
    key: "getInsertionPosition",

    /**
     * Helper function that returns a default insertion position basing on given `splitPosition`. The default insertion
     * position is after the split element.
     *
     * @param {module:engine/model/position~Position} splitPosition
     * @returns {module:engine/model/position~Position}
     */
    value: function getInsertionPosition(splitPosition) {
      var path = splitPosition.path.slice(0, -1);
      path[path.length - 1]++;
      return new model_position_Position(splitPosition.root, path);
    }
    /**
     * Creates `SplitOperation` object from deserilized object, i.e. from parsed JSON string.
     *
     * @param {Object} json Deserialized JSON object.
     * @param {module:engine/model/document~Document} document Document on which this operation will be applied.
     * @returns {module:engine/model/operation/splitoperation~SplitOperation}
     */

  }, {
    key: "fromJSON",
    value: function fromJSON(json, document) {
      var splitPosition = model_position_Position.fromJSON(json.splitPosition, document);
      var insertionPosition = model_position_Position.fromJSON(json.insertionPosition, document);
      var graveyardPosition = json.graveyardPosition ? model_position_Position.fromJSON(json.graveyardPosition, document) : null;
      var split = new this(splitPosition, json.howMany, graveyardPosition, json.baseVersion);
      split.insertionPosition = insertionPosition;
      return split;
    } // @if CK_DEBUG_ENGINE // toString() {
    // @if CK_DEBUG_ENGINE // 	return `SplitOperation( ${ this.baseVersion } ): ${ this.splitPosition } ` +
    // @if CK_DEBUG_ENGINE //		`( ${ this.howMany } ) -> ${ this.insertionPosition }` +
    // @if CK_DEBUG_ENGINE //		`${ this.graveyardPosition ? ' with ' + this.graveyardPosition : '' }`;
    // @if CK_DEBUG_ENGINE // }

  }, {
    key: "className",
    get: function get() {
      return 'SplitOperation';
    }
  }]);

  return SplitOperation;
}(operation_Operation);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/rootelement.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/rootelement
 */

/**
 * Type of {@link module:engine/model/element~Element} that is a root of a model tree.
 * @extends module:engine/model/element~Element
 */

var rootelement_RootElement = /*#__PURE__*/function (_Element) {
  Object(inherits["a" /* default */])(RootElement, _Element);

  var _super = Object(createSuper["a" /* default */])(RootElement);

  /**
   * Creates root element.
   *
   * @param {module:engine/model/document~Document} document Document that is an owner of this root.
   * @param {String} name Node name.
   * @param {String} [rootName='main'] Unique root name used to identify this root
   * element by {@link module:engine/model/document~Document}.
   */
  function RootElement(document, name) {
    var _this;

    var rootName = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'main';

    Object(classCallCheck["a" /* default */])(this, RootElement);

    _this = _super.call(this, name);
    /**
     * Document that is an owner of this root.
     *
     * @private
     * @member {module:engine/model/document~Document}
     */

    _this._document = document;
    /**
     * Unique root name used to identify this root element by {@link module:engine/model/document~Document}.
     *
     * @readonly
     * @member {String}
     */

    _this.rootName = rootName;
    return _this;
  }
  /**
   * {@link module:engine/model/document~Document Document} that owns this root element.
   *
   * @readonly
   * @type {module:engine/model/document~Document|null}
   */


  Object(createClass["a" /* default */])(RootElement, [{
    key: "is",

    /**
     * Checks whether this object is of the given.
     *
     *		rootElement.is( 'rootElement' ); // -> true
     *		rootElement.is( 'element' ); // -> true
     *		rootElement.is( 'node' ); // -> true
     *		rootElement.is( 'model:rootElement' ); // -> true
     *		rootElement.is( 'model:element' ); // -> true
     *		rootElement.is( 'model:node' ); // -> true
     *
     *		rootElement.is( 'view:element' ); // -> false
     *		rootElement.is( 'documentFragment' ); // -> false
     *
     * Assuming that the object being checked is an element, you can also check its
     * {@link module:engine/model/element~Element#name name}:
     *
     *		rootElement.is( '$root' ); // -> true if this is a $root element
     *		rootElement.is( 'rootElement', '$root' ); // -> same as above
     *		text.is( '$root' ); -> false
     *
     * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.
     *
     * @param {String} type Type to check when `name` parameter is present.
     * Otherwise, it acts like the `name` parameter.
     * @param {String} [name] Element name.
     * @returns {Boolean}
     */
    value: function is(type, name) {
      if (!name) {
        return type === 'rootElement' || type === 'model:rootElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
        type === 'element' || type === 'model:element' || type === this.name || type === 'model:' + this.name || type === 'node' || type === 'model:node';
      }

      return name === this.name && (type === 'rootElement' || type === 'model:rootElement' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
      type === 'element' || type === 'model:element');
    }
    /**
     * Converts `RootElement` instance to `String` containing it's name.
     *
     * @returns {String} `RootElement` instance converted to `String`.
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      return this.rootName;
    } // @if CK_DEBUG_ENGINE // toString() {
    // @if CK_DEBUG_ENGINE // 	return this.rootName;
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // log() {
    // @if CK_DEBUG_ENGINE // 	console.log( 'ModelRootElement: ' + this );
    // @if CK_DEBUG_ENGINE // }

  }, {
    key: "document",
    get: function get() {
      return this._document;
    }
  }]);

  return RootElement;
}(model_element_Element);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/writer.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/writer
 */


















/**
 * The model can only be modified by using the writer. It should be used whenever you want to create a node, modify
 * child nodes, attributes or text, set the selection's position and its attributes.
 *
 * The instance of the writer is only available in the {@link module:engine/model/model~Model#change `change()`} or
 * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`}.
 *
 *		model.change( writer => {
 *			writer.insertText( 'foo', paragraph, 'end' );
 *		} );
 *
 * Note that the writer should never be stored and used outside of the `change()` and
 * `enqueueChange()` blocks.
 *
 * Note that writer's methods do not check the {@link module:engine/model/schema~Schema}. It is possible
 * to create incorrect model structures by using the writer. Read more about in
 * {@glink framework/guides/deep-dive/schema#who-checks-the-schema "Who checks the schema?"}.
 *
 * @see module:engine/model/model~Model#change
 * @see module:engine/model/model~Model#enqueueChange
 */

var writer_Writer = /*#__PURE__*/function () {
  /**
   * Creates a writer instance.
   *
   * **Note:** It is not recommended to use it directly. Use {@link module:engine/model/model~Model#change `Model#change()`} or
   * {@link module:engine/model/model~Model#enqueueChange `Model#enqueueChange()`} instead.
   *
   * @protected
   * @param {module:engine/model/model~Model} model
   * @param {module:engine/model/batch~Batch} batch
   */
  function Writer(model, batch) {
    Object(classCallCheck["a" /* default */])(this, Writer);

    /**
     * Instance of the model on which this writer operates.
     *
     * @readonly
     * @type {module:engine/model/model~Model}
     */
    this.model = model;
    /**
     * The batch to which this writer will add changes.
     *
     * @readonly
     * @type {module:engine/model/batch~Batch}
     */

    this.batch = batch;
  }
  /**
   * Creates a new {@link module:engine/model/text~Text text node}.
   *
   *		writer.createText( 'foo' );
   *		writer.createText( 'foo', { bold: true } );
   *
   * @param {String} data Text data.
   * @param {Object} [attributes] Text attributes.
   * @returns {module:engine/model/text~Text} Created text node.
   */


  Object(createClass["a" /* default */])(Writer, [{
    key: "createText",
    value: function createText(data, attributes) {
      return new model_text_Text(data, attributes);
    }
    /**
     * Creates a new {@link module:engine/model/element~Element element}.
     *
     *		writer.createElement( 'paragraph' );
     *		writer.createElement( 'paragraph', { alignment: 'center' } );
     *
     * @param {String} name Name of the element.
     * @param {Object} [attributes] Elements attributes.
     * @returns {module:engine/model/element~Element} Created element.
     */

  }, {
    key: "createElement",
    value: function createElement(name, attributes) {
      return new model_element_Element(name, attributes);
    }
    /**
     * Creates a new {@link module:engine/model/documentfragment~DocumentFragment document fragment}.
     *
     * @returns {module:engine/model/documentfragment~DocumentFragment} Created document fragment.
     */

  }, {
    key: "createDocumentFragment",
    value: function createDocumentFragment() {
      return new model_documentfragment_DocumentFragment();
    }
    /**
     * Creates a copy of the element and returns it. Created element has the same name and attributes as the original element.
     * If clone is deep, the original element's children are also cloned. If not, then empty element is returned.
     *
     * @param {module:engine/model/element~Element} element The element to clone.
     * @param {Boolean} [deep=true] If set to `true` clones element and all its children recursively. When set to `false`,
     * element will be cloned without any child.
     */

  }, {
    key: "cloneElement",
    value: function cloneElement(element) {
      var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
      return element._clone(deep);
    }
    /**
     * Inserts item on given position.
     *
     *		const paragraph = writer.createElement( 'paragraph' );
     *		writer.insert( paragraph, position );
     *
     * Instead of using position you can use parent and offset:
     *
     *		const text = writer.createText( 'foo' );
     *		writer.insert( text, paragraph, 5 );
     *
     * You can also use `end` instead of the offset to insert at the end:
     *
     *		const text = writer.createText( 'foo' );
     *		writer.insert( text, paragraph, 'end' );
     *
     * Or insert before or after another element:
     *
     *		const paragraph = writer.createElement( 'paragraph' );
     *		writer.insert( paragraph, anotherParagraph, 'after' );
     *
     * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.
     *
     * Note that if the item already has parent it will be removed from the previous parent.
     *
     * Note that you cannot re-insert a node from a document to a different document or a document fragment. In this case,
     * `model-writer-insert-forbidden-move` is thrown.
     *
     * If you want to move {@link module:engine/model/range~Range range} instead of an
     * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.
     *
     * **Note:** For a paste-like content insertion mechanism see
     * {@link module:engine/model/model~Model#insertContent `model.insertContent()`}.
     *
     * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment} item Item or document
     * fragment to insert.
     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition
     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when
     * second parameter is a {@link module:engine/model/item~Item model item}.
     */

  }, {
    key: "insert",
    value: function insert(item, itemOrPosition) {
      var offset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

      this._assertWriterUsedCorrectly();

      if (item instanceof model_text_Text && item.data == '') {
        return;
      }

      var position = model_position_Position._createAt(itemOrPosition, offset); // If item has a parent already.


      if (item.parent) {
        // We need to check if item is going to be inserted within the same document.
        if (isSameTree(item.root, position.root)) {
          // If it's we just need to move it.
          this.move(model_range_Range._createOn(item), position);
          return;
        } // If it isn't the same root.
        else {
            if (item.root.document) {
              /**
               * Cannot move a node from a document to a different tree.
               * It is forbidden to move a node that was already in a document outside of it.
               *
               * @error model-writer-insert-forbidden-move
               */
              throw new ckeditorerror["b" /* default */]('model-writer-insert-forbidden-move: ' + 'Cannot move a node from a document to a different tree. ' + 'It is forbidden to move a node that was already in a document outside of it.', this);
            } else {
              // Move between two different document fragments or from document fragment to a document is possible.
              // In that case, remove the item from it's original parent.
              this.remove(item);
            }
          }
      }

      var version = position.root.document ? position.root.document.version : null;
      var insert = new insertoperation_InsertOperation(position, item, version);

      if (item instanceof model_text_Text) {
        insert.shouldReceiveAttributes = true;
      }

      this.batch.addOperation(insert);
      this.model.applyOperation(insert); // When element is a DocumentFragment we need to move its markers to Document#markers.

      if (item instanceof model_documentfragment_DocumentFragment) {
        var _iterator = _createForOfIteratorHelper(item.markers),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _step$value = _slicedToArray(_step.value, 2),
                markerName = _step$value[0],
                markerRange = _step$value[1];

            // We need to migrate marker range from DocumentFragment to Document.
            var rangeRootPosition = model_position_Position._createAt(markerRange.root, 0);

            var range = new model_range_Range(markerRange.start._getCombined(rangeRootPosition, position), markerRange.end._getCombined(rangeRootPosition, position));
            var options = {
              range: range,
              usingOperation: true,
              affectsData: true
            };

            if (this.model.markers.has(markerName)) {
              this.updateMarker(markerName, options);
            } else {
              this.addMarker(markerName, options);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }
    /**
     * Creates and inserts text on given position. You can optionally set text attributes:
     *
     *		writer.insertText( 'foo', position );
     *		writer.insertText( 'foo', { bold: true }, position );
     *
     * Instead of using position you can use parent and offset or define that text should be inserted at the end
     * or before or after other node:
     *
     *		// Inserts 'foo' in paragraph, at offset 5:
     *		writer.insertText( 'foo', paragraph, 5 );
     *		// Inserts 'foo' at the end of a paragraph:
     *		writer.insertText( 'foo', paragraph, 'end' );
     *		// Inserts 'foo' after an image:
     *		writer.insertText( 'foo', image, 'after' );
     *
     * These parameters work in the same way as {@link #createPositionAt `writer.createPositionAt()`}.
     *
     * @param {String} data Text data.
     * @param {Object} [attributes] Text attributes.
     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition
     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when
     * third parameter is a {@link module:engine/model/item~Item model item}.
     */

  }, {
    key: "insertText",
    value: function insertText(text, attributes, itemOrPosition, offset) {
      if (attributes instanceof model_documentfragment_DocumentFragment || attributes instanceof model_element_Element || attributes instanceof model_position_Position) {
        this.insert(this.createText(text), attributes, itemOrPosition);
      } else {
        this.insert(this.createText(text, attributes), itemOrPosition, offset);
      }
    }
    /**
     * Creates and inserts element on given position. You can optionally set attributes:
     *
     *		writer.insertElement( 'paragraph', position );
     *		writer.insertElement( 'paragraph', { alignment: 'center' }, position );
     *
     * Instead of using position you can use parent and offset or define that text should be inserted at the end
     * or before or after other node:
     *
     *		// Inserts paragraph in the root at offset 5:
     *		writer.insertElement( 'paragraph', root, 5 );
     *		// Inserts paragraph at the end of a blockquote:
     *		writer.insertElement( 'paragraph', blockquote, 'end' );
     *		// Inserts after an image:
     *		writer.insertElement( 'paragraph', image, 'after' );
     *
     * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.
     *
     * @param {String} name Name of the element.
     * @param {Object} [attributes] Elements attributes.
     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition
     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when
     * third parameter is a {@link module:engine/model/item~Item model item}.
     */

  }, {
    key: "insertElement",
    value: function insertElement(name, attributes, itemOrPosition, offset) {
      if (attributes instanceof model_documentfragment_DocumentFragment || attributes instanceof model_element_Element || attributes instanceof model_position_Position) {
        this.insert(this.createElement(name), attributes, itemOrPosition);
      } else {
        this.insert(this.createElement(name, attributes), itemOrPosition, offset);
      }
    }
    /**
     * Inserts item at the end of the given parent.
     *
     *		const paragraph = writer.createElement( 'paragraph' );
     *		writer.append( paragraph, root );
     *
     * Note that if the item already has parent it will be removed from the previous parent.
     *
     * If you want to move {@link module:engine/model/range~Range range} instead of an
     * {@link module:engine/model/item~Item item} use {@link module:engine/model/writer~Writer#move `Writer#move()`}.
     *
     * @param {module:engine/model/item~Item|module:engine/model/documentfragment~DocumentFragment}
     * item Item or document fragment to insert.
     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent
     */

  }, {
    key: "append",
    value: function append(item, parent) {
      this.insert(item, parent, 'end');
    }
    /**
     * Creates text node and inserts it at the end of the parent. You can optionally set text attributes:
     *
     *		writer.appendText( 'foo', paragraph );
     *		writer.appendText( 'foo', { bold: true }, paragraph );
     *
     * @param {String} text Text data.
     * @param {Object} [attributes] Text attributes.
     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent
     */

  }, {
    key: "appendText",
    value: function appendText(text, attributes, parent) {
      if (attributes instanceof model_documentfragment_DocumentFragment || attributes instanceof model_element_Element) {
        this.insert(this.createText(text), attributes, 'end');
      } else {
        this.insert(this.createText(text, attributes), parent, 'end');
      }
    }
    /**
     * Creates element and inserts it at the end of the parent. You can optionally set attributes:
     *
     *		writer.appendElement( 'paragraph', root );
     *		writer.appendElement( 'paragraph', { alignment: 'center' }, root );
     *
     * @param {String} name Name of the element.
     * @param {Object} [attributes] Elements attributes.
     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} parent
     */

  }, {
    key: "appendElement",
    value: function appendElement(name, attributes, parent) {
      if (attributes instanceof model_documentfragment_DocumentFragment || attributes instanceof model_element_Element) {
        this.insert(this.createElement(name), attributes, 'end');
      } else {
        this.insert(this.createElement(name, attributes), parent, 'end');
      }
    }
    /**
     * Sets value of the attribute with given key on a {@link module:engine/model/item~Item model item}
     * or on a {@link module:engine/model/range~Range range}.
     *
     * @param {String} key Attribute key.
     * @param {*} value Attribute new value.
     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange
     * Model item or range on which the attribute will be set.
     */

  }, {
    key: "setAttribute",
    value: function setAttribute(key, value, itemOrRange) {
      this._assertWriterUsedCorrectly();

      if (itemOrRange instanceof model_range_Range) {
        var ranges = itemOrRange.getMinimalFlatRanges();

        var _iterator2 = _createForOfIteratorHelper(ranges),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var range = _step2.value;
            setAttributeOnRange(this, key, value, range);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } else {
        setAttributeOnItem(this, key, value, itemOrRange);
      }
    }
    /**
     * Sets values of attributes on a {@link module:engine/model/item~Item model item}
     * or on a {@link module:engine/model/range~Range range}.
     *
     *		writer.setAttributes( {
     *			bold: true,
     *			italic: true
     *		}, range );
     *
     * @param {Object} attributes Attributes keys and values.
     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange
     * Model item or range on which the attributes will be set.
     */

  }, {
    key: "setAttributes",
    value: function setAttributes(attributes, itemOrRange) {
      var _iterator3 = _createForOfIteratorHelper(toMap(attributes)),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var _step3$value = _slicedToArray(_step3.value, 2),
              key = _step3$value[0],
              val = _step3$value[1];

          this.setAttribute(key, val, itemOrRange);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    }
    /**
     * Removes an attribute with given key from a {@link module:engine/model/item~Item model item}
     * or from a {@link module:engine/model/range~Range range}.
     *
     * @param {String} key Attribute key.
     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange
     * Model item or range from which the attribute will be removed.
     */

  }, {
    key: "removeAttribute",
    value: function removeAttribute(key, itemOrRange) {
      this._assertWriterUsedCorrectly();

      if (itemOrRange instanceof model_range_Range) {
        var ranges = itemOrRange.getMinimalFlatRanges();

        var _iterator4 = _createForOfIteratorHelper(ranges),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var range = _step4.value;
            setAttributeOnRange(this, key, null, range);
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      } else {
        setAttributeOnItem(this, key, null, itemOrRange);
      }
    }
    /**
     * Removes all attributes from all elements in the range or from the given item.
     *
     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange
     * Model item or range from which all attributes will be removed.
     */

  }, {
    key: "clearAttributes",
    value: function clearAttributes(itemOrRange) {
      var _this = this;

      this._assertWriterUsedCorrectly();

      var removeAttributesFromItem = function removeAttributesFromItem(item) {
        var _iterator5 = _createForOfIteratorHelper(item.getAttributeKeys()),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var attribute = _step5.value;

            _this.removeAttribute(attribute, item);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      };

      if (!(itemOrRange instanceof model_range_Range)) {
        removeAttributesFromItem(itemOrRange);
      } else {
        var _iterator6 = _createForOfIteratorHelper(itemOrRange.getItems()),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var item = _step6.value;
            removeAttributesFromItem(item);
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
      }
    }
    /**
     * Moves all items in the source range to the target position.
     *
     *		writer.move( sourceRange, targetPosition );
     *
     * Instead of the target position you can use parent and offset or define that range should be moved to the end
     * or before or after chosen item:
     *
     *		// Moves all items in the range to the paragraph at offset 5:
     *		writer.move( sourceRange, paragraph, 5 );
     *		// Moves all items in the range to the end of a blockquote:
     *		writer.move( sourceRange, blockquote, 'end' );
     *		// Moves all items in the range to a position after an image:
     *		writer.move( sourceRange, image, 'after' );
     *
     * These parameters works the same way as {@link #createPositionAt `writer.createPositionAt()`}.
     *
     * Note that items can be moved only within the same tree. It means that you can move items within the same root
     * (element or document fragment) or between {@link module:engine/model/document~Document#roots documents roots},
     * but you can not move items from document fragment to the document or from one detached element to another. Use
     * {@link module:engine/model/writer~Writer#insert} in such cases.
     *
     * @param {module:engine/model/range~Range} range Source range.
     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition
     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when
     * second parameter is a {@link module:engine/model/item~Item model item}.
     */

  }, {
    key: "move",
    value: function move(range, itemOrPosition, offset) {
      this._assertWriterUsedCorrectly();

      if (!(range instanceof model_range_Range)) {
        /**
         * Invalid range to move.
         *
         * @error writer-move-invalid-range
         */
        throw new ckeditorerror["b" /* default */]('writer-move-invalid-range: Invalid range to move.', this);
      }

      if (!range.isFlat) {
        /**
         * Range to move is not flat.
         *
         * @error writer-move-range-not-flat
         */
        throw new ckeditorerror["b" /* default */]('writer-move-range-not-flat: Range to move is not flat.', this);
      }

      var position = model_position_Position._createAt(itemOrPosition, offset); // Do not move anything if the move target is same as moved range start.


      if (position.isEqual(range.start)) {
        return;
      } // If part of the marker is removed, create additional marker operation for undo purposes.


      this._addOperationForAffectedMarkers('move', range);

      if (!isSameTree(range.root, position.root)) {
        /**
         * Range is going to be moved within not the same document. Please use
         * {@link module:engine/model/writer~Writer#insert insert} instead.
         *
         * @error writer-move-different-document
         */
        throw new ckeditorerror["b" /* default */]('writer-move-different-document: Range is going to be moved between different documents.', this);
      }

      var version = range.root.document ? range.root.document.version : null;
      var operation = new moveoperation_MoveOperation(range.start, range.end.offset - range.start.offset, position, version);
      this.batch.addOperation(operation);
      this.model.applyOperation(operation);
    }
    /**
     * Removes given model {@link module:engine/model/item~Item item} or {@link module:engine/model/range~Range range}.
     *
     * @param {module:engine/model/item~Item|module:engine/model/range~Range} itemOrRange Model item or range to remove.
     */

  }, {
    key: "remove",
    value: function remove(itemOrRange) {
      this._assertWriterUsedCorrectly();

      var rangeToRemove = itemOrRange instanceof model_range_Range ? itemOrRange : model_range_Range._createOn(itemOrRange);
      var ranges = rangeToRemove.getMinimalFlatRanges().reverse();

      var _iterator7 = _createForOfIteratorHelper(ranges),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var flat = _step7.value;

          // If part of the marker is removed, create additional marker operation for undo purposes.
          this._addOperationForAffectedMarkers('move', flat);

          applyRemoveOperation(flat.start, flat.end.offset - flat.start.offset, this.batch, this.model);
        }
      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }
    }
    /**
     * Merges two siblings at the given position.
     *
     * Node before and after the position have to be an element. Otherwise `writer-merge-no-element-before` or
     * `writer-merge-no-element-after` error will be thrown.
     *
     * @param {module:engine/model/position~Position} position Position between merged elements.
     */

  }, {
    key: "merge",
    value: function merge(position) {
      this._assertWriterUsedCorrectly();

      var nodeBefore = position.nodeBefore;
      var nodeAfter = position.nodeAfter; // If part of the marker is removed, create additional marker operation for undo purposes.

      this._addOperationForAffectedMarkers('merge', position);

      if (!(nodeBefore instanceof model_element_Element)) {
        /**
         * Node before merge position must be an element.
         *
         * @error writer-merge-no-element-before
         */
        throw new ckeditorerror["b" /* default */]('writer-merge-no-element-before: Node before merge position must be an element.', this);
      }

      if (!(nodeAfter instanceof model_element_Element)) {
        /**
         * Node after merge position must be an element.
         *
         * @error writer-merge-no-element-after
         */
        throw new ckeditorerror["b" /* default */]('writer-merge-no-element-after: Node after merge position must be an element.', this);
      }

      if (!position.root.document) {
        this._mergeDetached(position);
      } else {
        this._merge(position);
      }
    }
    /**
     * Shortcut for {@link module:engine/model/model~Model#createPositionFromPath `Model#createPositionFromPath()`}.
     *
     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.
     * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.
     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.
     * See {@link module:engine/model/position~PositionStickiness}.
     * @returns {module:engine/model/position~Position}
     */

  }, {
    key: "createPositionFromPath",
    value: function createPositionFromPath(root, path, stickiness) {
      return this.model.createPositionFromPath(root, path, stickiness);
    }
    /**
     * Shortcut for {@link module:engine/model/model~Model#createPositionAt `Model#createPositionAt()`}.
     *
     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition
     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when
     * first parameter is a {@link module:engine/model/item~Item model item}.
     * @returns {module:engine/model/position~Position}
     */

  }, {
    key: "createPositionAt",
    value: function createPositionAt(itemOrPosition, offset) {
      return this.model.createPositionAt(itemOrPosition, offset);
    }
    /**
     * Shortcut for {@link module:engine/model/model~Model#createPositionAfter `Model#createPositionAfter()`}.
     *
     * @param {module:engine/model/item~Item} item Item after which the position should be placed.
     * @returns {module:engine/model/position~Position}
     */

  }, {
    key: "createPositionAfter",
    value: function createPositionAfter(item) {
      return this.model.createPositionAfter(item);
    }
    /**
     * Shortcut for {@link module:engine/model/model~Model#createPositionBefore `Model#createPositionBefore()`}.
     *
     * @param {module:engine/model/item~Item} item Item after which the position should be placed.
     * @returns {module:engine/model/position~Position}
     */

  }, {
    key: "createPositionBefore",
    value: function createPositionBefore(item) {
      return this.model.createPositionBefore(item);
    }
    /**
     * Shortcut for {@link module:engine/model/model~Model#createRange `Model#createRange()`}.
     *
     * @param {module:engine/model/position~Position} start Start position.
     * @param {module:engine/model/position~Position} [end] End position. If not set, range will be collapsed at `start` position.
     * @returns {module:engine/model/range~Range}
     */

  }, {
    key: "createRange",
    value: function createRange(start, end) {
      return this.model.createRange(start, end);
    }
    /**
     * Shortcut for {@link module:engine/model/model~Model#createRangeIn `Model#createRangeIn()`}.
     *
     * @param {module:engine/model/element~Element} element Element which is a parent for the range.
     * @returns {module:engine/model/range~Range}
     */

  }, {
    key: "createRangeIn",
    value: function createRangeIn(element) {
      return this.model.createRangeIn(element);
    }
    /**
     * Shortcut for {@link module:engine/model/model~Model#createRangeOn `Model#createRangeOn()`}.
     *
     * @param {module:engine/model/element~Element} element Element which is a parent for the range.
     * @returns {module:engine/model/range~Range}
     */

  }, {
    key: "createRangeOn",
    value: function createRangeOn(element) {
      return this.model.createRangeOn(element);
    }
    /**
     * Shortcut for {@link module:engine/model/model~Model#createSelection `Model#createSelection()`}.
     *
     * @param {module:engine/model/selection~Selectable} selectable
     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.
     * @param {Object} [options]
     * @param {Boolean} [options.backward] Sets this selection instance to be backward.
     * @returns {module:engine/model/selection~Selection}
     */

  }, {
    key: "createSelection",
    value: function createSelection(selectable, placeOrOffset, options) {
      return this.model.createSelection(selectable, placeOrOffset, options);
    }
    /**
     * Performs merge action in a detached tree.
     *
     * @private
     * @param {module:engine/model/position~Position} position Position between merged elements.
     */

  }, {
    key: "_mergeDetached",
    value: function _mergeDetached(position) {
      var nodeBefore = position.nodeBefore;
      var nodeAfter = position.nodeAfter;
      this.move(model_range_Range._createIn(nodeAfter), model_position_Position._createAt(nodeBefore, 'end'));
      this.remove(nodeAfter);
    }
    /**
     * Performs merge action in a non-detached tree.
     *
     * @private
     * @param {module:engine/model/position~Position} position Position between merged elements.
     */

  }, {
    key: "_merge",
    value: function _merge(position) {
      var targetPosition = model_position_Position._createAt(position.nodeBefore, 'end');

      var sourcePosition = model_position_Position._createAt(position.nodeAfter, 0);

      var graveyard = position.root.document.graveyard;
      var graveyardPosition = new model_position_Position(graveyard, [0]);
      var version = position.root.document.version;
      var merge = new mergeoperation_MergeOperation(sourcePosition, position.nodeAfter.maxOffset, targetPosition, graveyardPosition, version);
      this.batch.addOperation(merge);
      this.model.applyOperation(merge);
    }
    /**
     * Renames the given element.
     *
     * @param {module:engine/model/element~Element} element The element to rename.
     * @param {String} newName New element name.
     */

  }, {
    key: "rename",
    value: function rename(element, newName) {
      this._assertWriterUsedCorrectly();

      if (!(element instanceof model_element_Element)) {
        /**
         * Trying to rename an object which is not an instance of Element.
         *
         * @error writer-rename-not-element-instance
         */
        throw new ckeditorerror["b" /* default */]('writer-rename-not-element-instance: Trying to rename an object which is not an instance of Element.', this);
      }

      var version = element.root.document ? element.root.document.version : null;
      var renameOperation = new renameoperation_RenameOperation(model_position_Position._createBefore(element), element.name, newName, version);
      this.batch.addOperation(renameOperation);
      this.model.applyOperation(renameOperation);
    }
    /**
     * Splits elements starting from the given position and going to the top of the model tree as long as given
     * `limitElement` is reached. When `limitElement` is not defined then only the parent of the given position will be split.
     *
     * The element needs to have a parent. It cannot be a root element nor a document fragment.
     * The `writer-split-element-no-parent` error will be thrown if you try to split an element with no parent.
     *
     * @param {module:engine/model/position~Position} position Position of split.
     * @param {module:engine/model/node~Node} [limitElement] Stop splitting when this element will be reached.
     * @returns {Object} result Split result.
     * @returns {module:engine/model/position~Position} result.position Position between split elements.
     * @returns {module:engine/model/range~Range} result.range Range that stars from the end of the first split element and ends
     * at the beginning of the first copy element.
     */

  }, {
    key: "split",
    value: function split(position, limitElement) {
      this._assertWriterUsedCorrectly();

      var splitElement = position.parent;

      if (!splitElement.parent) {
        /**
         * Element with no parent can not be split.
         *
         * @error writer-split-element-no-parent
         */
        throw new ckeditorerror["b" /* default */]('writer-split-element-no-parent: Element with no parent can not be split.', this);
      } // When limit element is not defined lets set splitElement parent as limit.


      if (!limitElement) {
        limitElement = splitElement.parent;
      }

      if (!position.parent.getAncestors({
        includeSelf: true
      }).includes(limitElement)) {
        throw new ckeditorerror["b" /* default */]('writer-split-invalid-limit-element: Limit element is not a position ancestor.', this);
      } // We need to cache elements that will be created as a result of the first split because
      // we need to create a range from the end of the first split element to the beginning of the
      // first copy element. This should be handled by LiveRange but it doesn't work on detached nodes.


      var firstSplitElement, firstCopyElement;

      do {
        var version = splitElement.root.document ? splitElement.root.document.version : null;
        var howMany = splitElement.maxOffset - position.offset;
        var split = new splitoperation_SplitOperation(position, howMany, null, version);
        this.batch.addOperation(split);
        this.model.applyOperation(split); // Cache result of the first split.

        if (!firstSplitElement && !firstCopyElement) {
          firstSplitElement = splitElement;
          firstCopyElement = position.parent.nextSibling;
        }

        position = this.createPositionAfter(position.parent);
        splitElement = position.parent;
      } while (splitElement !== limitElement);

      return {
        position: position,
        range: new model_range_Range(model_position_Position._createAt(firstSplitElement, 'end'), model_position_Position._createAt(firstCopyElement, 0))
      };
    }
    /**
     * Wraps the given range with the given element or with a new element (if a string was passed).
     *
     * **Note:** range to wrap should be a "flat range" (see {@link module:engine/model/range~Range#isFlat `Range#isFlat`}).
     * If not, an error will be thrown.
     *
     * @param {module:engine/model/range~Range} range Range to wrap.
     * @param {module:engine/model/element~Element|String} elementOrString Element or name of element to wrap the range with.
     */

  }, {
    key: "wrap",
    value: function wrap(range, elementOrString) {
      this._assertWriterUsedCorrectly();

      if (!range.isFlat) {
        /**
         * Range to wrap is not flat.
         *
         * @error writer-wrap-range-not-flat
         */
        throw new ckeditorerror["b" /* default */]('writer-wrap-range-not-flat: Range to wrap is not flat.', this);
      }

      var element = elementOrString instanceof model_element_Element ? elementOrString : new model_element_Element(elementOrString);

      if (element.childCount > 0) {
        /**
         * Element to wrap with is not empty.
         *
         * @error writer-wrap-element-not-empty
         */
        throw new ckeditorerror["b" /* default */]('writer-wrap-element-not-empty: Element to wrap with is not empty.', this);
      }

      if (element.parent !== null) {
        /**
         * Element to wrap with is already attached to a tree model.
         *
         * @error writer-wrap-element-attached
         */
        throw new ckeditorerror["b" /* default */]('writer-wrap-element-attached: Element to wrap with is already attached to tree model.', this);
      }

      this.insert(element, range.start); // Shift the range-to-wrap because we just inserted an element before that range.

      var shiftedRange = new model_range_Range(range.start.getShiftedBy(1), range.end.getShiftedBy(1));
      this.move(shiftedRange, model_position_Position._createAt(element, 0));
    }
    /**
     * Unwraps children of the given element – all its children are moved before it and then the element is removed.
     * Throws error if you try to unwrap an element which does not have a parent.
     *
     * @param {module:engine/model/element~Element} element Element to unwrap.
     */

  }, {
    key: "unwrap",
    value: function unwrap(element) {
      this._assertWriterUsedCorrectly();

      if (element.parent === null) {
        /**
         * Trying to unwrap an element which has no parent.
         *
         * @error writer-unwrap-element-no-parent
         */
        throw new ckeditorerror["b" /* default */]('writer-unwrap-element-no-parent: Trying to unwrap an element which has no parent.', this);
      }

      this.move(model_range_Range._createIn(element), this.createPositionAfter(element));
      this.remove(element);
    }
    /**
     * Adds a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks
     * changes in the document and updates its range automatically, when model tree changes.
     *
     * As the first parameter you can set marker name.
     *
     * The required `options.usingOperation` parameter lets you decide if the marker should be managed by operations or not. See
     * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between
     * markers managed by operations and not-managed by operations.
     *
     * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be
     * `true` when the marker change changes the data returned by the
     * {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.
     * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.
     * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.
     *
     * Create marker directly base on marker's name:
     *
     *		addMarker( markerName, { range, usingOperation: false } );
     *
     * Create marker using operation:
     *
     *		addMarker( markerName, { range, usingOperation: true } );
     *
     * Create marker that affects the editor data:
     *
     *		addMarker( markerName, { range, usingOperation: false, affectsData: true } );
     *
     * Note: For efficiency reasons, it's best to create and keep as little markers as possible.
     *
     * @see module:engine/model/markercollection~Marker
     * @param {String} name Name of a marker to create - must be unique.
     * @param {Object} options
     * @param {Boolean} options.usingOperation Flag indicating that the marker should be added by MarkerOperation.
     * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.
     * @param {module:engine/model/range~Range} options.range Marker range.
     * @param {Boolean} [options.affectsData=false] Flag indicating that the marker changes the editor data.
     * @returns {module:engine/model/markercollection~Marker} Marker that was set.
     */

  }, {
    key: "addMarker",
    value: function addMarker(name, options) {
      this._assertWriterUsedCorrectly();

      if (!options || typeof options.usingOperation != 'boolean') {
        /**
         * The `options.usingOperation` parameter is required when adding a new marker.
         *
         * @error writer-addMarker-no-usingOperation
         */
        throw new ckeditorerror["b" /* default */]('writer-addMarker-no-usingOperation: The options.usingOperation parameter is required when adding a new marker.', this);
      }

      var usingOperation = options.usingOperation;
      var range = options.range;
      var affectsData = options.affectsData === undefined ? false : options.affectsData;

      if (this.model.markers.has(name)) {
        /**
         * Marker with provided name already exists.
         *
         * @error writer-addMarker-marker-exists
         */
        throw new ckeditorerror["b" /* default */]('writer-addMarker-marker-exists: Marker with provided name already exists.', this);
      }

      if (!range) {
        /**
         * Range parameter is required when adding a new marker.
         *
         * @error writer-addMarker-no-range
         */
        throw new ckeditorerror["b" /* default */]('writer-addMarker-no-range: Range parameter is required when adding a new marker.', this);
      }

      if (!usingOperation) {
        return this.model.markers._set(name, range, usingOperation, affectsData);
      }

      applyMarkerOperation(this, name, null, range, affectsData);
      return this.model.markers.get(name);
    }
    /**
     * Adds, updates or refreshes a {@link module:engine/model/markercollection~Marker marker}. Marker is a named range, which tracks
     * changes in the document and updates its range automatically, when model tree changes. Still, it is possible to change the
     * marker's range directly using this method.
     *
     * As the first parameter you can set marker name or instance. If none of them is provided, new marker, with a unique
     * name is created and returned.
     *
     * As the second parameter you can set the new marker data or leave this parameter as empty which will just refresh
     * the marker by triggering downcast conversion for it. Refreshing the marker is useful when you want to change
     * the marker {@link module:engine/view/element~Element view element} without changing any marker data.
     *
     * 		let isCommentActive = false;
     *
     * 		model.conversion.markerToHighlight( {
     * 			model: 'comment',
     *			view: data => {
     *				const classes = [ 'comment-marker' ];
     *
     *				if ( isCommentActive ) {
     *					classes.push( 'comment-marker--active' );
     *				}
     *
     *				return { classes };
     *			}
     * 		} );
     *
     * 		// Change the property that indicates if marker is displayed as active or not.
     * 		isCommentActive = true;
     *
     * 		// And refresh the marker to convert it with additional class.
     * 		model.change( writer => writer.updateMarker( 'comment' ) );
     *
     * The `options.usingOperation` parameter lets you change if the marker should be managed by operations or not. See
     * {@link module:engine/model/markercollection~Marker marker class description} to learn about the difference between
     * markers managed by operations and not-managed by operations. It is possible to change this option for an existing marker.
     *
     * The `options.affectsData` parameter, which defaults to `false`, allows you to define if a marker affects the data. It should be
     * `true` when the marker change changes the data returned by
     * the {@link module:core/editor/utils/dataapimixin~DataApi#getData `editor.getData()`} method.
     * When set to `true` it fires the {@link module:engine/model/document~Document#event:change:data `change:data`} event.
     * When set to `false` it fires the {@link module:engine/model/document~Document#event:change `change`} event.
     *
     * Update marker directly base on marker's name:
     *
     *		updateMarker( markerName, { range } );
     *
     * Update marker using operation:
     *
     *		updateMarker( marker, { range, usingOperation: true } );
     *		updateMarker( markerName, { range, usingOperation: true } );
     *
     * Change marker's option (start using operations to manage it):
     *
     *		updateMarker( marker, { usingOperation: true } );
     *
     * Change marker's option (inform the engine, that the marker does not affect the data anymore):
     *
     *		updateMarker( markerName, { affectsData: false } );
     *
     * @see module:engine/model/markercollection~Marker
     * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of a marker to update, or a marker instance.
     * @param {Object} [options] If options object is not defined then marker will be refreshed by triggering
     * downcast conversion for this marker with the same data.
     * @param {module:engine/model/range~Range} [options.range] Marker range to update.
     * @param {Boolean} [options.usingOperation] Flag indicated whether the marker should be added by MarkerOperation.
     * See {@link module:engine/model/markercollection~Marker#managedUsingOperations}.
     * @param {Boolean} [options.affectsData] Flag indicating that the marker changes the editor data.
     */

  }, {
    key: "updateMarker",
    value: function updateMarker(markerOrName, options) {
      this._assertWriterUsedCorrectly();

      var markerName = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;
      var currentMarker = this.model.markers.get(markerName);

      if (!currentMarker) {
        /**
         * Marker with provided name does not exists.
         *
         * @error writer-updateMarker-marker-not-exists
         */
        throw new ckeditorerror["b" /* default */]('writer-updateMarker-marker-not-exists: Marker with provided name does not exists.', this);
      }

      if (!options) {
        this.model.markers._refresh(currentMarker);

        return;
      }

      var hasUsingOperationDefined = typeof options.usingOperation == 'boolean';
      var affectsDataDefined = typeof options.affectsData == 'boolean'; // Use previously defined marker's affectsData if the property is not provided.

      var affectsData = affectsDataDefined ? options.affectsData : currentMarker.affectsData;

      if (!hasUsingOperationDefined && !options.range && !affectsDataDefined) {
        /**
         * One of the options is required - provide range, usingOperations or affectsData.
         *
         * @error writer-updateMarker-wrong-options
         */
        throw new ckeditorerror["b" /* default */]('writer-updateMarker-wrong-options: One of the options is required - provide range, usingOperations or affectsData.', this);
      }

      var currentRange = currentMarker.getRange();
      var updatedRange = options.range ? options.range : currentRange;

      if (hasUsingOperationDefined && options.usingOperation !== currentMarker.managedUsingOperations) {
        // The marker type is changed so it's necessary to create proper operations.
        if (options.usingOperation) {
          // If marker changes to a managed one treat this as synchronizing existing marker.
          // Create `MarkerOperation` with `oldRange` set to `null`, so reverse operation will remove the marker.
          applyMarkerOperation(this, markerName, null, updatedRange, affectsData);
        } else {
          // If marker changes to a marker that do not use operations then we need to create additional operation
          // that removes that marker first.
          applyMarkerOperation(this, markerName, currentRange, null, affectsData); // Although not managed the marker itself should stay in model and its range should be preserver or changed to passed range.

          this.model.markers._set(markerName, updatedRange, undefined, affectsData);
        }

        return;
      } // Marker's type doesn't change so update it accordingly.


      if (currentMarker.managedUsingOperations) {
        applyMarkerOperation(this, markerName, currentRange, updatedRange, affectsData);
      } else {
        this.model.markers._set(markerName, updatedRange, undefined, affectsData);
      }
    }
    /**
     * Removes given {@link module:engine/model/markercollection~Marker marker} or marker with given name.
     * The marker is removed accordingly to how it has been created, so if the marker was created using operation,
     * it will be destroyed using operation.
     *
     * @param {module:engine/model/markercollection~Marker|String} markerOrName Marker or marker name to remove.
     */

  }, {
    key: "removeMarker",
    value: function removeMarker(markerOrName) {
      this._assertWriterUsedCorrectly();

      var name = typeof markerOrName == 'string' ? markerOrName : markerOrName.name;

      if (!this.model.markers.has(name)) {
        /**
         * Trying to remove marker which does not exist.
         *
         * @error writer-removeMarker-no-marker
         */
        throw new ckeditorerror["b" /* default */]('writer-removeMarker-no-marker: Trying to remove marker which does not exist.', this);
      }

      var marker = this.model.markers.get(name);

      if (!marker.managedUsingOperations) {
        this.model.markers._remove(name);

        return;
      }

      var oldRange = marker.getRange();
      applyMarkerOperation(this, name, oldRange, null, marker.affectsData);
    }
    /**
     * Sets the document's selection (ranges and direction) to the specified location based on the given
     * {@link module:engine/model/selection~Selectable selectable} or creates an empty selection if no arguments were passed.
     *
     *		// Sets selection to the given range.
     *		const range = writer.createRange( start, end );
     *		writer.setSelection( range );
     *
     *		// Sets selection to given ranges.
     *		const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
     *		writer.setSelection( ranges );
     *
     *		// Sets selection to other selection.
     *		const otherSelection = writer.createSelection();
     *		writer.setSelection( otherSelection );
     *
     *		// Sets selection to the given document selection.
     *		const documentSelection = model.document.selection;
     *		writer.setSelection( documentSelection );
     *
     *		// Sets collapsed selection at the given position.
     *		const position = writer.createPosition( root, path );
     *		writer.setSelection( position );
     *
     *		// Sets collapsed selection at the position of the given node and an offset.
     *		writer.setSelection( paragraph, offset );
     *
     * Creates a range inside an {@link module:engine/model/element~Element element} which starts before the first child of
    	 * that element and ends after the last child of that element.
     *
     *		writer.setSelection( paragraph, 'in' );
     *
     * Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends just after the item.
     *
     *		writer.setSelection( paragraph, 'on' );
     *
     *		// Removes all selection's ranges.
     *		writer.setSelection( null );
     *
     * `Writer#setSelection()` allow passing additional options (`backward`) as the last argument.
     *
     *		// Sets selection as backward.
     *		writer.setSelection( range, { backward: true } );
     *
     * Throws `writer-incorrect-use` error when the writer is used outside the `change()` block.
     *
     * @param {module:engine/model/selection~Selectable} selectable
     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.
     * @param {Object} [options]
     * @param {Boolean} [options.backward] Sets this selection instance to be backward.
     */

  }, {
    key: "setSelection",
    value: function setSelection(selectable, placeOrOffset, options) {
      this._assertWriterUsedCorrectly();

      this.model.document.selection._setTo(selectable, placeOrOffset, options);
    }
    /**
     * Moves {@link module:engine/model/documentselection~DocumentSelection#focus} to the specified location.
     *
     * The location can be specified in the same form as
     * {@link #createPositionAt `writer.createPositionAt()`} parameters.
     *
     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition
     * @param {Number|'end'|'before'|'after'} [offset=0] Offset or one of the flags. Used only when
     * first parameter is a {@link module:engine/model/item~Item model item}.
     */

  }, {
    key: "setSelectionFocus",
    value: function setSelectionFocus(itemOrPosition, offset) {
      this._assertWriterUsedCorrectly();

      this.model.document.selection._setFocus(itemOrPosition, offset);
    }
    /**
     * Sets attribute(s) on the selection. If attribute with the same key already is set, it's value is overwritten.
     *
     * Using key and value pair:
     *
     * 	writer.setSelectionAttribute( 'italic', true );
     *
     * Using key-value object:
     *
     * 	writer.setSelectionAttribute( { italic: true, bold: false } );
     *
     * Using iterable object:
     *
     * 	writer.setSelectionAttribute( new Map( [ [ 'italic', true ] ] ) );
     *
     * @param {String|Object|Iterable.<*>} keyOrObjectOrIterable Key of the attribute to set
     * or object / iterable of key => value attribute pairs.
     * @param {*} [value] Attribute value.
     */

  }, {
    key: "setSelectionAttribute",
    value: function setSelectionAttribute(keyOrObjectOrIterable, value) {
      this._assertWriterUsedCorrectly();

      if (typeof keyOrObjectOrIterable === 'string') {
        this._setSelectionAttribute(keyOrObjectOrIterable, value);
      } else {
        var _iterator8 = _createForOfIteratorHelper(toMap(keyOrObjectOrIterable)),
            _step8;

        try {
          for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
            var _step8$value = _slicedToArray(_step8.value, 2),
                key = _step8$value[0],
                _value = _step8$value[1];

            this._setSelectionAttribute(key, _value);
          }
        } catch (err) {
          _iterator8.e(err);
        } finally {
          _iterator8.f();
        }
      }
    }
    /**
     * Removes attribute(s) with given key(s) from the selection.
     *
     * Remove one attribute:
     *
     *		writer.removeSelectionAttribute( 'italic' );
     *
     * Remove multiple attributes:
     *
     *		writer.removeSelectionAttribute( [ 'italic', 'bold' ] );
     *
     * @param {String|Iterable.<String>} keyOrIterableOfKeys Key of the attribute to remove or an iterable of attribute keys to remove.
     */

  }, {
    key: "removeSelectionAttribute",
    value: function removeSelectionAttribute(keyOrIterableOfKeys) {
      this._assertWriterUsedCorrectly();

      if (typeof keyOrIterableOfKeys === 'string') {
        this._removeSelectionAttribute(keyOrIterableOfKeys);
      } else {
        var _iterator9 = _createForOfIteratorHelper(keyOrIterableOfKeys),
            _step9;

        try {
          for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
            var key = _step9.value;

            this._removeSelectionAttribute(key);
          }
        } catch (err) {
          _iterator9.e(err);
        } finally {
          _iterator9.f();
        }
      }
    }
    /**
     * Temporarily changes the {@link module:engine/model/documentselection~DocumentSelection#isGravityOverridden gravity}
     * of the selection from left to right.
     *
     * The gravity defines from which direction the selection inherits its attributes. If it's the default left gravity,
     * then the selection (after being moved by the user) inherits attributes from its left-hand side.
     * This method allows to temporarily override this behavior by forcing the gravity to the right.
     *
     * For the following model fragment:
     *
     *		<$text bold="true" linkHref="url">bar[]</$text><$text bold="true">biz</$text>
     *
     * * Default gravity: selection will have the `bold` and `linkHref` attributes.
     * * Overridden gravity: selection will have `bold` attribute.
     *
     * **Note**: It returns an unique identifier which is required to restore the gravity. It guarantees the symmetry
     * of the process.
     *
     * @returns {String} The unique id which allows restoring the gravity.
     */

  }, {
    key: "overrideSelectionGravity",
    value: function overrideSelectionGravity() {
      return this.model.document.selection._overrideGravity();
    }
    /**
     * Restores {@link ~Writer#overrideSelectionGravity} gravity to default.
     *
     * Restoring the gravity is only possible using the unique identifier returned by
     * {@link ~Writer#overrideSelectionGravity}. Note that the gravity remains overridden as long as won't be restored
     * the same number of times it was overridden.
     *
     * @param {String} uid The unique id returned by {@link ~Writer#overrideSelectionGravity}.
     */

  }, {
    key: "restoreSelectionGravity",
    value: function restoreSelectionGravity(uid) {
      this.model.document.selection._restoreGravity(uid);
    }
    /**
     * @private
     * @param {String} key Key of the attribute to remove.
     * @param {*} value Attribute value.
     */

  }, {
    key: "_setSelectionAttribute",
    value: function _setSelectionAttribute(key, value) {
      var selection = this.model.document.selection; // Store attribute in parent element if the selection is collapsed in an empty node.

      if (selection.isCollapsed && selection.anchor.parent.isEmpty) {
        var storeKey = model_documentselection_DocumentSelection._getStoreAttributeKey(key);

        this.setAttribute(storeKey, value, selection.anchor.parent);
      }

      selection._setAttribute(key, value);
    }
    /**
     * @private
     * @param {String} key Key of the attribute to remove.
     */

  }, {
    key: "_removeSelectionAttribute",
    value: function _removeSelectionAttribute(key) {
      var selection = this.model.document.selection; // Remove stored attribute from parent element if the selection is collapsed in an empty node.

      if (selection.isCollapsed && selection.anchor.parent.isEmpty) {
        var storeKey = model_documentselection_DocumentSelection._getStoreAttributeKey(key);

        this.removeAttribute(storeKey, selection.anchor.parent);
      }

      selection._removeAttribute(key);
    }
    /**
     * Throws `writer-detached-writer-tries-to-modify-model` error when the writer is used outside of the `change()` block.
     *
     * @private
     */

  }, {
    key: "_assertWriterUsedCorrectly",
    value: function _assertWriterUsedCorrectly() {
      /**
       * Trying to use a writer outside a {@link module:engine/model/model~Model#change `change()`} or
       * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()`} blocks.
       *
       * The writer can only be used inside these blocks which ensures that the model
       * can only be changed during such "sessions".
       *
       * @error writer-incorrect-use
       */
      if (this.model._currentWriter !== this) {
        throw new ckeditorerror["b" /* default */]('writer-incorrect-use: Trying to use a writer outside the change() block.', this);
      }
    }
    /**
     * For given action `type` and `positionOrRange` where the action happens, this function finds all affected markers
     * and applies a marker operation with the new marker range equal to the current range. Thanks to this, the marker range
     * can be later correctly processed during undo.
     *
     * @private
     * @param {'move'|'merge'} type Writer action type.
     * @param {module:engine/model/position~Position|module:engine/model/range~Range} positionOrRange Position or range
     * where the writer action happens.
     */

  }, {
    key: "_addOperationForAffectedMarkers",
    value: function _addOperationForAffectedMarkers(type, positionOrRange) {
      var _iterator10 = _createForOfIteratorHelper(this.model.markers),
          _step10;

      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var marker = _step10.value;

          if (!marker.managedUsingOperations) {
            continue;
          }

          var markerRange = marker.getRange();
          var isAffected = false;

          if (type === 'move') {
            isAffected = positionOrRange.containsPosition(markerRange.start) || positionOrRange.start.isEqual(markerRange.start) || positionOrRange.containsPosition(markerRange.end) || positionOrRange.end.isEqual(markerRange.end);
          } else {
            // if type === 'merge'.
            var elementBefore = positionOrRange.nodeBefore;
            var elementAfter = positionOrRange.nodeAfter; //               Start:  <p>Foo[</p><p>Bar]</p>
            //         After merge:  <p>Foo[Bar]</p>
            // After undoing split:  <p>Foo</p><p>[Bar]</p>     <-- incorrect, needs remembering for undo.
            //

            var affectedInLeftElement = markerRange.start.parent == elementBefore && markerRange.start.isAtEnd; //               Start:  <p>[Foo</p><p>]Bar</p>
            //         After merge:  <p>[Foo]Bar</p>
            // After undoing split:  <p>[Foo]</p><p>Bar</p>     <-- incorrect, needs remembering for undo.
            //

            var affectedInRightElement = markerRange.end.parent == elementAfter && markerRange.end.offset == 0; //               Start:  <p>[Foo</p>]<p>Bar</p>
            //         After merge:  <p>[Foo]Bar</p>
            // After undoing split:  <p>[Foo]</p><p>Bar</p>     <-- incorrect, needs remembering for undo.
            //

            var affectedAfterLeftElement = markerRange.end.nodeAfter == elementAfter; //               Start:  <p>Foo</p>[<p>Bar]</p>
            //         After merge:  <p>Foo[Bar]</p>
            // After undoing split:  <p>Foo</p><p>[Bar]</p>     <-- incorrect, needs remembering for undo.
            //

            var affectedBeforeRightElement = markerRange.start.nodeAfter == elementAfter;
            isAffected = affectedInLeftElement || affectedInRightElement || affectedAfterLeftElement || affectedBeforeRightElement;
          }

          if (isAffected) {
            this.updateMarker(marker.name, {
              range: markerRange
            });
          }
        }
      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }
    }
  }]);

  return Writer;
}(); // Sets given attribute to each node in given range. When attribute value is null then attribute will be removed.
//
// Because attribute operation needs to have the same attribute value on the whole range, this function splits
// the range into smaller parts.
//
// Given `range` must be flat.
//
// @private
// @param {module:engine/model/writer~Writer} writer
// @param {String} key Attribute key.
// @param {*} value Attribute new value.
// @param {module:engine/model/range~Range} range Model range on which the attribute will be set.




function setAttributeOnRange(writer, key, value, range) {
  var model = writer.model;
  var doc = model.document; // Position of the last split, the beginning of the new range.

  var lastSplitPosition = range.start; // Currently position in the scanning range. Because we need value after the position, it is not a current
  // position of the iterator but the previous one (we need to iterate one more time to get the value after).

  var position; // Value before the currently position.

  var valueBefore; // Value after the currently position.

  var valueAfter;

  var _iterator11 = _createForOfIteratorHelper(range.getWalker({
    shallow: true
  })),
      _step11;

  try {
    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
      var val = _step11.value;
      valueAfter = val.item.getAttribute(key); // At the first run of the iterator the position in undefined. We also do not have a valueBefore, but
      // because valueAfter may be null, valueBefore may be equal valueAfter ( undefined == null ).

      if (position && valueBefore != valueAfter) {
        // if valueBefore == value there is nothing to change, so we add operation only if these values are different.
        if (valueBefore != value) {
          addOperation();
        }

        lastSplitPosition = position;
      }

      position = val.nextPosition;
      valueBefore = valueAfter;
    } // Because position in the loop is not the iterator position (see let position comment), the last position in
    // the while loop will be last but one position in the range. We need to check the last position manually.

  } catch (err) {
    _iterator11.e(err);
  } finally {
    _iterator11.f();
  }

  if (position instanceof model_position_Position && position != lastSplitPosition && valueBefore != value) {
    addOperation();
  }

  function addOperation() {
    var range = new model_range_Range(lastSplitPosition, position);
    var version = range.root.document ? doc.version : null;
    var operation = new attributeoperation_AttributeOperation(range, key, valueBefore, value, version);
    writer.batch.addOperation(operation);
    model.applyOperation(operation);
  }
} // Sets given attribute to the given node. When attribute value is null then attribute will be removed.
//
// @private
// @param {module:engine/model/writer~Writer} writer
// @param {String} key Attribute key.
// @param {*} value Attribute new value.
// @param {module:engine/model/item~Item} item Model item on which the attribute will be set.


function setAttributeOnItem(writer, key, value, item) {
  var model = writer.model;
  var doc = model.document;
  var previousValue = item.getAttribute(key);
  var range, operation;

  if (previousValue != value) {
    var isRootChanged = item.root === item;

    if (isRootChanged) {
      // If we change attributes of root element, we have to use `RootAttributeOperation`.
      var version = item.document ? doc.version : null;
      operation = new rootattributeoperation_RootAttributeOperation(item, key, previousValue, value, version);
    } else {
      range = new model_range_Range(model_position_Position._createBefore(item), writer.createPositionAfter(item));

      var _version = range.root.document ? doc.version : null;

      operation = new attributeoperation_AttributeOperation(range, key, previousValue, value, _version);
    }

    writer.batch.addOperation(operation);
    model.applyOperation(operation);
  }
} // Creates and applies marker operation to {@link module:engine/model/operation/operation~Operation operation}.
//
// @private
// @param {module:engine/model/writer~Writer} writer
// @param {String} name Marker name.
// @param {module:engine/model/range~Range} oldRange Marker range before the change.
// @param {module:engine/model/range~Range} newRange Marker range after the change.
// @param {Boolean} affectsData


function applyMarkerOperation(writer, name, oldRange, newRange, affectsData) {
  var model = writer.model;
  var doc = model.document;
  var operation = new markeroperation_MarkerOperation(name, oldRange, newRange, model.markers, affectsData, doc.version);
  writer.batch.addOperation(operation);
  model.applyOperation(operation);
} // Creates `MoveOperation` or `DetachOperation` that removes `howMany` nodes starting from `position`.
// The operation will be applied on given model instance and added to given operation instance.
//
// @private
// @param {module:engine/model/position~Position} position Position from which nodes are removed.
// @param {Number} howMany Number of nodes to remove.
// @param {Batch} batch Batch to which the operation will be added.
// @param {module:engine/model/model~Model} model Model instance on which operation will be applied.


function applyRemoveOperation(position, howMany, batch, model) {
  var operation;

  if (position.root.document) {
    var doc = model.document;
    var graveyardPosition = new model_position_Position(doc.graveyard, [0]);
    operation = new moveoperation_MoveOperation(position, howMany, graveyardPosition, doc.version);
  } else {
    operation = new detachoperation_DetachOperation(position, howMany);
  }

  batch.addOperation(operation);
  model.applyOperation(operation);
} // Returns `true` if both root elements are the same element or both are documents root elements.
//
// Elements in the same tree can be moved (for instance you can move element form one documents root to another, or
// within the same document fragment), but when element supposed to be moved from document fragment to the document, or
// to another document it should be removed and inserted to avoid problems with OT. This is because features like undo or
// collaboration may track changes on the document but ignore changes on detached fragments and should not get
// unexpected `move` operation.


function isSameTree(rootA, rootB) {
  // If it is the same root this is the same tree.
  if (rootA === rootB) {
    return true;
  } // If both roots are documents root it is operation within the document what we still treat as the same tree.


  if (rootA instanceof rootelement_RootElement && rootB instanceof rootelement_RootElement) {
    return true;
  }

  return false;
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.string.repeat.js
var es_string_repeat = __webpack_require__("38cf");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/differ.js




















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/differ
 */


/**
 * Calculates the difference between two model states.
 *
 * Receives operations that are to be applied on the model document. Marks parts of the model document tree which
 * are changed and saves the state of these elements before the change. Then, it compares saved elements with the
 * changed elements, after all changes are applied on the model document. Calculates the diff between saved
 * elements and new ones and returns a change set.
 */

var differ_Differ = /*#__PURE__*/function () {
  /**
   * Creates a `Differ` instance.
   *
   * @param {module:engine/model/markercollection~MarkerCollection} markerCollection Model's marker collection.
   */
  function Differ(markerCollection) {
    Object(classCallCheck["a" /* default */])(this, Differ);

    /**
     * Reference to the model's marker collection.
     *
     * @private
     * @type {module:engine/model/markercollection~MarkerCollection}
     */
    this._markerCollection = markerCollection;
    /**
     * A map that stores changes that happened in a given element.
     *
     * The keys of the map are references to the model elements.
     * The values of the map are arrays with changes that were done on this element.
     *
     * @private
     * @type {Map}
     */

    this._changesInElement = new Map();
    /**
     * A map that stores "element's children snapshots". A snapshot is representing children of a given element before
     * the first change was applied on that element. Snapshot items are objects with two properties: `name`,
     * containing the element name (or `'$text'` for a text node) and `attributes` which is a map of the node's attributes.
     *
     * @private
     * @type {Map}
     */

    this._elementSnapshots = new Map();
    /**
     * A map that stores all changed markers.
     *
     * The keys of the map are marker names.
     * The values of the map are objects with the `oldRange` and `newRange` properties. They store the marker range
     * state before and after the change.
     *
     * @private
     * @type {Map}
     */

    this._changedMarkers = new Map();
    /**
     * Stores the number of changes that were processed. Used to order the changes chronologically. It is important
     * when changes are sorted.
     *
     * @private
     * @type {Number}
     */

    this._changeCount = 0;
    /**
     * For efficiency purposes, `Differ` stores the change set returned by the differ after {@link #getChanges} call.
     * Cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will
     * return the cached value instead of calculating it again.
     *
     * This property stores those changes that did not take place in graveyard root.
     *
     * @private
     * @type {Array.<Object>|null}
     */

    this._cachedChanges = null;
    /**
     * For efficiency purposes, `Differ` stores the change set returned by the differ after the {@link #getChanges} call.
     * The cache is reset each time a new operation is buffered. If the cache has not been reset, {@link #getChanges} will
     * return the cached value instead of calculating it again.
     *
     * This property stores all changes evaluated by `Differ`, including those that took place in the graveyard.
     *
     * @private
     * @type {Array.<Object>|null}
     */

    this._cachedChangesWithGraveyard = null;
  }
  /**
   * Informs whether there are any changes buffered in `Differ`.
   *
   * @readonly
   * @type {Boolean}
   */


  Object(createClass["a" /* default */])(Differ, [{
    key: "refreshItem",

    /**
     * Marks given `item` in differ to be "refreshed". It means that the item will be marked as removed and inserted in the differ changes
     * set, so it will be effectively re-converted when differ changes will be handled by a dispatcher.
     *
     * @param {module:engine/model/item~Item} item Item to refresh.
     */
    value: function refreshItem(item) {
      if (this._isInInsertedElement(item.parent)) {
        return;
      }

      this._markRemove(item.parent, item.startOffset, item.offsetSize);

      this._markInsert(item.parent, item.startOffset, item.offsetSize);

      var range = model_range_Range._createOn(item);

      var _iterator = _createForOfIteratorHelper(this._markerCollection.getMarkersIntersectingRange(range)),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var marker = _step.value;
          var markerRange = marker.getRange();
          this.bufferMarkerChange(marker.name, markerRange, markerRange, marker.affectsData);
        } // Clear cache after each buffered operation as it is no longer valid.

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this._cachedChanges = null;
    }
    /**
     * Buffers the given operation. An operation has to be buffered before it is executed.
     *
     * Operation type is checked and it is checked which nodes it will affect. These nodes are then stored in `Differ`
     * in the state before the operation is executed.
     *
     * @param {module:engine/model/operation/operation~Operation} operation An operation to buffer.
     */

  }, {
    key: "bufferOperation",
    value: function bufferOperation(operation) {
      // Below we take an operation, check its type, then use its parameters in marking (private) methods.
      // The general rule is to not mark elements inside inserted element. All inserted elements are re-rendered.
      // Marking changes in them would cause a "double" changing then.
      //
      switch (operation.type) {
        case 'insert':
          {
            if (this._isInInsertedElement(operation.position.parent)) {
              return;
            }

            this._markInsert(operation.position.parent, operation.position.offset, operation.nodes.maxOffset);

            break;
          }

        case 'addAttribute':
        case 'removeAttribute':
        case 'changeAttribute':
          {
            var _iterator2 = _createForOfIteratorHelper(operation.range.getItems({
              shallow: true
            })),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var item = _step2.value;

                if (this._isInInsertedElement(item.parent)) {
                  continue;
                }

                this._markAttribute(item);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }

            break;
          }

        case 'remove':
        case 'move':
        case 'reinsert':
          {
            // When range is moved to the same position then not mark it as a change.
            // See: https://github.com/ckeditor/ckeditor5-engine/issues/1664.
            if (operation.sourcePosition.isEqual(operation.targetPosition) || operation.sourcePosition.getShiftedBy(operation.howMany).isEqual(operation.targetPosition)) {
              return;
            }

            var sourceParentInserted = this._isInInsertedElement(operation.sourcePosition.parent);

            var targetParentInserted = this._isInInsertedElement(operation.targetPosition.parent);

            if (!sourceParentInserted) {
              this._markRemove(operation.sourcePosition.parent, operation.sourcePosition.offset, operation.howMany);
            }

            if (!targetParentInserted) {
              this._markInsert(operation.targetPosition.parent, operation.getMovedRangeStart().offset, operation.howMany);
            }

            break;
          }

        case 'rename':
          {
            if (this._isInInsertedElement(operation.position.parent)) {
              return;
            }

            this._markRemove(operation.position.parent, operation.position.offset, 1);

            this._markInsert(operation.position.parent, operation.position.offset, 1);

            var range = model_range_Range._createFromPositionAndShift(operation.position, 1);

            var _iterator3 = _createForOfIteratorHelper(this._markerCollection.getMarkersIntersectingRange(range)),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var marker = _step3.value;
                var markerRange = marker.getRange();
                this.bufferMarkerChange(marker.name, markerRange, markerRange, marker.affectsData);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }

            break;
          }

        case 'split':
          {
            var splitElement = operation.splitPosition.parent; // Mark that children of the split element were removed.

            if (!this._isInInsertedElement(splitElement)) {
              this._markRemove(splitElement, operation.splitPosition.offset, operation.howMany);
            } // Mark that the new element (split copy) was inserted.


            if (!this._isInInsertedElement(operation.insertionPosition.parent)) {
              this._markInsert(operation.insertionPosition.parent, operation.insertionPosition.offset, 1);
            } // If the split took the element from the graveyard, mark that the element from the graveyard was removed.


            if (operation.graveyardPosition) {
              this._markRemove(operation.graveyardPosition.parent, operation.graveyardPosition.offset, 1);
            }

            break;
          }

        case 'merge':
          {
            // Mark that the merged element was removed.
            var mergedElement = operation.sourcePosition.parent;

            if (!this._isInInsertedElement(mergedElement.parent)) {
              this._markRemove(mergedElement.parent, mergedElement.startOffset, 1);
            } // Mark that the merged element was inserted into graveyard.


            var graveyardParent = operation.graveyardPosition.parent;

            this._markInsert(graveyardParent, operation.graveyardPosition.offset, 1); // Mark that children of merged element were inserted at new parent.


            var mergedIntoElement = operation.targetPosition.parent;

            if (!this._isInInsertedElement(mergedIntoElement)) {
              this._markInsert(mergedIntoElement, operation.targetPosition.offset, mergedElement.maxOffset);
            }

            break;
          }
      } // Clear cache after each buffered operation as it is no longer valid.


      this._cachedChanges = null;
    }
    /**
     * Buffers a marker change.
     *
     * @param {String} markerName The name of the marker that changed.
     * @param {module:engine/model/range~Range|null} oldRange Marker range before the change or `null` if the marker has just
     * been created.
     * @param {module:engine/model/range~Range|null} newRange Marker range after the change or `null` if the marker was removed.
     * @param {Boolean} affectsData Flag indicating whether marker affects the editor data.
     */

  }, {
    key: "bufferMarkerChange",
    value: function bufferMarkerChange(markerName, oldRange, newRange, affectsData) {
      var buffered = this._changedMarkers.get(markerName);

      if (!buffered) {
        this._changedMarkers.set(markerName, {
          oldRange: oldRange,
          newRange: newRange,
          affectsData: affectsData
        });
      } else {
        buffered.newRange = newRange;
        buffered.affectsData = affectsData;

        if (buffered.oldRange == null && buffered.newRange == null) {
          // The marker is going to be removed (`newRange == null`) but it did not exist before the first buffered change
          // (`buffered.oldRange == null`). In this case, do not keep the marker in buffer at all.
          this._changedMarkers.delete(markerName);
        }
      }
    }
    /**
     * Returns all markers that should be removed as a result of buffered changes.
     *
     * @returns {Array.<Object>} Markers to remove. Each array item is an object containing the `name` and `range` properties.
     */

  }, {
    key: "getMarkersToRemove",
    value: function getMarkersToRemove() {
      var result = [];

      var _iterator4 = _createForOfIteratorHelper(this._changedMarkers),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var _step4$value = _slicedToArray(_step4.value, 2),
              name = _step4$value[0],
              change = _step4$value[1];

          if (change.oldRange != null) {
            result.push({
              name: name,
              range: change.oldRange
            });
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      return result;
    }
    /**
     * Returns all markers which should be added as a result of buffered changes.
     *
     * @returns {Array.<Object>} Markers to add. Each array item is an object containing the `name` and `range` properties.
     */

  }, {
    key: "getMarkersToAdd",
    value: function getMarkersToAdd() {
      var result = [];

      var _iterator5 = _createForOfIteratorHelper(this._changedMarkers),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var _step5$value = _slicedToArray(_step5.value, 2),
              name = _step5$value[0],
              change = _step5$value[1];

          if (change.newRange != null) {
            result.push({
              name: name,
              range: change.newRange
            });
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }

      return result;
    }
    /**
     * Returns all markers which changed.
     *
     * @returns {Array.<Object>}
     */

  }, {
    key: "getChangedMarkers",
    value: function getChangedMarkers() {
      return Array.from(this._changedMarkers).map(function (item) {
        return {
          name: item[0],
          data: {
            oldRange: item[1].oldRange,
            newRange: item[1].newRange
          }
        };
      });
    }
    /**
     * Checks whether some of the buffered changes affect the editor data.
     *
     * Types of changes which affect the editor data:
     *
     * * model structure changes,
     * * attribute changes,
     * * changes of markers which were defined as `affectingData`.
     *
     * @returns {Boolean}
     */

  }, {
    key: "hasDataChanges",
    value: function hasDataChanges() {
      var _iterator6 = _createForOfIteratorHelper(this._changedMarkers),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var _step6$value = _slicedToArray(_step6.value, 2),
              change = _step6$value[1];

          if (change.affectsData) {
            return true;
          }
        } // If markers do not affect the data, check whether there are some changes in elements.

      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      return this._changesInElement.size > 0;
    }
    /**
     * Calculates the diff between the old model tree state (the state before the first buffered operations since the last {@link #reset}
     * call) and the new model tree state (actual one). It should be called after all buffered operations are executed.
     *
     * The diff set is returned as an array of diff items, each describing a change done on the model. The items are sorted by
     * the position on which the change happened. If a position {@link module:engine/model/position~Position#isBefore is before}
     * another one, it will be on an earlier index in the diff set.
     *
     * Because calculating the diff is a costly operation, the result is cached. If no new operation was buffered since the
     * previous {@link #getChanges} call, the next call will return the cached value.
     *
     * @param {Object} options Additional options.
     * @param {Boolean} [options.includeChangesInGraveyard=false] If set to `true`, also changes that happened
     * in the graveyard root will be returned. By default, changes in the graveyard root are not returned.
     * @returns {Array.<Object>} Diff between the old and the new model tree state.
     */

  }, {
    key: "getChanges",
    value: function getChanges() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {
        includeChangesInGraveyard: false
      };

      // If there are cached changes, just return them instead of calculating changes again.
      if (this._cachedChanges) {
        if (options.includeChangesInGraveyard) {
          return this._cachedChangesWithGraveyard.slice();
        } else {
          return this._cachedChanges.slice();
        }
      } // Will contain returned results.


      var diffSet = []; // Check all changed elements.

      var _iterator7 = _createForOfIteratorHelper(this._changesInElement.keys()),
          _step7;

      try {
        for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
          var element = _step7.value;

          // Get changes for this element and sort them.
          var changes = this._changesInElement.get(element).sort(function (a, b) {
            if (a.offset === b.offset) {
              if (a.type != b.type) {
                // If there are multiple changes at the same position, "remove" change should be first.
                // If the order is different, for example, we would first add some nodes and then removed them
                // (instead of the nodes that we should remove).
                return a.type == 'remove' ? -1 : 1;
              }

              return 0;
            }

            return a.offset < b.offset ? -1 : 1;
          }); // Get children of this element before any change was applied on it.


          var snapshotChildren = this._elementSnapshots.get(element); // Get snapshot of current element's children.


          var elementChildren = _getChildrenSnapshot(element.getChildren()); // Generate actions basing on changes done on element.


          var actions = _generateActionsFromChanges(snapshotChildren.length, changes);

          var _i2 = 0; // Iterator in `elementChildren` array -- iterates through current children of element.

          var j = 0; // Iterator in `snapshotChildren` array -- iterates through old children of element.
          // Process every action.

          var _iterator8 = _createForOfIteratorHelper(actions),
              _step8;

          try {
            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
              var action = _step8.value;

              if (action === 'i') {
                // Generate diff item for this element and insert it into the diff set.
                diffSet.push(this._getInsertDiff(element, _i2, elementChildren[_i2].name));
                _i2++;
              } else if (action === 'r') {
                // Generate diff item for this element and insert it into the diff set.
                diffSet.push(this._getRemoveDiff(element, _i2, snapshotChildren[j].name));
                j++;
              } else if (action === 'a') {
                // Take attributes from saved and current children.
                var elementAttributes = elementChildren[_i2].attributes;
                var snapshotAttributes = snapshotChildren[j].attributes;
                var range = void 0;

                if (elementChildren[_i2].name == '$text') {
                  range = new model_range_Range(model_position_Position._createAt(element, _i2), model_position_Position._createAt(element, _i2 + 1));
                } else {
                  var index = element.offsetToIndex(_i2);
                  range = new model_range_Range(model_position_Position._createAt(element, _i2), model_position_Position._createAt(element.getChild(index), 0));
                } // Generate diff items for this change (there might be multiple attributes changed and
                // there is a single diff for each of them) and insert them into the diff set.


                diffSet.push.apply(diffSet, _toConsumableArray(this._getAttributesDiff(range, snapshotAttributes, elementAttributes)));
                _i2++;
                j++;
              } else {
                // `action` is 'equal'. Child not changed.
                _i2++;
                j++;
              }
            }
          } catch (err) {
            _iterator8.e(err);
          } finally {
            _iterator8.f();
          }
        } // Then, sort the changes by the position (change at position before other changes is first).

      } catch (err) {
        _iterator7.e(err);
      } finally {
        _iterator7.f();
      }

      diffSet.sort(function (a, b) {
        // If the change is in different root, we don't care much, but we'd like to have all changes in given
        // root "together" in the array. So let's just sort them by the root name. It does not matter which root
        // will be processed first.
        if (a.position.root != b.position.root) {
          return a.position.root.rootName < b.position.root.rootName ? -1 : 1;
        } // If change happens at the same position...


        if (a.position.isEqual(b.position)) {
          // Keep chronological order of operations.
          return a.changeCount - b.changeCount;
        } // If positions differ, position "on the left" should be earlier in the result.


        return a.position.isBefore(b.position) ? -1 : 1;
      }); // Glue together multiple changes (mostly on text nodes).

      for (var i = 1; i < diffSet.length; i++) {
        var prevDiff = diffSet[i - 1];
        var thisDiff = diffSet[i]; // Glue remove changes if they happen on text on same position.

        var isConsecutiveTextRemove = prevDiff.type == 'remove' && thisDiff.type == 'remove' && prevDiff.name == '$text' && thisDiff.name == '$text' && prevDiff.position.isEqual(thisDiff.position); // Glue insert changes if they happen on text on consecutive fragments.

        var isConsecutiveTextAdd = prevDiff.type == 'insert' && thisDiff.type == 'insert' && prevDiff.name == '$text' && thisDiff.name == '$text' && prevDiff.position.parent == thisDiff.position.parent && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset; // Glue attribute changes if they happen on consecutive fragments and have same key, old value and new value.

        var isConsecutiveAttributeChange = prevDiff.type == 'attribute' && thisDiff.type == 'attribute' && prevDiff.position.parent == thisDiff.position.parent && prevDiff.range.isFlat && thisDiff.range.isFlat && prevDiff.position.offset + prevDiff.length == thisDiff.position.offset && prevDiff.attributeKey == thisDiff.attributeKey && prevDiff.attributeOldValue == thisDiff.attributeOldValue && prevDiff.attributeNewValue == thisDiff.attributeNewValue;

        if (isConsecutiveTextRemove || isConsecutiveTextAdd || isConsecutiveAttributeChange) {
          diffSet[i - 1].length++;

          if (isConsecutiveAttributeChange) {
            diffSet[i - 1].range.end = diffSet[i - 1].range.end.getShiftedBy(1);
          }

          diffSet.splice(i, 1);
          i--;
        }
      } // Remove `changeCount` property from diff items. It is used only for sorting and is internal thing.


      for (var _i = 0, _diffSet = diffSet; _i < _diffSet.length; _i++) {
        var item = _diffSet[_i];
        delete item.changeCount;

        if (item.type == 'attribute') {
          delete item.position;
          delete item.length;
        }
      }

      this._changeCount = 0; // Cache changes.

      this._cachedChangesWithGraveyard = diffSet.slice();
      this._cachedChanges = diffSet.slice().filter(_changesInGraveyardFilter);

      if (options.includeChangesInGraveyard) {
        return this._cachedChangesWithGraveyard;
      } else {
        return this._cachedChanges;
      }
    }
    /**
     * Resets `Differ`. Removes all buffered changes.
     */

  }, {
    key: "reset",
    value: function reset() {
      this._changesInElement.clear();

      this._elementSnapshots.clear();

      this._changedMarkers.clear();

      this._cachedChanges = null;
    }
    /**
     * Saves and handles an insert change.
     *
     * @private
     * @param {module:engine/model/element~Element} parent
     * @param {Number} offset
     * @param {Number} howMany
     */

  }, {
    key: "_markInsert",
    value: function _markInsert(parent, offset, howMany) {
      var changeItem = {
        type: 'insert',
        offset: offset,
        howMany: howMany,
        count: this._changeCount++
      };

      this._markChange(parent, changeItem);
    }
    /**
     * Saves and handles a remove change.
     *
     * @private
     * @param {module:engine/model/element~Element} parent
     * @param {Number} offset
     * @param {Number} howMany
     */

  }, {
    key: "_markRemove",
    value: function _markRemove(parent, offset, howMany) {
      var changeItem = {
        type: 'remove',
        offset: offset,
        howMany: howMany,
        count: this._changeCount++
      };

      this._markChange(parent, changeItem);

      this._removeAllNestedChanges(parent, offset, howMany);
    }
    /**
     * Saves and handles an attribute change.
     *
     * @private
     * @param {module:engine/model/item~Item} item
     */

  }, {
    key: "_markAttribute",
    value: function _markAttribute(item) {
      var changeItem = {
        type: 'attribute',
        offset: item.startOffset,
        howMany: item.offsetSize,
        count: this._changeCount++
      };

      this._markChange(item.parent, changeItem);
    }
    /**
     * Saves and handles a model change.
     *
     * @private
     * @param {module:engine/model/element~Element} parent
     * @param {Object} changeItem
     */

  }, {
    key: "_markChange",
    value: function _markChange(parent, changeItem) {
      // First, make a snapshot of this parent's children (it will be made only if it was not made before).
      this._makeSnapshot(parent); // Then, get all changes that already were done on the element (empty array if this is the first change).


      var changes = this._getChangesForElement(parent); // Then, look through all the changes, and transform them or the new change.


      this._handleChange(changeItem, changes); // Add the new change.


      changes.push(changeItem); // Remove incorrect changes. During transformation some change might be, for example, included in another.
      // In that case, the change will have `howMany` property set to `0` or less. We need to remove those changes.

      for (var i = 0; i < changes.length; i++) {
        if (changes[i].howMany < 1) {
          changes.splice(i, 1);
          i--;
        }
      }
    }
    /**
     * Gets an array of changes that have already been saved for a given element.
     *
     * @private
     * @param {module:engine/model/element~Element} element
     * @returns {Array.<Object>}
     */

  }, {
    key: "_getChangesForElement",
    value: function _getChangesForElement(element) {
      var changes;

      if (this._changesInElement.has(element)) {
        changes = this._changesInElement.get(element);
      } else {
        changes = [];

        this._changesInElement.set(element, changes);
      }

      return changes;
    }
    /**
     * Saves a children snapshot for a given element.
     *
     * @private
     * @param {module:engine/model/element~Element} element
     */

  }, {
    key: "_makeSnapshot",
    value: function _makeSnapshot(element) {
      if (!this._elementSnapshots.has(element)) {
        this._elementSnapshots.set(element, _getChildrenSnapshot(element.getChildren()));
      }
    }
    /**
     * For a given newly saved change, compares it with a change already done on the element and modifies the incoming
     * change and/or the old change.
     *
     * @private
     * @param {Object} inc Incoming (new) change.
     * @param {Array.<Object>} changes An array containing all the changes done on that element.
     */

  }, {
    key: "_handleChange",
    value: function _handleChange(inc, changes) {
      // We need a helper variable that will store how many nodes are to be still handled for this change item.
      // `nodesToHandle` (how many nodes still need to be handled) and `howMany` (how many nodes were affected)
      // needs to be differentiated.
      //
      // This comes up when there are multiple changes that are affected by `inc` change item.
      //
      // For example: assume two insert changes: `{ offset: 2, howMany: 1 }` and `{ offset: 5, howMany: 1 }`.
      // Assume that `inc` change is remove `{ offset: 2, howMany: 2, nodesToHandle: 2 }`.
      //
      // Then, we:
      // - "forget" about first insert change (it is "eaten" by remove),
      // - because of that, at the end we will want to remove only one node (`nodesToHandle = 1`),
      // - but still we have to change offset of the second insert change from `5` to `3`!
      //
      // So, `howMany` does not change throughout items transformation and keeps information about how many nodes were affected,
      // while `nodesToHandle` means how many nodes need to be handled after the change item is transformed by other changes.
      inc.nodesToHandle = inc.howMany;

      var _iterator9 = _createForOfIteratorHelper(changes),
          _step9;

      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var old = _step9.value;
          var incEnd = inc.offset + inc.howMany;
          var oldEnd = old.offset + old.howMany;

          if (inc.type == 'insert') {
            if (old.type == 'insert') {
              if (inc.offset <= old.offset) {
                old.offset += inc.howMany;
              } else if (inc.offset < oldEnd) {
                old.howMany += inc.nodesToHandle;
                inc.nodesToHandle = 0;
              }
            }

            if (old.type == 'remove') {
              if (inc.offset < old.offset) {
                old.offset += inc.howMany;
              }
            }

            if (old.type == 'attribute') {
              if (inc.offset <= old.offset) {
                old.offset += inc.howMany;
              } else if (inc.offset < oldEnd) {
                // This case is more complicated, because attribute change has to be split into two.
                // Example (assume that uppercase and lowercase letters mean different attributes):
                //
                // initial state:		abcxyz
                // attribute change:	aBCXYz
                // incoming insert:		aBCfooXYz
                //
                // Change ranges cannot intersect because each item has to be described exactly (it was either
                // not changed, inserted, removed, or its attribute was changed). That's why old attribute
                // change has to be split and both parts has to be handled separately from now on.
                var howMany = old.howMany;
                old.howMany = inc.offset - old.offset; // Add the second part of attribute change to the beginning of processed array so it won't
                // be processed again in this loop.

                changes.unshift({
                  type: 'attribute',
                  offset: incEnd,
                  howMany: howMany - old.howMany,
                  count: this._changeCount++
                });
              }
            }
          }

          if (inc.type == 'remove') {
            if (old.type == 'insert') {
              if (incEnd <= old.offset) {
                old.offset -= inc.howMany;
              } else if (incEnd <= oldEnd) {
                if (inc.offset < old.offset) {
                  var intersectionLength = incEnd - old.offset;
                  old.offset = inc.offset;
                  old.howMany -= intersectionLength;
                  inc.nodesToHandle -= intersectionLength;
                } else {
                  old.howMany -= inc.nodesToHandle;
                  inc.nodesToHandle = 0;
                }
              } else {
                if (inc.offset <= old.offset) {
                  inc.nodesToHandle -= old.howMany;
                  old.howMany = 0;
                } else if (inc.offset < oldEnd) {
                  var _intersectionLength = oldEnd - inc.offset;

                  old.howMany -= _intersectionLength;
                  inc.nodesToHandle -= _intersectionLength;
                }
              }
            }

            if (old.type == 'remove') {
              if (incEnd <= old.offset) {
                old.offset -= inc.howMany;
              } else if (inc.offset < old.offset) {
                inc.nodesToHandle += old.howMany;
                old.howMany = 0;
              }
            }

            if (old.type == 'attribute') {
              if (incEnd <= old.offset) {
                old.offset -= inc.howMany;
              } else if (inc.offset < old.offset) {
                var _intersectionLength2 = incEnd - old.offset;

                old.offset = inc.offset;
                old.howMany -= _intersectionLength2;
              } else if (inc.offset < oldEnd) {
                if (incEnd <= oldEnd) {
                  // On first sight in this case we don't need to split attribute operation into two.
                  // However the changes set is later converted to actions (see `_generateActionsFromChanges`).
                  // For that reason, no two changes may intersect.
                  // So we cannot have an attribute change that "contains" remove change.
                  // Attribute change needs to be split.
                  var _howMany = old.howMany;
                  old.howMany = inc.offset - old.offset;
                  var howManyAfter = _howMany - old.howMany - inc.nodesToHandle; // Add the second part of attribute change to the beginning of processed array so it won't
                  // be processed again in this loop.

                  changes.unshift({
                    type: 'attribute',
                    offset: inc.offset,
                    howMany: howManyAfter,
                    count: this._changeCount++
                  });
                } else {
                  old.howMany -= oldEnd - inc.offset;
                }
              }
            }
          }

          if (inc.type == 'attribute') {
            // In case of attribute change, `howMany` should be kept same as `nodesToHandle`. It's not an error.
            if (old.type == 'insert') {
              if (inc.offset < old.offset && incEnd > old.offset) {
                if (incEnd > oldEnd) {
                  // This case is similar to a case described when incoming change was insert and old change was attribute.
                  // See comment above.
                  //
                  // This time incoming change is attribute. We need to split incoming change in this case too.
                  // However this time, the second part of the attribute change needs to be processed further
                  // because there might be other changes that it collides with.
                  var attributePart = {
                    type: 'attribute',
                    offset: oldEnd,
                    howMany: incEnd - oldEnd,
                    count: this._changeCount++
                  };

                  this._handleChange(attributePart, changes);

                  changes.push(attributePart);
                }

                inc.nodesToHandle = old.offset - inc.offset;
                inc.howMany = inc.nodesToHandle;
              } else if (inc.offset >= old.offset && inc.offset < oldEnd) {
                if (incEnd > oldEnd) {
                  inc.nodesToHandle = incEnd - oldEnd;
                  inc.offset = oldEnd;
                } else {
                  inc.nodesToHandle = 0;
                }
              }
            }

            if (old.type == 'remove') {
              // This is a case when attribute change "contains" remove change.
              // The attribute change needs to be split into two because changes cannot intersect.
              if (inc.offset < old.offset && incEnd > old.offset) {
                var _attributePart = {
                  type: 'attribute',
                  offset: old.offset,
                  howMany: incEnd - old.offset,
                  count: this._changeCount++
                };

                this._handleChange(_attributePart, changes);

                changes.push(_attributePart);
                inc.nodesToHandle = old.offset - inc.offset;
                inc.howMany = inc.nodesToHandle;
              }
            }

            if (old.type == 'attribute') {
              // There are only two conflicting scenarios possible here:
              if (inc.offset >= old.offset && incEnd <= oldEnd) {
                // `old` change includes `inc` change, or they are the same.
                inc.nodesToHandle = 0;
                inc.howMany = 0;
                inc.offset = 0;
              } else if (inc.offset <= old.offset && incEnd >= oldEnd) {
                // `inc` change includes `old` change.
                old.howMany = 0;
              }
            }
          }
        }
      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }

      inc.howMany = inc.nodesToHandle;
      delete inc.nodesToHandle;
    }
    /**
     * Returns an object with a single insert change description.
     *
     * @private
     * @param {module:engine/model/element~Element} parent The element in which the change happened.
     * @param {Number} offset The offset at which change happened.
     * @param {String} name The name of the removed element or `'$text'` for a character.
     * @returns {Object} The diff item.
     */

  }, {
    key: "_getInsertDiff",
    value: function _getInsertDiff(parent, offset, name) {
      return {
        type: 'insert',
        position: model_position_Position._createAt(parent, offset),
        name: name,
        length: 1,
        changeCount: this._changeCount++
      };
    }
    /**
     * Returns an object with a single remove change description.
     *
     * @private
     * @param {module:engine/model/element~Element} parent The element in which change happened.
     * @param {Number} offset The offset at which change happened.
     * @param {String} name The name of the removed element or `'$text'` for a character.
     * @returns {Object} The diff item.
     */

  }, {
    key: "_getRemoveDiff",
    value: function _getRemoveDiff(parent, offset, name) {
      return {
        type: 'remove',
        position: model_position_Position._createAt(parent, offset),
        name: name,
        length: 1,
        changeCount: this._changeCount++
      };
    }
    /**
     * Returns an array of objects where each one is a single attribute change description.
     *
     * @private
     * @param {module:engine/model/range~Range} range The range where the change happened.
     * @param {Map} oldAttributes A map, map iterator or compatible object that contains attributes before the change.
     * @param {Map} newAttributes A map, map iterator or compatible object that contains attributes after the change.
     * @returns {Array.<Object>} An array containing one or more diff items.
     */

  }, {
    key: "_getAttributesDiff",
    value: function _getAttributesDiff(range, oldAttributes, newAttributes) {
      // Results holder.
      var diffs = []; // Clone new attributes as we will be performing changes on this object.

      newAttributes = new Map(newAttributes); // Look through old attributes.

      var _iterator10 = _createForOfIteratorHelper(oldAttributes),
          _step10;

      try {
        for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
          var _step10$value = _slicedToArray(_step10.value, 2),
              key = _step10$value[0],
              oldValue = _step10$value[1];

          // Check what is the new value of the attribute (or if it was removed).
          var newValue = newAttributes.has(key) ? newAttributes.get(key) : null; // If values are different (or attribute was removed)...

          if (newValue !== oldValue) {
            // Add diff item.
            diffs.push({
              type: 'attribute',
              position: range.start,
              range: range.clone(),
              length: 1,
              attributeKey: key,
              attributeOldValue: oldValue,
              attributeNewValue: newValue,
              changeCount: this._changeCount++
            });
          } // Prevent returning two diff items for the same change.


          newAttributes.delete(key);
        } // Look through new attributes that weren't handled above.

      } catch (err) {
        _iterator10.e(err);
      } finally {
        _iterator10.f();
      }

      var _iterator11 = _createForOfIteratorHelper(newAttributes),
          _step11;

      try {
        for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
          var _step11$value = _slicedToArray(_step11.value, 2),
              _key = _step11$value[0],
              _newValue = _step11$value[1];

          // Each of them is a new attribute. Add diff item.
          diffs.push({
            type: 'attribute',
            position: range.start,
            range: range.clone(),
            length: 1,
            attributeKey: _key,
            attributeOldValue: null,
            attributeNewValue: _newValue,
            changeCount: this._changeCount++
          });
        }
      } catch (err) {
        _iterator11.e(err);
      } finally {
        _iterator11.f();
      }

      return diffs;
    }
    /**
     * Checks whether given element or any of its parents is an element that is buffered as an inserted element.
     *
     * @private
     * @param {module:engine/model/element~Element} element Element to check.
     * @returns {Boolean}
     */

  }, {
    key: "_isInInsertedElement",
    value: function _isInInsertedElement(element) {
      var parent = element.parent;

      if (!parent) {
        return false;
      }

      var changes = this._changesInElement.get(parent);

      var offset = element.startOffset;

      if (changes) {
        var _iterator12 = _createForOfIteratorHelper(changes),
            _step12;

        try {
          for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
            var change = _step12.value;

            if (change.type == 'insert' && offset >= change.offset && offset < change.offset + change.howMany) {
              return true;
            }
          }
        } catch (err) {
          _iterator12.e(err);
        } finally {
          _iterator12.f();
        }
      }

      return this._isInInsertedElement(parent);
    }
    /**
     * Removes deeply all buffered changes that are registered in elements from range specified by `parent`, `offset`
     * and `howMany`.
     *
     * @private
     * @param {module:engine/model/element~Element} parent
     * @param {Number} offset
     * @param {Number} howMany
     */

  }, {
    key: "_removeAllNestedChanges",
    value: function _removeAllNestedChanges(parent, offset, howMany) {
      var range = new model_range_Range(model_position_Position._createAt(parent, offset), model_position_Position._createAt(parent, offset + howMany));

      var _iterator13 = _createForOfIteratorHelper(range.getItems({
        shallow: true
      })),
          _step13;

      try {
        for (_iterator13.s(); !(_step13 = _iterator13.n()).done;) {
          var item = _step13.value;

          if (item.is('element')) {
            this._elementSnapshots.delete(item);

            this._changesInElement.delete(item);

            this._removeAllNestedChanges(item, 0, item.maxOffset);
          }
        }
      } catch (err) {
        _iterator13.e(err);
      } finally {
        _iterator13.f();
      }
    }
  }, {
    key: "isEmpty",
    get: function get() {
      return this._changesInElement.size == 0 && this._changedMarkers.size == 0;
    }
  }]);

  return Differ;
}(); // Returns an array that is a copy of passed child list with the exception that text nodes are split to one or more
// objects, each representing one character and attributes set on that character.




function _getChildrenSnapshot(children) {
  var snapshot = [];

  var _iterator14 = _createForOfIteratorHelper(children),
      _step14;

  try {
    for (_iterator14.s(); !(_step14 = _iterator14.n()).done;) {
      var child = _step14.value;

      if (child.is('text')) {
        for (var i = 0; i < child.data.length; i++) {
          snapshot.push({
            name: '$text',
            attributes: new Map(child.getAttributes())
          });
        }
      } else {
        snapshot.push({
          name: child.name,
          attributes: new Map(child.getAttributes())
        });
      }
    }
  } catch (err) {
    _iterator14.e(err);
  } finally {
    _iterator14.f();
  }

  return snapshot;
} // Generates array of actions for given changes set.
// It simulates what `diff` function does.
// Generated actions are:
// - 'e' for 'equal' - when item at that position did not change,
// - 'i' for 'insert' - when item at that position was inserted,
// - 'r' for 'remove' - when item at that position was removed,
// - 'a' for 'attribute' - when item at that position has it attributes changed.
//
// Example (assume that uppercase letters have bold attribute, compare with function code):
//
// children before:	fooBAR
// children after:	foxybAR
//
// changes: type: remove, offset: 1, howMany: 1
//			type: insert, offset: 2, howMany: 2
//			type: attribute, offset: 4, howMany: 1
//
// expected actions: equal (f), remove (o), equal (o), insert (x), insert (y), attribute (b), equal (A), equal (R)
//
// steps taken by th script:
//
// 1. change = "type: remove, offset: 1, howMany: 1"; offset = 0; oldChildrenHandled = 0
//    1.1 between this change and the beginning is one not-changed node, fill with one equal action, one old child has been handled
//    1.2 this change removes one node, add one remove action
//    1.3 change last visited `offset` to 1
//    1.4 since an old child has been removed, one more old child has been handled
//    1.5 actions at this point are: equal, remove
//
// 2. change = "type: insert, offset: 2, howMany: 2"; offset = 1; oldChildrenHandled = 2
//    2.1 between this change and previous change is one not-changed node, add equal action, another one old children has been handled
//    2.2 this change inserts two nodes, add two insert actions
//    2.3 change last visited offset to the end of the inserted range, that is 4
//    2.4 actions at this point are: equal, remove, equal, insert, insert
//
// 3. change = "type: attribute, offset: 4, howMany: 1"; offset = 4, oldChildrenHandled = 3
//    3.1 between this change and previous change are no not-changed nodes
//    3.2 this change changes one node, add one attribute action
//    3.3 change last visited `offset` to the end of change range, that is 5
//    3.4 since an old child has been changed, one more old child has been handled
//    3.5 actions at this point are: equal, remove, equal, insert, insert, attribute
//
// 4. after loop oldChildrenHandled = 4, oldChildrenLength = 6 (fooBAR is 6 characters)
//    4.1 fill up with two equal actions
//
// The result actions are: equal, remove, equal, insert, insert, attribute, equal, equal.


function _generateActionsFromChanges(oldChildrenLength, changes) {
  var actions = [];
  var offset = 0;
  var oldChildrenHandled = 0; // Go through all buffered changes.

  var _iterator15 = _createForOfIteratorHelper(changes),
      _step15;

  try {
    for (_iterator15.s(); !(_step15 = _iterator15.n()).done;) {
      var change = _step15.value;

      // First, fill "holes" between changes with "equal" actions.
      if (change.offset > offset) {
        for (var _i3 = 0; _i3 < change.offset - offset; _i3++) {
          actions.push('e');
        }

        oldChildrenHandled += change.offset - offset;
      } // Then, fill up actions accordingly to change type.


      if (change.type == 'insert') {
        for (var _i4 = 0; _i4 < change.howMany; _i4++) {
          actions.push('i');
        } // The last handled offset is after inserted range.


        offset = change.offset + change.howMany;
      } else if (change.type == 'remove') {
        for (var _i5 = 0; _i5 < change.howMany; _i5++) {
          actions.push('r');
        } // The last handled offset is at the position where the nodes were removed.


        offset = change.offset; // We removed `howMany` old nodes, update `oldChildrenHandled`.

        oldChildrenHandled += change.howMany;
      } else {
        actions.push.apply(actions, _toConsumableArray('a'.repeat(change.howMany).split(''))); // The last handled offset is at the position after the changed range.

        offset = change.offset + change.howMany; // We changed `howMany` old nodes, update `oldChildrenHandled`.

        oldChildrenHandled += change.howMany;
      }
    } // Fill "equal" actions at the end of actions set. Use `oldChildrenHandled` to see how many children
    // has not been changed / removed at the end of their parent.

  } catch (err) {
    _iterator15.e(err);
  } finally {
    _iterator15.f();
  }

  if (oldChildrenHandled < oldChildrenLength) {
    for (var i = 0; i < oldChildrenLength - oldChildrenHandled - offset; i++) {
      actions.push('e');
    }
  }

  return actions;
} // Filter callback for Array.filter that filters out change entries that are in graveyard.


function _changesInGraveyardFilter(entry) {
  var posInGy = entry.position && entry.position.root.rootName == '$graveyard';
  var rangeInGy = entry.range && entry.range.root.rootName == '$graveyard';
  return !posInGy && !rangeInGy;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/history.js













/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/history
 */

/**
 * `History` keeps the track of all the operations applied to the {@link module:engine/model/document~Document document}.
 */
var history_History = /*#__PURE__*/function () {
  /**
   * Creates an empty History instance.
   */
  function History() {
    Object(classCallCheck["a" /* default */])(this, History);

    /**
     * Operations added to the history.
     *
     * @protected
     * @member {Array.<module:engine/model/operation/operation~Operation>} module:engine/model/history~History#_operations
     */
    this._operations = [];
    /**
     * Holds an information which {@link module:engine/model/operation/operation~Operation operation} undoes which
     * {@link module:engine/model/operation/operation~Operation operation}.
     *
     * Keys of the map are "undoing operations", that is operations that undone some other operations. For each key, the
     * value is an operation that has been undone by the "undoing operation".
     *
     * @private
     * @member {Map} module:engine/model/history~History#_undoPairs
     */

    this._undoPairs = new Map();
    /**
     * Holds all undone operations.
     *
     * @private
     * @member {Set.<module:engine/model/operation/operation~Operation>} module:engine/model/history~History#_undoneOperations
     */

    this._undoneOperations = new Set();
  }
  /**
   * Adds an operation to the history.
   *
   * @param {module:engine/model/operation/operation~Operation} operation Operation to add.
   */


  Object(createClass["a" /* default */])(History, [{
    key: "addOperation",
    value: function addOperation(operation) {
      if (this._operations.includes(operation)) {
        return;
      }

      this._operations.push(operation);
    }
    /**
     * Returns operations added to the history.
     *
     * @param {Number} [from=0] Base version from which operations should be returned (inclusive). Defaults to `0`, which means
     * that operations from the first one will be returned.
     * @param {Number} [to=Number.POSITIVE_INFINITY] Base version up to which operations should be returned (exclusive).
     * Defaults to `Number.POSITIVE_INFINITY` which means that operations up to the last one will be returned.
     * @returns {Iterable.<module:engine/model/operation/operation~Operation>} Operations added to the history.
     */

  }, {
    key: "getOperations",
    value: function getOperations() {
      var from = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
      var to = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : Number.POSITIVE_INFINITY;

      if (from < 0) {
        return [];
      }

      return this._operations.slice(from, to);
    }
    /**
     * Returns operation from the history that bases on given `baseVersion`.
     *
     * @param {Number} baseVersion Base version of the operation to get.
     * @returns {module:engine/model/operation/operation~Operation|null} Operation with given base version or `null` if
     * there is no such operation in history.
     */

  }, {
    key: "getOperation",
    value: function getOperation(baseVersion) {
      return this._operations[baseVersion];
    }
    /**
     * Marks in history that one operation is an operation that is undoing the other operation. By marking operation this way,
     * history is keeping more context information about operations, which helps in operational transformation.
     *
     * @param {module:engine/model/operation/operation~Operation} undoneOperation Operation which is undone by `undoingOperation`.
     * @param {module:engine/model/operation/operation~Operation} undoingOperation Operation which undoes `undoneOperation`.
     */

  }, {
    key: "setOperationAsUndone",
    value: function setOperationAsUndone(undoneOperation, undoingOperation) {
      this._undoPairs.set(undoingOperation, undoneOperation);

      this._undoneOperations.add(undoneOperation);
    }
    /**
     * Checks whether given `operation` is undoing any other operation.
     *
     * @param {module:engine/model/operation/operation~Operation} operation Operation to check.
     * @returns {Boolean} `true` if given `operation` is undoing any other operation, `false` otherwise.
     */

  }, {
    key: "isUndoingOperation",
    value: function isUndoingOperation(operation) {
      return this._undoPairs.has(operation);
    }
    /**
     * Checks whether given `operation` has been undone by any other operation.
     *
     * @param {module:engine/model/operation/operation~Operation} operation Operation to check.
     * @returns {Boolean} `true` if given `operation` has been undone any other operation, `false` otherwise.
     */

  }, {
    key: "isUndoneOperation",
    value: function isUndoneOperation(operation) {
      return this._undoneOperations.has(operation);
    }
    /**
     * For given `undoingOperation`, returns the operation which has been undone by it.
     *
     * @param {module:engine/model/operation/operation~Operation} undoingOperation
     * @returns {module:engine/model/operation/operation~Operation|undefined} Operation that has been undone by given
     * `undoingOperation` or `undefined` if given `undoingOperation` is not undoing any other operation.
     */

  }, {
    key: "getUndoneOperation",
    value: function getUndoneOperation(undoingOperation) {
      return this._undoPairs.get(undoingOperation);
    }
  }]);

  return History;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/unicode.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * Set of utils to handle unicode characters.
 *
 * @module utils/unicode
 */

/**
 * Checks whether given `character` is a combining mark.
 *
 * @param {String} character Character to check.
 * @returns {Boolean}
 */
function isCombiningMark(character) {
  // eslint-disable-next-line no-misleading-character-class
  return !!character && character.length == 1 && /[\u0300-\u036f\u1ab0-\u1aff\u1dc0-\u1dff\u20d0-\u20ff\ufe20-\ufe2f]/.test(character);
}
/**
 * Checks whether given `character` is a high half of surrogate pair.
 *
 * Using UTF-16 terminology, a surrogate pair denotes UTF-16 character using two UTF-8 characters. The surrogate pair
 * consist of high surrogate pair character followed by low surrogate pair character.
 *
 * @param {String} character Character to check.
 * @returns {Boolean}
 */

function isHighSurrogateHalf(character) {
  return !!character && character.length == 1 && /[\ud800-\udbff]/.test(character);
}
/**
 * Checks whether given `character` is a low half of surrogate pair.
 *
 * Using UTF-16 terminology, a surrogate pair denotes UTF-16 character using two UTF-8 characters. The surrogate pair
 * consist of high surrogate pair character followed by low surrogate pair character.
 *
 * @param {String} character Character to check.
 * @returns {Boolean}
 */

function isLowSurrogateHalf(character) {
  return !!character && character.length == 1 && /[\udc00-\udfff]/.test(character);
}
/**
 * Checks whether given offset in a string is inside a surrogate pair (between two surrogate halves).
 *
 * @param {String} string String to check.
 * @param {Number} offset Offset to check.
 * @returns {Boolean}
 */

function isInsideSurrogatePair(string, offset) {
  return isHighSurrogateHalf(string.charAt(offset - 1)) && isLowSurrogateHalf(string.charAt(offset));
}
/**
 * Checks whether given offset in a string is between base character and combining mark or between two combining marks.
 *
 * @param {String} string String to check.
 * @param {Number} offset Offset to check.
 * @returns {Boolean}
 */

function isInsideCombinedSymbol(string, offset) {
  return isCombiningMark(string.charAt(offset));
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/document.js












/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/document
 */









 // @if CK_DEBUG_ENGINE // const { logDocument } = require( '../dev-utils/utils' );

var graveyardName = '$graveyard';
/**
 * Data model's document. It contains the model's structure, its selection and the history of changes.
 *
 * Read more about working with the model in
 * {@glink framework/guides/architecture/editing-engine#model introduction to the the editing engine's architecture}.
 *
 * Usually, the document contains just one {@link module:engine/model/document~Document#roots root element}, so
 * you can retrieve it by just calling {@link module:engine/model/document~Document#getRoot} without specifying its name:
 *
 *		model.document.getRoot(); // -> returns the main root
 *
 * However, the document may contain multiple roots – e.g. when the editor has multiple editable areas
 * (e.g. a title and a body of a message).
 *
 * @mixes module:utils/emittermixin~EmitterMixin
 */

var model_document_Document = /*#__PURE__*/function () {
  /**
   * Creates an empty document instance with no {@link #roots} (other than
   * the {@link #graveyard graveyard root}).
   */
  function Document(model) {
    var _this = this;

    Object(classCallCheck["a" /* default */])(this, Document);

    /**
     * The {@link module:engine/model/model~Model model} that the document is a part of.
     *
     * @readonly
     * @type {module:engine/model/model~Model}
     */
    this.model = model;
    /**
     * The document version. It starts from `0` and every operation increases the version number. It is used to ensure that
     * operations are applied on a proper document version.
     *
     * If the {@link module:engine/model/operation/operation~Operation#baseVersion base version} does not match the document version,
     * a {@link module:utils/ckeditorerror~CKEditorError model-document-applyOperation-wrong-version} error is thrown.
     *
     * @type {Number}
     */

    this.version = 0;
    /**
     * The document's history.
     *
     * @readonly
     * @type {module:engine/model/history~History}
     */

    this.history = new history_History(this);
    /**
     * The selection in this document.
     *
     * @readonly
     * @type {module:engine/model/documentselection~DocumentSelection}
     */

    this.selection = new model_documentselection_DocumentSelection(this);
    /**
     * A list of roots that are owned and managed by this document. Use {@link #createRoot} and
     * {@link #getRoot} to manipulate it.
     *
     * @readonly
     * @type {module:utils/collection~Collection}
     */

    this.roots = new collection_Collection({
      idProperty: 'rootName'
    });
    /**
     * The model differ object. Its role is to buffer changes done on the model document and then calculate a diff of those changes.
     *
     * @readonly
     * @type {module:engine/model/differ~Differ}
     */

    this.differ = new differ_Differ(model.markers);
    /**
     * Post-fixer callbacks registered to the model document.
     *
     * @private
     * @type {Set.<Function>}
     */

    this._postFixers = new Set();
    /**
     * A boolean indicates whether the selection has changed until
     *
     * @private
     * @type {Boolean}
     */

    this._hasSelectionChangedFromTheLastChangeBlock = false; // Graveyard tree root. Document always have a graveyard root, which stores removed nodes.

    this.createRoot('$root', graveyardName); // First, if the operation is a document operation check if it's base version is correct.

    this.listenTo(model, 'applyOperation', function (evt, args) {
      var operation = args[0];

      if (operation.isDocumentOperation && operation.baseVersion !== _this.version) {
        /**
         * Only operations with matching versions can be applied.
         *
         * @error document-applyOperation-wrong-version
         * @param {module:engine/model/operation/operation~Operation} operation
         */
        throw new ckeditorerror["b" /* default */]('model-document-applyOperation-wrong-version: Only operations with matching versions can be applied.', _this, {
          operation: operation
        });
      }
    }, {
      priority: 'highest'
    }); // Then, still before an operation is applied on model, buffer the change in differ.

    this.listenTo(model, 'applyOperation', function (evt, args) {
      var operation = args[0];

      if (operation.isDocumentOperation) {
        _this.differ.bufferOperation(operation);
      }
    }, {
      priority: 'high'
    }); // After the operation is applied, bump document's version and add the operation to the history.

    this.listenTo(model, 'applyOperation', function (evt, args) {
      var operation = args[0];

      if (operation.isDocumentOperation) {
        _this.version++;

        _this.history.addOperation(operation);
      }
    }, {
      priority: 'low'
    }); // Listen to selection changes. If selection changed, mark it.

    this.listenTo(this.selection, 'change', function () {
      _this._hasSelectionChangedFromTheLastChangeBlock = true;
    }); // Buffer marker changes.
    // This is not covered in buffering operations because markers may change outside of them (when they
    // are modified using `model.markers` collection, not through `MarkerOperation`).

    this.listenTo(model.markers, 'update', function (evt, marker, oldRange, newRange) {
      // Whenever marker is updated, buffer that change.
      _this.differ.bufferMarkerChange(marker.name, oldRange, newRange, marker.affectsData);

      if (oldRange === null) {
        // If this is a new marker, add a listener that will buffer change whenever marker changes.
        marker.on('change', function (evt, oldRange) {
          _this.differ.bufferMarkerChange(marker.name, oldRange, marker.getRange(), marker.affectsData);
        });
      }
    });
  }
  /**
   * The graveyard tree root. A document always has a graveyard root that stores removed nodes.
   *
   * @readonly
   * @member {module:engine/model/rootelement~RootElement}
   */


  Object(createClass["a" /* default */])(Document, [{
    key: "createRoot",

    /**
     * Creates a new root.
     *
     * @param {String} [elementName='$root'] The element name. Defaults to `'$root'` which also has some basic schema defined
     * (`$block`s are allowed inside the `$root`). Make sure to define a proper schema if you use a different name.
     * @param {String} [rootName='main'] A unique root name.
     * @returns {module:engine/model/rootelement~RootElement} The created root.
     */
    value: function createRoot() {
      var elementName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '$root';
      var rootName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'main';

      if (this.roots.get(rootName)) {
        /**
         * A root with the specified name already exists.
         *
         * @error model-document-createRoot-name-exists
         * @param {module:engine/model/document~Document} doc
         * @param {String} name
         */
        throw new ckeditorerror["b" /* default */]('model-document-createRoot-name-exists: Root with specified name already exists.', this, {
          name: rootName
        });
      }

      var root = new rootelement_RootElement(this, elementName, rootName);
      this.roots.add(root);
      return root;
    }
    /**
     * Removes all event listeners set by the document instance.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.selection.destroy();
      this.stopListening();
    }
    /**
     * Returns a root by its name.
     *
     * @param {String} [name='main'] A unique root name.
     * @returns {module:engine/model/rootelement~RootElement|null} The root registered under a given name or `null` when
     * there is no root with the given name.
     */

  }, {
    key: "getRoot",
    value: function getRoot() {
      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';
      return this.roots.get(name);
    }
    /**
     * Returns an array with names of all roots (without the {@link #graveyard}) added to the document.
     *
     * @returns {Array.<String>} Roots names.
     */

  }, {
    key: "getRootNames",
    value: function getRootNames() {
      return Array.from(this.roots, function (root) {
        return root.rootName;
      }).filter(function (name) {
        return name != graveyardName;
      });
    }
    /**
     * Used to register a post-fixer callback. A post-fixer mechanism guarantees that the features
     * will operate on a correct model state.
     *
     * An execution of a feature may lead to an incorrect document tree state. The callbacks are used to fix the document tree after
     * it has changed. Post-fixers are fired just after all changes from the outermost change block were applied but
     * before the {@link module:engine/model/document~Document#event:change change event} is fired. If a post-fixer callback made
     * a change, it should return `true`. When this happens, all post-fixers are fired again to check if something else should
     * not be fixed in the new document tree state.
     *
     * As a parameter, a post-fixer callback receives a {@link module:engine/model/writer~Writer writer} instance connected with the
     * executed changes block. Thanks to that, all changes done by the callback will be added to the same
     * {@link module:engine/model/batch~Batch batch} (and undo step) as the original changes. This makes post-fixer changes transparent
     * for the user.
     *
     * An example of a post-fixer is a callback that checks if all the data were removed from the editor. If so, the
     * callback should add an empty paragraph so that the editor is never empty:
     *
     *		document.registerPostFixer( writer => {
     *			const changes = document.differ.getChanges();
     *
     *			// Check if the changes lead to an empty root in the editor.
     *			for ( const entry of changes ) {
     *				if ( entry.type == 'remove' && entry.position.root.isEmpty ) {
     *					writer.insertElement( 'paragraph', entry.position.root, 0 );
     *
     *					// It is fine to return early, even if multiple roots would need to be fixed.
     *					// All post-fixers will be fired again, so if there are more empty roots, those will be fixed, too.
     *					return true;
     *				}
     *			}
     *		} );
     *
     * @param {Function} postFixer
     */

  }, {
    key: "registerPostFixer",
    value: function registerPostFixer(postFixer) {
      this._postFixers.add(postFixer);
    }
    /**
     * A custom `toJSON()` method to solve child-parent circular dependencies.
     *
     * @returns {Object} A clone of this object with the document property changed to a string.
     */

  }, {
    key: "toJSON",
    value: function toJSON() {
      var json = lodash_es_clone(this); // Due to circular references we need to remove parent reference.

      json.selection = '[engine.model.DocumentSelection]';
      json.model = '[engine.model.Model]';
      return json;
    }
    /**
     * Check if there were any changes done on document, and if so, call post-fixers,
     * fire `change` event for features and conversion and then reset the differ.
     * Fire `change:data` event when at least one operation or buffered marker changes the data.
     *
     * @protected
     * @fires change
     * @fires change:data
     * @param {module:engine/model/writer~Writer} writer The writer on which post-fixers will be called.
     */

  }, {
    key: "_handleChangeBlock",
    value: function _handleChangeBlock(writer) {
      if (this._hasDocumentChangedFromTheLastChangeBlock()) {
        this._callPostFixers(writer); // Refresh selection attributes according to the final position in the model after the change.


        this.selection.refresh();

        if (this.differ.hasDataChanges()) {
          this.fire('change:data', writer.batch);
        } else {
          this.fire('change', writer.batch);
        } // Theoretically, it is not necessary to refresh selection after change event because
        // post-fixers are the last who should change the model, but just in case...


        this.selection.refresh();
        this.differ.reset();
      }

      this._hasSelectionChangedFromTheLastChangeBlock = false;
    }
    /**
     * Returns whether there is a buffered change or if the selection has changed from the last
     * {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block}
     * or {@link module:engine/model/model~Model#change `change()` block}.
     *
     * @protected
     * @returns {Boolean} Returns `true` if document has changed from the last `change()` or `enqueueChange()` block.
     */

  }, {
    key: "_hasDocumentChangedFromTheLastChangeBlock",
    value: function _hasDocumentChangedFromTheLastChangeBlock() {
      return !this.differ.isEmpty || this._hasSelectionChangedFromTheLastChangeBlock;
    }
    /**
     * Returns the default root for this document which is either the first root that was added to the document using
     * {@link #createRoot} or the {@link #graveyard graveyard root} if no other roots were created.
     *
     * @protected
     * @returns {module:engine/model/rootelement~RootElement} The default root for this document.
     */

  }, {
    key: "_getDefaultRoot",
    value: function _getDefaultRoot() {
      var _iterator = _createForOfIteratorHelper(this.roots),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var root = _step.value;

          if (root !== this.graveyard) {
            return root;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return this.graveyard;
    }
    /**
     * Returns the default range for this selection. The default range is a collapsed range that starts and ends
     * at the beginning of this selection's document {@link #_getDefaultRoot default root}.
     *
     * @protected
     * @returns {module:engine/model/range~Range}
     */

  }, {
    key: "_getDefaultRange",
    value: function _getDefaultRange() {
      var defaultRoot = this._getDefaultRoot();

      var model = this.model;
      var schema = model.schema; // Find the first position where the selection can be put.

      var position = model.createPositionFromPath(defaultRoot, [0]);
      var nearestRange = schema.getNearestSelectionRange(position); // If valid selection range is not found - return range collapsed at the beginning of the root.

      return nearestRange || model.createRange(position);
    }
    /**
     * Checks whether a given {@link module:engine/model/range~Range range} is a valid range for
     * the {@link #selection document's selection}.
     *
     * @private
     * @param {module:engine/model/range~Range} range A range to check.
     * @returns {Boolean} `true` if `range` is valid, `false` otherwise.
     */

  }, {
    key: "_validateSelectionRange",
    value: function _validateSelectionRange(range) {
      return validateTextNodePosition(range.start) && validateTextNodePosition(range.end);
    }
    /**
     * Performs post-fixer loops. Executes post-fixer callbacks as long as none of them has done any changes to the model.
     *
     * @private
     * @param {module:engine/model/writer~Writer} writer The writer on which post-fixer callbacks will be called.
     */

  }, {
    key: "_callPostFixers",
    value: function _callPostFixers(writer) {
      var wasFixed = false;

      do {
        var _iterator2 = _createForOfIteratorHelper(this._postFixers),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var callback = _step2.value;
            // Ensure selection attributes are up to date before each post-fixer.
            // https://github.com/ckeditor/ckeditor5-engine/issues/1673.
            //
            // It might be good to refresh the selection after each operation but at the moment it leads
            // to losing attributes for composition or and spell checking
            // https://github.com/ckeditor/ckeditor5-typing/issues/188
            this.selection.refresh();
            wasFixed = callback(writer);

            if (wasFixed) {
              break;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      } while (wasFixed);
    }
    /**
     * Fired after each {@link module:engine/model/model~Model#enqueueChange `enqueueChange()` block} or the outermost
     * {@link module:engine/model/model~Model#change `change()` block} was executed and the document was changed
     * during that block's execution.
     *
     * The changes which this event will cover include:
     *
     * * document structure changes,
     * * selection changes,
     * * marker changes.
     *
     * If you want to be notified about all these changes, then simply listen to this event like this:
     *
     *		model.document.on( 'change', () => {
     *			console.log( 'The document has changed!' );
     *		} );
     *
     * If, however, you only want to be notified about the data changes, then use the
     * {@link module:engine/model/document~Document#event:change:data change:data} event,
     * which is fired for document structure changes and marker changes (which affects the data).
     *
     *		model.document.on( 'change:data', () => {
     *			console.log( 'The data has changed!' );
     *		} );
     *
     * @event change
     * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.
     */

    /**
     * It is a narrower version of the {@link #event:change} event. It is fired for changes which
     * affect the editor data. This is:
     *
     * * document structure changes,
     * * marker changes (which affects the data).
     *
     * If you want to be notified about the data changes, then listen to this event:
     *
     *		model.document.on( 'change:data', () => {
     *			console.log( 'The data has changed!' );
     *		} );
     *
     * If you would like to listen to all document changes, then check out the
     * {@link module:engine/model/document~Document#event:change change} event.
     *
     * @event change:data
     * @param {module:engine/model/batch~Batch} batch The batch that was used in the executed changes block.
     */
    // @if CK_DEBUG_ENGINE // log( version = null ) {
    // @if CK_DEBUG_ENGINE // 	version = version === null ? this.version : version;
    // @if CK_DEBUG_ENGINE // 	logDocument( this, version );
    // @if CK_DEBUG_ENGINE // }

  }, {
    key: "graveyard",
    get: function get() {
      return this.getRoot(graveyardName);
    }
  }]);

  return Document;
}();


mix(model_document_Document, emittermixin); // Checks whether given range boundary position is valid for document selection, meaning that is not between
// unicode surrogate pairs or base character and combining marks.

function validateTextNodePosition(rangeBoundary) {
  var textNode = rangeBoundary.textNode;

  if (textNode) {
    var data = textNode.data;
    var offset = rangeBoundary.offset - textNode.startOffset;
    return !isInsideSurrogatePair(data, offset) && !isInsideCombinedSymbol(data, offset);
  }

  return true;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/markercollection.js















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/markercollection
 */




/**
 * The collection of all {@link module:engine/model/markercollection~Marker markers} attached to the document.
 * It lets you {@link module:engine/model/markercollection~MarkerCollection#get get} markers or track them using
 * {@link module:engine/model/markercollection~MarkerCollection#event:update} event.
 *
 * To create, change or remove makers use {@link module:engine/model/writer~Writer model writers'} methods:
 * {@link module:engine/model/writer~Writer#addMarker} or {@link module:engine/model/writer~Writer#removeMarker}. Since
 * the writer is the only proper way to change the data model it is not possible to change markers directly using this
 * collection. All markers created by the writer will be automatically added to this collection.
 *
 * By default there is one marker collection available as {@link module:engine/model/model~Model#markers model property}.
 *
 * @see module:engine/model/markercollection~Marker
 */

var markercollection_MarkerCollection = /*#__PURE__*/function () {
  /**
   * Creates a markers collection.
   */
  function MarkerCollection() {
    Object(classCallCheck["a" /* default */])(this, MarkerCollection);

    /**
     * Stores {@link ~Marker markers} added to the collection.
     *
     * @private
     * @member {Map} #_markers
     */
    this._markers = new Map();
  }
  /**
   * Iterable interface.
   *
   * Iterates over all {@link ~Marker markers} added to the collection.
   *
   * @returns {Iterable}
   */


  Object(createClass["a" /* default */])(MarkerCollection, [{
    key: Symbol.iterator,
    value: function value() {
      return this._markers.values();
    }
    /**
     * Checks if marker with given `markerName` is in the collection.
     *
     * @param {String} markerName Marker name.
     * @returns {Boolean} `true` if marker with given `markerName` is in the collection, `false` otherwise.
     */

  }, {
    key: "has",
    value: function has(markerName) {
      return this._markers.has(markerName);
    }
    /**
     * Returns {@link ~Marker marker} with given `markerName`.
     *
     * @param {String} markerName Name of marker to get.
     * @returns {module:engine/model/markercollection~Marker|null} Marker with given name or `null` if such marker was
     * not added to the collection.
     */

  }, {
    key: "get",
    value: function get(markerName) {
      return this._markers.get(markerName) || null;
    }
    /**
     * Creates and adds a {@link ~Marker marker} to the `MarkerCollection` with given name on given
     * {@link module:engine/model/range~Range range}.
     *
     * If `MarkerCollection` already had a marker with given name (or {@link ~Marker marker} was passed), the marker in
     * collection is updated and {@link module:engine/model/markercollection~MarkerCollection#event:update} event is fired
     * but only if there was a change (marker range or {@link module:engine/model/markercollection~Marker#managedUsingOperations}
     * flag has changed.
     *
     * @protected
     * @fires module:engine/model/markercollection~MarkerCollection#event:update
     * @param {String|module:engine/model/markercollection~Marker} markerOrName Name of marker to set or marker instance to update.
     * @param {module:engine/model/range~Range} range Marker range.
     * @param {Boolean} [managedUsingOperations=false] Specifies whether the marker is managed using operations.
     * @param {Boolean} [affectsData=false] Specifies whether the marker affects the data produced by the data pipeline
     * (is persisted in the editor's data).
     * @returns {module:engine/model/markercollection~Marker} `Marker` instance which was added or updated.
     */

  }, {
    key: "_set",
    value: function _set(markerOrName, range) {
      var managedUsingOperations = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var affectsData = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
      var markerName = markerOrName instanceof markercollection_Marker ? markerOrName.name : markerOrName;

      var oldMarker = this._markers.get(markerName);

      if (oldMarker) {
        var oldRange = oldMarker.getRange();
        var hasChanged = false;

        if (!oldRange.isEqual(range)) {
          oldMarker._attachLiveRange(liverange_LiveRange.fromRange(range));

          hasChanged = true;
        }

        if (managedUsingOperations != oldMarker.managedUsingOperations) {
          oldMarker._managedUsingOperations = managedUsingOperations;
          hasChanged = true;
        }

        if (typeof affectsData === 'boolean' && affectsData != oldMarker.affectsData) {
          oldMarker._affectsData = affectsData;
          hasChanged = true;
        }

        if (hasChanged) {
          this.fire('update:' + markerName, oldMarker, oldRange, range);
        }

        return oldMarker;
      }

      var liveRange = liverange_LiveRange.fromRange(range);
      var marker = new markercollection_Marker(markerName, liveRange, managedUsingOperations, affectsData);

      this._markers.set(markerName, marker);

      this.fire('update:' + markerName, marker, null, range);
      return marker;
    }
    /**
     * Removes given {@link ~Marker marker} or a marker with given name from the `MarkerCollection`.
     *
     * @protected
     * @fires module:engine/model/markercollection~MarkerCollection#event:update
     * @param {String} markerOrName Marker or name of a marker to remove.
     * @returns {Boolean} `true` if marker was found and removed, `false` otherwise.
     */

  }, {
    key: "_remove",
    value: function _remove(markerOrName) {
      var markerName = markerOrName instanceof markercollection_Marker ? markerOrName.name : markerOrName;

      var oldMarker = this._markers.get(markerName);

      if (oldMarker) {
        this._markers.delete(markerName);

        this.fire('update:' + markerName, oldMarker, oldMarker.getRange(), null);

        this._destroyMarker(oldMarker);

        return true;
      }

      return false;
    }
    /**
     * Fires an {@link module:engine/model/markercollection~MarkerCollection#event:update} event for the given {@link ~Marker marker}
     * but does not change the marker. Useful to force {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast
     * conversion} for the marker.
     *
     * @protected
     * @fires module:engine/model/markercollection~MarkerCollection#event:update
     * @param {String} markerOrName Marker or name of a marker to refresh.
     */

  }, {
    key: "_refresh",
    value: function _refresh(markerOrName) {
      var markerName = markerOrName instanceof markercollection_Marker ? markerOrName.name : markerOrName;

      var marker = this._markers.get(markerName);

      if (!marker) {
        throw new ckeditorerror["b" /* default */]('markercollection-refresh-marker-not-exists: Marker with provided name does not exists.', this);
      }

      var range = marker.getRange();
      this.fire('update:' + markerName, marker, range, range, marker.managedUsingOperations, marker.affectsData);
    }
    /**
     * Returns iterator that iterates over all markers, which ranges contain given {@link module:engine/model/position~Position position}.
     *
     * @param {module:engine/model/position~Position} position
     * @returns {Iterable.<module:engine/model/markercollection~Marker>}
     */

  }, {
    key: "getMarkersAtPosition",
    value: /*#__PURE__*/regeneratorRuntime.mark(function getMarkersAtPosition(position) {
      var _iterator, _step, marker;

      return regeneratorRuntime.wrap(function getMarkersAtPosition$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _iterator = _createForOfIteratorHelper(this);
              _context.prev = 1;

              _iterator.s();

            case 3:
              if ((_step = _iterator.n()).done) {
                _context.next = 10;
                break;
              }

              marker = _step.value;

              if (!marker.getRange().containsPosition(position)) {
                _context.next = 8;
                break;
              }

              _context.next = 8;
              return marker;

            case 8:
              _context.next = 3;
              break;

            case 10:
              _context.next = 15;
              break;

            case 12:
              _context.prev = 12;
              _context.t0 = _context["catch"](1);

              _iterator.e(_context.t0);

            case 15:
              _context.prev = 15;

              _iterator.f();

              return _context.finish(15);

            case 18:
            case "end":
              return _context.stop();
          }
        }
      }, getMarkersAtPosition, this, [[1, 12, 15, 18]]);
    })
    /**
     * Returns iterator that iterates over all markers, which intersects with given {@link module:engine/model/range~Range range}.
     *
     * @param {module:engine/model/range~Range} range
     * @returns {Iterable.<module:engine/model/markercollection~Marker>}
     */

  }, {
    key: "getMarkersIntersectingRange",
    value: /*#__PURE__*/regeneratorRuntime.mark(function getMarkersIntersectingRange(range) {
      var _iterator2, _step2, marker;

      return regeneratorRuntime.wrap(function getMarkersIntersectingRange$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _iterator2 = _createForOfIteratorHelper(this);
              _context2.prev = 1;

              _iterator2.s();

            case 3:
              if ((_step2 = _iterator2.n()).done) {
                _context2.next = 10;
                break;
              }

              marker = _step2.value;

              if (!(marker.getRange().getIntersection(range) !== null)) {
                _context2.next = 8;
                break;
              }

              _context2.next = 8;
              return marker;

            case 8:
              _context2.next = 3;
              break;

            case 10:
              _context2.next = 15;
              break;

            case 12:
              _context2.prev = 12;
              _context2.t0 = _context2["catch"](1);

              _iterator2.e(_context2.t0);

            case 15:
              _context2.prev = 15;

              _iterator2.f();

              return _context2.finish(15);

            case 18:
            case "end":
              return _context2.stop();
          }
        }
      }, getMarkersIntersectingRange, this, [[1, 12, 15, 18]]);
    })
    /**
     * Destroys marker collection and all markers inside it.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      var _iterator3 = _createForOfIteratorHelper(this._markers.values()),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var marker = _step3.value;

          this._destroyMarker(marker);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this._markers = null;
      this.stopListening();
    }
    /**
     * Iterates over all markers that starts with given `prefix`.
     *
     *		const markerFooA = markersCollection.set( 'foo:a', rangeFooA );
     *		const markerFooB = markersCollection.set( 'foo:b', rangeFooB );
     *		const markerBarA = markersCollection.set( 'bar:a', rangeBarA );
     *		const markerFooBarA = markersCollection.set( 'foobar:a', rangeFooBarA );
     *		Array.from( markersCollection.getMarkersGroup( 'foo' ) ); // [ markerFooA, markerFooB ]
     *		Array.from( markersCollection.getMarkersGroup( 'a' ) ); // []
     *
     * @param prefix
     * @returns {Iterable.<module:engine/model/markercollection~Marker>}
     */

  }, {
    key: "getMarkersGroup",
    value: /*#__PURE__*/regeneratorRuntime.mark(function getMarkersGroup(prefix) {
      var _iterator4, _step4, marker;

      return regeneratorRuntime.wrap(function getMarkersGroup$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _iterator4 = _createForOfIteratorHelper(this._markers.values());
              _context3.prev = 1;

              _iterator4.s();

            case 3:
              if ((_step4 = _iterator4.n()).done) {
                _context3.next = 10;
                break;
              }

              marker = _step4.value;

              if (!marker.name.startsWith(prefix + ':')) {
                _context3.next = 8;
                break;
              }

              _context3.next = 8;
              return marker;

            case 8:
              _context3.next = 3;
              break;

            case 10:
              _context3.next = 15;
              break;

            case 12:
              _context3.prev = 12;
              _context3.t0 = _context3["catch"](1);

              _iterator4.e(_context3.t0);

            case 15:
              _context3.prev = 15;

              _iterator4.f();

              return _context3.finish(15);

            case 18:
            case "end":
              return _context3.stop();
          }
        }
      }, getMarkersGroup, this, [[1, 12, 15, 18]]);
    })
    /**
     * Destroys the marker.
     *
     * @private
     * @param {module:engine/model/markercollection~Marker} marker Marker to destroy.
     */

  }, {
    key: "_destroyMarker",
    value: function _destroyMarker(marker) {
      marker.stopListening();

      marker._detachLiveRange();
    }
    /**
     * Fired whenever marker is added, updated or removed from `MarkerCollection`.
     *
     * @event update
     * @param {module:engine/model/markercollection~Marker} marker Updated Marker.
     * @param {module:engine/model/range~Range|null} oldRange Marker range before the update. When is not defined it
     * means that marker is just added.
     * @param {module:engine/model/range~Range|null} newRange Marker range after update. When is not defined it
     * means that marker is just removed.
     */

  }]);

  return MarkerCollection;
}();


mix(markercollection_MarkerCollection, emittermixin);
/**
 * `Marker` is a continuous parts of model (like a range), is named and represent some kind of information about marked
 * part of model document. In contrary to {@link module:engine/model/node~Node nodes}, which are building blocks of
 * model document tree, markers are not stored directly in document tree but in
 * {@link module:engine/model/model~Model#markers model markers' collection}. Still, they are document data, by giving
 * additional meaning to the part of a model document between marker start and marker end.
 *
 * In this sense, markers are similar to adding and converting attributes on nodes. The difference is that attribute is
 * connected with a given node (e.g. a character is bold no matter if it gets moved or content around it changes).
 * Markers on the other hand are continuous ranges and are characterized by their start and end position. This means that
 * any character in the marker is marked by the marker. For example, if a character is moved outside of marker it stops being
 * "special" and the marker is shrunk. Similarly, when a character is moved into the marker from other place in document
 * model, it starts being "special" and the marker is enlarged.
 *
 * Another upside of markers is that finding marked part of document is fast and easy. Using attributes to mark some nodes
 * and then trying to find that part of document would require traversing whole document tree. Marker gives instant access
 * to the range which it is marking at the moment.
 *
 * Markers are built from a name and a range.
 *
 * Range of the marker is updated automatically when document changes, using
 * {@link module:engine/model/liverange~LiveRange live range} mechanism.
 *
 * Name is used to group and identify markers. Names have to be unique, but markers can be grouped by
 * using common prefixes, separated with `:`, for example: `user:john` or `search:3`. That's useful in term of creating
 * namespaces for custom elements (e.g. comments, highlights). You can use this prefixes in
 * {@link module:engine/model/markercollection~MarkerCollection#event:update} listeners to listen on changes in a group of markers.
 * For instance: `model.markers.on( 'update:user', callback );` will be called whenever any `user:*` markers changes.
 *
 * There are two types of markers.
 *
 * 1. Markers managed directly, without using operations. They are added directly by {@link module:engine/model/writer~Writer}
 * to the {@link module:engine/model/markercollection~MarkerCollection} without any additional mechanism. They can be used
 * as bookmarks or visual markers. They are great for showing results of the find, or select link when the focus is in the input.
 *
 * 1. Markers managed using operations. These markers are also stored in {@link module:engine/model/markercollection~MarkerCollection}
 * but changes in these markers is managed the same way all other changes in the model structure - using operations.
 * Therefore, they are handled in the undo stack and synchronized between clients if the collaboration plugin is enabled.
 * This type of markers is useful for solutions like spell checking or comments.
 *
 * Both type of them should be added / updated by {@link module:engine/model/writer~Writer#addMarker}
 * and removed by {@link module:engine/model/writer~Writer#removeMarker} methods.
 *
 *		model.change( ( writer ) => {
 * 			const marker = writer.addMarker( name, { range, usingOperation: true } );
 *
 * 			// ...
 *
 * 			writer.removeMarker( marker );
 *		} );
 *
 * See {@link module:engine/model/writer~Writer} to find more examples.
 *
 * Since markers need to track change in the document, for efficiency reasons, it is best to create and keep as little
 * markers as possible and remove them as soon as they are not needed anymore.
 *
 * Markers can be downcasted and upcasted.
 *
 * Markers downcast happens on {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:addMarker} and
 * {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:removeMarker} events.
 * Use {@link module:engine/conversion/downcasthelpers downcast converters} or attach a custom converter to mentioned events.
 * For {@link module:engine/controller/datacontroller~DataController data pipeline}, marker should be downcasted to an element.
 * Then, it can be upcasted back to a marker. Again, use {@link module:engine/conversion/upcasthelpers upcast converters} or
 * attach a custom converter to {@link module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element}.
 *
 * `Marker` instances are created and destroyed only by {@link ~MarkerCollection MarkerCollection}.
 */

var markercollection_Marker = /*#__PURE__*/function () {
  /**
   * Creates a marker instance.
   *
   * @param {String} name Marker name.
   * @param {module:engine/model/liverange~LiveRange} liveRange Range marked by the marker.
   * @param {Boolean} managedUsingOperations Specifies whether the marker is managed using operations.
   * @param {Boolean} affectsData Specifies whether the marker affects the data produced by the data pipeline
   * (is persisted in the editor's data).
   */
  function Marker(name, liveRange, managedUsingOperations, affectsData) {
    Object(classCallCheck["a" /* default */])(this, Marker);

    /**
     * Marker's name.
     *
     * @readonly
     * @type {String}
     */
    this.name = name;
    /**
     * Range marked by the marker.
     *
     * @protected
     * @member {module:engine/model/liverange~LiveRange}
     */

    this._liveRange = this._attachLiveRange(liveRange);
    /**
     * Flag indicates if the marker is managed using operations or not.
     *
     * @private
     * @member {Boolean}
     */

    this._managedUsingOperations = managedUsingOperations;
    /**
     * Specifies whether the marker affects the data produced by the data pipeline
     * (is persisted in the editor's data).
     *
     * @private
     * @member {Boolean}
     */

    this._affectsData = affectsData;
  }
  /**
   * A value indicating if the marker is managed using operations.
   * See {@link ~Marker marker class description} to learn more about marker types.
   * See {@link module:engine/model/writer~Writer#addMarker}.
   *
   * @returns {Boolean}
   */


  Object(createClass["a" /* default */])(Marker, [{
    key: "getStart",

    /**
     * Returns current marker start position.
     *
     * @returns {module:engine/model/position~Position}
     */
    value: function getStart() {
      if (!this._liveRange) {
        throw new ckeditorerror["b" /* default */]('marker-destroyed: Cannot use a destroyed marker instance.', this);
      }

      return this._liveRange.start.clone();
    }
    /**
     * Returns current marker end position.
     *
     * @returns {module:engine/model/position~Position}
     */

  }, {
    key: "getEnd",
    value: function getEnd() {
      if (!this._liveRange) {
        throw new ckeditorerror["b" /* default */]('marker-destroyed: Cannot use a destroyed marker instance.', this);
      }

      return this._liveRange.end.clone();
    }
    /**
     * Returns a range that represents the current state of the marker.
     *
     * Keep in mind that returned value is a {@link module:engine/model/range~Range Range}, not a
     * {@link module:engine/model/liverange~LiveRange LiveRange}. This means that it is up-to-date and relevant only
     * until next model document change. Do not store values returned by this method. Instead, store {@link ~Marker#name}
     * and get `Marker` instance from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection} every
     * time there is a need to read marker properties. This will guarantee that the marker has not been removed and
     * that it's data is up-to-date.
     *
     * @returns {module:engine/model/range~Range}
     */

  }, {
    key: "getRange",
    value: function getRange() {
      if (!this._liveRange) {
        throw new ckeditorerror["b" /* default */]('marker-destroyed: Cannot use a destroyed marker instance.', this);
      }

      return this._liveRange.toRange();
    }
    /**
     * Checks whether this object is of the given.
     *
     *		marker.is( 'marker' ); // -> true
     *		marker.is( 'model:marker' ); // -> true
     *
     *		marker.is( 'view:element' ); // -> false
     *		marker.is( 'documentSelection' ); // -> false
     *
     * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.
     *
     * @param {String} type
     * @returns {Boolean}
     */

  }, {
    key: "is",
    value: function is(type) {
      return type === 'marker' || type === 'model:marker';
    }
    /**
     * Binds new live range to the marker and detach the old one if is attached.
     *
     * @protected
     * @param {module:engine/model/liverange~LiveRange} liveRange Live range to attach
     * @returns {module:engine/model/liverange~LiveRange} Attached live range.
     */

  }, {
    key: "_attachLiveRange",
    value: function _attachLiveRange(liveRange) {
      if (this._liveRange) {
        this._detachLiveRange();
      } // Delegating does not work with namespaces. Alternatively, we could delegate all events (using `*`).


      liveRange.delegate('change:range').to(this);
      liveRange.delegate('change:content').to(this);
      this._liveRange = liveRange;
      return liveRange;
    }
    /**
     * Unbinds and destroys currently attached live range.
     *
     * @protected
     */

  }, {
    key: "_detachLiveRange",
    value: function _detachLiveRange() {
      this._liveRange.stopDelegating('change:range', this);

      this._liveRange.stopDelegating('change:content', this);

      this._liveRange.detach();

      this._liveRange = null;
    }
    /**
     * Fired whenever {@link ~Marker#_liveRange marker range} is changed due to changes on {@link module:engine/model/document~Document}.
     * This is a delegated {@link module:engine/model/liverange~LiveRange#event:change:range LiveRange change:range event}.
     *
     * When marker is removed from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection},
     * all event listeners listening to it should be removed. It is best to do it on
     * {@link module:engine/model/markercollection~MarkerCollection#event:update MarkerCollection update event}.
     *
     * @see module:engine/model/liverange~LiveRange#event:change:range
     * @event change:range
     * @param {module:engine/model/range~Range} oldRange
     * @param {Object} data
     */

    /**
     * Fired whenever change on {@link module:engine/model/document~Document} is done inside {@link ~Marker#_liveRange marker range}.
     * This is a delegated {@link module:engine/model/liverange~LiveRange#event:change:content LiveRange change:content event}.
     *
     * When marker is removed from {@link module:engine/model/markercollection~MarkerCollection MarkerCollection},
     * all event listeners listening to it should be removed. It is best to do it on
     * {@link module:engine/model/markercollection~MarkerCollection#event:update MarkerCollection update event}.
     *
     * @see module:engine/model/liverange~LiveRange#event:change:content
     * @event change:content
     * @param {module:engine/model/range~Range} oldRange
     * @param {Object} data
     */

  }, {
    key: "managedUsingOperations",
    get: function get() {
      if (!this._liveRange) {
        throw new ckeditorerror["b" /* default */]('marker-destroyed: Cannot use a destroyed marker instance.', this);
      }

      return this._managedUsingOperations;
    }
    /**
     * A value indicating if the marker changes the data.
     *
     * @returns {Boolean}
     */

  }, {
    key: "affectsData",
    get: function get() {
      if (!this._liveRange) {
        throw new ckeditorerror["b" /* default */]('marker-destroyed: Cannot use a destroyed marker instance.', this);
      }

      return this._affectsData;
    }
  }]);

  return Marker;
}();

mix(markercollection_Marker, emittermixin);
/**
 * Cannot use a {@link module:engine/model/markercollection~MarkerCollection#destroy destroyed marker} instance.
 *
 * @error marker-destroyed
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/operation/nooperation.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/operation/nooperation
 */

/**
 * Operation which is doing nothing ("empty operation", "do-nothing operation", "noop"). This is an operation,
 * which when executed does not change the tree model. It still has some parameters defined for transformation purposes.
 *
 * In most cases this operation is a result of transforming operations. When transformation returns
 * {@link module:engine/model/operation/nooperation~NoOperation} it means that changes done by the transformed operation
 * have already been applied.
 *
 * @extends module:engine/model/operation/operation~Operation
 */

var nooperation_NoOperation = /*#__PURE__*/function (_Operation) {
  Object(inherits["a" /* default */])(NoOperation, _Operation);

  var _super = Object(createSuper["a" /* default */])(NoOperation);

  function NoOperation() {
    Object(classCallCheck["a" /* default */])(this, NoOperation);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(NoOperation, [{
    key: "clone",

    /**
     * Creates and returns an operation that has the same parameters as this operation.
     *
     * @returns {module:engine/model/operation/nooperation~NoOperation} Clone of this operation.
     */
    value: function clone() {
      return new NoOperation(this.baseVersion);
    }
    /**
     * See {@link module:engine/model/operation/operation~Operation#getReversed `Operation#getReversed()`}.
     *
     * @returns {module:engine/model/operation/nooperation~NoOperation}
     */

  }, {
    key: "getReversed",
    value: function getReversed() {
      return new NoOperation(this.baseVersion + 1);
    }
  }, {
    key: "_execute",
    value: function _execute() {}
    /**
     * @inheritDoc
     */

  }, {
    key: "type",
    get: function get() {
      return 'noop';
    }
  }], [{
    key: "className",
    get: function get() {
      return 'NoOperation';
    } // @if CK_DEBUG_ENGINE // toString() {
    // @if CK_DEBUG_ENGINE // 	return `NoOperation( ${ this.baseVersion } )`;
    // @if CK_DEBUG_ENGINE // }

  }]);

  return NoOperation;
}(operation_Operation);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/operation/operationfactory.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/operation/operationfactory
 */










var operationfactory_operations = {};
operationfactory_operations[attributeoperation_AttributeOperation.className] = attributeoperation_AttributeOperation;
operationfactory_operations[insertoperation_InsertOperation.className] = insertoperation_InsertOperation;
operationfactory_operations[markeroperation_MarkerOperation.className] = markeroperation_MarkerOperation;
operationfactory_operations[moveoperation_MoveOperation.className] = moveoperation_MoveOperation;
operationfactory_operations[nooperation_NoOperation.className] = nooperation_NoOperation;
operationfactory_operations[operation_Operation.className] = operation_Operation;
operationfactory_operations[renameoperation_RenameOperation.className] = renameoperation_RenameOperation;
operationfactory_operations[rootattributeoperation_RootAttributeOperation.className] = rootattributeoperation_RootAttributeOperation;
operationfactory_operations[splitoperation_SplitOperation.className] = splitoperation_SplitOperation;
operationfactory_operations[mergeoperation_MergeOperation.className] = mergeoperation_MergeOperation;
/**
 * A factory class for creating operations.
 *
 * @abstract
 */

var operationfactory_OperationFactory = /*#__PURE__*/function () {
  function OperationFactory() {
    Object(classCallCheck["a" /* default */])(this, OperationFactory);
  }

  Object(createClass["a" /* default */])(OperationFactory, null, [{
    key: "fromJSON",

    /**
     * Creates an operation instance from a JSON object (parsed JSON string).
     *
     * @param {Object} json Deserialized JSON object.
     * @param {module:engine/model/document~Document} document Document on which this operation will be applied.
     * @returns {module:engine/model/operation/operation~Operation}
     */
    value: function fromJSON(json, document) {
      return operationfactory_operations[json.__className].fromJSON(json, document);
    }
  }]);

  return OperationFactory;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/liveposition.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/liveposition
 */




/**
 * `LivePosition` is a type of {@link module:engine/model/position~Position Position}
 * that updates itself as {@link module:engine/model/document~Document document}
 * is changed through operations. It may be used as a bookmark.
 *
 * **Note:** Contrary to {@link module:engine/model/position~Position}, `LivePosition` works only in roots that are
 * {@link module:engine/model/rootelement~RootElement}.
 * If {@link module:engine/model/documentfragment~DocumentFragment} is passed, error will be thrown.
 *
 * **Note:** Be very careful when dealing with `LivePosition`. Each `LivePosition` instance bind events that might
 * have to be unbound.
 * Use {@link module:engine/model/liveposition~LivePosition#detach} whenever you don't need `LivePosition` anymore.
 *
 * @extends module:engine/model/position~Position
 */

var liveposition_LivePosition = /*#__PURE__*/function (_Position) {
  Object(inherits["a" /* default */])(LivePosition, _Position);

  var _super = Object(createSuper["a" /* default */])(LivePosition);

  /**
   * Creates a live position.
   *
   * @see module:engine/model/position~Position
   * @param {module:engine/model/rootelement~RootElement} root
   * @param {Array.<Number>} path
   * @param {module:engine/model/position~PositionStickiness} [stickiness]
   */
  function LivePosition(root, path) {
    var _this;

    var stickiness = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'toNone';

    Object(classCallCheck["a" /* default */])(this, LivePosition);

    _this = _super.call(this, root, path, stickiness);

    if (!_this.root.is('rootElement')) {
      /**
       * LivePosition's root has to be an instance of RootElement.
       *
       * @error liveposition-root-not-rootelement
       */
      throw new ckeditorerror["b" /* default */]('model-liveposition-root-not-rootelement: LivePosition\'s root has to be an instance of RootElement.', root);
    }

    liveposition_bindWithDocument.call(Object(assertThisInitialized["a" /* default */])(_this));
    return _this;
  }
  /**
   * Unbinds all events previously bound by `LivePosition`. Use it whenever you don't need `LivePosition` instance
   * anymore (i.e. when leaving scope in which it was declared or before re-assigning variable that was
   * referring to it).
   */


  Object(createClass["a" /* default */])(LivePosition, [{
    key: "detach",
    value: function detach() {
      this.stopListening();
    }
    /**
     * Checks whether this object is of the given.
     *
     *		livePosition.is( 'position' ); // -> true
     *		livePosition.is( 'model:position' ); // -> true
     *		livePosition.is( 'liveposition' ); // -> true
     *		livePosition.is( 'model:livePosition' ); // -> true
     *
     *		livePosition.is( 'view:position' ); // -> false
     *		livePosition.is( 'documentSelection' ); // -> false
     *
     * {@link module:engine/model/node~Node#is Check the entire list of model objects} which implement the `is()` method.
     *
     * @param {String} type
     * @returns {Boolean}
     */

  }, {
    key: "is",
    value: function is(type) {
      return type === 'livePosition' || type === 'model:livePosition' || // From super.is(). This is highly utilised method and cannot call super. See ckeditor/ckeditor5#6529.
      type == 'position' || type === 'model:position';
    }
    /**
     * Creates a {@link module:engine/model/position~Position position instance}, which is equal to this live position.
     *
     * @returns {module:engine/model/position~Position}
     */

  }, {
    key: "toPosition",
    value: function toPosition() {
      return new model_position_Position(this.root, this.path.slice(), this.stickiness);
    }
    /**
     * Creates a `LivePosition` instance that is equal to position.
     *
     * @param {module:engine/model/position~Position} position
     * @param {module:engine/model/position~PositionStickiness} [stickiness]
     * @returns {module:engine/model/position~Position}
     */

  }], [{
    key: "fromPosition",
    value: function fromPosition(position, stickiness) {
      return new this(position.root, position.path.slice(), stickiness ? stickiness : position.stickiness);
    }
    /**
     * @static
     * @protected
     * @method module:engine/model/liveposition~LivePosition._createAfter
     * @see module:engine/model/position~Position._createAfter
     * @param {module:engine/model/node~Node} node
     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone']
     * @returns {module:engine/model/liveposition~LivePosition}
     */

    /**
     * @static
     * @protected
     * @method module:engine/model/liveposition~LivePosition._createBefore
     * @see module:engine/model/position~Position._createBefore
     * @param {module:engine/model/node~Node} node
     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone']
     * @returns {module:engine/model/liveposition~LivePosition}
     */

    /**
     * @static
     * @protected
     * @method module:engine/model/liveposition~LivePosition._createAt
     * @see module:engine/model/position~Position._createAt
     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition
     * @param {Number|'end'|'before'|'after'} [offset]
     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone']
     * @returns {module:engine/model/liveposition~LivePosition}
     */

    /**
     * Fired when `LivePosition` instance is changed due to changes on {@link module:engine/model/document~Document}.
     *
     * @event module:engine/model/liveposition~LivePosition#change
     * @param {module:engine/model/position~Position} oldPosition Position equal to this live position before it got changed.
     */

  }]);

  return LivePosition;
}(model_position_Position); // Binds this `LivePosition` to the {@link module:engine/model/document~Document document} that owns
// this position's {@link module:engine/model/position~Position#root root}.
//
// @private




function liveposition_bindWithDocument() {
  var _this2 = this;

  this.listenTo(this.root.document.model, 'applyOperation', function (event, args) {
    var operation = args[0];

    if (!operation.isDocumentOperation) {
      return;
    }

    liveposition_transform.call(_this2, operation);
  }, {
    priority: 'low'
  });
} // Updates this position accordingly to the updates applied to the model. Bases on change events.
//
// @private
// @param {module:engine/model/operation/operation~Operation} operation Executed operation.


function liveposition_transform(operation) {
  var result = this.getTransformedByOperation(operation);

  if (!this.isEqual(result)) {
    var oldPosition = this.toPosition();
    this.path = result.path;
    this.root = result.root;
    this.fire('change', oldPosition);
  }
}

mix(liveposition_LivePosition, emittermixin);
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/utils/insertcontent.js












/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/utils/insertcontent
 */







/**
 * Inserts content into the editor (specified selection) as one would expect the paste
 * functionality to work.
 *
 * If an instance of {@link module:engine/model/selection~Selection} is passed as `selectable` it will be modified
 * to the insertion selection (equal to a range to be selected after insertion).
 *
 * If `selectable` is not passed, the content will be inserted using the current selection of the model document.
 *
 * **Note:** Use {@link module:engine/model/model~Model#insertContent} instead of this function.
 * This function is only exposed to be reusable in algorithms which change the {@link module:engine/model/model~Model#insertContent}
 * method's behavior.
 *
 * @param {module:engine/model/model~Model} model The model in context of which the insertion
 * should be performed.
 * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.
 * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]
 * Selection into which the content should be inserted.
 * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.
 * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,
 * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed
 * at the insertion position.
 */

function insertcontent_insertContent(model, content, selectable, placeOrOffset) {
  return model.change(function (writer) {
    var selection;

    if (!selectable) {
      selection = model.document.selection;
    } else if (selectable instanceof model_selection_Selection || selectable instanceof model_documentselection_DocumentSelection) {
      selection = selectable;
    } else {
      selection = writer.createSelection(selectable, placeOrOffset);
    }

    if (!selection.isCollapsed) {
      model.deleteContent(selection, {
        doNotAutoparagraph: true
      });
    }

    var insertion = new insertcontent_Insertion(model, writer, selection.anchor);
    var nodesToInsert;

    if (content.is('documentFragment')) {
      nodesToInsert = content.getChildren();
    } else {
      nodesToInsert = [content];
    }

    insertion.handleNodes(nodesToInsert, {
      // The set of children being inserted is the only set in this context
      // so it's the first and last (it's a hack ;)).
      isFirst: true,
      isLast: true
    });
    var newRange = insertion.getSelectionRange();
    /* istanbul ignore else */

    if (newRange) {
      if (selection instanceof model_documentselection_DocumentSelection) {
        writer.setSelection(newRange);
      } else {
        selection.setTo(newRange);
      }
    } else {// We are not testing else because it's a safe check for unpredictable edge cases:
      // an insertion without proper range to select.
      //
      // @if CK_DEBUG // console.warn( 'Cannot determine a proper selection range after insertion.' );
    }

    var affectedRange = insertion.getAffectedRange() || model.createRange(selection.anchor);
    insertion.destroy();
    return affectedRange;
  });
}
/**
 * Utility class for performing content insertion.
 *
 * @private
 */

var insertcontent_Insertion = /*#__PURE__*/function () {
  function Insertion(model, writer, position) {
    Object(classCallCheck["a" /* default */])(this, Insertion);

    /**
     * The model in context of which the insertion should be performed.
     *
     * @member {module:engine/model~Model} #model
     */
    this.model = model;
    /**
     * Batch to which operations will be added.
     *
     * @member {module:engine/controller/writer~Batch} #writer
     */

    this.writer = writer;
    /**
     * The position at which (or near which) the next node will be inserted.
     *
     * @member {module:engine/model/position~Position} #position
     */

    this.position = position;
    /**
     * Elements with which the inserted elements can be merged.
     *
     *		<p>x^</p><p>y</p> + <p>z</p> (can merge to <p>x</p>)
     *		<p>x</p><p>^y</p> + <p>z</p> (can merge to <p>y</p>)
     *		<p>x^y</p> + <p>z</p> (can merge to <p>xy</p> which will be split during the action,
     *								so both its pieces will be added to this set)
     *
     *
     * @member {Set} #canMergeWith
     */

    this.canMergeWith = new Set([this.position.parent]);
    /**
     * Schema of the model.
     *
     * @member {module:engine/model/schema~Schema} #schema
     */

    this.schema = model.schema;
    this._filterAttributesOf = [];
    /**
     * Beginning of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.
     *
     * @private
     * @member {module:engine/model/liveposition~LivePosition|null} #_affectedStart
     */

    this._affectedStart = null;
    /**
     * End of the affected range. See {@link module:engine/model/utils/insertcontent~Insertion#getAffectedRange}.
     *
     * @private
     * @member {module:engine/model/liveposition~LivePosition|null} #_affectedEnd
     */

    this._affectedEnd = null;
  }
  /**
   * Handles insertion of a set of nodes.
   *
   * @param {Iterable.<module:engine/model/node~Node>} nodes Nodes to insert.
   * @param {Object} parentContext Context in which parent of these nodes was supposed to be inserted.
   * If the parent context is passed it means that the parent element was stripped (was not allowed).
   */


  Object(createClass["a" /* default */])(Insertion, [{
    key: "handleNodes",
    value: function handleNodes(nodes, parentContext) {
      nodes = Array.from(nodes);

      for (var i = 0; i < nodes.length; i++) {
        var node = nodes[i];

        this._handleNode(node, {
          isFirst: i === 0 && parentContext.isFirst,
          isLast: i === nodes.length - 1 && parentContext.isLast
        });
      } // TMP this will become a post-fixer.


      this.schema.removeDisallowedAttributes(this._filterAttributesOf, this.writer);
      this._filterAttributesOf = [];
    }
    /**
     * Returns range to be selected after insertion.
     * Returns `null` if there is no valid range to select after insertion.
     *
     * @returns {module:engine/model/range~Range|null}
     */

  }, {
    key: "getSelectionRange",
    value: function getSelectionRange() {
      if (this.nodeToSelect) {
        return model_range_Range._createOn(this.nodeToSelect);
      }

      return this.model.schema.getNearestSelectionRange(this.position);
    }
    /**
     * Returns a range which contains all the performed changes. This is a range that, if removed, would return the model to the state
     * before the insertion. Returns `null` if no changes were done.
     *
     * @returns {module:engine/model/range~Range|null}
     */

  }, {
    key: "getAffectedRange",
    value: function getAffectedRange() {
      if (!this._affectedStart) {
        return null;
      }

      return new model_range_Range(this._affectedStart, this._affectedEnd);
    }
    /**
     * Destroys `Insertion` instance.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      if (this._affectedStart) {
        this._affectedStart.detach();
      }

      if (this._affectedEnd) {
        this._affectedEnd.detach();
      }
    }
    /**
     * Handles insertion of a single node.
     *
     * @private
     * @param {module:engine/model/node~Node} node
     * @param {Object} context
     * @param {Boolean} context.isFirst Whether the given node is the first one in the content to be inserted.
     * @param {Boolean} context.isLast Whether the given node is the last one in the content to be inserted.
     */

  }, {
    key: "_handleNode",
    value: function _handleNode(node, context) {
      // Let's handle object in a special way.
      // * They should never be merged with other elements.
      // * If they are not allowed in any of the selection ancestors, they could be either autoparagraphed or totally removed.
      if (this.schema.isObject(node)) {
        this._handleObject(node, context);

        return;
      } // Try to find a place for the given node.
      // Split the position.parent's branch up to a point where the node can be inserted.
      // If it isn't allowed in the whole branch, then of course don't split anything.


      var isAllowed = this._checkAndSplitToAllowedPosition(node, context);

      if (!isAllowed) {
        this._handleDisallowedNode(node, context);

        return;
      }

      this._insert(node); // After the node was inserted we may try to merge it with its siblings.
      // This should happen only if it was the first and/or last of the nodes (so only with boundary nodes)
      // and only if the selection was in those elements initially.
      //
      // E.g.:
      // <p>x^</p> + <p>y</p> => <p>x</p><p>y</p> => <p>xy[]</p>
      // and:
      // <p>x^y</p> + <p>z</p> => <p>x</p>^<p>y</p> + <p>z</p> => <p>x</p><p>z</p><p>y</p> => <p>xz[]y</p>
      // but:
      // <p>x</p><p>^</p><p>z</p> + <p>y</p> => <p>x</p><p>y</p><p>z</p> (no merging)
      // <p>x</p>[<img>]<p>z</p> + <p>y</p> => <p>x</p><p>y</p><p>z</p> (no merging, note: after running deleteContents
      //																	 it's exactly the same case as above)


      this._mergeSiblingsOf(node, context);
    }
    /**
     * @private
     * @param {module:engine/model/element~Element} node The object element.
     * @param {Object} context
     */

  }, {
    key: "_handleObject",
    value: function _handleObject(node, context) {
      // Try finding it a place in the tree.
      if (this._checkAndSplitToAllowedPosition(node)) {
        this._insert(node);
      } // Try autoparagraphing.
      else {
          this._tryAutoparagraphing(node, context);
        }
    }
    /**
     * @private
     * @param {module:engine/model/node~Node} node The disallowed node which needs to be handled.
     * @param {Object} context
     */

  }, {
    key: "_handleDisallowedNode",
    value: function _handleDisallowedNode(node, context) {
      // If the node is an element, try inserting its children (strip the parent).
      if (node.is('element')) {
        this.handleNodes(node.getChildren(), context);
      } // If text is not allowed, try autoparagraphing it.
      else {
          this._tryAutoparagraphing(node, context);
        }
    }
    /**
     * @private
     * @param {module:engine/model/node~Node} node The node to insert.
     */

  }, {
    key: "_insert",
    value: function _insert(node) {
      /* istanbul ignore if */
      if (!this.schema.checkChild(this.position, node)) {
        // Algorithm's correctness check. We should never end up here but it's good to know that we did.
        // Note that it would often be a silent issue if we insert node in a place where it's not allowed.

        /**
         * Given node cannot be inserted on the given position.
         *
         * @error insertcontent-wrong-position
         * @param {module:engine/model/node~Node} node Node to insert.
         * @param {module:engine/model/position~Position} position Position to insert the node at.
         */
        throw new ckeditorerror["b" /* default */]('insertcontent-wrong-position: Given node cannot be inserted on the given position.', this, {
          node: node,
          position: this.position
        });
      }

      var livePos = liveposition_LivePosition.fromPosition(this.position, 'toNext');

      this._setAffectedBoundaries(this.position);

      this.writer.insert(node, this.position);
      this.position = livePos.toPosition();
      livePos.detach(); // The last inserted object should be selected because we can't put a collapsed selection after it.

      if (this.schema.isObject(node) && !this.schema.checkChild(this.position, '$text')) {
        this.nodeToSelect = node;
      } else {
        this.nodeToSelect = null;
      }

      this._filterAttributesOf.push(node);
    }
    /**
     * Sets `_affectedStart` and `_affectedEnd` to the given `position`. Should be used before a change is done during insertion process to
     * mark the affected range.
     *
     * This method is used before inserting a node or splitting a parent node. `_affectedStart` and `_affectedEnd` are also changed
     * during merging, but the logic there is more complicated so it is left out of this function.
     *
     * @private
     * @param {module:engine/model/position~Position} position
     */

  }, {
    key: "_setAffectedBoundaries",
    value: function _setAffectedBoundaries(position) {
      // Set affected boundaries stickiness so that those position will "expand" when something is inserted in between them:
      // <paragraph>Foo][bar</paragraph> -> <paragraph>Foo]xx[bar</paragraph>
      // This is why it cannot be a range but two separate positions.
      if (!this._affectedStart) {
        this._affectedStart = liveposition_LivePosition.fromPosition(position, 'toPrevious');
      } // If `_affectedEnd` is before the new boundary position, expand `_affectedEnd`. This can happen if first inserted node was
      // inserted into the parent but the next node is moved-out of that parent:
      // (1) <paragraph>Foo][</paragraph> -> <paragraph>Foo]xx[</paragraph>
      // (2) <paragraph>Foo]xx[</paragraph> -> <paragraph>Foo]xx</paragraph><widget></widget>[


      if (!this._affectedEnd || this._affectedEnd.isBefore(position)) {
        if (this._affectedEnd) {
          this._affectedEnd.detach();
        }

        this._affectedEnd = liveposition_LivePosition.fromPosition(position, 'toNext');
      }
    }
    /**
     * @private
     * @param {module:engine/model/node~Node} node The node which could potentially be merged.
     * @param {Object} context
     */

  }, {
    key: "_mergeSiblingsOf",
    value: function _mergeSiblingsOf(node, context) {
      if (!(node instanceof model_element_Element)) {
        return;
      }

      var mergeLeft = this._canMergeLeft(node, context);

      var mergeRight = this._canMergeRight(node, context);

      var mergePosLeft = liveposition_LivePosition._createBefore(node);

      mergePosLeft.stickiness = 'toNext';

      var mergePosRight = liveposition_LivePosition._createAfter(node);

      mergePosRight.stickiness = 'toNext';

      if (mergeLeft) {
        var livePosition = liveposition_LivePosition.fromPosition(this.position);
        livePosition.stickiness = 'toNext'; // If `_affectedStart` is sames as merge position, it means that the element "marked" by `_affectedStart` is going to be
        // removed and its contents will be moved. This won't transform `LivePosition` so `_affectedStart` needs to be moved
        // by hand to properly reflect affected range. (Due to `_affectedStart` and `_affectedEnd` stickiness, the "range" is
        // shown as `][`).
        //
        // Example - insert `<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>` at the end of `<paragraph>Foo^</paragraph>`:
        //
        // <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->
        // <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>   -->
        // <paragraph>Foo]Abc</paragraph><paragraph>Xyz</paragraph>[<paragraph>Bar</paragraph>
        //
        // Note, that if we are here then something must have been inserted, so `_affectedStart` and `_affectedEnd` have to be set.

        if (this._affectedStart.isEqual(mergePosLeft)) {
          this._affectedStart.detach();

          this._affectedStart = liveposition_LivePosition._createAt(mergePosLeft.nodeBefore, 'end', 'toPrevious');
        }

        this.writer.merge(mergePosLeft); // If only one element (the merged one) is in the "affected range", also move the affected range end appropriately.
        //
        // Example - insert `<paragraph>Abc</paragraph>` at the of `<paragraph>Foo^</paragraph>`:
        //
        // <paragraph>Foo</paragraph><paragraph>Bar</paragraph>   -->
        // <paragraph>Foo</paragraph>]<paragraph>Abc</paragraph>[<paragraph>Bar</paragraph>   -->
        // <paragraph>Foo]Abc</paragraph>[<paragraph>Bar</paragraph>   -->
        // <paragraph>Foo]Abc[</paragraph><paragraph>Bar</paragraph>

        if (mergePosLeft.isEqual(this._affectedEnd) && context.isLast) {
          this._affectedEnd.detach();

          this._affectedEnd = liveposition_LivePosition._createAt(mergePosLeft.nodeBefore, 'end', 'toNext');
        }

        this.position = livePosition.toPosition();
        livePosition.detach();
      }

      if (mergeRight) {
        /* istanbul ignore if */
        if (!this.position.isEqual(mergePosRight)) {
          // Algorithm's correctness check. We should never end up here but it's good to know that we did.
          // At this point the insertion position should be after the node we'll merge. If it isn't,
          // it should need to be secured as in the left merge case.

          /**
           * An internal error occured during merging insertion content with siblings.
           * The insertion position should equal to the merge position.
           *
           * @error insertcontent-invalid-insertion-position
           */
          throw new ckeditorerror["b" /* default */]('insertcontent-invalid-insertion-position', this);
        } // Move the position to the previous node, so it isn't moved to the graveyard on merge.
        // <p>x</p>[]<p>y</p> => <p>x[]</p><p>y</p>


        this.position = model_position_Position._createAt(mergePosRight.nodeBefore, 'end'); // OK:  <p>xx[]</p> + <p>yy</p> => <p>xx[]yy</p> (when sticks to previous)
        // NOK: <p>xx[]</p> + <p>yy</p> => <p>xxyy[]</p> (when sticks to next)

        var _livePosition = liveposition_LivePosition.fromPosition(this.position, 'toPrevious'); // See comment above on moving `_affectedStart`.


        if (this._affectedEnd.isEqual(mergePosRight)) {
          this._affectedEnd.detach();

          this._affectedEnd = liveposition_LivePosition._createAt(mergePosRight.nodeBefore, 'end', 'toNext');
        }

        this.writer.merge(mergePosRight); // See comment above on moving `_affectedStart`.

        if (mergePosRight.getShiftedBy(-1).isEqual(this._affectedStart) && context.isFirst) {
          this._affectedStart.detach();

          this._affectedStart = liveposition_LivePosition._createAt(mergePosRight.nodeBefore, 0, 'toPrevious');
        }

        this.position = _livePosition.toPosition();

        _livePosition.detach();
      }

      if (mergeLeft || mergeRight) {
        // After merge elements that were marked by _insert() to be filtered might be gone so
        // we need to mark the new container.
        this._filterAttributesOf.push(this.position.parent);
      }

      mergePosLeft.detach();
      mergePosRight.detach();
    }
    /**
     * Checks whether specified node can be merged with previous sibling element.
     *
     * @private
     * @param {module:engine/model/node~Node} node The node which could potentially be merged.
     * @param {Object} context
     * @returns {Boolean}
     */

  }, {
    key: "_canMergeLeft",
    value: function _canMergeLeft(node, context) {
      var previousSibling = node.previousSibling;
      return context.isFirst && previousSibling instanceof model_element_Element && this.canMergeWith.has(previousSibling) && this.model.schema.checkMerge(previousSibling, node);
    }
    /**
     * Checks whether specified node can be merged with next sibling element.
     *
     * @private
     * @param {module:engine/model/node~Node} node The node which could potentially be merged.
     * @param {Object} context
     * @returns {Boolean}
     */

  }, {
    key: "_canMergeRight",
    value: function _canMergeRight(node, context) {
      var nextSibling = node.nextSibling;
      return context.isLast && nextSibling instanceof model_element_Element && this.canMergeWith.has(nextSibling) && this.model.schema.checkMerge(node, nextSibling);
    }
    /**
     * Tries wrapping the node in a new paragraph and inserting it this way.
     *
     * @private
     * @param {module:engine/model/node~Node} node The node which needs to be autoparagraphed.
     * @param {Object} context
     */

  }, {
    key: "_tryAutoparagraphing",
    value: function _tryAutoparagraphing(node, context) {
      var paragraph = this.writer.createElement('paragraph'); // Do not autoparagraph if the paragraph won't be allowed there,
      // cause that would lead to an infinite loop. The paragraph would be rejected in
      // the next _handleNode() call and we'd be here again.

      if (this._getAllowedIn(paragraph, this.position.parent) && this.schema.checkChild(paragraph, node)) {
        paragraph._appendChild(node);

        this._handleNode(paragraph, context);
      }
    }
    /**
     * @private
     * @param {module:engine/model/node~Node} node
     * @returns {Boolean} Whether an allowed position was found.
     * `false` is returned if the node isn't allowed at any position up in the tree, `true` if was.
     */

  }, {
    key: "_checkAndSplitToAllowedPosition",
    value: function _checkAndSplitToAllowedPosition(node) {
      var allowedIn = this._getAllowedIn(node, this.position.parent);

      if (!allowedIn) {
        return false;
      }

      while (allowedIn != this.position.parent) {
        // If a parent which we'd need to leave is a limit element, break.
        if (this.schema.isLimit(this.position.parent)) {
          return false;
        }

        if (this.position.isAtStart) {
          // If insertion position is at the beginning of the parent, move it out instead of splitting.
          // <p>^Foo</p> -> ^<p>Foo</p>
          var parent = this.position.parent;
          this.position = this.writer.createPositionBefore(parent); // Special case – parent is empty (<p>^</p>).
          //
          // 1. parent.isEmpty
          // We can remove the element after moving insertion position out of it.
          //
          // 2. parent.parent === allowedIn
          // However parent should remain in place when allowed element is above limit element in document tree.
          // For example there shouldn't be allowed to remove empty paragraph from tableCell, when is pasted
          // content allowed in $root.

          if (parent.isEmpty && parent.parent === allowedIn) {
            this.writer.remove(parent);
          }
        } else if (this.position.isAtEnd) {
          // If insertion position is at the end of the parent, move it out instead of splitting.
          // <p>Foo^</p> -> <p>Foo</p>^
          this.position = this.writer.createPositionAfter(this.position.parent);
        } else {
          var tempPos = this.writer.createPositionAfter(this.position.parent);

          this._setAffectedBoundaries(this.position);

          this.writer.split(this.position);
          this.position = tempPos;
          this.canMergeWith.add(this.position.nodeAfter);
        }
      }

      return true;
    }
    /**
     * Gets the element in which the given node is allowed. It checks the passed element and all its ancestors.
     *
     * @private
     * @param {module:engine/model/node~Node} node The node to check.
     * @param {module:engine/model/element~Element} element The element in which the node's correctness should be checked.
     * @returns {module:engine/model/element~Element|null}
     */

  }, {
    key: "_getAllowedIn",
    value: function _getAllowedIn(node, element) {
      if (this.schema.checkChild(element, node)) {
        return element;
      }

      if (element.parent) {
        return this._getAllowedIn(node, element.parent);
      }

      return null;
    }
  }]);

  return Insertion;
}();
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.object.from-entries.js
var es_object_from_entries = __webpack_require__("c1f9");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/utils/deletecontent.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/utils/deletecontent
 */



/**
 * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.
 *
 * **Note:** Use {@link module:engine/model/model~Model#deleteContent} instead of this function.
 * This function is only exposed to be reusable in algorithms
 * which change the {@link module:engine/model/model~Model#deleteContent}
 * method's behavior.
 *
 * @param {module:engine/model/model~Model} model The model in context of which the insertion
 * should be performed.
 * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection
 * Selection of which the content should be deleted.
 * @param {Object} [options]
 * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.
 *
 * For example `<heading>x[x</heading><paragraph>y]y</paragraph>` will become:
 *
 * * `<heading>x^y</heading>` with the option disabled (`leaveUnmerged == false`)
 * * `<heading>x^</heading><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).
 *
 * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}
 * elements will not be merged.
 *
 * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a
 * paragraph when the entire content was selected.
 *
 * For example `<heading>[x</heading><paragraph>y]</paragraph>` will become:
 *
 * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)
 * * `<heading>^</heading>` with enabled (`doNotResetEntireContent == true`).
 *
 * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved
 * to a place where text cannot be inserted.
 *
 * For example `<paragraph>x</paragraph>[<image src="foo.jpg"></image>]` will become:
 *
 * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)
 * * `<paragraph>x</paragraph>[]` with the option enabled (`doNotAutoparagraph == true`).
 *
 * If you use this option you need to make sure to handle invalid selections yourself or leave
 * them to the selection post-fixer (may not always work).
 *
 * **Note:** if there is no valid position for the selection, the paragraph will always be created:
 *
 * `[<image src="foo.jpg"></image>]` -> `<paragraph>[]</paragraph>`.
 */

function deletecontent_deleteContent(model, selection) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

  if (selection.isCollapsed) {
    return;
  }

  var selRange = selection.getFirstRange(); // If the selection is already removed, don't do anything.

  if (selRange.root.rootName == '$graveyard') {
    return;
  }

  var schema = model.schema;
  model.change(function (writer) {
    // 1. Replace the entire content with paragraph.
    // See: https://github.com/ckeditor/ckeditor5-engine/issues/1012#issuecomment-315017594.
    if (!options.doNotResetEntireContent && shouldEntireContentBeReplacedWithParagraph(schema, selection)) {
      replaceEntireContentWithParagraph(writer, selection, schema);
      return;
    } // Get the live positions for the range adjusted to span only blocks selected from the user perspective.


    var _getLivePositionsForS = getLivePositionsForSelectedBlocks(selRange),
        _getLivePositionsForS2 = _slicedToArray(_getLivePositionsForS, 2),
        startPosition = _getLivePositionsForS2[0],
        endPosition = _getLivePositionsForS2[1]; // 2. Remove the content if there is any.


    if (!selRange.start.isTouching(selRange.end)) {
      writer.remove(selRange);
    } // 3. Merge elements in the right branch to the elements in the left branch.
    // The only reasonable (in terms of data and selection correctness) case in which we need to do that is:
    //
    // <heading type=1>Fo[</heading><paragraph>]ar</paragraph> => <heading type=1>Fo^ar</heading>
    //
    // However, the algorithm supports also merging deeper structures (up to the depth of the shallower branch),
    // as it's hard to imagine what should actually be the default behavior. Usually, specific features will
    // want to override that behavior anyway.


    if (!options.leaveUnmerged) {
      mergeBranches(writer, startPosition, endPosition); // TMP this will be replaced with a postfixer.
      // We need to check and strip disallowed attributes in all nested nodes because after merge
      // some attributes could end up in a path where are disallowed.
      //
      // e.g. bold is disallowed for <H1>
      // <h1>Fo{o</h1><p>b}a<b>r</b><p> -> <h1>Fo{}a<b>r</b><h1> -> <h1>Fo{}ar<h1>.

      schema.removeDisallowedAttributes(startPosition.parent.getChildren(), writer);
    }

    collapseSelectionAt(writer, selection, startPosition); // 4. Add a paragraph to set selection in it.
    // Check if a text is allowed in the new container. If not, try to create a new paragraph (if it's allowed here).
    // If autoparagraphing is off, we assume that you know what you do so we leave the selection wherever it was.

    if (!options.doNotAutoparagraph && shouldAutoparagraph(schema, startPosition)) {
      insertParagraph(writer, startPosition, selection);
    }

    startPosition.detach();
    endPosition.detach();
  });
} // Returns the live positions for the range adjusted to span only blocks selected from the user perspective. Example:
//
//     <heading1>[foo</heading1>
//     <paragraph>bar</paragraph>
//     <heading1>]abc</heading1>  <-- this block is not considered as selected
//
// This is the same behavior as in Selection#getSelectedBlocks() "special case".

function getLivePositionsForSelectedBlocks(range) {
  var model = range.root.document.model;
  var startPosition = range.start;
  var endPosition = range.end; // If the end of selection is at the start position of last block in the selection, then
  // shrink it to not include that trailing block. Note that this should happen only for not empty selection.

  if (model.hasContent(range, {
    ignoreMarkers: true
  })) {
    var endBlock = deletecontent_getParentBlock(endPosition);

    if (endBlock && endPosition.isTouching(model.createPositionAt(endBlock, 0))) {
      // Create forward selection as a probe to find a valid position after excluding last block from the range.
      var selection = model.createSelection(range); // Modify the forward selection in backward direction to shrink it and remove first position of following block from it.
      // This is how modifySelection works and here we are making use of it.

      model.modifySelection(selection, {
        direction: 'backward'
      });
      endPosition = selection.getLastPosition();
    }
  }

  return [liveposition_LivePosition.fromPosition(startPosition, 'toPrevious'), liveposition_LivePosition.fromPosition(endPosition, 'toNext')];
} // Finds the lowest element in position's ancestors which is a block.
// Returns null if a limit element is encountered before reaching a block element.


function deletecontent_getParentBlock(position) {
  var element = position.parent;
  var schema = element.root.document.model.schema;
  var ancestors = element.getAncestors({
    parentFirst: true,
    includeSelf: true
  });

  var _iterator = _createForOfIteratorHelper(ancestors),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _element = _step.value;

      if (schema.isLimit(_element)) {
        return null;
      }

      if (schema.isBlock(_element)) {
        return _element;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
} // This function is a result of reaching the Ballmer's peak for just the right amount of time.
// Even I had troubles documenting it after a while and after reading it again I couldn't believe that it really works.


function mergeBranches(writer, startPosition, endPosition) {
  var model = writer.model; // Verify if there is a need and possibility to merge.

  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {
    return;
  } // If the start element on the common ancestor level is empty, and the end element on the same level is not empty
  // then merge those to the right element so that it's properties are preserved (name, attributes).
  // Because of OT merging is used instead of removing elements.
  //
  // Merge left:
  //     <heading1>foo[</heading1>    ->  <heading1>foo[]bar</heading1>
  //     <paragraph>]bar</paragraph>  ->               --^
  //
  // Merge right:
  //     <heading1>[</heading1>       ->
  //     <paragraph>]bar</paragraph>  ->  <paragraph>[]bar</paragraph>
  //
  // Merge left:
  //     <blockQuote>                     ->  <blockQuote>
  //         <heading1>foo[</heading1>    ->      <heading1>foo[]bar</heading1>
  //         <paragraph>]bar</paragraph>  ->                   --^
  //     </blockQuote>                    ->  </blockQuote>
  //
  // Merge right:
  //     <blockQuote>                     ->  <blockQuote>
  //         <heading1>[</heading1>       ->
  //         <paragraph>]bar</paragraph>  ->      <paragraph>[]bar</paragraph>
  //     </blockQuote>                    ->  </blockQuote>
  // Merging should not go deeper than common ancestor.


  var _getAncestorsJustBelo = getAncestorsJustBelowCommonAncestor(startPosition, endPosition),
      _getAncestorsJustBelo2 = _slicedToArray(_getAncestorsJustBelo, 2),
      startAncestor = _getAncestorsJustBelo2[0],
      endAncestor = _getAncestorsJustBelo2[1];

  if (!model.hasContent(startAncestor, {
    ignoreMarkers: true
  }) && model.hasContent(endAncestor, {
    ignoreMarkers: true
  })) {
    mergeBranchesRight(writer, startPosition, endPosition, startAncestor.parent);
  } else {
    mergeBranchesLeft(writer, startPosition, endPosition, startAncestor.parent);
  }
} // Merging blocks to the left (properties of the left block are preserved).
// Simple example:
//     <heading1>foo[</heading1>    ->  <heading1>foo[bar</heading1>]
//     <paragraph>]bar</paragraph>  ->              --^
//
// Nested example:
//     <blockQuote>                     ->  <blockQuote>
//         <heading1>foo[</heading1>    ->      <heading1>foo[bar</heading1>
//     </blockQuote>                    ->  </blockQuote>]    ^
//     <blockBlock>                     ->                    |
//         <paragraph>]bar</paragraph>  ->                 ---
//     </blockBlock>                    ->
//


function mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor) {
  var startElement = startPosition.parent;
  var endElement = endPosition.parent; // Merging reached the common ancestor element, stop here.

  if (startElement == commonAncestor || endElement == commonAncestor) {
    return;
  } // Remember next positions to merge in next recursive step (also used as modification points pointers).


  startPosition = writer.createPositionAfter(startElement);
  endPosition = writer.createPositionBefore(endElement); // Move endElement just after startElement if they aren't siblings.

  if (!endPosition.isEqual(startPosition)) {
    //
    //     <blockQuote>                     ->  <blockQuote>
    //         <heading1>foo[</heading1>    ->      <heading1>foo</heading1>[<paragraph>bar</paragraph>
    //     </blockQuote>                    ->  </blockQuote>                ^
    //     <blockBlock>                     ->  <blockBlock>                 |
    //         <paragraph>]bar</paragraph>  ->      ]                     ---
    //     </blockBlock>                    ->  </blockBlock>
    //
    writer.insert(endElement, startPosition);
  } // Merge two siblings (nodes on sides of startPosition):
  //
  //     <blockQuote>                                             ->  <blockQuote>
  //         <heading1>foo</heading1>[<paragraph>bar</paragraph>  ->      <heading1>foo[bar</heading1>
  //     </blockQuote>                                            ->  </blockQuote>
  //     <blockBlock>                                             ->  <blockBlock>
  //         ]                                                    ->      ]
  //     </blockBlock>                                            ->  </blockBlock>
  //
  // Or in simple case (without moving elements in above if):
  //     <heading1>foo</heading1>[<paragraph>bar</paragraph>]  ->  <heading1>foo[bar</heading1>]
  //


  writer.merge(startPosition); // Remove empty end ancestors:
  //
  //     <blockQuote>                      ->  <blockQuote>
  //         <heading1>foo[bar</heading1>  ->      <heading1>foo[bar</heading1>
  //     </blockQuote>                     ->  </blockQuote>
  //     <blockBlock>                      ->
  //         ]                             ->  ]
  //     </blockBlock>                     ->
  //

  while (endPosition.parent.isEmpty) {
    var parentToRemove = endPosition.parent;
    endPosition = writer.createPositionBefore(parentToRemove);
    writer.remove(parentToRemove);
  } // Verify if there is a need and possibility to merge next level.


  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {
    return;
  } // Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).


  mergeBranchesLeft(writer, startPosition, endPosition, commonAncestor);
} // Merging blocks to the right (properties of the right block are preserved).
// Simple example:
//     <heading1>foo[</heading1>    ->            --v
//     <paragraph>]bar</paragraph>  ->  [<paragraph>foo]bar</paragraph>
//
// Nested example:
//     <blockQuote>                     ->
//         <heading1>foo[</heading1>    ->              ---
//     </blockQuote>                    ->                 |
//     <blockBlock>                     ->  [<blockBlock>  v
//         <paragraph>]bar</paragraph>  ->      <paragraph>foo]bar</paragraph>
//     </blockBlock>                    ->  </blockBlock>
//


function mergeBranchesRight(writer, startPosition, endPosition, commonAncestor) {
  var startElement = startPosition.parent;
  var endElement = endPosition.parent; // Merging reached the common ancestor element, stop here.

  if (startElement == commonAncestor || endElement == commonAncestor) {
    return;
  } // Remember next positions to merge in next recursive step (also used as modification points pointers).


  startPosition = writer.createPositionAfter(startElement);
  endPosition = writer.createPositionBefore(endElement); // Move startElement just before endElement if they aren't siblings.

  if (!endPosition.isEqual(startPosition)) {
    //
    //     <blockQuote>                     ->  <blockQuote>
    //         <heading1>foo[</heading1>    ->      [                   ---
    //     </blockQuote>                    ->  </blockQuote>              |
    //     <blockBlock>                     ->  <blockBlock>               v
    //         <paragraph>]bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>
    //     </blockBlock>                    ->  </blockBlock>
    //
    writer.insert(startElement, endPosition);
  } // Remove empty end ancestors:
  //
  //     <blockQuote>                                             ->
  //         [                                                    ->  [
  //     </blockQuote>                                            ->
  //     <blockBlock>                                             ->  <blockBlock>
  //         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <heading1>foo</heading1>]<paragraph>bar</paragraph>
  //     </blockBlock>                                            ->  </blockBlock>
  //


  while (startPosition.parent.isEmpty) {
    var parentToRemove = startPosition.parent;
    startPosition = writer.createPositionBefore(parentToRemove);
    writer.remove(parentToRemove);
  } // Update endPosition after inserting and removing elements.


  endPosition = writer.createPositionBefore(endElement); // Merge right two siblings (nodes on sides of endPosition):
  //                                                              ->
  //     [                                                        ->  [
  //                                                              ->
  //     <blockBlock>                                             ->  <blockBlock>
  //         <heading1>foo</heading1>]<paragraph>bar</paragraph>  ->      <paragraph>foo]bar</paragraph>
  //     </blockBlock>                                            ->  </blockBlock>
  //
  // Or in simple case (without moving elements in above if):
  //     [<heading1>foo</heading1>]<paragraph>bar</paragraph>  ->  [<heading1>foo]bar</heading1>
  //

  deletecontent_mergeRight(writer, endPosition); // Verify if there is a need and possibility to merge next level.

  if (!checkShouldMerge(writer.model.schema, startPosition, endPosition)) {
    return;
  } // Continue merging next level (blockQuote with blockBlock in the examples above if it would not be empty and got removed).


  mergeBranchesRight(writer, startPosition, endPosition, commonAncestor);
} // There is no right merge operation so we need to simulate it.


function deletecontent_mergeRight(writer, position) {
  var startElement = position.nodeBefore;
  var endElement = position.nodeAfter;

  if (startElement.name != endElement.name) {
    writer.rename(startElement, endElement.name);
  }

  writer.clearAttributes(startElement);
  writer.setAttributes(Object.fromEntries(endElement.getAttributes()), startElement);
  writer.merge(position);
} // Verifies if merging is needed and possible. It's not needed if both positions are in the same element
// and it's not possible if some element is a limit or the range crosses a limit element.


function checkShouldMerge(schema, startPosition, endPosition) {
  var startElement = startPosition.parent;
  var endElement = endPosition.parent; // If both positions ended up in the same parent, then there's nothing more to merge:
  // <$root><p>x[</p><p>]y</p></$root> => <$root><p>xy</p>[]</$root>

  if (startElement == endElement) {
    return false;
  } // If one of the positions is a limit element, then there's nothing to merge because we don't want to cross the limit boundaries.


  if (schema.isLimit(startElement) || schema.isLimit(endElement)) {
    return false;
  } // Check if operations we'll need to do won't need to cross object or limit boundaries.
  // E.g., we can't merge endElement into startElement in this case:
  // <limit><startElement>x[</startElement></limit><endElement>]</endElement>


  return isCrossingLimitElement(startPosition, endPosition, schema);
} // Returns the elements that are the ancestors of the provided positions that are direct children of the common ancestor.


function getAncestorsJustBelowCommonAncestor(positionA, positionB) {
  var ancestorsA = positionA.getAncestors();
  var ancestorsB = positionB.getAncestors();
  var i = 0;

  while (ancestorsA[i] && ancestorsA[i] == ancestorsB[i]) {
    i++;
  }

  return [ancestorsA[i], ancestorsB[i]];
}

function shouldAutoparagraph(schema, position) {
  var isTextAllowed = schema.checkChild(position, '$text');
  var isParagraphAllowed = schema.checkChild(position, 'paragraph');
  return !isTextAllowed && isParagraphAllowed;
} // Check if parents of two positions can be merged by checking if there are no limit/object
// boundaries between those two positions.
//
// E.g. in <bQ><p>x[]</p></bQ><widget><caption>{}</caption></widget>
// we'll check <p>, <bQ>, <widget> and <caption>.
// Usually, widget and caption are marked as objects/limits in the schema, so in this case merging will be blocked.


function isCrossingLimitElement(leftPos, rightPos, schema) {
  var rangeToCheck = new model_range_Range(leftPos, rightPos);

  var _iterator2 = _createForOfIteratorHelper(rangeToCheck.getWalker()),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var value = _step2.value;

      if (schema.isLimit(value.item)) {
        return false;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return true;
}

function insertParagraph(writer, position, selection) {
  var paragraph = writer.createElement('paragraph');
  writer.insert(paragraph, position);
  collapseSelectionAt(writer, selection, writer.createPositionAt(paragraph, 0));
}

function replaceEntireContentWithParagraph(writer, selection) {
  var limitElement = writer.model.schema.getLimitElement(selection);
  writer.remove(writer.createRangeIn(limitElement));
  insertParagraph(writer, writer.createPositionAt(limitElement, 0), selection);
} // We want to replace the entire content with a paragraph when:
// * the entire content is selected,
// * selection contains at least two elements,
// * whether the paragraph is allowed in schema in the common ancestor.


function shouldEntireContentBeReplacedWithParagraph(schema, selection) {
  var limitElement = schema.getLimitElement(selection);

  if (!selection.containsEntireContent(limitElement)) {
    return false;
  }

  var range = selection.getFirstRange();

  if (range.start.parent == range.end.parent) {
    return false;
  }

  return schema.checkChild(limitElement, 'paragraph');
} // Helper function that sets the selection. Depending whether given `selection` is a document selection or not,
// uses a different method to set it.


function collapseSelectionAt(writer, selection, positionOrRange) {
  if (selection instanceof model_documentselection_DocumentSelection) {
    writer.setSelection(positionOrRange);
  } else {
    selection.setTo(positionOrRange);
  }
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/utils/modifyselection.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/utils/modifyselection
 */





var wordBoundaryCharacters = ' ,.?!:;"-()';
/**
 * Modifies the selection. Currently, the supported modifications are:
 *
 * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.
 * Possible values for `unit` are:
 *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one
 *  character in `String` sense. However, unicode also defines "combing marks". These are special symbols, that combines
 *  with a symbol before it ("base character") to create one user-perceived character. For example, `q̣̇` is a normal
 *  letter `q` with two "combining marks": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending
 *  selection by one position, it is correct to include both "base character" and all of it's "combining marks". That is
 *  why `'character'` value is most natural and common method of modifying selection.
 *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert
 *  selection between "base character" and "combining mark", because "combining marks" have their own unicode code points.
 *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by
 *  two characters, called "surrogate pairs". Halves of "surrogate pairs" have a meaning only when placed next to each other.
 *  For example `𨭎` is represented in `String` by `\uD862\uDF4E`. Both `\uD862` and `\uDF4E` do not have any meaning
 *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection
 *  extension will include whole "surrogate pair".
 *  * `'word'` - moves selection by a whole word.
 *
 * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.
 *
 * **Note:** Use {@link module:engine/model/model~Model#modifySelection} instead of this function.
 * This function is only exposed to be reusable in algorithms
 * which change the {@link module:engine/model/model~Model#modifySelection}
 * method's behavior.
 *
 * @param {module:engine/model/model~Model} model The model in context of which
 * the selection modification should be performed.
 * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection
 * The selection to modify.
 * @param {Object} [options]
 * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.
 * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.
 */

function modifyselection_modifySelection(model, selection) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var schema = model.schema;
  var isForward = options.direction != 'backward';
  var unit = options.unit ? options.unit : 'character';
  var focus = selection.focus;
  var walker = new model_treewalker_TreeWalker({
    boundaries: getSearchRange(focus, isForward),
    singleCharacters: true,
    direction: isForward ? 'forward' : 'backward'
  });
  var data = {
    walker: walker,
    schema: schema,
    isForward: isForward,
    unit: unit
  };
  var next;

  var _loop = function _loop() {
    if (next.done) {
      return {
        v: void 0
      };
    }

    var position = tryExtendingTo(data, next.value);

    if (position) {
      if (selection instanceof model_documentselection_DocumentSelection) {
        model.change(function (writer) {
          writer.setSelectionFocus(position);
        });
      } else {
        selection.setFocus(position);
      }

      return {
        v: void 0
      };
    }
  };

  while (next = walker.next()) {
    var _ret = _loop();

    if (Object(esm_typeof["a" /* default */])(_ret) === "object") return _ret.v;
  }
} // Checks whether the selection can be extended to the the walker's next value (next position).
// @param {{ walker, unit, isForward, schema }} data
// @param {module:engine/view/treewalker~TreeWalkerValue} value

function tryExtendingTo(data, value) {
  // If found text, we can certainly put the focus in it. Let's just find a correct position
  // based on the unit.
  if (value.type == 'text') {
    if (data.unit === 'word') {
      return getCorrectWordBreakPosition(data.walker, data.isForward);
    }

    return getCorrectPosition(data.walker, data.unit, data.isForward);
  } // Entering an element.


  if (value.type == (data.isForward ? 'elementStart' : 'elementEnd')) {
    // If it's an object, we can select it now.
    if (data.schema.isObject(value.item)) {
      return model_position_Position._createAt(value.item, data.isForward ? 'after' : 'before');
    } // If text allowed on this position, extend to this place.


    if (data.schema.checkChild(value.nextPosition, '$text')) {
      return value.nextPosition;
    }
  } // Leaving an element.
  else {
      // If leaving a limit element, stop.
      if (data.schema.isLimit(value.item)) {
        // NOTE: Fast-forward the walker until the end.
        data.walker.skip(function () {
          return true;
        });
        return;
      } // If text allowed on this position, extend to this place.


      if (data.schema.checkChild(value.nextPosition, '$text')) {
        return value.nextPosition;
      }
    }
} // Finds a correct position by walking in a text node and checking whether selection can be extended to given position
// or should be extended further.
//
// @param {module:engine/model/treewalker~TreeWalker} walker
// @param {String} unit The unit by which selection should be modified.


function getCorrectPosition(walker, unit) {
  var textNode = walker.position.textNode;

  if (textNode) {
    var data = textNode.data;
    var offset = walker.position.offset - textNode.startOffset;

    while (isInsideSurrogatePair(data, offset) || unit == 'character' && isInsideCombinedSymbol(data, offset)) {
      walker.next();
      offset = walker.position.offset - textNode.startOffset;
    }
  }

  return walker.position;
} // Finds a correct position of a word break by walking in a text node and checking whether selection can be extended to given position
// or should be extended further.
//
// @param {module:engine/model/treewalker~TreeWalker} walker
// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.


function getCorrectWordBreakPosition(walker, isForward) {
  var textNode = walker.position.textNode;

  if (textNode) {
    var offset = walker.position.offset - textNode.startOffset;

    while (!isAtWordBoundary(textNode.data, offset, isForward) && !isAtNodeBoundary(textNode, offset, isForward)) {
      walker.next(); // Check of adjacent text nodes with different attributes (like BOLD).
      // Example          : 'foofoo []bar<$text bold="true">bar</$text> bazbaz'
      // should expand to : 'foofoo [bar<$text bold="true">bar</$text>] bazbaz'.

      var nextNode = isForward ? walker.position.nodeAfter : walker.position.nodeBefore; // Scan only text nodes. Ignore inline elements (like `<softBreak>`).

      if (nextNode && nextNode.is('text')) {
        // Check boundary char of an adjacent text node.
        var boundaryChar = nextNode.data.charAt(isForward ? 0 : nextNode.data.length - 1); // Go to the next node if the character at the boundary of that node belongs to the same word.

        if (!wordBoundaryCharacters.includes(boundaryChar)) {
          // If adjacent text node belongs to the same word go to it & reset values.
          walker.next();
          textNode = walker.position.textNode;
        }
      }

      offset = walker.position.offset - textNode.startOffset;
    }
  }

  return walker.position;
}

function getSearchRange(start, isForward) {
  var root = start.root;

  var searchEnd = model_position_Position._createAt(root, isForward ? 'end' : 0);

  if (isForward) {
    return new model_range_Range(start, searchEnd);
  } else {
    return new model_range_Range(searchEnd, start);
  }
} // Checks if selection is on word boundary.
//
// @param {String} data The text node value to investigate.
// @param {Number} offset Position offset.
// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.


function isAtWordBoundary(data, offset, isForward) {
  // The offset to check depends on direction.
  var offsetToCheck = offset + (isForward ? 0 : -1);
  return wordBoundaryCharacters.includes(data.charAt(offsetToCheck));
} // Checks if selection is on node boundary.
//
// @param {module:engine/model/text~Text} textNode The text node to investigate.
// @param {Number} offset Position offset.
// @param {Boolean} isForward Is the direction in which the selection should be modified is forward.


function isAtNodeBoundary(textNode, offset, isForward) {
  return offset === (isForward ? textNode.endOffset : 0);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/utils/getselectedcontent.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/utils/getselectedcontent
 */

/**
 * Gets a clone of the selected content.
 *
 * For example, for the following selection:
 *
 * ```html
 * <p>x</p><quote><p>y</p><h>fir[st</h></quote><p>se]cond</p><p>z</p>
 * ```
 *
 * It will return a document fragment with such a content:
 *
 * ```html
 * <quote><h>st</h></quote><p>se</p>
 * ```
 *
 * @param {module:engine/model/model~Model} model The model in context of which
 * the selection modification should be performed.
 * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection
 * The selection of which content will be returned.
 * @returns {module:engine/model/documentfragment~DocumentFragment}
 */
function getselectedcontent_getSelectedContent(model, selection) {
  return model.change(function (writer) {
    var frag = writer.createDocumentFragment();
    var range = selection.getFirstRange();

    if (!range || range.isCollapsed) {
      return frag;
    }

    var root = range.start.root;
    var commonPath = range.start.getCommonPath(range.end);
    var commonParent = root.getNodeByPath(commonPath); // ## 1st step
    //
    // First, we'll clone a fragment represented by a minimal flat range
    // containing the original range to be cloned.
    // E.g. let's consider such a range:
    //
    // <p>x</p><quote><p>y</p><h>fir[st</h></quote><p>se]cond</p><p>z</p>
    //
    // A minimal flat range containing this one is:
    //
    // <p>x</p>[<quote><p>y</p><h>first</h></quote><p>second</p>]<p>z</p>
    //
    // We can easily clone this structure, preserving e.g. the <quote> element.

    var flatSubtreeRange;

    if (range.start.parent == range.end.parent) {
      // The original range is flat, so take it.
      flatSubtreeRange = range;
    } else {
      flatSubtreeRange = writer.createRange(writer.createPositionAt(commonParent, range.start.path[commonPath.length]), writer.createPositionAt(commonParent, range.end.path[commonPath.length] + 1));
    }

    var howMany = flatSubtreeRange.end.offset - flatSubtreeRange.start.offset; // Clone the whole contents.

    var _iterator = _createForOfIteratorHelper(flatSubtreeRange.getItems({
      shallow: true
    })),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var item = _step.value;

        if (item.is('textProxy')) {
          writer.appendText(item.data, item.getAttributes(), frag);
        } else {
          writer.append(writer.cloneElement(item, true), frag);
        }
      } // ## 2nd step
      //
      // If the original range wasn't flat, then we need to remove the excess nodes from the both ends of the cloned fragment.
      //
      // For example, for the range shown in the 1st step comment, we need to remove these pieces:
      //
      // <quote>[<p>y</p>]<h>[fir]st</h></quote><p>se[cond]</p>
      //
      // So this will be the final copied content:
      //
      // <quote><h>st</h></quote><p>se</p>
      //
      // In order to do that, we remove content from these two ranges:
      //
      // [<quote><p>y</p><h>fir]st</h></quote><p>se[cond</p>]

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    if (flatSubtreeRange != range) {
      // Find the position of the original range in the cloned fragment.
      var newRange = range._getTransformedByMove(flatSubtreeRange.start, writer.createPositionAt(frag, 0), howMany)[0];

      var leftExcessRange = writer.createRange(writer.createPositionAt(frag, 0), newRange.start);
      var rightExcessRange = writer.createRange(newRange.end, writer.createPositionAt(frag, 'end'));
      removeRangeContent(rightExcessRange, writer);
      removeRangeContent(leftExcessRange, writer);
    }

    return frag;
  });
} // After https://github.com/ckeditor/ckeditor5-engine/issues/690 is fixed,
// this function will, most likely, be able to rewritten using getMinimalFlatRanges().

function removeRangeContent(range, writer) {
  var parentsToCheck = [];
  Array.from(range.getItems({
    direction: 'backward'
  })) // We should better store ranges because text proxies will lose integrity
  // with the text nodes when we'll start removing content.
  .map(function (item) {
    return writer.createRangeOn(item);
  }) // Filter only these items which are fully contained in the passed range.
  //
  // E.g. for the following range: [<quote><p>y</p><h>fir]st</h>
  // the walker will return the entire <h> element, when only the "fir" item inside it is fully contained.
  .filter(function (itemRange) {
    // We should be able to use Range.containsRange, but https://github.com/ckeditor/ckeditor5-engine/issues/691.
    var contained = (itemRange.start.isAfter(range.start) || itemRange.start.isEqual(range.start)) && (itemRange.end.isBefore(range.end) || itemRange.end.isEqual(range.end));
    return contained;
  }).forEach(function (itemRange) {
    parentsToCheck.push(itemRange.start.parent);
    writer.remove(itemRange);
  }); // Remove ancestors of the removed items if they turned to be empty now
  // (their whole content was contained in the range).

  parentsToCheck.forEach(function (parentToCheck) {
    var parent = parentToCheck;

    while (parent.parent && parent.isEmpty) {
      var removeRange = writer.createRangeOn(parent);
      parent = parent.parent;
      writer.remove(removeRange);
    }
  });
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/utils/selection-post-fixer.js


/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/utils/selection-post-fixer
 */


/**
 * Injects selection post-fixer to the model.
 *
 * The role of the selection post-fixer is to ensure that the selection is in a correct place
 * after a {@link module:engine/model/model~Model#change `change()`} block was executed.
 *
 * The correct position means that:
 *
 * * All collapsed selection ranges are in a place where the {@link module:engine/model/schema~Schema}
 * allows a `$text`.
 * * None of the selection's non-collapsed ranges crosses a {@link module:engine/model/schema~Schema#isLimit limit element}
 * boundary (a range must be rooted within one limit element).
 * * Only {@link module:engine/model/schema~Schema#isObject object elements} can be selected from the outside
 * (e.g. `[<paragraph>foo</paragraph>]` is invalid). This rule applies independently to both selection ends, so this
 * selection is correct: `<paragraph>f[oo</paragraph><image></image>]`.
 *
 * If the position is not correct, the post-fixer will automatically correct it.
 *
 * ## Fixing a non-collapsed selection
 *
 * See as an example a selection that starts in a P1 element and ends inside the text of a TD element
 * (`[` and `]` are range boundaries and `(l)` denotes an element defined as `isLimit=true`):
 *
 *		root
 *		 |- element P1
 *		 |   |- "foo"                                      root
 *		 |- element TABLE (l)                   P1         TABLE             P2
 *		 |   |- element TR (l)                 f o[o     TR      TR         b a r
 *		 |   |   |- element TD (l)                       TD      TD
 *		 |   |       |- "aaa"                          a]a a    b b b
 *		 |   |- element TR (l)
 *		 |   |   |- element TD (l)                           ||
 *		 |   |       |- "bbb"                                ||
 *		 |- element P2                                       VV
 *		 |   |- "bar"
 *		                                                   root
 *		                                        P1         TABLE]            P2
 *		                                       f o[o     TR      TR         b a r
 *		                                                 TD      TD
 *		                                               a a a    b b b
 *
 * In the example above, the TABLE, TR and TD are defined as `isLimit=true` in the schema. The range which is not contained within
 * a single limit element must be expanded to select the outermost limit element. The range end is inside the text node of the TD element.
 * As the TD element is a child of the TR and TABLE elements, where both are defined as `isLimit=true` in the schema, the range must be
 * expanded to select the whole TABLE element.
 *
 * **Note** If the selection contains multiple ranges, the method returns a minimal set of ranges that are not intersecting after expanding
 * them to select `isLimit=true` elements.
 *
 * @param {module:engine/model/model~Model} model
 */

function injectSelectionPostFixer(model) {
  model.document.registerPostFixer(function (writer) {
    return selectionPostFixer(writer, model);
  });
} // The selection post-fixer.
//
// @param {module:engine/model/writer~Writer} writer
// @param {module:engine/model/model~Model} model

function selectionPostFixer(writer, model) {
  var selection = model.document.selection;
  var schema = model.schema;
  var ranges = [];
  var wasFixed = false;

  var _iterator = _createForOfIteratorHelper(selection.getRanges()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var modelRange = _step.value;
      // Go through all ranges in selection and try fixing each of them.
      // Those ranges might overlap but will be corrected later.
      var correctedRange = tryFixingRange(modelRange, schema); // "Selection fixing" algorithms sometimes get lost. In consequence, it may happen
      // that a new range is returned but, in fact, it has the same positions as the original
      // range anyway. If this range is not discarded, a new selection will be set and that,
      // for instance, would destroy the selection attributes. Let's make sure that the post-fixer
      // actually worked first before setting a new selection.
      //
      // https://github.com/ckeditor/ckeditor5/issues/6693

      if (correctedRange && !correctedRange.isEqual(modelRange)) {
        ranges.push(correctedRange);
        wasFixed = true;
      } else {
        ranges.push(modelRange);
      }
    } // If any of ranges were corrected update the selection.

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (wasFixed) {
    writer.setSelection(mergeIntersectingRanges(ranges), {
      backward: selection.isBackward
    });
  }
} // Tries fixing a range if it's incorrect.
//
// @param {module:engine/model/range~Range} range
// @param {module:engine/model/schema~Schema} schema
// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.


function tryFixingRange(range, schema) {
  if (range.isCollapsed) {
    return tryFixingCollapsedRange(range, schema);
  }

  return tryFixingNonCollapsedRage(range, schema);
} // Tries to fix collapsed ranges.
//
// * Fixes situation when a range is in a place where $text is not allowed
//
// @param {module:engine/model/range~Range} range Collapsed range to fix.
// @param {module:engine/model/schema~Schema} schema
// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.


function tryFixingCollapsedRange(range, schema) {
  var originalPosition = range.start;
  var nearestSelectionRange = schema.getNearestSelectionRange(originalPosition); // This might be null ie when editor data is empty.
  // In such cases there is no need to fix the selection range.

  if (!nearestSelectionRange) {
    return null;
  }

  if (!nearestSelectionRange.isCollapsed) {
    return nearestSelectionRange;
  }

  var fixedPosition = nearestSelectionRange.start; // Fixed position is the same as original - no need to return corrected range.

  if (originalPosition.isEqual(fixedPosition)) {
    return null;
  }

  return new model_range_Range(fixedPosition);
} // Tries to fix an expanded range.
//
// @param {module:engine/model/range~Range} range Expanded range to fix.
// @param {module:engine/model/schema~Schema} schema
// @returns {module:engine/model/range~Range|null} Returns fixed range or null if range is valid.


function tryFixingNonCollapsedRage(range, schema) {
  var start = range.start;
  var end = range.end;
  var isTextAllowedOnStart = schema.checkChild(start, '$text');
  var isTextAllowedOnEnd = schema.checkChild(end, '$text');
  var startLimitElement = schema.getLimitElement(start);
  var endLimitElement = schema.getLimitElement(end); // Ranges which both end are inside the same limit element (or root) might needs only minor fix.

  if (startLimitElement === endLimitElement) {
    // Range is valid when both position allows to place a text:
    // - <block>f[oobarba]z</block>
    // This would be "fixed" by a next check but as it will be the same it's better to return null so the selection stays the same.
    if (isTextAllowedOnStart && isTextAllowedOnEnd) {
      return null;
    } // Range that is on non-limit element (or is partially) must be fixed so it is placed inside the block around $text:
    // - [<block>foo</block>]    ->    <block>[foo]</block>
    // - [<block>foo]</block>    ->    <block>[foo]</block>
    // - <block>f[oo</block>]    ->    <block>f[oo]</block>
    // - [<block>foo</block><object></object>]    ->    <block>[foo</block><object></object>]


    if (checkSelectionOnNonLimitElements(start, end, schema)) {
      var isStartObject = start.nodeAfter && schema.isObject(start.nodeAfter);
      var fixedStart = isStartObject ? null : schema.getNearestSelectionRange(start, 'forward');
      var isEndObject = end.nodeBefore && schema.isObject(end.nodeBefore);
      var fixedEnd = isEndObject ? null : schema.getNearestSelectionRange(end, 'backward'); // The schema.getNearestSelectionRange might return null - if that happens use original position.

      var rangeStart = fixedStart ? fixedStart.start : start;
      var rangeEnd = fixedEnd ? fixedEnd.start : end;
      return new model_range_Range(rangeStart, rangeEnd);
    }
  }

  var isStartInLimit = startLimitElement && !startLimitElement.is('rootElement');
  var isEndInLimit = endLimitElement && !endLimitElement.is('rootElement'); // At this point we eliminated valid positions on text nodes so if one of range positions is placed inside a limit element
  // then the range crossed limit element boundaries and needs to be fixed.

  if (isStartInLimit || isEndInLimit) {
    var bothInSameParent = start.nodeAfter && end.nodeBefore && start.nodeAfter.parent === end.nodeBefore.parent;
    var expandStart = isStartInLimit && (!bothInSameParent || !isInObject(start.nodeAfter, schema));
    var expandEnd = isEndInLimit && (!bothInSameParent || !isInObject(end.nodeBefore, schema)); // Although we've already found limit element on start/end positions we must find the outer-most limit element.
    // as limit elements might be nested directly inside (ie table > tableRow > tableCell).

    var _fixedStart = start;
    var _fixedEnd = end;

    if (expandStart) {
      _fixedStart = model_position_Position._createBefore(findOutermostLimitAncestor(startLimitElement, schema));
    }

    if (expandEnd) {
      _fixedEnd = model_position_Position._createAfter(findOutermostLimitAncestor(endLimitElement, schema));
    }

    return new model_range_Range(_fixedStart, _fixedEnd);
  } // Range was not fixed at this point so it is valid - ie it was placed around limit element already.


  return null;
} // Finds the outer-most ancestor.
//
// @param {module:engine/model/node~Node} startingNode
// @param {module:engine/model/schema~Schema} schema
// @param {String} expandToDirection Direction of expansion - either 'start' or 'end' of the range.
// @returns {module:engine/model/node~Node}


function findOutermostLimitAncestor(startingNode, schema) {
  var isLimitNode = startingNode;
  var parent = isLimitNode; // Find outer most isLimit block as such blocks might be nested (ie. in tables).

  while (schema.isLimit(parent) && parent.parent) {
    isLimitNode = parent;
    parent = parent.parent;
  }

  return isLimitNode;
} // Checks whether any of range boundaries is placed around non-limit elements.
//
// @param {module:engine/model/position~Position} start
// @param {module:engine/model/position~Position} end
// @param {module:engine/model/schema~Schema} schema
// @returns {Boolean}


function checkSelectionOnNonLimitElements(start, end, schema) {
  var startIsOnBlock = start.nodeAfter && !schema.isLimit(start.nodeAfter) || schema.checkChild(start, '$text');
  var endIsOnBlock = end.nodeBefore && !schema.isLimit(end.nodeBefore) || schema.checkChild(end, '$text'); // We should fix such selection when one of those nodes needs fixing.

  return startIsOnBlock || endIsOnBlock;
} // Returns a minimal non-intersecting array of ranges.
//
// @param {Array.<module:engine/model/range~Range>} ranges
// @returns {Array.<module:engine/model/range~Range>}


function mergeIntersectingRanges(ranges) {
  var nonIntersectingRanges = []; // First range will always be fine.

  nonIntersectingRanges.push(ranges.shift());

  var _iterator2 = _createForOfIteratorHelper(ranges),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var range = _step2.value;
      var previousRange = nonIntersectingRanges.pop();

      if (range.isIntersecting(previousRange)) {
        // Get the sum of two ranges.
        var start = previousRange.start.isAfter(range.start) ? range.start : previousRange.start;
        var end = previousRange.end.isAfter(range.end) ? previousRange.end : range.end;
        var merged = new model_range_Range(start, end);
        nonIntersectingRanges.push(merged);
      } else {
        nonIntersectingRanges.push(previousRange);
        nonIntersectingRanges.push(range);
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return nonIntersectingRanges;
} // Checks if node exists and if it's an object.
//
// @param {module:engine/model/node~Node} node
// @param {module:engine/model/schema~Schema} schema
// @returns {Boolean}


function isInObject(node, schema) {
  return node && schema.isObject(node);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/model.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/model/model
 */

















 // @if CK_DEBUG_ENGINE // const { dumpTrees } = require( '../dev-utils/utils' );
// @if CK_DEBUG_ENGINE // const { OperationReplayer } = require( '../dev-utils/operationreplayer' ).default;

/**
 * Editor's data model. Read about the model in the
 * {@glink framework/guides/architecture/editing-engine engine architecture guide}.
 *
 * @mixes module:utils/observablemixin~ObservableMixin
 */

var model_Model = /*#__PURE__*/function () {
  function Model() {
    var _this = this;

    Object(classCallCheck["a" /* default */])(this, Model);

    /**
     * Model's marker collection.
     *
     * @readonly
     * @member {module:engine/model/markercollection~MarkerCollection}
     */
    this.markers = new markercollection_MarkerCollection();
    /**
     * Model's document.
     *
     * @readonly
     * @member {module:engine/model/document~Document}
     */

    this.document = new model_document_Document(this);
    /**
     * Model's schema.
     *
     * @readonly
     * @member {module:engine/model/schema~Schema}
     */

    this.schema = new schema_Schema();
    /**
     * All callbacks added by {@link module:engine/model/model~Model#change} or
     * {@link module:engine/model/model~Model#enqueueChange} methods waiting to be executed.
     *
     * @private
     * @type {Array.<Function>}
     */

    this._pendingChanges = [];
    /**
     * The last created and currently used writer instance.
     *
     * @private
     * @member {module:engine/model/writer~Writer}
     */

    this._currentWriter = null;
    ['insertContent', 'deleteContent', 'modifySelection', 'getSelectedContent', 'applyOperation'].forEach(function (methodName) {
      return _this.decorate(methodName);
    }); // Adding operation validation with `highest` priority, so it is called before any other feature would like
    // to do anything with the operation. If the operation has incorrect parameters it should throw on the earliest occasion.

    this.on('applyOperation', function (evt, args) {
      var operation = args[0];

      operation._validate();
    }, {
      priority: 'highest'
    }); // Register some default abstract entities.

    this.schema.register('$root', {
      isLimit: true
    });
    this.schema.register('$block', {
      allowIn: '$root',
      isBlock: true
    });
    this.schema.register('$text', {
      allowIn: '$block',
      isInline: true
    });
    this.schema.register('$clipboardHolder', {
      allowContentOf: '$root',
      isLimit: true
    });
    this.schema.extend('$text', {
      allowIn: '$clipboardHolder'
    }); // An element needed by the `upcastElementToMarker` converter.
    // This element temporarily represents a marker boundary during the conversion process and is removed
    // at the end of the conversion. `UpcastDispatcher` or at least `Conversion` class looks like a
    // better place for this registration but both know nothing about `Schema`.

    this.schema.register('$marker');
    this.schema.addChildCheck(function (context, childDefinition) {
      if (childDefinition.name === '$marker') {
        return true;
      }
    });
    injectSelectionPostFixer(this); // @if CK_DEBUG_ENGINE // this.on( 'applyOperation', () => {
    // @if CK_DEBUG_ENGINE // 	dumpTrees( this.document, this.document.version );
    // @if CK_DEBUG_ENGINE // }, { priority: 'lowest' } );
  }
  /**
   * The `change()` method is the primary way of changing the model. You should use it to modify all document nodes
   * (including detached nodes – i.e. nodes not added to the {@link module:engine/model/model~Model#document model document}),
   * the {@link module:engine/model/document~Document#selection document's selection}, and
   * {@link module:engine/model/model~Model#markers model markers}.
   *
   *		model.change( writer => {
   *			writer.insertText( 'foo', paragraph, 'end' );
   *		} );
   *
   * All changes inside the change block use the same {@link module:engine/model/batch~Batch} so they are combined
   * into a single undo step.
   *
   *		model.change( writer => {
   *			writer.insertText( 'foo', paragraph, 'end' ); // foo.
   *
   *			model.change( writer => {
   *				writer.insertText( 'bar', paragraph, 'end' ); // foobar.
   *			} );
   *
   * 			writer.insertText( 'bom', paragraph, 'end' ); // foobarbom.
   *		} );
   *
   * The callback of the `change()` block is executed synchronously.
   *
   * You can also return a value from the change block.
   *
   *		const img = model.change( writer => {
   *			return writer.createElement( 'img' );
   *		} );
   *
   * @see #enqueueChange
   * @param {Function} callback Callback function which may modify the model.
   * @returns {*} Value returned by the callback.
   */


  Object(createClass["a" /* default */])(Model, [{
    key: "change",
    value: function change(callback) {
      try {
        if (this._pendingChanges.length === 0) {
          // If this is the outermost block, create a new batch and start `_runPendingChanges` execution flow.
          this._pendingChanges.push({
            batch: new batch_Batch(),
            callback: callback
          });

          return this._runPendingChanges()[0];
        } else {
          // If this is not the outermost block, just execute the callback.
          return callback(this._currentWriter);
        }
      } catch (err) {
        // @if CK_DEBUG // throw err;

        /* istanbul ignore next */
        ckeditorerror["b" /* default */].rethrowUnexpectedError(err, this);
      }
    }
    /**
     * The `enqueueChange()` method performs similar task as the {@link #change `change()` method}, with two major differences.
     *
     * First, the callback of `enqueueChange()` is executed when all other enqueued changes are done. It might be executed
     * immediately if it is not nested in any other change block, but if it is nested in another (enqueue)change block,
     * it will be delayed and executed after the outermost block.
     *
     *		model.change( writer => {
     *			console.log( 1 );
     *
     *			model.enqueueChange( writer => {
     *				console.log( 2 );
     *			} );
     *
     * 			console.log( 3 );
     *		} ); // Will log: 1, 3, 2.
     *
     * In addition to that, the changes enqueued with `enqueueChange()` will be converted separately from the changes
     * done in the outer `change()` block.
     *
     * Second, it lets you define the {@link module:engine/model/batch~Batch} into which you want to add your changes.
     * By default, a new batch is created. In the sample above, `change` and `enqueueChange` blocks use a different
     * batch (and different {@link module:engine/model/writer~Writer} since each of them operates on the separate batch).
     *
     * When using the `enqueueChange()` block you can also add some changes to the batch you used before.
     *
     *		model.enqueueChange( batch, writer => {
     *			writer.insertText( 'foo', paragraph, 'end' );
     *		} );
     *
     * In order to make a nested `enqueueChange()` create a single undo step together with the changes done in the outer `change()`
     * block, you can obtain the batch instance from the  {@link module:engine/model/writer~Writer#batch writer} of the outer block.
     *
     * @param {module:engine/model/batch~Batch|'transparent'|'default'} batchOrType Batch or batch type should be used in the callback.
     * If not defined, a new batch will be created.
     * @param {Function} callback Callback function which may modify the model.
     */

  }, {
    key: "enqueueChange",
    value: function enqueueChange(batchOrType, callback) {
      try {
        if (typeof batchOrType === 'string') {
          batchOrType = new batch_Batch(batchOrType);
        } else if (typeof batchOrType == 'function') {
          callback = batchOrType;
          batchOrType = new batch_Batch();
        }

        this._pendingChanges.push({
          batch: batchOrType,
          callback: callback
        });

        if (this._pendingChanges.length == 1) {
          this._runPendingChanges();
        }
      } catch (err) {
        // @if CK_DEBUG // throw err;

        /* istanbul ignore next */
        ckeditorerror["b" /* default */].rethrowUnexpectedError(err, this);
      }
    }
    /**
     * {@link module:utils/observablemixin~ObservableMixin#decorate Decorated} function for applying
     * {@link module:engine/model/operation/operation~Operation operations} to the model.
     *
     * This is a low-level way of changing the model. It is exposed for very specific use cases (like the undo feature).
     * Normally, to modify the model, you will want to use {@link module:engine/model/writer~Writer `Writer`}.
     * See also {@glink framework/guides/architecture/editing-engine#changing-the-model Changing the model} section
     * of the {@glink framework/guides/architecture/editing-engine Editing architecture} guide.
     *
     * @param {module:engine/model/operation/operation~Operation} operation The operation to apply.
     */

  }, {
    key: "applyOperation",
    value: function applyOperation(operation) {
      // @if CK_DEBUG_ENGINE // console.log( 'Applying ' + operation );
      // @if CK_DEBUG_ENGINE // if ( !this._operationLogs ) {
      // @if CK_DEBUG_ENGINE //	this._operationLogs = [];
      // @if CK_DEBUG_ENGINE // }
      // @if CK_DEBUG_ENGINE // this._operationLogs.push( JSON.stringify( operation ) );
      // @if CK_DEBUG_ENGINE //if ( !this._appliedOperations ) {
      // @if CK_DEBUG_ENGINE //	this._appliedOperations = [];
      // @if CK_DEBUG_ENGINE //}
      // @if CK_DEBUG_ENGINE //this._appliedOperations.push( operation );
      operation._execute();
    } // @if CK_DEBUG_ENGINE // getAppliedOperation() {
    // @if CK_DEBUG_ENGINE //	if ( !this._appliedOperations ) {
    // @if CK_DEBUG_ENGINE //		return '';
    // @if CK_DEBUG_ENGINE //	}
    // @if CK_DEBUG_ENGINE //	return this._appliedOperations.map( JSON.stringify ).join( '-------' );
    // @if CK_DEBUG_ENGINE // }
    // @if CK_DEBUG_ENGINE // createReplayer( stringifiedOperations ) {
    // @if CK_DEBUG_ENGINE //	return new OperationReplayer( this, '-------', stringifiedOperations );
    // @if CK_DEBUG_ENGINE // }

    /**
     * Inserts content at the position in the editor specified by the selection, as one would expect the paste
     * functionality to work.
     *
     * This is a high-level method. It takes the {@link #schema schema} into consideration when inserting
     * the content, clears the given selection's content before inserting nodes and moves the selection
     * to its target position at the end of the process.
     * It can split elements, merge them, wrap bare text nodes with paragraphs, etc. &mdash; just like the
     * pasting feature should do.
     *
     * For lower-level methods see {@link module:engine/model/writer~Writer `Writer`}.
     *
     * This method, unlike {@link module:engine/model/writer~Writer `Writer`}'s methods, does not have to be used
     * inside a {@link #change `change()` block}.
     *
     * # Conversion and schema
     *
     * Inserting elements and text nodes into the model is not enough to make CKEditor 5 render that content
     * to the user. CKEditor 5 implements a model-view-controller architecture and what `model.insertContent()` does
     * is only adding nodes to the model. Additionally, you need to define
     * {@glink framework/guides/architecture/editing-engine#conversion converters} between the model and view
     * and define those nodes in the {@glink framework/guides/architecture/editing-engine#schema schema}.
     *
     * So, while this method may seem similar to CKEditor 4 `editor.insertHtml()` (in fact, both methods
     * are used for paste-like content insertion), the CKEditor 5 method cannot be use to insert arbitrary HTML
     * unless converters are defined for all elements and attributes in that HTML.
     *
     * # Examples
     *
     * Using `insertContent()` with a manually created model structure:
     *
     *		// Let's create a document fragment containing such content as:
     *		//
     *		// <paragraph>foo</paragraph>
     *		// <blockQuote>
     *		//    <paragraph>bar</paragraph>
     *		// </blockQuote>
     *		const docFrag = editor.model.change( writer => {
     *			const p1 = writer.createElement( 'paragraph' );
     *			const p2 = writer.createElement( 'paragraph' );
     *			const blockQuote = writer.createElement( 'blockQuote' );
     *			const docFrag = writer.createDocumentFragment();
     *
     *			writer.append( p1, docFrag );
     *			writer.append( blockQuote, docFrag );
     *			writer.append( p2, blockQuote );
     *			writer.insertText( 'foo', p1 );
     *			writer.insertText( 'bar', p2 );
     *
     *			return docFrag;
     *		} );
     *
     *		// insertContent() does not have to be used in a change() block. It can, though,
     *		// so this code could be moved to the callback defined above.
     *		editor.model.insertContent( docFrag );
     *
     * Using `insertContent()` with an HTML string converted to a model document fragment (similar to the pasting mechanism):
     *
     *		// You can create your own HtmlDataProcessor instance or use editor.data.processor
     *		// if you have not overridden the default one (which is the HtmlDataProcessor instance).
     *		const htmlDP = new HtmlDataProcessor( viewDocument );
     *
     *		// Convert an HTML string to a view document fragment:
     *		const viewFragment = htmlDP.toView( htmlString );
     *
     *		// Convert the view document fragment to a model document fragment
     *		// in the context of $root. This conversion takes the schema into
     *		// account so if, for example, the view document fragment contained a bare text node,
     *		// this text node cannot be a child of $root, so it will be automatically
     *		// wrapped with a <paragraph>. You can define the context yourself (in the second parameter),
     *		// and e.g. convert the content like it would happen in a <paragraph>.
     *		// Note: The clipboard feature uses a custom context called $clipboardHolder
     *		// which has a loosened schema.
     *		const modelFragment = editor.data.toModel( viewFragment );
     *
     *		editor.model.insertContent( modelFragment );
     *
     * By default this method will use the document selection but it can also be used with a position, range or selection instance.
     *
     *		// Insert text at the current document selection position.
     *		editor.model.change( writer => {
     *			editor.model.insertContent( writer.createText( 'x' ) );
     *		} );
     *
     *		// Insert text at a given position - the document selection will not be modified.
     *		editor.model.change( writer => {
     *			editor.model.insertContent( writer.createText( 'x' ), doc.getRoot(), 2 );
     *
     *			// Which is a shorthand for:
     *			editor.model.insertContent( writer.createText( 'x' ), writer.createPositionAt( doc.getRoot(), 2 ) );
     *		} );
     *
     * If you want the document selection to be moved to the inserted content, use the
     * {@link module:engine/model/writer~Writer#setSelection `setSelection()`} method of the writer after inserting
     * the content:
     *
     *		editor.model.change( writer => {
     *			const paragraph = writer.createElement( 'paragraph' );
     *
     *			// Insert an empty paragraph at the beginning of the root.
     *			editor.model.insertContent( paragraph, writer.createPositionAt( editor.model.document.getRoot(), 0 ) );
     *
     *			// Move the document selection to the inserted paragraph.
     *			writer.setSelection( paragraph, 'in' );
     *		} );
     *
     * If an instance of the {@link module:engine/model/selection~Selection model selection} is passed as `selectable`,
     * the new content will be inserted at the passed selection (instead of document selection):
     *
     *		editor.model.change( writer => {
     *			// Create a selection in a paragraph that will be used as a place of insertion.
     *			const selection = writer.createSelection( paragraph, 'in' );
     *
     *			// Insert the new text at the created selection.
     *			editor.model.insertContent( writer.createText( 'x' ), selection );
     *
     *			// insertContent() modifies the passed selection instance so it can be used to set the document selection.
     *			// Note: This is not necessary when you passed the document selection to insertContent().
     *			writer.setSelection( selection );
     *		} );
     *
     * @fires insertContent
     * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.
     * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]
     * The selection into which the content should be inserted. If not provided the current model document selection will be used.
     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] To be used when a model item was passed as `selectable`.
     * This param defines a position in relation to that item.
     * @returns {module:engine/model/range~Range} Range which contains all the performed changes. This is a range that, if removed,
     * would return the model to the state before the insertion. If no changes were preformed by `insertContent`, returns a range collapsed
     * at the insertion position.
     */

  }, {
    key: "insertContent",
    value: function insertContent(content, selectable, placeOrOffset) {
      return insertcontent_insertContent(this, content, selectable, placeOrOffset);
    }
    /**
     * Deletes content of the selection and merge siblings. The resulting selection is always collapsed.
     *
     * **Note:** For the sake of predictability, the resulting selection should always be collapsed.
     * In cases where a feature wants to modify deleting behavior so selection isn't collapsed
     * (e.g. a table feature may want to keep row selection after pressing <kbd>Backspace</kbd>),
     * then that behavior should be implemented in the view's listener. At the same time, the table feature
     * will need to modify this method's behavior too, e.g. to "delete contents and then collapse
     * the selection inside the last selected cell" or "delete the row and collapse selection somewhere near".
     * That needs to be done in order to ensure that other features which use `deleteContent()` will work well with tables.
     *
     * @fires deleteContent
     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection
     * Selection of which the content should be deleted.
     * @param {Object} [options]
     * @param {Boolean} [options.leaveUnmerged=false] Whether to merge elements after removing the content of the selection.
     *
     * For example `<heading1>x[x</heading1><paragraph>y]y</paragraph>` will become:
     *
     * * `<heading1>x^y</heading1>` with the option disabled (`leaveUnmerged == false`)
     * * `<heading1>x^</heading1><paragraph>y</paragraph>` with enabled (`leaveUnmerged == true`).
     *
     * Note: {@link module:engine/model/schema~Schema#isObject object} and {@link module:engine/model/schema~Schema#isLimit limit}
     * elements will not be merged.
     *
     * @param {Boolean} [options.doNotResetEntireContent=false] Whether to skip replacing the entire content with a
     * paragraph when the entire content was selected.
     *
     * For example `<heading1>[x</heading1><paragraph>y]</paragraph>` will become:
     *
     * * `<paragraph>^</paragraph>` with the option disabled (`doNotResetEntireContent == false`)
     * * `<heading1>^</heading1>` with enabled (`doNotResetEntireContent == true`)
     *
     * @param {Boolean} [options.doNotAutoparagraph=false] Whether to create a paragraph if after content deletion selection is moved
     * to a place where text cannot be inserted.
     *
     * For example `<paragraph>x</paragraph>[<image src="foo.jpg"></image>]` will become:
     *
     * * `<paragraph>x</paragraph><paragraph>[]</paragraph>` with the option disabled (`doNotAutoparagraph == false`)
     * * `<paragraph>x[]</paragraph>` with the option enabled (`doNotAutoparagraph == true`).
     *
     * **Note:** if there is no valid position for the selection, the paragraph will always be created:
     *
     * `[<image src="foo.jpg"></image>]` -> `<paragraph>[]</paragraph>`.
     *
     * @param {'forward'|'backward'} [options.direction='backward'] The direction in which the content is being consumed.
     * Deleting backward corresponds to using the <kbd>Backspace</kbd> key, while deleting content forward corresponds to
     * the <kbd>Shift</kbd>+<kbd>Backspace</kbd> keystroke.
     */

  }, {
    key: "deleteContent",
    value: function deleteContent(selection, options) {
      deletecontent_deleteContent(this, selection, options);
    }
    /**
     * Modifies the selection. Currently, the supported modifications are:
     *
     * * Extending. The selection focus is moved in the specified `options.direction` with a step specified in `options.unit`.
     * Possible values for `unit` are:
     *  * `'character'` (default) - moves selection by one user-perceived character. In most cases this means moving by one
     *  character in `String` sense. However, unicode also defines "combing marks". These are special symbols, that combines
     *  with a symbol before it ("base character") to create one user-perceived character. For example, `q̣̇` is a normal
     *  letter `q` with two "combining marks": upper dot (`Ux0307`) and lower dot (`Ux0323`). For most actions, i.e. extending
     *  selection by one position, it is correct to include both "base character" and all of it's "combining marks". That is
     *  why `'character'` value is most natural and common method of modifying selection.
     *  * `'codePoint'` - moves selection by one unicode code point. In contrary to, `'character'` unit, this will insert
     *  selection between "base character" and "combining mark", because "combining marks" have their own unicode code points.
     *  However, for technical reasons, unicode code points with values above `UxFFFF` are represented in native `String` by
     *  two characters, called "surrogate pairs". Halves of "surrogate pairs" have a meaning only when placed next to each other.
     *  For example `𨭎` is represented in `String` by `\uD862\uDF4E`. Both `\uD862` and `\uDF4E` do not have any meaning
     *  outside the pair (are rendered as ? when alone). Position between them would be incorrect. In this case, selection
     *  extension will include whole "surrogate pair".
     *  * `'word'` - moves selection by a whole word.
     *
     * **Note:** if you extend a forward selection in a backward direction you will in fact shrink it.
     *
     * @fires modifySelection
     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection
     * The selection to modify.
     * @param {Object} [options]
     * @param {'forward'|'backward'} [options.direction='forward'] The direction in which the selection should be modified.
     * @param {'character'|'codePoint'|'word'} [options.unit='character'] The unit by which selection should be modified.
     */

  }, {
    key: "modifySelection",
    value: function modifySelection(selection, options) {
      modifyselection_modifySelection(this, selection, options);
    }
    /**
     * Gets a clone of the selected content.
     *
     * For example, for the following selection:
     *
     * ```html
     * <paragraph>x</paragraph>
     * <blockQuote>
     *	<paragraph>y</paragraph>
     *	<heading1>fir[st</heading1>
     * </blockQuote>
     * <paragraph>se]cond</paragraph>
     * <paragraph>z</paragraph>
     * ```
     *
     * It will return a document fragment with such a content:
     *
     * ```html
     * <blockQuote>
     *	<heading1>st</heading1>
     * </blockQuote>
     * <paragraph>se</paragraph>
     * ```
     *
     * @fires getSelectedContent
     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection
     * The selection of which content will be returned.
     * @returns {module:engine/model/documentfragment~DocumentFragment}
     */

  }, {
    key: "getSelectedContent",
    value: function getSelectedContent(selection) {
      return getselectedcontent_getSelectedContent(this, selection);
    }
    /**
     * Checks whether the given {@link module:engine/model/range~Range range} or
     * {@link module:engine/model/element~Element element} has any meaningful content.
     *
     * Meaningful content is:
     *
     * * any text node (`options.ignoreWhitespaces` allows controlling whether this text node must also contain
     * any non-whitespace characters),
     * * or any {@link module:engine/model/schema~Schema#isObject object element},
     * * or any {@link module:engine/model/markercollection~Marker marker} which
     * {@link module:engine/model/markercollection~Marker#_affectsData affects data}.
     *
     * This means that a range containing an empty `<paragraph></paragraph>` is not considered to have a meaningful content.
     * However, a range containing an `<image></image>` (which would normally be marked in the schema as an object element)
     * is considered non-empty.
     *
     * @param {module:engine/model/range~Range|module:engine/model/element~Element} rangeOrElement Range or element to check.
     * @param {Object} [options]
     * @param {Boolean} [options.ignoreWhitespaces] Whether text node with whitespaces only should be considered empty.
     * @param {Boolean} [options.ignoreMarkers] Whether markers should be ignored.
     * @returns {Boolean}
     */

  }, {
    key: "hasContent",
    value: function hasContent(rangeOrElement) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var range = rangeOrElement instanceof model_element_Element ? model_range_Range._createIn(rangeOrElement) : rangeOrElement;

      if (range.isCollapsed) {
        return false;
      }

      var _options$ignoreWhites = options.ignoreWhitespaces,
          ignoreWhitespaces = _options$ignoreWhites === void 0 ? false : _options$ignoreWhites,
          _options$ignoreMarker = options.ignoreMarkers,
          ignoreMarkers = _options$ignoreMarker === void 0 ? false : _options$ignoreMarker; // Check if there are any markers which affects data in this given range.

      if (!ignoreMarkers) {
        var _iterator = _createForOfIteratorHelper(this.markers.getMarkersIntersectingRange(range)),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var intersectingMarker = _step.value;

            if (intersectingMarker.affectsData) {
              return true;
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      var _iterator2 = _createForOfIteratorHelper(range.getItems()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var item = _step2.value;

          if (item.is('textProxy')) {
            if (!ignoreWhitespaces) {
              return true;
            } else if (item.data.search(/\S/) !== -1) {
              return true;
            }
          } else if (this.schema.isObject(item)) {
            return true;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return false;
    }
    /**
     * Creates a position from the given root and path in that root.
     *
     * Note: This method is also available as
     * {@link module:engine/model/writer~Writer#createPositionFromPath `Writer#createPositionFromPath()`}.
     *
     * @param {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment} root Root of the position.
     * @param {Array.<Number>} path Position path. See {@link module:engine/model/position~Position#path}.
     * @param {module:engine/model/position~PositionStickiness} [stickiness='toNone'] Position stickiness.
     * See {@link module:engine/model/position~PositionStickiness}.
     * @returns {module:engine/model/position~Position}
     */

  }, {
    key: "createPositionFromPath",
    value: function createPositionFromPath(root, path, stickiness) {
      return new model_position_Position(root, path, stickiness);
    }
    /**
     * Creates position at the given location. The location can be specified as:
     *
     * * a {@link module:engine/model/position~Position position},
     * * a parent element and offset in that element,
     * * a parent element and `'end'` (the position will be set at the end of that element),
     * * a {@link module:engine/model/item~Item model item} and `'before'` or `'after'`
     * (the position will be set before or after the given model item).
     *
     * This method is a shortcut to other factory methods such as:
     *
     * * {@link module:engine/model/model~Model#createPositionBefore `createPositionBefore()`},
     * * {@link module:engine/model/model~Model#createPositionAfter `createPositionAfter()`}.
     *
     * Note: This method is also available as
     * {@link module:engine/model/writer~Writer#createPositionAt `Writer#createPositionAt()`},
     *
     * @param {module:engine/model/item~Item|module:engine/model/position~Position} itemOrPosition
     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when
     * first parameter is a {@link module:engine/model/item~Item model item}.
     */

  }, {
    key: "createPositionAt",
    value: function createPositionAt(itemOrPosition, offset) {
      return model_position_Position._createAt(itemOrPosition, offset);
    }
    /**
     * Creates a new position after the given {@link module:engine/model/item~Item model item}.
     *
     * Note: This method is also available as
     * {@link module:engine/model/writer~Writer#createPositionAfter `Writer#createPositionAfter()`}.
     *
     * @param {module:engine/model/item~Item} item Item after which the position should be placed.
     * @returns {module:engine/model/position~Position}
     */

  }, {
    key: "createPositionAfter",
    value: function createPositionAfter(item) {
      return model_position_Position._createAfter(item);
    }
    /**
     * Creates a new position before the given {@link module:engine/model/item~Item model item}.
     *
     * Note: This method is also available as
     * {@link module:engine/model/writer~Writer#createPositionBefore `Writer#createPositionBefore()`}.
     *
     * @param {module:engine/model/item~Item} item Item before which the position should be placed.
     * @returns {module:engine/model/position~Position}
     */

  }, {
    key: "createPositionBefore",
    value: function createPositionBefore(item) {
      return model_position_Position._createBefore(item);
    }
    /**
     * Creates a range spanning from the `start` position to the `end` position.
     *
     * Note: This method is also available as
     * {@link module:engine/model/writer~Writer#createRange `Writer#createRange()`}:
     *
     *		model.change( writer => {
     *			const range = writer.createRange( start, end );
     *		} );
     *
     * @param {module:engine/model/position~Position} start Start position.
     * @param {module:engine/model/position~Position} [end] End position. If not set, the range will be collapsed
     * to the `start` position.
     * @returns {module:engine/model/range~Range}
     */

  }, {
    key: "createRange",
    value: function createRange(start, end) {
      return new model_range_Range(start, end);
    }
    /**
     * Creates a range inside the given element which starts before the first child of
     * that element and ends after the last child of that element.
     *
     * Note: This method is also available as
     * {@link module:engine/model/writer~Writer#createRangeIn `Writer#createRangeIn()`}:
     *
     *		model.change( writer => {
     *			const range = writer.createRangeIn( paragraph );
     *		} );
     *
     * @param {module:engine/model/element~Element} element Element which is a parent for the range.
     * @returns {module:engine/model/range~Range}
     */

  }, {
    key: "createRangeIn",
    value: function createRangeIn(element) {
      return model_range_Range._createIn(element);
    }
    /**
     * Creates a range that starts before the given {@link module:engine/model/item~Item model item} and ends after it.
     *
     * Note: This method is also available on `writer` instance as
     * {@link module:engine/model/writer~Writer#createRangeOn `Writer.createRangeOn()`}:
     *
     *		model.change( writer => {
     *			const range = writer.createRangeOn( paragraph );
     *		} );
     *
     * @param {module:engine/model/item~Item} item
     * @returns {module:engine/model/range~Range}
     */

  }, {
    key: "createRangeOn",
    value: function createRangeOn(item) {
      return model_range_Range._createOn(item);
    }
    /**
     * Creates a new selection instance based on the given {@link module:engine/model/selection~Selectable selectable}
     * or creates an empty selection if no arguments were passed.
     *
     * Note: This method is also available as
     * {@link module:engine/model/writer~Writer#createSelection `Writer#createSelection()`}.
     *
     *		// Creates empty selection without ranges.
     *		const selection = writer.createSelection();
     *
     *		// Creates selection at the given range.
     *		const range = writer.createRange( start, end );
     *		const selection = writer.createSelection( range );
     *
     *		// Creates selection at the given ranges
     *		const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
     *		const selection = writer.createSelection( ranges );
     *
     *		// Creates selection from the other selection.
     *		// Note: It doesn't copies selection attributes.
     *		const otherSelection = writer.createSelection();
     *		const selection = writer.createSelection( otherSelection );
     *
     *		// Creates selection from the given document selection.
     *		// Note: It doesn't copies selection attributes.
     *		const documentSelection = model.document.selection;
     *		const selection = writer.createSelection( documentSelection );
     *
     *		// Creates selection at the given position.
     *		const position = writer.createPositionFromPath( root, path );
     *		const selection = writer.createSelection( position );
     *
     *		// Creates selection at the given offset in the given element.
     *		const paragraph = writer.createElement( 'paragraph' );
     *		const selection = writer.createSelection( paragraph, offset );
     *
     *		// Creates a range inside an {@link module:engine/model/element~Element element} which starts before the
     *		// first child of that element and ends after the last child of that element.
     *		const selection = writer.createSelection( paragraph, 'in' );
     *
     *		// Creates a range on an {@link module:engine/model/item~Item item} which starts before the item and ends
     *		// just after the item.
     *		const selection = writer.createSelection( paragraph, 'on' );
     *
     *		// Additional options (`'backward'`) can be specified as the last argument.
     *
     *		// Creates backward selection.
     *		const selection = writer.createSelection( range, { backward: true } );
     *
     * @param {module:engine/model/selection~Selectable} selectable
     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Sets place or offset of the selection.
     * @param {Object} [options]
     * @param {Boolean} [options.backward] Sets this selection instance to be backward.
     * @returns {module:engine/model/selection~Selection}
     */

  }, {
    key: "createSelection",
    value: function createSelection(selectable, placeOrOffset, options) {
      return new model_selection_Selection(selectable, placeOrOffset, options);
    }
    /**
     * Creates a {@link module:engine/model/batch~Batch} instance.
     *
     * **Note:** In most cases creating a batch instance is not necessary as they are created when using:
     *
     * * {@link #change `change()`},
     * * {@link #enqueueChange `enqueueChange()`}.
     *
     * @param {'transparent'|'default'} [type='default'] The type of the batch.
     * @returns {module:engine/model/batch~Batch}
     */

  }, {
    key: "createBatch",
    value: function createBatch(type) {
      return new batch_Batch(type);
    }
    /**
     * Creates an operation instance from a JSON object (parsed JSON string).
     *
     * This is an alias for {@link module:engine/model/operation/operationfactory~OperationFactory.fromJSON `OperationFactory.fromJSON()`}.
     *
     * @param {Object} json Deserialized JSON object.
     * @returns {module:engine/model/operation/operation~Operation}
     */

  }, {
    key: "createOperationFromJSON",
    value: function createOperationFromJSON(json) {
      return operationfactory_OperationFactory.fromJSON(json, this.document);
    }
    /**
     * Removes all events listeners set by model instance and destroys {@link module:engine/model/document~Document}.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.document.destroy();
      this.stopListening();
    }
    /**
     * Common part of {@link module:engine/model/model~Model#change} and {@link module:engine/model/model~Model#enqueueChange}
     * which calls callbacks and returns array of values returned by these callbacks.
     *
     * @private
     * @returns {Array.<*>} Array of values returned by callbacks.
     */

  }, {
    key: "_runPendingChanges",
    value: function _runPendingChanges() {
      var ret = [];
      this.fire('_beforeChanges');

      while (this._pendingChanges.length) {
        // Create a new writer using batch instance created for this chain of changes.
        var currentBatch = this._pendingChanges[0].batch;
        this._currentWriter = new writer_Writer(this, currentBatch); // Execute changes callback and gather the returned value.

        var callbackReturnValue = this._pendingChanges[0].callback(this._currentWriter);

        ret.push(callbackReturnValue);

        this.document._handleChangeBlock(this._currentWriter);

        this._pendingChanges.shift();

        this._currentWriter = null;
      }

      this.fire('_afterChanges');
      return ret;
    }
    /**
     * Fired when entering the outermost {@link module:engine/model/model~Model#enqueueChange} or
     * {@link module:engine/model/model~Model#change} block.
     *
     * @protected
     * @event _beforeChanges
     */

    /**
     * Fired when leaving the outermost {@link module:engine/model/model~Model#enqueueChange} or
     * {@link module:engine/model/model~Model#change} block.
     *
     * @protected
     * @event _afterChanges
     */

    /**
     * Fired every time any {@link module:engine/model/operation/operation~Operation operation} is applied on the model
     * using {@link #applyOperation}.
     *
     * Note that this event is suitable only for very specific use-cases. Use it if you need to listen to every single operation
     * applied on the document. However, in most cases {@link module:engine/model/document~Document#event:change} should
     * be used.
     *
     * A few callbacks are already added to this event by engine internal classes:
     *
     * * with `highest` priority operation is validated,
     * * with `normal` priority operation is executed,
     * * with `low` priority the {@link module:engine/model/document~Document} updates its version,
     * * with `low` priority {@link module:engine/model/liveposition~LivePosition} and {@link module:engine/model/liverange~LiveRange}
     * update themselves.
     *
     * @event applyOperation
     * @param {Array} args Arguments of the `applyOperation` which is an array with a single element - applied
     * {@link module:engine/model/operation/operation~Operation operation}.
     */

    /**
     * Event fired when {@link #insertContent} method is called.
     *
     * The {@link #insertContent default action of that method} is implemented as a
     * listener to this event so it can be fully customized by the features.
     *
     * **Note** The `selectable` parameter for the {@link #insertContent} is optional. When `undefined` value is passed the method uses
     * `model.document.selection`.
     *
     * @event insertContent
     * @param {Array} args The arguments passed to the original method.
     */

    /**
     * Event fired when {@link #deleteContent} method is called.
     *
     * The {@link #deleteContent default action of that method} is implemented as a
     * listener to this event so it can be fully customized by the features.
     *
     * @event deleteContent
     * @param {Array} args The arguments passed to the original method.
     */

    /**
     * Event fired when {@link #modifySelection} method is called.
     *
     * The {@link #modifySelection default action of that method} is implemented as a
     * listener to this event so it can be fully customized by the features.
     *
     * @event modifySelection
     * @param {Array} args The arguments passed to the original method.
     */

    /**
     * Event fired when {@link #getSelectedContent} method is called.
     *
     * The {@link #getSelectedContent default action of that method} is implemented as a
     * listener to this event so it can be fully customized by the features.
     *
     * @event getSelectedContent
     * @param {Array} args The arguments passed to the original method.
     */

  }]);

  return Model;
}();


mix(model_Model, observablemixin);
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/keystrokehandler.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/keystrokehandler
 */


/**
 * Keystroke handler allows registering callbacks for given keystrokes.
 *
 * The most frequent use of this class is through the {@link module:core/editor/editor~Editor#keystrokes `editor.keystrokes`}
 * property. It allows listening to keystrokes executed in the editing view:
 *
 *		editor.keystrokes.set( 'Ctrl+A', ( keyEvtData, cancel ) => {
 *			console.log( 'Ctrl+A has been pressed' );
 *			cancel();
 *		} );
 *
 * However, this utility class can be used in various part of the UI. For instance, a certain {@link module:ui/view~View}
 * can use it like this:
 *
 *		class MyView extends View {
 *			constructor() {
 *				this.keystrokes = new KeystrokeHandler();
 *
 * 				this.keystrokes.set( 'tab', handleTabKey );
 *			}
 *
 *			render() {
 *				super.render();
 *
 *				this.keystrokes.listenTo( this.element );
 *			}
 *		}
 *
 * That keystroke handler will listen to `keydown` events fired in this view's main element.
 *
 */

var keystrokehandler_KeystrokeHandler = /*#__PURE__*/function () {
  /**
   * Creates an instance of the keystroke handler.
   */
  function KeystrokeHandler() {
    Object(classCallCheck["a" /* default */])(this, KeystrokeHandler);

    /**
     * Listener used to listen to events for easier keystroke handler destruction.
     *
     * @protected
     * @member {module:utils/dom/emittermixin~Emitter}
     */
    this._listener = Object.create(dom_emittermixin);
  }
  /**
   * Starts listening for `keydown` events from a given emitter.
   *
   * @param {module:utils/emittermixin~Emitter} emitter
   */


  Object(createClass["a" /* default */])(KeystrokeHandler, [{
    key: "listenTo",
    value: function listenTo(emitter) {
      var _this = this;

      // The #_listener works here as a kind of dispatcher. It groups the events coming from the same
      // keystroke so the listeners can be attached to them with different priorities.
      //
      // E.g. all the keystrokes with the `keyCode` of 42 coming from the `emitter` are propagated
      // as a `_keydown:42` event by the `_listener`. If there's a callback created by the `set`
      // method for this 42 keystroke, it listens to the `_listener#_keydown:42` event only and interacts
      // only with other listeners of this particular event, thus making it possible to prioritize
      // the listeners and safely cancel execution, when needed. Instead of duplicating the Emitter logic,
      // the KeystrokeHandler re–uses it to do its job.
      this._listener.listenTo(emitter, 'keydown', function (evt, keyEvtData) {
        _this._listener.fire('_keydown:' + getCode(keyEvtData), keyEvtData);
      });
    }
    /**
     * Registers a handler for the specified keystroke.
     *
     * @param {String|Array.<String|Number>} keystroke Keystroke defined in a format accepted by
     * the {@link module:utils/keyboard~parseKeystroke} function.
     * @param {Function} callback A function called with the
     * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and
     * a helper funcion to call both `preventDefault()` and `stopPropagation()` on the underlying event.
     * @param {Object} [options={}] Additional options.
     * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of the keystroke
     * callback. The higher the priority value the sooner the callback will be executed. Keystrokes having the same priority
     * are called in the order they were added.
     */

  }, {
    key: "set",
    value: function set(keystroke, callback) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var keyCode = parseKeystroke(keystroke);
      var priority = options.priority; // Execute the passed callback on KeystrokeHandler#_keydown.
      // TODO: https://github.com/ckeditor/ckeditor5-utils/issues/144

      this._listener.listenTo(this._listener, '_keydown:' + keyCode, function (evt, keyEvtData) {
        callback(keyEvtData, function () {
          // Stop the event in the DOM: no listener in the web page
          // will be triggered by this event.
          keyEvtData.preventDefault();
          keyEvtData.stopPropagation(); // Stop the event in the KeystrokeHandler: no more callbacks
          // will be executed for this keystroke.

          evt.stop();
        }); // Mark this keystroke as handled by the callback. See: #press.

        evt.return = true;
      }, {
        priority: priority
      });
    }
    /**
     * Triggers a keystroke handler for a specified key combination, if such a keystroke was {@link #set defined}.
     *
     * @param {module:engine/view/observer/keyobserver~KeyEventData} keyEvtData Key event data.
     * @returns {Boolean} Whether the keystroke was handled.
     */

  }, {
    key: "press",
    value: function press(keyEvtData) {
      return !!this._listener.fire('_keydown:' + getCode(keyEvtData), keyEvtData);
    }
    /**
     * Destroys the keystroke handler.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this._listener.stopListening();
    }
  }]);

  return KeystrokeHandler;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-core/src/editingkeystrokehandler.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module core/editingkeystrokehandler
 */

/**
 * A keystroke handler for editor editing. Its instance is available
 * in {@link module:core/editor/editor~Editor#keystrokes} so plugins
 * can register their keystrokes.
 *
 * E.g. an undo plugin would do this:
 *
 *		editor.keystrokes.set( 'Ctrl+Z', 'undo' );
 *		editor.keystrokes.set( 'Ctrl+Shift+Z', 'redo' );
 *		editor.keystrokes.set( 'Ctrl+Y', 'redo' );
 *
 * @extends module:utils/keystrokehandler~KeystrokeHandler
 */

var editingkeystrokehandler_EditingKeystrokeHandler = /*#__PURE__*/function (_KeystrokeHandler) {
  Object(inherits["a" /* default */])(EditingKeystrokeHandler, _KeystrokeHandler);

  var _super = Object(createSuper["a" /* default */])(EditingKeystrokeHandler);

  /**
   * Creates an instance of the keystroke handler.
   *
   * @param {module:core/editor/editor~Editor} editor
   */
  function EditingKeystrokeHandler(editor) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, EditingKeystrokeHandler);

    _this = _super.call(this);
    /**
     * The editor instance.
     *
     * @readonly
     * @member {module:core/editor/editor~Editor}
     */

    _this.editor = editor;
    return _this;
  }
  /**
   * Registers a handler for the specified keystroke.
   *
   * The handler can be specified as a command name or a callback.
   *
   * @param {String|Array.<String|Number>} keystroke Keystroke defined in a format accepted by
   * the {@link module:utils/keyboard~parseKeystroke} function.
   * @param {Function|String} callback If a string is passed, then the keystroke will
   * {@link module:core/editor/editor~Editor#execute execute a command}.
   * If a function, then it will be called with the
   * {@link module:engine/view/observer/keyobserver~KeyEventData key event data} object and
   * a `cancel()` helper to both `preventDefault()` and `stopPropagation()` of the event.
   * @param {Object} [options={}] Additional options.
   * @param {module:utils/priorities~PriorityString|Number} [options.priority='normal'] The priority of the keystroke
   * callback. The higher the priority value the sooner the callback will be executed. Keystrokes having the same priority
   * are called in the order they were added.
   */


  Object(createClass["a" /* default */])(EditingKeystrokeHandler, [{
    key: "set",
    value: function set(keystroke, callback) {
      var _this2 = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (typeof callback == 'string') {
        var commandName = callback;

        callback = function callback(evtData, cancel) {
          _this2.editor.execute(commandName);

          cancel();
        };
      }

      get_get(Object(getPrototypeOf["a" /* default */])(EditingKeystrokeHandler.prototype), "set", this).call(this, keystroke, callback, options);
    }
  }]);

  return EditingKeystrokeHandler;
}(keystrokehandler_KeystrokeHandler);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-core/src/editor/editor.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module core/editor/editor
 */













/**
 * The class representing a basic, generic editor.
 *
 * Check out the list of its subclasses to learn about specific editor implementations.
 *
 * All editor implementations (like {@link module:editor-classic/classiceditor~ClassicEditor} or
 * {@link module:editor-inline/inlineeditor~InlineEditor}) should extend this class. They can add their
 * own methods and properties.
 *
 * When you are implementing a plugin, this editor represents the API
 * which your plugin can expect to get when using its {@link module:core/plugin~Plugin#editor} property.
 *
 * This API should be sufficient in order to implement the "editing" part of your feature
 * (schema definition, conversion, commands, keystrokes, etc.).
 * It does not define the editor UI, which is available only if
 * the specific editor implements also the {@link module:core/editor/editorwithui~EditorWithUI} interface
 * (as most editor implementations do).
 *
 * @abstract
 * @mixes module:utils/observablemixin~ObservableMixin
 */

var editor_Editor = /*#__PURE__*/function () {
  /**
   * Creates a new instance of the editor class.
   *
   * Usually, not to be used directly. See the static {@link module:core/editor/editor~Editor.create `create()`} method.
   *
   * @param {Object} [config={}] The editor configuration.
   */
  function Editor() {
    var _this = this;

    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    Object(classCallCheck["a" /* default */])(this, Editor);

    /**
     * The editor context.
     * When it is not provided through the configuration, the editor creates it.
     *
     * @protected
     * @type {module:core/context~Context}
     */
    this._context = config.context || new context_Context({
      language: config.language
    });

    this._context._addEditor(this, !config.context); // Clone the plugins to make sure that the plugin array will not be shared
    // between editors and make the watchdog feature work correctly.


    var availablePlugins = Array.from(this.constructor.builtinPlugins || []);
    /**
     * Stores all configurations specific to this editor instance.
     *
     *		editor.config.get( 'image.toolbar' );
     *		// -> [ 'imageStyle:full', 'imageStyle:side', '|', 'imageTextAlternative' ]
     *
     * @readonly
     * @member {module:utils/config~Config}
     */

    this.config = new config_Config(config, this.constructor.defaultConfig);
    this.config.define('plugins', availablePlugins);
    this.config.define(this._context._getEditorConfig());
    /**
     * The plugins loaded and in use by this editor instance.
     *
     *		editor.plugins.get( 'Clipboard' ); // -> An instance of the clipboard plugin.
     *
     * @readonly
     * @member {module:core/plugincollection~PluginCollection}
     */

    this.plugins = new plugincollection_PluginCollection(this, availablePlugins, this._context.plugins);
    /**
     * @readonly
     * @type {module:utils/locale~Locale}
     */

    this.locale = this._context.locale;
    /**
     * Shorthand for {@link module:utils/locale~Locale#t}.
     *
     * @see module:utils/locale~Locale#t
     * @method #t
     */

    this.t = this.locale.t;
    /**
     * Commands registered to the editor.
     *
     * Use the shorthand {@link #execute `editor.execute()`} method to execute commands:
     *
     *		// Execute the bold command:
     *		editor.execute( 'bold' );
     *
     *		// Check the state of the bold command:
     *		editor.commands.get( 'bold' ).value;
     *
     * @readonly
     * @member {module:core/commandcollection~CommandCollection}
     */

    this.commands = new commandcollection_CommandCollection();
    /**
     * Indicates the editor life-cycle state.
     *
     * The editor is in one of the following states:
     *
     * * `initializing` &ndash; During the editor initialization (before
     * {@link module:core/editor/editor~Editor.create `Editor.create()`}) finished its job.
     * * `ready` &ndash; After the promise returned by the {@link module:core/editor/editor~Editor.create `Editor.create()`}
     * method is resolved.
     * * `destroyed` &ndash; Once the {@link #destroy `editor.destroy()`} method was called.
     *
     * @observable
     * @member {'initializing'|'ready'|'destroyed'} #state
     */

    this.set('state', 'initializing');
    this.once('ready', function () {
      return _this.state = 'ready';
    }, {
      priority: 'high'
    });
    this.once('destroy', function () {
      return _this.state = 'destroyed';
    }, {
      priority: 'high'
    });
    /**
     * Defines whether this editor is in read-only mode.
     *
     * In read-only mode the editor {@link #commands commands} are disabled so it is not possible
     * to modify the document by using them. Also, the editable element(s) become non-editable.
     *
     * In order to make the editor read-only, you can set this value directly:
     *
     *		editor.isReadOnly = true;
     *
     * @observable
     * @member {Boolean} #isReadOnly
     */

    this.set('isReadOnly', false);
    /**
     * The editor's model.
     *
     * The central point of the editor's abstract data model.
     *
     * @readonly
     * @member {module:engine/model/model~Model}
     */

    this.model = new model_Model();
    var stylesProcessor = new stylesmap_StylesProcessor();
    /**
     * The {@link module:engine/controller/datacontroller~DataController data controller}.
     * Used e.g. for setting and retrieving the editor data.
     *
     * @readonly
     * @member {module:engine/controller/datacontroller~DataController}
     */

    this.data = new datacontroller_DataController(this.model, stylesProcessor);
    /**
     * The {@link module:engine/controller/editingcontroller~EditingController editing controller}.
     * Controls user input and rendering the content for editing.
     *
     * @readonly
     * @member {module:engine/controller/editingcontroller~EditingController}
     */

    this.editing = new editingcontroller_EditingController(this.model, stylesProcessor);
    this.editing.view.document.bind('isReadOnly').to(this);
    /**
     * Conversion manager through which you can register model-to-view and view-to-model converters.
     *
     * See the {@link module:engine/conversion/conversion~Conversion} documentation to learn how to add converters.
     *
     * @readonly
     * @member {module:engine/conversion/conversion~Conversion}
     */

    this.conversion = new conversion_Conversion([this.editing.downcastDispatcher, this.data.downcastDispatcher], this.data.upcastDispatcher);
    this.conversion.addAlias('dataDowncast', this.data.downcastDispatcher);
    this.conversion.addAlias('editingDowncast', this.editing.downcastDispatcher);
    /**
     * An instance of the {@link module:core/editingkeystrokehandler~EditingKeystrokeHandler}.
     *
     * It allows setting simple keystrokes:
     *
     *		// Execute the bold command on Ctrl+E:
     *		editor.keystrokes.set( 'Ctrl+E', 'bold' );
     *
     *		// Execute your own callback:
     *		editor.keystrokes.set( 'Ctrl+E', ( data, cancel ) => {
     *			console.log( data.keyCode );
     *
     *			// Prevent the default (native) action and stop the underlying keydown event
     *			// so no other editor feature will interfere.
     *			cancel();
     *		} );
     *
     * Note: Certain typing-oriented keystrokes (like <kbd>Backspace</kbd> or <kbd>Enter</kbd>) are handled
     * by a low-level mechanism and trying to listen to them via the keystroke handler will not work reliably.
     * To handle these specific keystrokes, see the events fired by the
     * {@link module:engine/view/document~Document editing view document} (`editor.editing.view.document`).
     *
     * @readonly
     * @member {module:core/editingkeystrokehandler~EditingKeystrokeHandler}
     */

    this.keystrokes = new editingkeystrokehandler_EditingKeystrokeHandler(this);
    this.keystrokes.listenTo(this.editing.view.document);
  }
  /**
   * Loads and initializes plugins specified in the configuration.
   *
   * @returns {Promise.<module:core/plugin~LoadedPlugins>} A promise which resolves
   * once the initialization is completed, providing an array of loaded plugins.
   */


  Object(createClass["a" /* default */])(Editor, [{
    key: "initPlugins",
    value: function initPlugins() {
      var config = this.config;
      var plugins = config.get('plugins');
      var removePlugins = config.get('removePlugins') || [];
      var extraPlugins = config.get('extraPlugins') || [];
      return this.plugins.init(plugins.concat(extraPlugins), removePlugins);
    }
    /**
     * Destroys the editor instance, releasing all resources used by it.
     *
     * **Note** The editor cannot be destroyed during the initialization phase so if it is called
     * while the editor {@link #state is being initialized}, it will wait for the editor initialization before destroying it.
     *
     * @fires destroy
     * @returns {Promise} A promise that resolves once the editor instance is fully destroyed.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      var _this2 = this;

      var readyPromise = Promise.resolve();

      if (this.state == 'initializing') {
        readyPromise = new Promise(function (resolve) {
          return _this2.once('ready', resolve);
        });
      }

      return readyPromise.then(function () {
        _this2.fire('destroy');

        _this2.stopListening();

        _this2.commands.destroy();
      }).then(function () {
        return _this2.plugins.destroy();
      }).then(function () {
        _this2.model.destroy();

        _this2.data.destroy();

        _this2.editing.destroy();

        _this2.keystrokes.destroy();
      }) // Remove the editor from the context.
      // When the context was created by this editor, the context will be destroyed.
      .then(function () {
        return _this2._context._removeEditor(_this2);
      });
    }
    /**
     * Executes the specified command with given parameters.
     *
     * Shorthand for:
     *
     *		editor.commands.get( commandName ).execute( ... );
     *
     * @param {String} commandName The name of the command to execute.
     * @param {*} [...commandParams] Command parameters.
     */

  }, {
    key: "execute",
    value: function execute() {
      try {
        var _this$commands;

        (_this$commands = this.commands).execute.apply(_this$commands, arguments);
      } catch (err) {
        // @if CK_DEBUG // throw err;

        /* istanbul ignore next */
        ckeditorerror["b" /* default */].rethrowUnexpectedError(err, this);
      }
    }
    /**
     * Creates and initializes a new editor instance.
     *
     * This is an abstract method. Every editor type needs to implement its own initialization logic.
     *
     * See the `create()` methods of the existing editor types to learn how to use them:
     *
     * * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}
     * * {@link module:editor-balloon/ballooneditor~BalloonEditor.create `BalloonEditor.create()`}
     * * {@link module:editor-decoupled/decouplededitor~DecoupledEditor.create `DecoupledEditor.create()`}
     * * {@link module:editor-inline/inlineeditor~InlineEditor.create `InlineEditor.create()`}
     *
     * @abstract
     * @method module:core/editor/editor~Editor.create
     */

  }]);

  return Editor;
}();


mix(editor_Editor, observablemixin);
/**
 * Fired when the {@link module:engine/controller/datacontroller~DataController#event:ready data} and all additional
 * editor components are ready.
 *
 * Note: This event is most useful for plugin developers. When integrating the editor with your website or
 * application, you do not have to listen to `editor#ready` because when the promise returned by the static
 * {@link module:core/editor/editor~Editor.create `Editor.create()`} event is resolved, the editor is already ready.
 * In fact, since the first moment when the editor instance is available to you is inside `then()`'s callback,
 * you cannot even add a listener to the `editor#ready` event.
 *
 * See also the {@link #state `editor.state`} property.
 *
 * @event ready
 */

/**
 * Fired when this editor instance is destroyed. The editor at this point is not usable and this event should be used to
 * perform the clean-up in any plugin.
 *
 *
 * See also the {@link #state `editor.state`} property.
 *
 * @event destroy
 */

/**
 * This error is thrown when trying to pass a `<textarea>` element to a `create()` function of an editor class.
 *
 * The only editor type which can be initialized on `<textarea>` elements is {@glink builds/guides/overview#classic-editor classic editor}.
 * This editor hides the passed element and inserts its own UI next to it. Other types of editors reuse the passed element as their root
 * editable element and therefore `<textarea>` is not appropriate for them. Use a `<div>` or another text container instead:
 *
 *		<div id="editor">
 *			<p>Initial content.</p>
 *		</div>
 *
 * @error editor-wrong-element
 */

/**
 * An array of plugins built into this editor class.
 *
 * It is used in CKEditor 5 builds to provide a list of plugins which are later automatically initialized
 * during the editor initialization.
 *
 * They will be automatically initialized by the editor, unless listed in `config.removePlugins` and
 * unless `config.plugins` is passed.
 *
 *		// Build some plugins into the editor class first.
 *		ClassicEditor.builtinPlugins = [ FooPlugin, BarPlugin ];
 *
 *		// Normally, you need to define config.plugins, but since ClassicEditor.builtinPlugins was
 *		// defined, now you can call create() without any configuration.
 *		ClassicEditor
 *			.create( sourceElement )
 *			.then( editor => {
 *				editor.plugins.get( FooPlugin ); // -> An instance of the Foo plugin.
 *				editor.plugins.get( BarPlugin ); // -> An instance of the Bar plugin.
 *			} );
 *
 *		ClassicEditor
 *			.create( sourceElement, {
 *				// Do not initialize these plugins (note: it is defined by a string):
 *				removePlugins: [ 'Foo' ]
 *			} )
 *			.then( editor => {
 *				editor.plugins.get( FooPlugin ); // -> Undefined.
 *				editor.config.get( BarPlugin ); // -> An instance of the Bar plugin.
 *			} );
 *
 *		ClassicEditor
 *			.create( sourceElement, {
 *				// Load only this plugin. It can also be defined by a string if
 *				// this plugin was built into the editor class.
 *				plugins: [ FooPlugin ]
 *			} )
 *			.then( editor => {
 *				editor.plugins.get( FooPlugin ); // -> An instance of the Foo plugin.
 *				editor.config.get( BarPlugin ); // -> Undefined.
 *			} );
 *
 * See also {@link module:core/editor/editor~Editor.defaultConfig}.
 *
 * @static
 * @member {Array.<Function>} module:core/editor/editor~Editor.builtinPlugins
 */

/**
 * The default configuration which is built into the editor class.
 *
 * It is used in CKEditor 5 builds to provide the default configuration options which are later used during the editor initialization.
 *
 *		ClassicEditor.defaultConfig = {
 *			foo: 1,
 *			bar: 2
 *		};
 *
 *		ClassicEditor
 *			.create( sourceElement )
 *			.then( editor => {
 *				editor.config.get( 'foo' ); // -> 1
 *				editor.config.get( 'bar' ); // -> 2
 *			} );
 *
 *		// The default options can be overridden by the configuration passed to create().
 *		ClassicEditor
 *			.create( sourceElement, { bar: 3 } )
 *			.then( editor => {
 *				editor.config.get( 'foo' ); // -> 1
 *				editor.config.get( 'bar' ); // -> 3
 *			} );
 *
 * See also {@link module:core/editor/editor~Editor.builtinPlugins}.
 *
 * @static
 * @member {Object} module:core/editor/editor~Editor.defaultConfig
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-core/src/editor/utils/dataapimixin.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module core/editor/utils/dataapimixin
 */

/**
 * Implementation of the {@link module:core/editor/utils/dataapimixin~DataApi}.
 *
 * @mixin DataApiMixin
 * @implements module:core/editor/utils/dataapimixin~DataApi
 */
var DataApiMixin = {
  /**
   * @inheritDoc
   */
  setData: function setData(data) {
    this.data.set(data);
  },

  /**
   * @inheritDoc
   */
  getData: function getData(options) {
    return this.data.get(options);
  }
};
/* harmony default export */ var dataapimixin = (DataApiMixin);
/**
 * Interface defining editor methods for setting and getting data to and from the editor's main root element
 * using the {@link module:core/editor/editor~Editor#data data pipeline}.
 *
 * This interface is not a part of the {@link module:core/editor/editor~Editor} class because one may want to implement
 * an editor with multiple root elements, in which case the methods for setting and getting data will need to be implemented
 * differently.
 *
 * @interface DataApi
 */

/**
 * Sets the data in the editor.
 *
 *		editor.setData( '<p>This is editor!</p>' );
 *
 * By default the editor accepts HTML. This can be controlled by injecting a different data processor.
 * See the {@glink features/markdown Markdown output} guide for more details.
 *
 * Note: Not only is the format of the data configurable, but the type of the `setData()`'s parameter does not
 * have to be a string either. You can e.g. accept an object or a DOM `DocumentFragment` if you consider this
 * the right format for you.
 *
 * @method #setData
 * @param {String} data Input data.
 */

/**
 * Gets the data from the editor.
 *
 *		editor.getData(); // -> '<p>This is editor!</p>'
 *
 * By default the editor outputs HTML. This can be controlled by injecting a different data processor.
 * See the {@glink features/markdown Markdown output} guide for more details.
 *
 * Note: Not only is the format of the data configurable, but the type of the `getData()`'s return value does not
 * have to be a string either. You can e.g. return an object or a DOM `DocumentFragment` if you consider this
 * the right format for you.
 *
 * @method #getData
 * @param {Object} [options]
 * @param {String} [options.rootName='main'] Root name.
 * @param {String} [options.trim='empty'] Whether returned data should be trimmed. This option is set to `'empty'` by default,
 * which means that whenever editor content is considered empty, an empty string is returned. To turn off trimming
 * use `'none'`. In such cases exact content will be returned (for example `'<p>&nbsp;</p>'` for an empty editor).
 * @returns {String} Output data.
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/setdatainelement.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/dom/setdatainelement
 */

/* globals HTMLTextAreaElement */

/**
 * Sets data in a given element.
 *
 * @param {HTMLElement} el The element in which the data will be set.
 * @param {String} data The data string.
 */
function setDataInElement(el, data) {
  if (el instanceof HTMLTextAreaElement) {
    el.value = data;
  }

  el.innerHTML = data;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-core/src/editor/utils/elementapimixin.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */


/**
 * @module core/editor/utils/elementapimixin
 */

/**
 * Implementation of the {@link module:core/editor/utils/elementapimixin~ElementApi}.
 *
 * @mixin ElementApiMixin
 * @implements module:core/editor/utils/elementapimixin~ElementApi
 */

var ElementApiMixin = {
  /**
   * @inheritDoc
   */
  updateSourceElement: function updateSourceElement() {
    if (!this.sourceElement) {
      /**
       * Cannot update the source element of a detached editor.
       *
       * The {@link ~ElementApi#updateSourceElement `updateSourceElement()`} method cannot be called if you did not
       * pass an element to `Editor.create()`.
       *
       * @error editor-missing-sourceelement
       */
      throw new ckeditorerror["b" /* default */]('editor-missing-sourceelement: Cannot update the source element of a detached editor.', this);
    }

    setDataInElement(this.sourceElement, this.data.get());
  }
};
/* harmony default export */ var elementapimixin = (ElementApiMixin);
/**
 * Interface describing an editor that replaced a DOM element (was "initialized on an element").
 *
 * Such an editor should provide a method to
 * {@link module:core/editor/utils/elementapimixin~ElementApi#updateSourceElement update the replaced element with the current data}.
 *
 * @interface ElementApi
 */

/**
 * The element on which the editor has been initialized.
 *
 * @readonly
 * @member {HTMLElement} #sourceElement
 */

/**
 * Updates the {@link #sourceElement editor source element}'s content with the data.
 *
 * @method #updateSourceElement
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-core/src/editor/utils/attachtoform.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */


/**
 * @module core/editor/utils/attachtoform
 */

/**
 * Checks if the editor is initialized on a `<textarea>` element that belongs to a form. If yes, it updates the editor's element
 * content before submitting the form.
 *
 * This helper requires the {@link module:core/editor/utils/elementapimixin~ElementApi ElementApi interface}.
 *
 * @param {module:core/editor/editor~Editor} editor Editor instance.
 */

function attachToForm(editor) {
  if (!lodash_es_isFunction(editor.updateSourceElement)) {
    /**
     * The editor passed to `attachToForm()` must implement the
     * {@link module:core/editor/utils/elementapimixin~ElementApi} interface.
     *
     * @error attachtoform-missing-elementapi-interface
     */
    throw new ckeditorerror["b" /* default */]('attachtoform-missing-elementapi-interface: Editor passed to attachToForm() must implement ElementApi.', editor);
  }

  var sourceElement = editor.sourceElement; // Only when replacing a textarea which is inside of a form element.

  if (sourceElement && sourceElement.tagName.toLowerCase() === 'textarea' && sourceElement.form) {
    var originalSubmit;
    var form = sourceElement.form;

    var onSubmit = function onSubmit() {
      return editor.updateSourceElement();
    }; // Replace the original form#submit() to call a custom submit function first.
    // Check if #submit is a function because the form might have an input named "submit".


    if (lodash_es_isFunction(form.submit)) {
      originalSubmit = form.submit;

      form.submit = function () {
        onSubmit();
        originalSubmit.apply(form);
      };
    } // Update the replaced textarea with data before each form#submit event.


    form.addEventListener('submit', onSubmit); // Remove the submit listener and revert the original submit method on
    // editor#destroy.

    editor.on('destroy', function () {
      form.removeEventListener('submit', onSubmit);

      if (originalSubmit) {
        form.submit = originalSubmit;
      }
    });
  }
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/dataprocessor/basichtmlwriter.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/dataprocessor/basichtmlwriter
 */

/* globals document */

/**
 * Basic HTML writer. It uses the native `innerHTML` property for basic conversion
 * from a document fragment to an HTML string.
 *
 * @implements module:engine/dataprocessor/htmlwriter~HtmlWriter
 */
var basichtmlwriter_BasicHtmlWriter = /*#__PURE__*/function () {
  function BasicHtmlWriter() {
    Object(classCallCheck["a" /* default */])(this, BasicHtmlWriter);
  }

  Object(createClass["a" /* default */])(BasicHtmlWriter, [{
    key: "getHtml",

    /**
     * Returns an HTML string created from the document fragment.
     *
     * @param {DocumentFragment} fragment
     * @returns {String}
     */
    value: function getHtml(fragment) {
      var doc = document.implementation.createHTMLDocument('');
      var container = doc.createElement('div');
      container.appendChild(fragment);
      return container.innerHTML;
    }
  }]);

  return BasicHtmlWriter;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/dataprocessor/htmldataprocessor.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/dataprocessor/htmldataprocessor
 */

/* globals document, DOMParser */


/**
 * The HTML data processor class.
 * This data processor implementation uses HTML as input and output data.
 *
 * @implements module:engine/dataprocessor/dataprocessor~DataProcessor
 */

var htmldataprocessor_HtmlDataProcessor = /*#__PURE__*/function () {
  /**
   * Creates a new instance of the HTML data processor class.
   *
   * @param {module:engine/view/document~Document} document The view document instance.
   */
  function HtmlDataProcessor(document) {
    Object(classCallCheck["a" /* default */])(this, HtmlDataProcessor);

    /**
     * A DOM parser instance used to parse an HTML string to an HTML document.
     *
     * @private
     * @member {DOMParser}
     */
    this._domParser = new DOMParser();
    /**
     * A DOM converter used to convert DOM elements to view elements.
     *
     * @private
     * @member {module:engine/view/domconverter~DomConverter}
     */

    this._domConverter = new domconverter_DomConverter(document, {
      blockFillerMode: 'nbsp'
    });
    /**
     * A basic HTML writer instance used to convert DOM elements to an HTML string.
     *
     * @private
     * @member {module:engine/dataprocessor/basichtmlwriter~BasicHtmlWriter}
     */

    this._htmlWriter = new basichtmlwriter_BasicHtmlWriter();
  }
  /**
   * Converts a provided {@link module:engine/view/documentfragment~DocumentFragment document fragment}
   * to data format &mdash; in this case to an HTML string.
   *
   * @param {module:engine/view/documentfragment~DocumentFragment} viewFragment
   * @returns {String} HTML string.
   */


  Object(createClass["a" /* default */])(HtmlDataProcessor, [{
    key: "toData",
    value: function toData(viewFragment) {
      // Convert view DocumentFragment to DOM DocumentFragment.
      var domFragment = this._domConverter.viewToDom(viewFragment, document); // Convert DOM DocumentFragment to HTML output.


      return this._htmlWriter.getHtml(domFragment);
    }
    /**
     * Converts the provided HTML string to a view tree.
     *
     * @param {String} data An HTML string.
     * @returns {module:engine/view/node~Node|module:engine/view/documentfragment~DocumentFragment|null} A converted view element.
     */

  }, {
    key: "toView",
    value: function toView(data) {
      // Convert input HTML data to DOM DocumentFragment.
      var domFragment = this._toDom(data); // Convert DOM DocumentFragment to view DocumentFragment.


      return this._domConverter.domToView(domFragment);
    }
    /**
     * Converts an HTML string to its DOM representation. Returns a document fragment containing nodes parsed from
     * the provided data.
     *
     * @private
     * @param {String} data
     * @returns {DocumentFragment}
     */

  }, {
    key: "_toDom",
    value: function _toDom(data) {
      var document = this._domParser.parseFromString(data, 'text/html');

      var fragment = document.createDocumentFragment();
      var nodes = document.body.childNodes;

      while (nodes.length > 0) {
        fragment.appendChild(nodes[0]);
      }

      return fragment;
    }
  }]);

  return HtmlDataProcessor;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/componentfactory.js










/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/componentfactory
 */

/**
 * A helper class implementing the UI component ({@link module:ui/view~View view}) factory.
 *
 * It allows functions producing specific UI components to be registered under their unique names
 * in the factory. A registered component can be then instantiated by providing its name.
 * Note that names are case insensitive.
 *
 *		// The editor provides localization tools for the factory.
 *		const factory = new ComponentFactory( editor );
 *
 *		factory.add( 'foo', locale => new FooView( locale ) );
 *		factory.add( 'bar', locale => new BarView( locale ) );
 *
 *		// An instance of FooView.
 *		const fooInstance = factory.create( 'foo' );
 *
 *		// Names are case insensitive so this is also allowed:
 *		const barInstance = factory.create( 'Bar' );
 *
 * The {@link module:core/editor/editor~Editor#locale editor locale} is passed to the factory
 * function when {@link module:ui/componentfactory~ComponentFactory#create} is called.
 */

var componentfactory_ComponentFactory = /*#__PURE__*/function () {
  /**
   * Creates an instance of the factory.
   *
   * @constructor
   * @param {module:core/editor/editor~Editor} editor The editor instance.
   */
  function ComponentFactory(editor) {
    Object(classCallCheck["a" /* default */])(this, ComponentFactory);

    /**
     * The editor instance that the factory belongs to.
     *
     * @readonly
     * @member {module:core/editor/editor~Editor}
     */
    this.editor = editor;
    /**
     * Registered component factories.
     *
     * @private
     * @member {Map}
     */

    this._components = new Map();
  }
  /**
   * Returns an iterator of registered component names. Names are returned in lower case.
   *
   * @returns {Iterable.<String>}
   */


  Object(createClass["a" /* default */])(ComponentFactory, [{
    key: "names",
    value: /*#__PURE__*/regeneratorRuntime.mark(function names() {
      var _iterator, _step, value;

      return regeneratorRuntime.wrap(function names$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _iterator = _createForOfIteratorHelper(this._components.values());
              _context.prev = 1;

              _iterator.s();

            case 3:
              if ((_step = _iterator.n()).done) {
                _context.next = 9;
                break;
              }

              value = _step.value;
              _context.next = 7;
              return value.originalName;

            case 7:
              _context.next = 3;
              break;

            case 9:
              _context.next = 14;
              break;

            case 11:
              _context.prev = 11;
              _context.t0 = _context["catch"](1);

              _iterator.e(_context.t0);

            case 14:
              _context.prev = 14;

              _iterator.f();

              return _context.finish(14);

            case 17:
            case "end":
              return _context.stop();
          }
        }
      }, names, this, [[1, 11, 14, 17]]);
    })
    /**
     * Registers a component factory function that will be used by the
     * {@link #create create} method and called with the
     * {@link module:core/editor/editor~Editor#locale editor locale} as an argument,
     * allowing localization of the {@link module:ui/view~View view}.
     *
     * @param {String} name The name of the component.
     * @param {Function} callback The callback that returns the component.
     */

  }, {
    key: "add",
    value: function add(name, callback) {
      if (this.has(name)) {
        /**
         * The item already exists in the component factory.
         *
         * @error componentfactory-item-exists
         * @param {String} name The name of the component.
         */
        throw new ckeditorerror["b" /* default */]('componentfactory-item-exists: The item already exists in the component factory.', this, {
          name: name
        });
      }

      this._components.set(componentfactory_getNormalized(name), {
        callback: callback,
        originalName: name
      });
    }
    /**
     * Creates an instance of a component registered in the factory under a specific name.
     *
     * When called, the {@link module:core/editor/editor~Editor#locale editor locale} is passed to
     * the previously {@link #add added} factory function, allowing localization of the
     * {@link module:ui/view~View view}.
     *
     * @param {String} name The name of the component.
     * @returns {module:ui/view~View} The instantiated component view.
     */

  }, {
    key: "create",
    value: function create(name) {
      if (!this.has(name)) {
        /**
         * The required component is not registered in the component factory. Please make sure
         * the provided name is correct and the component has been correctly
         * {@link #add added} to the factory.
         *
         * @error componentfactory-item-missing
         * @param {String} name The name of the missing component.
         */
        throw new ckeditorerror["b" /* default */]('componentfactory-item-missing: The required component is not registered in the factory.', this, {
          name: name
        });
      }

      return this._components.get(componentfactory_getNormalized(name)).callback(this.editor.locale);
    }
    /**
     * Checks if a component of a given name is registered in the factory.
     *
     * @param {String} name The name of the component.
     * @returns {Boolean}
     */

  }, {
    key: "has",
    value: function has(name) {
      return this._components.has(componentfactory_getNormalized(name));
    }
  }]);

  return ComponentFactory;
}(); //
// Ensures that the component name used as the key in the internal map is in lower case.
//
// @private
// @param {String} name
// @returns {String}




function componentfactory_getNormalized(name) {
  return String(name).toLowerCase();
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/focustracker.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* global setTimeout, clearTimeout */

/**
 * @module utils/focustracker
 */




/**
 * Allows observing a group of `HTMLElement`s whether at least one of them is focused.
 *
 * Used by the {@link module:core/editor/editor~Editor} in order to track whether the focus is still within the application,
 * or were used outside of its UI.
 *
 * **Note** `focus` and `blur` listeners use event capturing, so it is only needed to register wrapper `HTMLElement`
 * which contain other `focusable` elements. But note that this wrapper element has to be focusable too
 * (have e.g. `tabindex="-1"`).
 *
 * Check out the {@glink framework/guides/deep-dive/ui/focus-tracking "Deep dive into focus tracking" guide} to learn more.
 *
 * @mixes module:utils/dom/emittermixin~EmitterMixin
 * @mixes module:utils/observablemixin~ObservableMixin
 */

var focustracker_FocusTracker = /*#__PURE__*/function () {
  function FocusTracker() {
    Object(classCallCheck["a" /* default */])(this, FocusTracker);

    /**
     * True when one of the registered elements is focused.
     *
     * @readonly
     * @observable
     * @member {Boolean} #isFocused
     */
    this.set('isFocused', false);
    /**
     * The currently focused element.
     *
     * While {@link #isFocused `isFocused`} remains `true`, the focus can
     * move between different UI elements. This property tracks those
     * elements and tells which one is currently focused.
     *
     * @readonly
     * @observable
     * @member {HTMLElement|null} #focusedElement
     */

    this.set('focusedElement', null);
    /**
     * List of registered elements.
     *
     * @private
     * @member {Set.<HTMLElement>}
     */

    this._elements = new Set();
    /**
     * Event loop timeout.
     *
     * @private
     * @member {Number}
     */

    this._nextEventLoopTimeout = null;
  }
  /**
   * Starts tracking the specified element.
   *
   * @param {HTMLElement} element
   */


  Object(createClass["a" /* default */])(FocusTracker, [{
    key: "add",
    value: function add(element) {
      var _this = this;

      if (this._elements.has(element)) {
        throw new ckeditorerror["b" /* default */]('focusTracker-add-element-already-exist', this);
      }

      this.listenTo(element, 'focus', function () {
        return _this._focus(element);
      }, {
        useCapture: true
      });
      this.listenTo(element, 'blur', function () {
        return _this._blur();
      }, {
        useCapture: true
      });

      this._elements.add(element);
    }
    /**
     * Stops tracking the specified element and stops listening on this element.
     *
     * @param {HTMLElement} element
     */

  }, {
    key: "remove",
    value: function remove(element) {
      if (element === this.focusedElement) {
        this._blur(element);
      }

      if (this._elements.has(element)) {
        this.stopListening(element);

        this._elements.delete(element);
      }
    }
    /**
     * Destroys the focus tracker by:
     * - Disabling all event listeners attached to tracked elements.
     * - Removing all tracked elements that were previously added.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.stopListening();
    }
    /**
     * Stores currently focused element and set {#isFocused} as `true`.
     *
     * @private
     * @param {HTMLElement} element Element which has been focused.
     */

  }, {
    key: "_focus",
    value: function _focus(element) {
      clearTimeout(this._nextEventLoopTimeout);
      this.focusedElement = element;
      this.isFocused = true;
    }
    /**
     * Clears currently focused element and set {@link #isFocused} as `false`.
     * This method uses `setTimeout` to change order of fires `blur` and `focus` events.
     *
     * @private
     * @fires blur
     */

  }, {
    key: "_blur",
    value: function _blur() {
      var _this2 = this;

      clearTimeout(this._nextEventLoopTimeout);
      this._nextEventLoopTimeout = setTimeout(function () {
        _this2.focusedElement = null;
        _this2.isFocused = false;
      }, 0);
    }
    /**
     * @event focus
     */

    /**
     * @event blur
     */

  }]);

  return FocusTracker;
}();


mix(focustracker_FocusTracker, dom_emittermixin);
mix(focustracker_FocusTracker, observablemixin);
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-core/src/editor/editorui.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module core/editor/editorui
 */

/* globals console */




/**
 * A class providing the minimal interface that is required to successfully bootstrap any editor UI.
 *
 * @mixes module:utils/emittermixin~EmitterMixin
 */

var editorui_EditorUI = /*#__PURE__*/function () {
  /**
   * Creates an instance of the editor UI class.
   *
   * @param {module:core/editor/editor~Editor} editor The editor instance.
   */
  function EditorUI(editor) {
    var _this = this;

    Object(classCallCheck["a" /* default */])(this, EditorUI);

    /**
     * The editor that the UI belongs to.
     *
     * @readonly
     * @member {module:core/editor/editor~Editor} #editor
     */
    this.editor = editor;
    /**
     * An instance of the {@link module:ui/componentfactory~ComponentFactory}, a registry used by plugins
     * to register factories of specific UI components.
     *
     * @readonly
     * @member {module:ui/componentfactory~ComponentFactory} #componentFactory
     */

    this.componentFactory = new componentfactory_ComponentFactory(editor);
    /**
     * Stores the information about the editor UI focus and propagates it so various plugins and components
     * are unified as a focus group.
     *
     * @readonly
     * @member {module:utils/focustracker~FocusTracker} #focusTracker
     */

    this.focusTracker = new focustracker_FocusTracker();
    /**
     * Stores all editable elements used by the editor instance.
     *
     * @private
     * @member {Map.<String,HTMLElement>}
     */

    this._editableElementsMap = new Map(); // Informs UI components that should be refreshed after layout change.

    this.listenTo(editor.editing.view.document, 'layoutChanged', function () {
      return _this.update();
    });
  }
  /**
   * The main (outermost) DOM element of the editor UI.
   *
   * For example, in {@link module:editor-classic/classiceditor~ClassicEditor} it is a `<div>` which
   * wraps the editable element and the toolbar. In {@link module:editor-inline/inlineeditor~InlineEditor}
   * it is the editable element itself (as there is no other wrapper). However, in
   * {@link module:editor-decoupled/decouplededitor~DecoupledEditor} it is set to `null` because this editor does not
   * come with a single "main" HTML element (its editable element and toolbar are separate).
   *
   * This property can be understood as a shorthand for retrieving the element that a specific editor integration
   * considers to be its main DOM element.
   *
   * @readonly
   * @member {HTMLElement|null} #element
   */


  Object(createClass["a" /* default */])(EditorUI, [{
    key: "update",

    /**
     * Fires the {@link module:core/editor/editorui~EditorUI#event:update `update`} event.
     *
     * This method should be called when the editor UI (e.g. positions of its balloons) needs to be updated due to
     * some environmental change which CKEditor 5 is not aware of (e.g. resize of a container in which it is used).
     */
    value: function update() {
      this.fire('update');
    }
    /**
     * Destroys the UI.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.stopListening();
      this.focusTracker.destroy(); // Clean–up the references to the CKEditor instance stored in the native editable DOM elements.

      var _iterator = _createForOfIteratorHelper(this._editableElementsMap.values()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var domElement = _step.value;
          domElement.ckeditorInstance = null;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this._editableElementsMap = new Map();
    }
    /**
     * Store the native DOM editable element used by the editor under
     * a unique name.
     *
     * @param {String} rootName The unique name of the editable element.
     * @param {HTMLElement} domElement The native DOM editable element.
     */

  }, {
    key: "setEditableElement",
    value: function setEditableElement(rootName, domElement) {
      this._editableElementsMap.set(rootName, domElement); // Put a reference to the CKEditor instance in the editable native DOM element.
      // It helps 3rd–party software (browser extensions, other libraries) access and recognize
      // CKEditor 5 instances (editing roots) and use their API (there is no global editor
      // instance registry).


      if (!domElement.ckeditorInstance) {
        domElement.ckeditorInstance = this.editor;
      }
    }
    /**
     * Returns the editable editor element with the given name or null if editable does not exist.
     *
     * @param {String} [rootName=main] The editable name.
     * @returns {HTMLElement|undefined}
     */

  }, {
    key: "getEditableElement",
    value: function getEditableElement() {
      var rootName = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'main';
      return this._editableElementsMap.get(rootName);
    }
    /**
     * Returns array of names of all editor editable elements.
     *
     * @returns {Iterable.<String>}
     */

  }, {
    key: "getEditableElementsNames",
    value: function getEditableElementsNames() {
      return this._editableElementsMap.keys();
    }
    /**
     * Stores all editable elements used by the editor instance.
     *
     * @protected
     * @deprecated
     * @member {Map.<String,HTMLElement>}
     */

  }, {
    key: "element",
    get: function get() {
      return null;
    }
  }, {
    key: "_editableElements",
    get: function get() {
      /**
       * The {@link module:core/editor/editorui~EditorUI#_editableElements `EditorUI#_editableElements`} property has been
       * deprecated and will be removed in the near future. Please use {@link #setEditableElement `setEditableElement()`} and
       * {@link #getEditableElement `getEditableElement()`} methods instead.
       *
       * @error editor-ui-deprecated-editable-elements
       * @param {module:core/editor/editorui~EditorUI} editorUI Editor UI instance the deprecated property belongs to.
       */
      console.warn('editor-ui-deprecated-editable-elements: ' + 'The EditorUI#_editableElements property has been deprecated and will be removed in the near future.', {
        editorUI: this
      });
      return this._editableElementsMap;
    }
    /**
     * Fired when the editor UI is ready.
     *
     * Fired before {@link module:engine/controller/datacontroller~DataController#event:ready}.
     *
     * @event ready
     */

    /**
     * Fired whenever the UI (all related components) should be refreshed.
     *
     * **Note:**: The event is fired after each {@link module:engine/view/document~Document#event:layoutChanged}.
     * It can also be fired manually via the {@link module:core/editor/editorui~EditorUI#update} method.
     *
     * @event update
     */

  }]);

  return EditorUI;
}();


mix(editorui_EditorUI, emittermixin);
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/toolbar/enabletoolbarkeyboardfocus.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/toolbar/enabletoolbarkeyboardfocus
 */

/**
 * Enables focus/blur toolbar navigation using `Alt+F10` and `Esc` keystrokes.
 *
 * @param {Object} options Options of the utility.
 * @param {*} options.origin A view to which the focus will return when `Esc` is pressed and
 * `options.toolbar` is focused.
 * @param {module:utils/keystrokehandler~KeystrokeHandler} options.originKeystrokeHandler A keystroke
 * handler to register `Alt+F10` keystroke.
 * @param {module:utils/focustracker~FocusTracker} options.originFocusTracker A focus tracker
 * for `options.origin`.
 * @param {module:ui/toolbar/toolbarview~ToolbarView} options.toolbar A toolbar which is to gain
 * focus when `Alt+F10` is pressed.
 * @param {Function} [options.beforeFocus] A callback executed before the `options.toolbar` gains focus
 * upon the `Alt+F10` keystroke.
 * @param {Function} [options.afterBlur] A callback executed after `options.toolbar` loses focus upon
 * `Esc` keystroke but before the focus goes back to `options.origin`.
 */
function enableToolbarKeyboardFocus(_ref) {
  var origin = _ref.origin,
      originKeystrokeHandler = _ref.originKeystrokeHandler,
      originFocusTracker = _ref.originFocusTracker,
      toolbar = _ref.toolbar,
      beforeFocus = _ref.beforeFocus,
      afterBlur = _ref.afterBlur;
  // Because toolbar items can get focus, the overall state of the toolbar must
  // also be tracked.
  originFocusTracker.add(toolbar.element); // Focus the toolbar on the keystroke, if not already focused.

  originKeystrokeHandler.set('Alt+F10', function (data, cancel) {
    if (originFocusTracker.isFocused && !toolbar.focusTracker.isFocused) {
      if (beforeFocus) {
        beforeFocus();
      }

      toolbar.focus();
      cancel();
    }
  }); // Blur the toolbar and bring the focus back to origin.

  toolbar.keystrokes.set('Esc', function (data, cancel) {
    if (toolbar.focusTracker.isFocused) {
      origin.focus();

      if (afterBlur) {
        afterBlur();
      }

      cancel();
    }
  });
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/toolbar/normalizetoolbarconfig.js


/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/toolbar/normalizetoolbarconfig
 */

/**
 * Normalizes the toolbar configuration (`config.toolbar`), which:
 *
 * * may be defined as an `Array`:
 *
 * 		toolbar: [ 'heading', 'bold', 'italic', 'link', ... ]
 *
 * * or an `Object`:
 *
 *		toolbar: {
 *			items: [ 'heading', 'bold', 'italic', 'link', ... ],
 *			...
 *		}
 *
 * * or may not be defined at all (`undefined`)
 *
 * and returns it in the object form.
 *
 * @param {Array|Object|undefined} config The value of `config.toolbar`.
 * @returns {Object} A normalized toolbar config object.
 */
function normalizeToolbarConfig(config) {
  if (Array.isArray(config)) {
    return {
      items: config
    };
  }

  if (!config) {
    return {
      items: []
    };
  }

  return Object.assign({
    items: []
  }, config);
}
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-engine/theme/placeholder.css
var theme_placeholder = __webpack_require__("507e");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/placeholder.js












/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/placeholder
 */
 // Each document stores information about its placeholder elements and check functions.

var documentPlaceholders = new WeakMap();
/**
 * A helper that enables a placeholder on the provided view element (also updates its visibility).
 * The placeholder is a CSS pseudo–element (with a text content) attached to the element.
 *
 * To change the placeholder text, simply call this method again with new options.
 *
 * To disable the placeholder, use {@link module:engine/view/placeholder~disablePlaceholder `disablePlaceholder()`} helper.
 *
 * @param {Object} [options] Configuration options of the placeholder.
 * @param {module:engine/view/view~View} options.view Editing view instance.
 * @param {module:engine/view/element~Element} options.element Element that will gain a placeholder.
 * See `options.isDirectHost` to learn more.
 * @param {String} options.text Placeholder text.
 * @param {Boolean} [options.isDirectHost=true] If set `false`, the placeholder will not be enabled directly
 * in the passed `element` but in one of its children (selected automatically, i.e. a first empty child element).
 * Useful when attaching placeholders to elements that can host other elements (not just text), for instance,
 * editable root elements.
 */

function enablePlaceholder(options) {
  var view = options.view,
      element = options.element,
      text = options.text,
      _options$isDirectHost = options.isDirectHost,
      isDirectHost = _options$isDirectHost === void 0 ? true : _options$isDirectHost;
  var doc = view.document; // Use a single a single post fixer per—document to update all placeholders.

  if (!documentPlaceholders.has(doc)) {
    documentPlaceholders.set(doc, new Map()); // If a post-fixer callback makes a change, it should return `true` so other post–fixers
    // can re–evaluate the document again.

    doc.registerPostFixer(function (writer) {
      return updateDocumentPlaceholders(doc, writer);
    });
  } // Store information about the element placeholder under its document.


  documentPlaceholders.get(doc).set(element, {
    text: text,
    isDirectHost: isDirectHost
  }); // Update the placeholders right away.

  view.change(function (writer) {
    return updateDocumentPlaceholders(doc, writer);
  });
}
/**
 * Disables the placeholder functionality from a given element.
 *
 * See {@link module:engine/view/placeholder~enablePlaceholder `enablePlaceholder()`} to learn more.
 *
 * @param {module:engine/view/view~View} view
 * @param {module:engine/view/element~Element} element
 */

function disablePlaceholder(view, element) {
  var doc = element.document;
  view.change(function (writer) {
    if (!documentPlaceholders.has(doc)) {
      return;
    }

    var placeholders = documentPlaceholders.get(doc);
    var config = placeholders.get(element);
    writer.removeAttribute('data-placeholder', config.hostElement);
    hidePlaceholder(writer, config.hostElement);
    placeholders.delete(element);
  });
}
/**
 * Shows a placeholder in the provided element by changing related attributes and CSS classes.
 *
 * **Note**: This helper will not update the placeholder visibility nor manage the
 * it in any way in the future. What it does is a one–time state change of an element. Use
 * {@link module:engine/view/placeholder~enablePlaceholder `enablePlaceholder()`} and
 * {@link module:engine/view/placeholder~disablePlaceholder `disablePlaceholder()`} for full
 * placeholder functionality.
 *
 * **Note**: This helper will blindly show the placeholder directly in the root editable element if
 * one is passed, which could result in a visual clash if the editable element has some children
 * (for instance, an empty paragraph). Use {@link module:engine/view/placeholder~enablePlaceholder `enablePlaceholder()`}
 * in that case or make sure the correct element is passed to the helper.
 *
 * @param {module:engine/view/downcastwriter~DowncastWriter} writer
 * @param {module:engine/view/element~Element} element
 * @returns {Boolean} `true`, if any changes were made to the `element`.
 */

function showPlaceholder(writer, element) {
  if (!element.hasClass('ck-placeholder')) {
    writer.addClass('ck-placeholder', element);
    return true;
  }

  return false;
}
/**
 * Hides a placeholder in the element by changing related attributes and CSS classes.
 *
 * **Note**: This helper will not update the placeholder visibility nor manage the
 * it in any way in the future. What it does is a one–time state change of an element. Use
 * {@link module:engine/view/placeholder~enablePlaceholder `enablePlaceholder()`} and
 * {@link module:engine/view/placeholder~disablePlaceholder `disablePlaceholder()`} for full
 * placeholder functionality.
 *
 * @param {module:engine/view/downcastwriter~DowncastWriter} writer
 * @param {module:engine/view/element~Element} element
 * @returns {Boolean} `true`, if any changes were made to the `element`.
 */

function hidePlaceholder(writer, element) {
  if (element.hasClass('ck-placeholder')) {
    writer.removeClass('ck-placeholder', element);
    return true;
  }

  return false;
}
/**
 * Checks if a placeholder should be displayed in the element.
 *
 * **Note**: This helper will blindly check the possibility of showing a placeholder directly in the
 * root editable element if one is passed, which may not be the expected result. If an element can
 * host other elements (not just text), most likely one of its children should be checked instead
 * because it will be the final host for the placeholder. Use
 * {@link module:engine/view/placeholder~enablePlaceholder `enablePlaceholder()`} in that case or make
 * sure the correct element is passed to the helper.
 *
 * @param {module:engine/view/element~Element} element
 * @returns {Boolean}
 */

function needsPlaceholder(element) {
  if (!element.isAttached()) {
    return false;
  } // The element is empty only as long as it contains nothing but uiElements.


  var isEmptyish = !Array.from(element.getChildren()).some(function (element) {
    return !element.is('uiElement');
  });
  var doc = element.document; // If the element is empty and the document is blurred.

  if (!doc.isFocused && isEmptyish) {
    return true;
  }

  var viewSelection = doc.selection;
  var selectionAnchor = viewSelection.anchor; // If document is focused and the element is empty but the selection is not anchored inside it.

  if (isEmptyish && selectionAnchor && selectionAnchor.parent !== element) {
    return true;
  }

  return false;
} // Updates all placeholders associated with a document in a post–fixer callback.
//
// @private
// @param { module:engine/view/document~Document} doc
// @param {module:engine/view/downcastwriter~DowncastWriter} writer
// @returns {Boolean} True if any changes were made to the view document.

function updateDocumentPlaceholders(doc, writer) {
  var placeholders = documentPlaceholders.get(doc);
  var wasViewModified = false;

  var _iterator = _createForOfIteratorHelper(placeholders),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _slicedToArray(_step.value, 2),
          element = _step$value[0],
          config = _step$value[1];

      if (updatePlaceholder(writer, element, config)) {
        wasViewModified = true;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return wasViewModified;
} // Updates a single placeholder in a post–fixer callback.
//
// @private
// @param {module:engine/view/downcastwriter~DowncastWriter} writer
// @param {module:engine/view/element~Element} element
// @param {Object} config Configuration of the placeholder
// @param {String} config.text
// @param {Boolean} config.isDirectHost
// @returns {Boolean} True if any changes were made to the view document.


function updatePlaceholder(writer, element, config) {
  var text = config.text,
      isDirectHost = config.isDirectHost;
  var hostElement = isDirectHost ? element : getChildPlaceholderHostSubstitute(element);
  var wasViewModified = false; // When not a direct host, it could happen that there is no child element
  // capable of displaying a placeholder.

  if (!hostElement) {
    return false;
  } // Cache the host element. It will be necessary for disablePlaceholder() to know
  // which element should have class and attribute removed because, depending on
  // the config.isDirectHost value, it could be the element or one of its descendants.


  config.hostElement = hostElement; // This may be necessary when updating the placeholder text to something else.

  if (hostElement.getAttribute('data-placeholder') !== text) {
    writer.setAttribute('data-placeholder', text, hostElement);
    wasViewModified = true;
  }

  if (needsPlaceholder(hostElement)) {
    if (showPlaceholder(writer, hostElement)) {
      wasViewModified = true;
    }
  } else if (hidePlaceholder(writer, hostElement)) {
    wasViewModified = true;
  }

  return wasViewModified;
} // Gets a child element capable of displaying a placeholder if a parent element can host more
// than just text (for instance, when it is a root editable element). The child element
// can then be used in other placeholder helpers as a substitute of its parent.
//
// @private
// @param {module:engine/view/element~Element} parent
// @returns {module:engine/view/element~Element|null}


function getChildPlaceholderHostSubstitute(parent) {
  if (parent.childCount === 1) {
    var firstChild = parent.getChild(0);

    if (firstChild.is('element') && !firstChild.is('uiElement')) {
      return firstChild;
    }
  }

  return null;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/elementreplacer.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/elementreplacer
 */

/**
 * Utility class allowing to hide existing HTML elements or replace them with given ones in a way that doesn't remove
 * the original elements from the DOM.
 */
var elementreplacer_ElementReplacer = /*#__PURE__*/function () {
  function ElementReplacer() {
    Object(classCallCheck["a" /* default */])(this, ElementReplacer);

    /**
     * The elements replaced by {@link #replace} and their replacements.
     *
     * @private
     * @member {Array.<Object>}
     */
    this._replacedElements = [];
  }
  /**
   * Hides the `element` and, if specified, inserts the the given element next to it.
   *
   * The effect of this method can be reverted by {@link #restore}.
   *
   * @param {HTMLElement} element The element to replace.
   * @param {HTMLElement} [newElement] The replacement element. If not passed, then the `element` will just be hidden.
   */


  Object(createClass["a" /* default */])(ElementReplacer, [{
    key: "replace",
    value: function replace(element, newElement) {
      this._replacedElements.push({
        element: element,
        newElement: newElement
      });

      element.style.display = 'none';

      if (newElement) {
        element.parentNode.insertBefore(newElement, element.nextSibling);
      }
    }
    /**
     * Restores what {@link #replace} did.
     */

  }, {
    key: "restore",
    value: function restore() {
      this._replacedElements.forEach(function (_ref) {
        var element = _ref.element,
            newElement = _ref.newElement;
        element.style.display = '';

        if (newElement) {
          newElement.remove();
        }
      });

      this._replacedElements = [];
    }
  }]);

  return ElementReplacer;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-editor-classic/src/classiceditorui.js










/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module editor-classic/classiceditorui
 */





/**
 * The classic editor UI class.
 *
 * @extends module:core/editor/editorui~EditorUI
 */

var classiceditorui_ClassicEditorUI = /*#__PURE__*/function (_EditorUI) {
  Object(inherits["a" /* default */])(ClassicEditorUI, _EditorUI);

  var _super = Object(createSuper["a" /* default */])(ClassicEditorUI);

  /**
   * Creates an instance of the classic editor UI class.
   *
   * @param {module:core/editor/editor~Editor} editor The editor instance.
   * @param {module:ui/editorui/editoruiview~EditorUIView} view The view of the UI.
   */
  function ClassicEditorUI(editor, view) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, ClassicEditorUI);

    _this = _super.call(this, editor);
    /**
     * The main (top–most) view of the editor UI.
     *
     * @readonly
     * @member {module:ui/editorui/editoruiview~EditorUIView} #view
     */

    _this.view = view;
    /**
     * A normalized `config.toolbar` object.
     *
     * @private
     * @member {Object}
     */

    _this._toolbarConfig = normalizeToolbarConfig(editor.config.get('toolbar'));
    /**
     * The element replacer instance used to hide the editor's source element.
     *
     * @protected
     * @member {module:utils/elementreplacer~ElementReplacer}
     */

    _this._elementReplacer = new elementreplacer_ElementReplacer();
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(ClassicEditorUI, [{
    key: "init",

    /**
     * Initializes the UI.
     *
     * @param {HTMLElement|null} replacementElement The DOM element that will be the source for the created editor.
     */
    value: function init(replacementElement) {
      var editor = this.editor;
      var view = this.view;
      var editingView = editor.editing.view;
      var editable = view.editable;
      var editingRoot = editingView.document.getRoot(); // The editable UI and editing root should share the same name. Then name is used
      // to recognize the particular editable, for instance in ARIA attributes.

      editable.name = editingRoot.rootName;
      view.render(); // The editable UI element in DOM is available for sure only after the editor UI view has been rendered.
      // But it can be available earlier if a DOM element has been passed to BalloonEditor.create().

      var editableElement = editable.element; // Register the editable UI view in the editor. A single editor instance can aggregate multiple
      // editable areas (roots) but the classic editor has only one.

      this.setEditableElement(editable.name, editableElement); // Let the global focus tracker know that the editable UI element is focusable and
      // belongs to the editor. From now on, the focus tracker will sustain the editor focus
      // as long as the editable is focused (e.g. the user is typing).

      this.focusTracker.add(editableElement); // Let the editable UI element respond to the changes in the global editor focus
      // tracker. It has been added to the same tracker a few lines above but, in reality, there are
      // many focusable areas in the editor, like balloons, toolbars or dropdowns and as long
      // as they have focus, the editable should act like it is focused too (although technically
      // it isn't), e.g. by setting the proper CSS class, visually announcing focus to the user.
      // Doing otherwise will result in editable focus styles disappearing, once e.g. the
      // toolbar gets focused.

      view.editable.bind('isFocused').to(this.focusTracker); // Bind the editable UI element to the editing view, making it an end– and entry–point
      // of the editor's engine. This is where the engine meets the UI.

      editingView.attachDomRoot(editableElement); // If an element containing the initial data of the editor was provided, replace it with
      // an editor instance's UI in DOM until the editor is destroyed. For instance, a <textarea>
      // can be such element.

      if (replacementElement) {
        this._elementReplacer.replace(replacementElement, this.element);
      }

      this._initPlaceholder();

      this._initToolbar();

      this.fire('ready');
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "destroy",
    value: function destroy() {
      var view = this.view;
      var editingView = this.editor.editing.view;

      this._elementReplacer.restore();

      editingView.detachDomRoot(view.editable.name);
      view.destroy();

      get_get(Object(getPrototypeOf["a" /* default */])(ClassicEditorUI.prototype), "destroy", this).call(this);
    }
    /**
     * Initializes the editor toolbar.
     *
     * @private
     */

  }, {
    key: "_initToolbar",
    value: function _initToolbar() {
      var editor = this.editor;
      var view = this.view;
      var editingView = editor.editing.view; // Set–up the sticky panel with toolbar.

      view.stickyPanel.bind('isActive').to(this.focusTracker, 'isFocused');
      view.stickyPanel.limiterElement = view.element;

      if (this._toolbarConfig.viewportTopOffset) {
        view.stickyPanel.viewportTopOffset = this._toolbarConfig.viewportTopOffset;
      }

      view.toolbar.fillFromConfig(this._toolbarConfig.items, this.componentFactory);
      enableToolbarKeyboardFocus({
        origin: editingView,
        originFocusTracker: this.focusTracker,
        originKeystrokeHandler: editor.keystrokes,
        toolbar: view.toolbar
      });
    }
    /**
     * Enable the placeholder text on the editing root, if any was configured.
     *
     * @private
     */

  }, {
    key: "_initPlaceholder",
    value: function _initPlaceholder() {
      var editor = this.editor;
      var editingView = editor.editing.view;
      var editingRoot = editingView.document.getRoot();
      var sourceElement = editor.sourceElement;
      var placeholderText = editor.config.get('placeholder') || sourceElement && sourceElement.tagName.toLowerCase() === 'textarea' && sourceElement.getAttribute('placeholder');

      if (placeholderText) {
        enablePlaceholder({
          view: editingView,
          element: editingRoot,
          text: placeholderText,
          isDirectHost: false
        });
      }
    }
  }, {
    key: "element",
    get: function get() {
      return this.view.element;
    }
  }]);

  return ClassicEditorUI;
}(editorui_EditorUI);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/viewcollection.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/viewcollection
 */


/**
 * Collects {@link module:ui/view~View} instances.
 *
 *		const parentView = new ParentView( locale );
 *		const collection = new ViewCollection( locale );
 *
 *		collection.setParent( parentView.element );
 *
 *		const viewA = new ChildView( locale );
 *		const viewB = new ChildView( locale );
 *
 * View collection renders and manages view {@link module:ui/view~View#element elements}:
 *
 *		collection.add( viewA );
 *		collection.add( viewB );
 *
 *		console.log( parentView.element.firsChild ); // -> viewA.element
 *		console.log( parentView.element.lastChild ); // -> viewB.element
 *
 * It {@link module:ui/viewcollection~ViewCollection#delegate propagates} DOM events too:
 *
 *		// Delegate #click and #keydown events from viewA and viewB to the parentView.
 *		collection.delegate( 'click' ).to( parentView );
 *
 *		parentView.on( 'click', ( evt ) => {
 *			console.log( `${ evt.source } has been clicked.` );
 *		} );
 *
 *		// This event will be delegated to the parentView.
 *		viewB.fire( 'click' );
 *
 * **Note**: A view collection can be used directly in the {@link module:ui/template~TemplateDefinition definition}
 * of a {@link module:ui/template~Template template}.
 *
 * @extends module:utils/collection~Collection
 * @mixes module:utils/observablemixin~ObservableMixin
 */

var viewcollection_ViewCollection = /*#__PURE__*/function (_Collection) {
  Object(inherits["a" /* default */])(ViewCollection, _Collection);

  var _super = Object(createSuper["a" /* default */])(ViewCollection);

  /**
   * Creates a new instance of the {@link module:ui/viewcollection~ViewCollection}.
   *
   * @param {Iterable.<module:ui/view~View>} [initialItems] The initial items of the collection.
   */
  function ViewCollection() {
    var _this;

    var initialItems = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

    Object(classCallCheck["a" /* default */])(this, ViewCollection);

    _this = _super.call(this, initialItems, {
      // An #id Number attribute should be legal and not break the `ViewCollection` instance.
      // https://github.com/ckeditor/ckeditor5-ui/issues/93
      idProperty: 'viewUid'
    }); // Handle {@link module:ui/view~View#element} in DOM when a new view is added to the collection.

    _this.on('add', function (evt, view, index) {
      _this._renderViewIntoCollectionParent(view, index);
    }); // Handle {@link module:ui/view~View#element} in DOM when a view is removed from the collection.


    _this.on('remove', function (evt, view) {
      if (view.element && _this._parentElement) {
        view.element.remove();
      }
    });
    /**
     * A parent element within which child views are rendered and managed in DOM.
     *
     * @protected
     * @member {HTMLElement}
     */


    _this._parentElement = null;
    return _this;
  }
  /**
   * Destroys the view collection along with child views.
   * See the view {@link module:ui/view~View#destroy} method.
   */


  Object(createClass["a" /* default */])(ViewCollection, [{
    key: "destroy",
    value: function destroy() {
      this.map(function (view) {
        return view.destroy();
      });
    }
    /**
     * Sets the parent HTML element of this collection. When parent is set, {@link #add adding} and
     * {@link #remove removing} views in the collection synchronizes their
     * {@link module:ui/view~View#element elements} in the parent element.
     *
     * @param {HTMLElement} element A new parent element.
     */

  }, {
    key: "setParent",
    value: function setParent(elementOrDocFragment) {
      this._parentElement = elementOrDocFragment; // Take care of the initial collection items passed to the constructor.

      var _iterator = _createForOfIteratorHelper(this),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var view = _step.value;

          this._renderViewIntoCollectionParent(view);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Delegates selected events coming from within views in the collection to any
     * {@link module:utils/emittermixin~Emitter}.
     *
     * For the following views and collection:
     *
     *		const viewA = new View();
     *		const viewB = new View();
     *		const viewC = new View();
     *
     *		const views = parentView.createCollection();
     *
     *		views.delegate( 'eventX' ).to( viewB );
     *		views.delegate( 'eventX', 'eventY' ).to( viewC );
     *
     *		views.add( viewA );
     *
     * the `eventX` is delegated (fired by) `viewB` and `viewC` along with `customData`:
     *
     *		viewA.fire( 'eventX', customData );
     *
     * and `eventY` is delegated (fired by) `viewC` along with `customData`:
     *
     *		viewA.fire( 'eventY', customData );
     *
     * See {@link module:utils/emittermixin~Emitter#delegate}.
     *
     * @param {...String} events {@link module:ui/view~View} event names to be delegated to another
     * {@link module:utils/emittermixin~Emitter}.
     * @returns {Object}
     * @returns {Function} return.to A function which accepts the destination of
     * {@link module:utils/emittermixin~Emitter#delegate delegated} events.
     */

  }, {
    key: "delegate",
    value: function delegate() {
      var _this2 = this;

      for (var _len = arguments.length, events = new Array(_len), _key = 0; _key < _len; _key++) {
        events[_key] = arguments[_key];
      }

      if (!events.length || !viewcollection_isStringArray(events)) {
        /**
         * All event names must be strings.
         *
         * @error ui-viewcollection-delegate-wrong-events
         */
        throw new ckeditorerror["b" /* default */]('ui-viewcollection-delegate-wrong-events: All event names must be strings.', this);
      }

      return {
        /**
         * Selects destination for {@link module:utils/emittermixin~Emitter#delegate} events.
         *
         * @memberOf module:ui/viewcollection~ViewCollection#delegate
         * @function module:ui/viewcollection~ViewCollection#delegate.to
         * @param {module:utils/emittermixin~Emitter} dest An `Emitter` instance which is
         * the destination for delegated events.
         */
        to: function to(dest) {
          // Activate delegating on existing views in this collection.
          var _iterator2 = _createForOfIteratorHelper(_this2),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var view = _step2.value;

              var _iterator5 = _createForOfIteratorHelper(events),
                  _step5;

              try {
                for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
                  var evtName = _step5.value;
                  view.delegate(evtName).to(dest);
                }
              } catch (err) {
                _iterator5.e(err);
              } finally {
                _iterator5.f();
              }
            } // Activate delegating on future views in this collection.

          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          _this2.on('add', function (evt, view) {
            var _iterator3 = _createForOfIteratorHelper(events),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var evtName = _step3.value;
                view.delegate(evtName).to(dest);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          }); // Deactivate delegating when view is removed from this collection.


          _this2.on('remove', function (evt, view) {
            var _iterator4 = _createForOfIteratorHelper(events),
                _step4;

            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var evtName = _step4.value;
                view.stopDelegating(evtName, dest);
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          });
        }
      };
    }
    /**
     * This method {@link module:ui/view~View#render renders} a new view added to the collection.
     *
     * If the {@link #_parentElement parent element} of the collection is set, this method also adds
     * the view's {@link module:ui/view~View#element} as a child of the parent in DOM at a specified index.
     *
     * **Note**: If index is not specified, the view's element is pushed as the last child
     * of the parent element.
     *
     * @private
     * @param {module:ui/view~View} view A new view added to the collection.
     * @param {Number} [index] An index the view holds in the collection. When not specified,
     * the view is added at the end.
     */

  }, {
    key: "_renderViewIntoCollectionParent",
    value: function _renderViewIntoCollectionParent(view, index) {
      if (!view.isRendered) {
        view.render();
      }

      if (view.element && this._parentElement) {
        this._parentElement.insertBefore(view.element, this._parentElement.children[index]);
      }
    }
    /**
     * Removes a child view from the collection. If the {@link #setParent parent element} of the
     * collection has been set, the {@link module:ui/view~View#element element} of the view is also removed
     * in DOM, reflecting the order of the collection.
     *
     * See the {@link #add} method.
     *
     * @method #remove
     * @param {module:ui/view~View|Number|String} subject The view to remove, its id or index in the collection.
     * @returns {Object} The removed view.
     */

  }]);

  return ViewCollection;
}(collection_Collection); // Check if all entries of the array are of `String` type.
//
// @private
// @param {Array} arr An array to be checked.
// @returns {Boolean}




function viewcollection_isStringArray(arr) {
  return arr.every(function (a) {
    return typeof a == 'string';
  });
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/template.js























/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/template
 */

/* global document */







var xhtmlNs = 'http://www.w3.org/1999/xhtml';
/**
 * A basic Template class. It renders a DOM HTML element or text from a
 * {@link module:ui/template~TemplateDefinition definition} and supports element attributes, children,
 * bindings to {@link module:utils/observablemixin~Observable observables} and DOM event propagation.
 *
 * A simple template can look like this:
 *
 *		const bind = Template.bind( observable, emitter );
 *
 *		new Template( {
 *			tag: 'p',
 *			attributes: {
 *				class: 'foo',
 *				style: {
 *					backgroundColor: 'yellow'
 *				}
 *			},
 *			on: {
 *				click: bind.to( 'clicked' )
 *			},
 *			children: [
 *				'A paragraph.'
 *			]
 *		} ).render();
 *
 * and it will render the following HTML element:
 *
 *		<p class="foo" style="background-color: yellow;">A paragraph.</p>
 *
 * Additionally, the `observable` will always fire `clicked` upon clicking `<p>` in the DOM.
 *
 * See {@link module:ui/template~TemplateDefinition} to know more about templates and complex
 * template definitions.
 *
* @mixes module:utils/emittermixin~EmitterMixin
 */

var template_Template = /*#__PURE__*/function () {
  /**
   * Creates an instance of the {@link ~Template} class.
   *
   * @param {module:ui/template~TemplateDefinition} def The definition of the template.
   */
  function Template(def) {
    Object(classCallCheck["a" /* default */])(this, Template);

    Object.assign(this, template_normalize(template_clone(def)));
    /**
     * Indicates whether this particular Template instance has been
     * {@link #render rendered}.
     *
     * @readonly
     * @protected
     * @member {Boolean}
     */

    this._isRendered = false;
    /**
     * The tag (`tagName`) of this template, e.g. `div`. It also indicates that the template
     * renders to an HTML element.
     *
     * @member {String} #tag
     */

    /**
     * The text of the template. It also indicates that the template renders to a DOM text node.
     *
     * @member {Array.<String|module:ui/template~TemplateValueSchema>} #text
     */

    /**
     * The attributes of the template, e.g. `{ id: [ 'ck-id' ] }`, corresponding with
     * the attributes of an HTML element.
     *
     * **Note**: This property only makes sense when {@link #tag} is defined.
     *
     * @member {Object} #attributes
     */

    /**
     * The children of the template. They can be either:
     * * independent instances of {@link ~Template} (sub–templates),
     * * native DOM Nodes.
     *
     * **Note**: This property only makes sense when {@link #tag} is defined.
     *
     * @member {Array.<module:ui/template~Template|Node>} #children
     */

    /**
     * The DOM event listeners of the template.
     *
     * @member {Object} #eventListeners
     */

    /**
     * The data used by the {@link #revert} method to restore a node to its original state.
     *
     * See: {@link #apply}.
     *
     * @readonly
     * @protected
     * @member {module:ui/template~RenderData}
     */

    this._revertData = null;
  }
  /**
   * Renders a DOM Node (an HTML element or text) out of the template.
   *
   *		const domNode = new Template( { ... } ).render();
   *
   * See: {@link #apply}.
   *
   * @returns {HTMLElement|Text}
   */


  Object(createClass["a" /* default */])(Template, [{
    key: "render",
    value: function render() {
      var node = this._renderNode({
        intoFragment: true
      });

      this._isRendered = true;
      return node;
    }
    /**
     * Applies the template to an existing DOM Node, either HTML element or text.
     *
     * **Note:** No new DOM nodes will be created. Applying extends:
     *
     * {@link module:ui/template~TemplateDefinition attributes},
     * {@link module:ui/template~TemplateDefinition event listeners}, and
     * `textContent` of {@link module:ui/template~TemplateDefinition children} only.
     *
     * **Note:** Existing `class` and `style` attributes are extended when a template
     * is applied to an HTML element, while other attributes and `textContent` are overridden.
     *
     * **Note:** The process of applying a template can be easily reverted using the
     * {@link module:ui/template~Template#revert} method.
     *
     *		const element = document.createElement( 'div' );
     *		const observable = new Model( { divClass: 'my-div' } );
     *		const emitter = Object.create( EmitterMixin );
     *		const bind = Template.bind( observable, emitter );
     *
     *		new Template( {
     *			attributes: {
     *				id: 'first-div',
     *				class: bind.to( 'divClass' )
     *			},
     *			on: {
     *				click: bind( 'elementClicked' ) // Will be fired by the observable.
     *			},
     *			children: [
     *				'Div text.'
     *			]
     *		} ).apply( element );
     *
     *		console.log( element.outerHTML ); // -> '<div id="first-div" class="my-div"></div>'
     *
     * @see module:ui/template~Template#render
     * @see module:ui/template~Template#revert
     * @param {Node} node Root node for the template to apply.
     */

  }, {
    key: "apply",
    value: function apply(node) {
      this._revertData = getEmptyRevertData();

      this._renderNode({
        node: node,
        isApplying: true,
        revertData: this._revertData
      });

      return node;
    }
    /**
     * Reverts a template {@link module:ui/template~Template#apply applied} to a DOM node.
     *
     * @param {Node} node The root node for the template to revert. In most of the cases, it is the
     * same node used by {@link module:ui/template~Template#apply}.
     */

  }, {
    key: "revert",
    value: function revert(node) {
      if (!this._revertData) {
        /**
         * Attempting to revert a template which has not been applied yet.
         *
         * @error ui-template-revert-not-applied
         */
        throw new ckeditorerror["b" /* default */]('ui-template-revert-not-applied: Attempting to revert a template which has not been applied yet.', [this, node]);
      }

      this._revertTemplateFromNode(node, this._revertData);
    }
    /**
     * Returns an iterator which traverses the template in search of {@link module:ui/view~View}
     * instances and returns them one by one.
     *
     *		const viewFoo = new View();
     *		const viewBar = new View();
     *		const viewBaz = new View();
     *		const template = new Template( {
     *			tag: 'div',
     *			children: [
     *				viewFoo,
     *				{
     *					tag: 'div',
     *					children: [
     *						viewBar
     *					]
     *				},
     *				viewBaz
     *			]
     *		} );
     *
     *		// Logs: viewFoo, viewBar, viewBaz
     *		for ( const view of template.getViews() ) {
     *			console.log( view );
     *		}
     *
     * @returns {Iterable.<module:ui/view~View>}
     */

  }, {
    key: "getViews",
    value: /*#__PURE__*/regeneratorRuntime.mark(function getViews() {
      var _marked, search;

      return regeneratorRuntime.wrap(function getViews$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              search = function _search(def) {
                var _iterator, _step, child;

                return regeneratorRuntime.wrap(function search$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        if (!def.children) {
                          _context.next = 23;
                          break;
                        }

                        _iterator = _createForOfIteratorHelper(def.children);
                        _context.prev = 2;

                        _iterator.s();

                      case 4:
                        if ((_step = _iterator.n()).done) {
                          _context.next = 15;
                          break;
                        }

                        child = _step.value;

                        if (!isView(child)) {
                          _context.next = 11;
                          break;
                        }

                        _context.next = 9;
                        return child;

                      case 9:
                        _context.next = 13;
                        break;

                      case 11:
                        if (!isTemplate(child)) {
                          _context.next = 13;
                          break;
                        }

                        return _context.delegateYield(search(child), "t0", 13);

                      case 13:
                        _context.next = 4;
                        break;

                      case 15:
                        _context.next = 20;
                        break;

                      case 17:
                        _context.prev = 17;
                        _context.t1 = _context["catch"](2);

                        _iterator.e(_context.t1);

                      case 20:
                        _context.prev = 20;

                        _iterator.f();

                        return _context.finish(20);

                      case 23:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _marked, null, [[2, 17, 20, 23]]);
              };

              _marked = /*#__PURE__*/regeneratorRuntime.mark(search);
              return _context2.delegateYield(search(this), "t0", 3);

            case 3:
            case "end":
              return _context2.stop();
          }
        }
      }, getViews, this);
    })
    /**
     * An entry point to the interface which binds DOM nodes to
     * {@link module:utils/observablemixin~Observable observables}.
     * There are two types of bindings:
     *
     * * HTML element attributes or text `textContent` synchronized with attributes of an
     * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}
     * and {@link module:ui/template~BindChain#if}.
     *
     *		const bind = Template.bind( observable, emitter );
     *
     *		new Template( {
     *			attributes: {
     *				// Binds the element "class" attribute to observable#classAttribute.
     *				class: bind.to( 'classAttribute' )
     *			}
     *		} ).render();
     *
     * * DOM events fired on HTML element propagated through
     * {@link module:utils/observablemixin~Observable}. Learn more about {@link module:ui/template~BindChain#to}.
     *
     *		const bind = Template.bind( observable, emitter );
     *
     *		new Template( {
     *			on: {
     *				// Will be fired by the observable.
     *				click: bind( 'elementClicked' )
     *			}
     *		} ).render();
     *
     * Also see {@link module:ui/view~View#bindTemplate}.
     *
     * @param {module:utils/observablemixin~Observable} observable An observable which provides boundable attributes.
     * @param {module:utils/emittermixin~Emitter} emitter An emitter that listens to observable attribute
     * changes or DOM Events (depending on the kind of the binding). Usually, a {@link module:ui/view~View} instance.
     * @returns {module:ui/template~BindChain}
     */

  }, {
    key: "_renderNode",

    /**
     * Renders a DOM Node (either an HTML element or text) out of the template.
     *
     * @protected
     * @param {module:ui/template~RenderData} data Rendering data.
     */
    value: function _renderNode(data) {
      var isInvalid;

      if (data.node) {
        // When applying, a definition cannot have "tag" and "text" at the same time.
        isInvalid = this.tag && this.text;
      } else {
        // When rendering, a definition must have either "tag" or "text": XOR( this.tag, this.text ).
        isInvalid = this.tag ? this.text : !this.text;
      }

      if (isInvalid) {
        /**
         * Node definition cannot have the "tag" and "text" properties at the same time.
         * Node definition must have either "tag" or "text" when rendering a new Node.
         *
         * @error ui-template-wrong-syntax
         */
        throw new ckeditorerror["b" /* default */]('ui-template-wrong-syntax: Node definition must have either "tag" or "text" when rendering a new Node.', this);
      }

      if (this.text) {
        return this._renderText(data);
      } else {
        return this._renderElement(data);
      }
    }
    /**
     * Renders an HTML element out of the template.
     *
     * @protected
     * @param {module:ui/template~RenderData} data Rendering data.
     */

  }, {
    key: "_renderElement",
    value: function _renderElement(data) {
      var node = data.node;

      if (!node) {
        node = data.node = document.createElementNS(this.ns || xhtmlNs, this.tag);
      }

      this._renderAttributes(data);

      this._renderElementChildren(data);

      this._setUpListeners(data);

      return node;
    }
    /**
     * Renders a text node out of {@link module:ui/template~Template#text}.
     *
     * @protected
     * @param {module:ui/template~RenderData} data Rendering data.
     */

  }, {
    key: "_renderText",
    value: function _renderText(data) {
      var node = data.node; // Save the original textContent to revert it in #revert().

      if (node) {
        data.revertData.text = node.textContent;
      } else {
        node = data.node = document.createTextNode('');
      } // Check if this Text Node is bound to Observable. Cases:
      //
      //		text: [ Template.bind( ... ).to( ... ) ]
      //
      //		text: [
      //			'foo',
      //			Template.bind( ... ).to( ... ),
      //			...
      //		]
      //


      if (hasTemplateBinding(this.text)) {
        this._bindToObservable({
          schema: this.text,
          updater: getTextUpdater(node),
          data: data
        });
      } // Simply set text. Cases:
      //
      //		text: [ 'all', 'are', 'static' ]
      //
      //		text: [ 'foo' ]
      //
      else {
          node.textContent = this.text.join('');
        }

      return node;
    }
    /**
     * Renders HTML element attributes out of {@link module:ui/template~Template#attributes}.
     *
     * @protected
     * @param {module:ui/template~RenderData} data Rendering data.
     */

  }, {
    key: "_renderAttributes",
    value: function _renderAttributes(data) {
      var attrName, attrValue, domAttrValue, attrNs;

      if (!this.attributes) {
        return;
      }

      var node = data.node;
      var revertData = data.revertData;

      for (attrName in this.attributes) {
        // Current attribute value in DOM.
        domAttrValue = node.getAttribute(attrName); // The value to be set.

        attrValue = this.attributes[attrName]; // Save revert data.

        if (revertData) {
          revertData.attributes[attrName] = domAttrValue;
        } // Detect custom namespace:
        //
        //		class: {
        //			ns: 'abc',
        //			value: Template.bind( ... ).to( ... )
        //		}
        //


        attrNs = lodash_es_isObject(attrValue[0]) && attrValue[0].ns ? attrValue[0].ns : null; // Activate binding if one is found. Cases:
        //
        //		class: [
        //			Template.bind( ... ).to( ... )
        //		]
        //
        //		class: [
        //			'bar',
        //			Template.bind( ... ).to( ... ),
        //			'baz'
        //		]
        //
        //		class: {
        //			ns: 'abc',
        //			value: Template.bind( ... ).to( ... )
        //		}
        //

        if (hasTemplateBinding(attrValue)) {
          // Normalize attributes with additional data like namespace:
          //
          //		class: {
          //			ns: 'abc',
          //			value: [ ... ]
          //		}
          //
          var valueToBind = attrNs ? attrValue[0].value : attrValue; // Extend the original value of attributes like "style" and "class",
          // don't override them.

          if (revertData && shouldExtend(attrName)) {
            valueToBind.unshift(domAttrValue);
          }

          this._bindToObservable({
            schema: valueToBind,
            updater: getAttributeUpdater(node, attrName, attrNs),
            data: data
          });
        } // Style attribute could be an Object so it needs to be parsed in a specific way.
        //
        //		style: {
        //			width: '100px',
        //			height: Template.bind( ... ).to( ... )
        //		}
        //
        else if (attrName == 'style' && typeof attrValue[0] !== 'string') {
            this._renderStyleAttribute(attrValue[0], data);
          } // Otherwise simply set the static attribute:
          //
          //		class: [ 'foo' ]
          //
          //		class: [ 'all', 'are', 'static' ]
          //
          //		class: [
          //			{
          //				ns: 'abc',
          //				value: [ 'foo' ]
          //			}
          //		]
          //
          else {
              // Extend the original value of attributes like "style" and "class",
              // don't override them.
              if (revertData && domAttrValue && shouldExtend(attrName)) {
                attrValue.unshift(domAttrValue);
              }

              attrValue = attrValue // Retrieve "values" from:
              //
              //		class: [
              //			{
              //				ns: 'abc',
              //				value: [ ... ]
              //			}
              //		]
              //
              .map(function (val) {
                return val ? val.value || val : val;
              }) // Flatten the array.
              .reduce(function (prev, next) {
                return prev.concat(next);
              }, []) // Convert into string.
              .reduce(arrayValueReducer, '');

              if (!isFalsy(attrValue)) {
                node.setAttributeNS(attrNs, attrName, attrValue);
              }
            }
      }
    }
    /**
     * Renders the `style` attribute of an HTML element based on
     * {@link module:ui/template~Template#attributes}.
     *
     * A style attribute is an {Object} with static values:
     *
     *		attributes: {
     *			style: {
     *				color: 'red'
     *			}
     *		}
     *
     * or values bound to {@link module:ui/model~Model} properties:
     *
     *		attributes: {
     *			style: {
     *				color: bind.to( ... )
     *			}
     *		}
     *
     * Note: The `style` attribute is rendered without setting the namespace. It does not seem to be
     * needed.
     *
     * @private
     * @param {Object} styles Styles located in `attributes.style` of {@link module:ui/template~TemplateDefinition}.
     * @param {module:ui/template~RenderData} data Rendering data.
     */

  }, {
    key: "_renderStyleAttribute",
    value: function _renderStyleAttribute(styles, data) {
      var node = data.node;

      for (var styleName in styles) {
        var styleValue = styles[styleName]; // Cases:
        //
        //		style: {
        //			color: bind.to( 'attribute' )
        //		}
        //

        if (hasTemplateBinding(styleValue)) {
          this._bindToObservable({
            schema: [styleValue],
            updater: getStyleUpdater(node, styleName),
            data: data
          });
        } // Cases:
        //
        //		style: {
        //			color: 'red'
        //		}
        //
        else {
            node.style[styleName] = styleValue;
          }
      }
    }
    /**
     * Recursively renders HTML element's children from {@link module:ui/template~Template#children}.
     *
     * @protected
     * @param {module:ui/template~RenderData} data Rendering data.
     */

  }, {
    key: "_renderElementChildren",
    value: function _renderElementChildren(data) {
      var node = data.node;
      var container = data.intoFragment ? document.createDocumentFragment() : node;
      var isApplying = data.isApplying;
      var childIndex = 0;

      var _iterator2 = _createForOfIteratorHelper(this.children),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var child = _step2.value;

          if (isViewCollection(child)) {
            if (!isApplying) {
              child.setParent(node); // Note: ViewCollection renders its children.

              var _iterator3 = _createForOfIteratorHelper(child),
                  _step3;

              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  var view = _step3.value;
                  container.appendChild(view.element);
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
            }
          } else if (isView(child)) {
            if (!isApplying) {
              if (!child.isRendered) {
                child.render();
              }

              container.appendChild(child.element);
            }
          } else if (isNode(child)) {
            container.appendChild(child);
          } else {
            if (isApplying) {
              var revertData = data.revertData;
              var childRevertData = getEmptyRevertData();
              revertData.children.push(childRevertData);

              child._renderNode({
                node: container.childNodes[childIndex++],
                isApplying: true,
                revertData: childRevertData
              });
            } else {
              container.appendChild(child.render());
            }
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      if (data.intoFragment) {
        node.appendChild(container);
      }
    }
    /**
     * Activates `on` event listeners from the {@link module:ui/template~TemplateDefinition}
     * on an HTML element.
     *
     * @protected
     * @param {module:ui/template~RenderData} data Rendering data.
     */

  }, {
    key: "_setUpListeners",
    value: function _setUpListeners(data) {
      var _this = this;

      if (!this.eventListeners) {
        return;
      }

      var _loop = function _loop(key) {
        var revertBindings = _this.eventListeners[key].map(function (schemaItem) {
          var _key$split = key.split('@'),
              _key$split2 = _slicedToArray(_key$split, 2),
              domEvtName = _key$split2[0],
              domSelector = _key$split2[1];

          return schemaItem.activateDomEventListener(domEvtName, domSelector, data);
        });

        if (data.revertData) {
          data.revertData.bindings.push(revertBindings);
        }
      };

      for (var key in this.eventListeners) {
        _loop(key);
      }
    }
    /**
     * For a given {@link module:ui/template~TemplateValueSchema} containing {@link module:ui/template~TemplateBinding}
     * activates the binding and sets its initial value.
     *
     * Note: {@link module:ui/template~TemplateValueSchema} can be for HTML element attributes or
     * text node `textContent`.
     *
     * @protected
     * @param {Object} options Binding options.
     * @param {module:ui/template~TemplateValueSchema} options.schema
     * @param {Function} options.updater A function which updates the DOM (like attribute or text).
     * @param {module:ui/template~RenderData} options.data Rendering data.
     */

  }, {
    key: "_bindToObservable",
    value: function _bindToObservable(_ref) {
      var schema = _ref.schema,
          updater = _ref.updater,
          data = _ref.data;
      var revertData = data.revertData; // Set initial values.

      syncValueSchemaValue(schema, updater, data);
      var revertBindings = schema // Filter "falsy" (false, undefined, null, '') value schema components out.
      .filter(function (item) {
        return !isFalsy(item);
      }) // Filter inactive bindings from schema, like static strings ('foo'), numbers (42), etc.
      .filter(function (item) {
        return item.observable;
      }) // Once only the actual binding are left, let the emitter listen to observable change:attribute event.
      // TODO: Reduce the number of listeners attached as many bindings may listen
      // to the same observable attribute.
      .map(function (templateBinding) {
        return templateBinding.activateAttributeListener(schema, updater, data);
      });

      if (revertData) {
        revertData.bindings.push(revertBindings);
      }
    }
    /**
     * Reverts {@link module:ui/template~RenderData#revertData template data} from a node to
     * return it to the original state.
     *
     * @protected
     * @param {HTMLElement|Text} node A node to be reverted.
     * @param {Object} revertData An object that stores information about what changes have been made by
     * {@link #apply} to the node. See {@link module:ui/template~RenderData#revertData} for more information.
     */

  }, {
    key: "_revertTemplateFromNode",
    value: function _revertTemplateFromNode(node, revertData) {
      var _iterator4 = _createForOfIteratorHelper(revertData.bindings),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var binding = _step4.value;

          // Each binding may consist of several observable+observable#attribute.
          // like the following has 2:
          //
          //		class: [
          //			'x',
          //			bind.to( 'foo' ),
          //			'y',
          //			bind.to( 'bar' )
          //		]
          //
          var _iterator5 = _createForOfIteratorHelper(binding),
              _step5;

          try {
            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              var revertBinding = _step5.value;
              revertBinding();
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      if (revertData.text) {
        node.textContent = revertData.text;
        return;
      }

      for (var attrName in revertData.attributes) {
        var attrValue = revertData.attributes[attrName]; // When the attribute has **not** been set before #apply().

        if (attrValue === null) {
          node.removeAttribute(attrName);
        } else {
          node.setAttribute(attrName, attrValue);
        }
      }

      for (var i = 0; i < revertData.children.length; ++i) {
        this._revertTemplateFromNode(node.childNodes[i], revertData.children[i]);
      }
    }
  }], [{
    key: "bind",
    value: function bind(observable, emitter) {
      return {
        to: function to(eventNameOrFunctionOrAttribute, callback) {
          return new template_TemplateToBinding({
            eventNameOrFunction: eventNameOrFunctionOrAttribute,
            attribute: eventNameOrFunctionOrAttribute,
            observable: observable,
            emitter: emitter,
            callback: callback
          });
        },
        if: function _if(attribute, valueIfTrue, callback) {
          return new template_TemplateIfBinding({
            observable: observable,
            emitter: emitter,
            attribute: attribute,
            valueIfTrue: valueIfTrue,
            callback: callback
          });
        }
      };
    }
    /**
     * Extends an existing {@link module:ui/template~Template} instance with some additional content
     * from another {@link module:ui/template~TemplateDefinition}.
     *
     *		const bind = Template.bind( observable, emitter );
     *
     *		const template = new Template( {
     *			tag: 'p',
     *			attributes: {
     *				class: 'a',
     *				data-x: bind.to( 'foo' )
     *			},
     *			children: [
     *				{
     *					tag: 'span',
     *					attributes: {
     *						class: 'b'
     *					},
     *					children: [
     *						'Span'
     *					]
     *				}
     *			]
     *		 } );
     *
     *		// Instance-level extension.
     *		Template.extend( template, {
     *			attributes: {
     *				class: 'b',
     *				data-x: bind.to( 'bar' )
     *			},
     *			children: [
     *				{
     *					attributes: {
     *						class: 'c'
     *					}
     *				}
     *			]
     *		} );
     *
     *		// Child extension.
     *		Template.extend( template.children[ 0 ], {
     *			attributes: {
     *				class: 'd'
     *			}
     *		} );
     *
     * the `outerHTML` of `template.render()` is:
     *
     *		<p class="a b" data-x="{ observable.foo } { observable.bar }">
     *			<span class="b c d">Span</span>
     *		</p>
     *
     * @param {module:ui/template~Template} template An existing template instance to be extended.
     * @param {module:ui/template~TemplateDefinition} def Additional definition to be applied to a template.
     */

  }, {
    key: "extend",
    value: function extend(template, def) {
      if (template._isRendered) {
        /**
         * Extending a template after rendering may not work as expected. To make sure
         * the {@link module:ui/template~Template.extend extending} works for an element,
         * make sure it happens before {@link #render} is called.
         *
         * @error template-extend-render
         */
        throw new ckeditorerror["b" /* default */]('template-extend-render: Attempting to extend a template which has already been rendered.', [this, template]);
      }

      template_extendTemplate(template, template_normalize(template_clone(def)));
    }
  }]);

  return Template;
}();


mix(template_Template, emittermixin);
/**
 * Describes a binding created by the {@link module:ui/template~Template.bind} interface.
 *
 * @protected
 */

var template_TemplateBinding = /*#__PURE__*/function () {
  /**
   * Creates an instance of the {@link module:ui/template~TemplateBinding} class.
   *
   * @param {module:ui/template~TemplateDefinition} def The definition of the binding.
   */
  function TemplateBinding(def) {
    Object(classCallCheck["a" /* default */])(this, TemplateBinding);

    Object.assign(this, def);
    /**
     * An observable instance of the binding. It either:
     *
     * * provides the attribute with the value,
     * * or passes the event when a corresponding DOM event is fired.
     *
     * @member {module:utils/observablemixin~ObservableMixin} module:ui/template~TemplateBinding#observable
     */

    /**
     * An {@link module:utils/emittermixin~Emitter} used by the binding to:
     *
     * * listen to the attribute change in the {@link module:ui/template~TemplateBinding#observable},
     * * or listen to the event in the DOM.
     *
     * @member {module:utils/emittermixin~EmitterMixin} module:ui/template~TemplateBinding#emitter
     */

    /**
     * The name of the {@link module:ui/template~TemplateBinding#observable observed attribute}.
     *
     * @member {String} module:ui/template~TemplateBinding#attribute
     */

    /**
     * A custom function to process the value of the {@link module:ui/template~TemplateBinding#attribute}.
     *
     * @member {Function} [module:ui/template~TemplateBinding#callback]
     */
  }
  /**
   * Returns the value of the binding. It is the value of the {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}. The value may be processed by the
   * {@link module:ui/template~TemplateBinding#callback}, if such has been passed to the binding.
   *
   * @param {Node} [node] A native DOM node, passed to the custom {@link module:ui/template~TemplateBinding#callback}.
   * @returns {*} The value of {@link module:ui/template~TemplateBinding#attribute} in
   * {@link module:ui/template~TemplateBinding#observable}.
   */


  Object(createClass["a" /* default */])(TemplateBinding, [{
    key: "getValue",
    value: function getValue(node) {
      var value = this.observable[this.attribute];
      return this.callback ? this.callback(value, node) : value;
    }
    /**
     * Activates the listener which waits for changes of the {@link module:ui/template~TemplateBinding#attribute} in
     * {@link module:ui/template~TemplateBinding#observable}, then updates the DOM with the aggregated
     * value of {@link module:ui/template~TemplateValueSchema}.
     *
     * @param {module:ui/template~TemplateValueSchema} schema A full schema to generate an attribute or text in the DOM.
     * @param {Function} updater A DOM updater function used to update the native DOM attribute or text.
     * @param {module:ui/template~RenderData} data Rendering data.
     * @returns {Function} A function to sever the listener binding.
     */

  }, {
    key: "activateAttributeListener",
    value: function activateAttributeListener(schema, updater, data) {
      var _this2 = this;

      var callback = function callback() {
        return syncValueSchemaValue(schema, updater, data);
      };

      this.emitter.listenTo(this.observable, 'change:' + this.attribute, callback); // Allows revert of the listener.

      return function () {
        _this2.emitter.stopListening(_this2.observable, 'change:' + _this2.attribute, callback);
      };
    }
  }]);

  return TemplateBinding;
}();
/**
 * Describes either:
 *
 * * a binding to an {@link module:utils/observablemixin~Observable},
 * * or a native DOM event binding.
 *
 * It is created by the {@link module:ui/template~BindChain#to} method.
 *
 * @protected
 */

var template_TemplateToBinding = /*#__PURE__*/function (_TemplateBinding) {
  Object(inherits["a" /* default */])(TemplateToBinding, _TemplateBinding);

  var _super = Object(createSuper["a" /* default */])(TemplateToBinding);

  function TemplateToBinding() {
    Object(classCallCheck["a" /* default */])(this, TemplateToBinding);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(TemplateToBinding, [{
    key: "activateDomEventListener",

    /**
     * Activates the listener for the native DOM event, which when fired, is propagated by
     * the {@link module:ui/template~TemplateBinding#emitter}.
     *
     * @param {String} domEvtName The name of the native DOM event.
     * @param {String} domSelector The selector in the DOM to filter delegated events.
     * @param {module:ui/template~RenderData} data Rendering data.
     * @returns {Function} A function to sever the listener binding.
     */
    value: function activateDomEventListener(domEvtName, domSelector, data) {
      var _this3 = this;

      var callback = function callback(evt, domEvt) {
        if (!domSelector || domEvt.target.matches(domSelector)) {
          if (typeof _this3.eventNameOrFunction == 'function') {
            _this3.eventNameOrFunction(domEvt);
          } else {
            _this3.observable.fire(_this3.eventNameOrFunction, domEvt);
          }
        }
      };

      this.emitter.listenTo(data.node, domEvtName, callback); // Allows revert of the listener.

      return function () {
        _this3.emitter.stopListening(data.node, domEvtName, callback);
      };
    }
  }]);

  return TemplateToBinding;
}(template_TemplateBinding);
/**
 * Describes a binding to {@link module:utils/observablemixin~ObservableMixin} created by the {@link module:ui/template~BindChain#if}
 * method.
 *
 * @protected
 */

var template_TemplateIfBinding = /*#__PURE__*/function (_TemplateBinding2) {
  Object(inherits["a" /* default */])(TemplateIfBinding, _TemplateBinding2);

  var _super2 = Object(createSuper["a" /* default */])(TemplateIfBinding);

  function TemplateIfBinding() {
    Object(classCallCheck["a" /* default */])(this, TemplateIfBinding);

    return _super2.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(TemplateIfBinding, [{
    key: "getValue",

    /**
     * @inheritDoc
     */
    value: function getValue(node) {
      var value = get_get(Object(getPrototypeOf["a" /* default */])(TemplateIfBinding.prototype), "getValue", this).call(this, node);

      return isFalsy(value) ? false : this.valueIfTrue || true;
    }
    /**
     * The value of the DOM attribute or text to be set if the {@link module:ui/template~TemplateBinding#attribute} in
     * {@link module:ui/template~TemplateBinding#observable} is `true`.
     *
     * @member {String} [module:ui/template~TemplateIfBinding#valueIfTrue]
     */

  }]);

  return TemplateIfBinding;
}(template_TemplateBinding); // Checks whether given {@link module:ui/template~TemplateValueSchema} contains a
// {@link module:ui/template~TemplateBinding}.
//
// @param {module:ui/template~TemplateValueSchema} schema
// @returns {Boolean}

function hasTemplateBinding(schema) {
  if (!schema) {
    return false;
  } // Normalize attributes with additional data like namespace:
  //
  //		class: {
  //			ns: 'abc',
  //			value: [ ... ]
  //		}
  //


  if (schema.value) {
    schema = schema.value;
  }

  if (Array.isArray(schema)) {
    return schema.some(hasTemplateBinding);
  } else if (schema instanceof template_TemplateBinding) {
    return true;
  }

  return false;
} // Assembles the value using {@link module:ui/template~TemplateValueSchema} and stores it in a form of
// an Array. Each entry of the Array corresponds to one of {@link module:ui/template~TemplateValueSchema}
// items.
//
// @param {module:ui/template~TemplateValueSchema} schema
// @param {Node} node DOM Node updated when {@link module:utils/observablemixin~ObservableMixin} changes.
// @returns {Array}


function getValueSchemaValue(schema, node) {
  return schema.map(function (schemaItem) {
    // Process {@link module:ui/template~TemplateBinding} bindings.
    if (schemaItem instanceof template_TemplateBinding) {
      return schemaItem.getValue(node);
    } // All static values like strings, numbers, and "falsy" values (false, null, undefined, '', etc.) just pass.


    return schemaItem;
  });
} // A function executed each time the bound Observable attribute changes, which updates the DOM with a value
// constructed from {@link module:ui/template~TemplateValueSchema}.
//
// @param {module:ui/template~TemplateValueSchema} schema
// @param {Function} updater A function which updates the DOM (like attribute or text).
// @param {Node} node DOM Node updated when {@link module:utils/observablemixin~ObservableMixin} changes.


function syncValueSchemaValue(schema, updater, _ref2) {
  var node = _ref2.node;
  var value = getValueSchemaValue(schema, node); // Check if schema is a single Template.bind.if, like:
  //
  //		class: Template.bind.if( 'foo' )
  //

  if (schema.length == 1 && schema[0] instanceof template_TemplateIfBinding) {
    value = value[0];
  } else {
    value = value.reduce(arrayValueReducer, '');
  }

  if (isFalsy(value)) {
    updater.remove();
  } else {
    updater.set(value);
  }
} // Returns an object consisting of `set` and `remove` functions, which
// can be used in the context of DOM Node to set or reset `textContent`.
// @see module:ui/view~View#_bindToObservable
//
// @param {Node} node DOM Node to be modified.
// @returns {Object}


function getTextUpdater(node) {
  return {
    set: function set(value) {
      node.textContent = value;
    },
    remove: function remove() {
      node.textContent = '';
    }
  };
} // Returns an object consisting of `set` and `remove` functions, which
// can be used in the context of DOM Node to set or reset an attribute.
// @see module:ui/view~View#_bindToObservable
//
// @param {Node} node DOM Node to be modified.
// @param {String} attrName Name of the attribute to be modified.
// @param {String} [ns=null] Namespace to use.
// @returns {Object}


function getAttributeUpdater(el, attrName, ns) {
  return {
    set: function set(value) {
      el.setAttributeNS(ns, attrName, value);
    },
    remove: function remove() {
      el.removeAttributeNS(ns, attrName);
    }
  };
} // Returns an object consisting of `set` and `remove` functions, which
// can be used in the context of CSSStyleDeclaration to set or remove a style.
// @see module:ui/view~View#_bindToObservable
//
// @param {Node} node DOM Node to be modified.
// @param {String} styleName Name of the style to be modified.
// @returns {Object}


function getStyleUpdater(el, styleName) {
  return {
    set: function set(value) {
      el.style[styleName] = value;
    },
    remove: function remove() {
      el.style[styleName] = null;
    }
  };
} // Clones definition of the template.
//
// @param {module:ui/template~TemplateDefinition} def
// @returns {module:ui/template~TemplateDefinition}


function template_clone(def) {
  var clone = lodash_es_cloneDeepWith(def, function (value) {
    // Don't clone the `Template.bind`* bindings because of the references to Observable
    // and DomEmitterMixin instances inside, which would also be traversed and cloned by greedy
    // cloneDeepWith algorithm. There's no point in cloning Observable/DomEmitterMixins
    // along with the definition.
    //
    // Don't clone Template instances if provided as a child. They're simply #render()ed
    // and nothing should interfere.
    //
    // Also don't clone View instances if provided as a child of the Template. The template
    // instance will be extracted from the View during the normalization and there's no need
    // to clone it.
    if (value && (value instanceof template_TemplateBinding || isTemplate(value) || isView(value) || isViewCollection(value))) {
      return value;
    }
  });
  return clone;
} // Normalizes given {@link module:ui/template~TemplateDefinition}.
//
// See:
//  * {@link normalizeAttributes}
//  * {@link normalizeListeners}
//  * {@link normalizePlainTextDefinition}
//  * {@link normalizeTextDefinition}
//
// @param {module:ui/template~TemplateDefinition} def
// @returns {module:ui/template~TemplateDefinition} Normalized definition.


function template_normalize(def) {
  if (typeof def == 'string') {
    def = normalizePlainTextDefinition(def);
  } else if (def.text) {
    normalizeTextDefinition(def);
  }

  if (def.on) {
    def.eventListeners = normalizeListeners(def.on); // Template mixes EmitterMixin, so delete #on to avoid collision.

    delete def.on;
  }

  if (!def.text) {
    if (def.attributes) {
      normalizeAttributes(def.attributes);
    }

    var children = [];

    if (def.children) {
      if (isViewCollection(def.children)) {
        children.push(def.children);
      } else {
        var _iterator6 = _createForOfIteratorHelper(def.children),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var child = _step6.value;

            if (isTemplate(child) || isView(child) || isNode(child)) {
              children.push(child);
            } else {
              children.push(new template_Template(child));
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
      }
    }

    def.children = children;
  }

  return def;
} // Normalizes "attributes" section of {@link module:ui/template~TemplateDefinition}.
//
//		attributes: {
//			a: 'bar',
//			b: {@link module:ui/template~TemplateBinding},
//			c: {
//				value: 'bar'
//			}
//		}
//
// becomes
//
//		attributes: {
//			a: [ 'bar' ],
//			b: [ {@link module:ui/template~TemplateBinding} ],
//			c: {
//				value: [ 'bar' ]
//			}
//		}
//
// @param {Object} attributes


function normalizeAttributes(attributes) {
  for (var a in attributes) {
    if (attributes[a].value) {
      attributes[a].value = [].concat(attributes[a].value);
    }

    arrayify(attributes, a);
  }
} // Normalizes "on" section of {@link module:ui/template~TemplateDefinition}.
//
//		on: {
//			a: 'bar',
//			b: {@link module:ui/template~TemplateBinding},
//			c: [ {@link module:ui/template~TemplateBinding}, () => { ... } ]
//		}
//
// becomes
//
//		on: {
//			a: [ 'bar' ],
//			b: [ {@link module:ui/template~TemplateBinding} ],
//			c: [ {@link module:ui/template~TemplateBinding}, () => { ... } ]
//		}
//
// @param {Object} listeners
// @returns {Object} Object containing normalized listeners.


function normalizeListeners(listeners) {
  for (var l in listeners) {
    arrayify(listeners, l);
  }

  return listeners;
} // Normalizes "string" {@link module:ui/template~TemplateDefinition}.
//
//		"foo"
//
// becomes
//
//		{ text: [ 'foo' ] },
//
// @param {String} def
// @returns {module:ui/template~TemplateDefinition} Normalized template definition.


function normalizePlainTextDefinition(def) {
  return {
    text: [def]
  };
} // Normalizes text {@link module:ui/template~TemplateDefinition}.
//
//		children: [
//			{ text: 'def' },
//			{ text: {@link module:ui/template~TemplateBinding} }
//		]
//
// becomes
//
//		children: [
//			{ text: [ 'def' ] },
//			{ text: [ {@link module:ui/template~TemplateBinding} ] }
//		]
//
// @param {module:ui/template~TemplateDefinition} def


function normalizeTextDefinition(def) {
  if (!Array.isArray(def.text)) {
    def.text = [def.text];
  }
} // Wraps an entry in Object in an Array, if not already one.
//
//		{
//			x: 'y',
//			a: [ 'b' ]
//		}
//
// becomes
//
//		{
//			x: [ 'y' ],
//			a: [ 'b' ]
//		}
//
// @param {Object} obj
// @param {String} key


function arrayify(obj, key) {
  if (!Array.isArray(obj[key])) {
    obj[key] = [obj[key]];
  }
} // A helper which concatenates the value avoiding unwanted
// leading white spaces.
//
// @param {String} prev
// @param {String} cur
// @returns {String}


function arrayValueReducer(prev, cur) {
  if (isFalsy(cur)) {
    return prev;
  } else if (isFalsy(prev)) {
    return cur;
  } else {
    return "".concat(prev, " ").concat(cur);
  }
} // Extends one object defined in the following format:
//
//		{
//			key1: [Array1],
//			key2: [Array2],
//			...
//			keyN: [ArrayN]
//		}
//
// with another object of the same data format.
//
// @param {Object} obj Base object.
// @param {Object} ext Object extending base.
// @returns {String}


function extendObjectValueArray(obj, ext) {
  for (var a in ext) {
    if (obj[a]) {
      var _obj$a;

      (_obj$a = obj[a]).push.apply(_obj$a, _toConsumableArray(ext[a]));
    } else {
      obj[a] = ext[a];
    }
  }
} // A helper for {@link module:ui/template~Template#extend}. Recursively extends {@link module:ui/template~Template} instance
// with content from {@link module:ui/template~TemplateDefinition}. See {@link module:ui/template~Template#extend} to learn more.
//
// @param {module:ui/template~Template} def A template instance to be extended.
// @param {module:ui/template~TemplateDefinition} def A definition which is to extend the template instance.
// @param {Object} Error context.


function template_extendTemplate(template, def) {
  if (def.attributes) {
    if (!template.attributes) {
      template.attributes = {};
    }

    extendObjectValueArray(template.attributes, def.attributes);
  }

  if (def.eventListeners) {
    if (!template.eventListeners) {
      template.eventListeners = {};
    }

    extendObjectValueArray(template.eventListeners, def.eventListeners);
  }

  if (def.text) {
    var _template$text;

    (_template$text = template.text).push.apply(_template$text, _toConsumableArray(def.text));
  }

  if (def.children && def.children.length) {
    if (template.children.length != def.children.length) {
      /**
       * The number of children in extended definition does not match.
       *
       * @error ui-template-extend-children-mismatch
       */
      throw new ckeditorerror["b" /* default */]('ui-template-extend-children-mismatch: The number of children in extended definition does not match.', template);
    }

    var childIndex = 0;

    var _iterator7 = _createForOfIteratorHelper(def.children),
        _step7;

    try {
      for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
        var childDef = _step7.value;
        template_extendTemplate(template.children[childIndex++], childDef);
      }
    } catch (err) {
      _iterator7.e(err);
    } finally {
      _iterator7.f();
    }
  }
} // Checks if value is "falsy".
// Note: 0 (Number) is not "falsy" in this context.
//
// @private
// @param {*} value Value to be checked.


function isFalsy(value) {
  return !value && value !== 0;
} // Checks if the item is an instance of {@link module:ui/view~View}
//
// @private
// @param {*} value Value to be checked.


function isView(item) {
  return item instanceof src_view_View;
} // Checks if the item is an instance of {@link module:ui/template~Template}
//
// @private
// @param {*} value Value to be checked.


function isTemplate(item) {
  return item instanceof template_Template;
} // Checks if the item is an instance of {@link module:ui/viewcollection~ViewCollection}
//
// @private
// @param {*} value Value to be checked.


function isViewCollection(item) {
  return item instanceof viewcollection_ViewCollection;
} // Creates an empty skeleton for {@link module:ui/template~Template#revert}
// data.
//
// @private


function getEmptyRevertData() {
  return {
    children: [],
    bindings: [],
    attributes: {}
  };
} // Checks whether an attribute should be extended when
// {@link module:ui/template~Template#apply} is called.
//
// @private
// @param {String} attrName Attribute name to check.


function shouldExtend(attrName) {
  return attrName == 'class' || attrName == 'style';
}
/**
 * A definition of the {@link module:ui/template~Template}. It describes what kind of
 * node a template will render (HTML element or text), attributes of an element, DOM event
 * listeners and children.
 *
 * Also see:
 * * {@link module:ui/template~TemplateValueSchema} to learn about HTML element attributes,
 * * {@link module:ui/template~TemplateListenerSchema} to learn about DOM event listeners.
 *
 * A sample definition on an HTML element can look like this:
 *
 *		new Template( {
 *			tag: 'p',
 *			children: [
 *				{
 *					tag: 'span',
 *					attributes: { ... },
 *					children: [ ... ],
 *				},
 *				{
 *					text: 'static–text'
 *				},
 *				'also-static–text',
 *			],
 *			attributes: {
 *				class: {@link module:ui/template~TemplateValueSchema},
 *				id: {@link module:ui/template~TemplateValueSchema},
 *				style: {@link module:ui/template~TemplateValueSchema}
 *
 *				// ...
 *			},
 *			on: {
 *				'click': {@link module:ui/template~TemplateListenerSchema}
 *
 *				// Document.querySelector format is also accepted.
 *				'keyup@a.some-class': {@link module:ui/template~TemplateListenerSchema}
 *
 *				// ...
 *			}
 *		} );
 *
 * A {@link module:ui/view~View}, another {@link module:ui/template~Template} or a native DOM node
 * can also become a child of a template. When a view is passed, its {@link module:ui/view~View#element} is used:
 *
 *		const view = new SomeView();
 *		const childTemplate = new Template( { ... } );
 *		const childNode = document.createElement( 'b' );
 *
 *		new Template( {
 *			tag: 'p',
 *
 *			children: [
 *				// view#element will be added as a child of this <p>.
 *				view,
 *
 * 				// The output of childTemplate.render() will be added here.
 *				childTemplate,
 *
 *				// Native DOM nodes are included directly in the rendered output.
 *				childNode
 *			]
 *		} );
 *
 * An entire {@link module:ui/viewcollection~ViewCollection} can be used as a child in the definition:
 *
 *		const collection = new ViewCollection();
 *		collection.add( someView );
 *
 *		new Template( {
 *			tag: 'p',
 *
 *			children: collection
 *		} );
 *
 * @typedef module:ui/template~TemplateDefinition
 * @type Object
 *
 * @property {String} tag See the template {@link module:ui/template~Template#tag} property.
 *
 * @property {Array.<module:ui/template~TemplateDefinition>} [children]
 * See the template {@link module:ui/template~Template#children} property.
 *
 * @property {Object.<String, module:ui/template~TemplateValueSchema>} [attributes]
 * See the template {@link module:ui/template~Template#attributes} property.
 *
 * @property {String|module:ui/template~TemplateValueSchema|Array.<String|module:ui/template~TemplateValueSchema>} [text]
 * See the template {@link module:ui/template~Template#text} property.
 *
 * @property {Object.<String, module:ui/template~TemplateListenerSchema>} [on]
 * See the template {@link module:ui/template~Template#eventListeners} property.
 */

/**
 * Describes a value of an HTML element attribute or `textContent`. It allows combining multiple
 * data sources like static values and {@link module:utils/observablemixin~Observable} attributes.
 *
 * Also see:
 * * {@link module:ui/template~TemplateDefinition} to learn where to use it,
 * * {@link module:ui/template~Template.bind} to learn how to configure
 * {@link module:utils/observablemixin~Observable} attribute bindings,
 * * {@link module:ui/template~Template#render} to learn how to render a template,
 * * {@link module:ui/template~BindChain#to `to()`} and {@link module:ui/template~BindChain#if `if()`}
 * methods to learn more about bindings.
 *
 * Attribute values can be described in many different ways:
 *
 *		// Bind helper will create bindings to attributes of the observable.
 *		const bind = Template.bind( observable, emitter );
 *
 *		new Template( {
 *			tag: 'p',
 *			attributes: {
 *				// A plain string schema.
 *				'class': 'static-text',
 *
 *				// An object schema, binds to the "foo" attribute of the
 *				// observable and follows its value.
 *				'class': bind.to( 'foo' ),
 *
 *				// An array schema, combines the above.
 *				'class': [
 *					'static-text',
 *					bind.to( 'bar', () => { ... } ),
 *
 * 					// Bindings can also be conditional.
 *					bind.if( 'baz', 'class-when-baz-is-true' )
 *				],
 *
 *				// An array schema, with a custom namespace, e.g. useful for creating SVGs.
 *				'class': {
 *					ns: 'http://ns.url',
 *					value: [
 *						bind.if( 'baz', 'value-when-true' ),
 *						'static-text'
 *					]
 *				},
 *
 *				// An object schema, specific for styles.
 *				style: {
 *					color: 'red',
 *					backgroundColor: bind.to( 'qux', () => { ... } )
 *				}
 *			}
 *		} );
 *
 * Text nodes can also have complex values:
 *
 *		const bind = Template.bind( observable, emitter );
 *
 *		// Will render a "foo" text node.
 *		new Template( {
 *			text: 'foo'
 *		} );
 *
 *		// Will render a "static text: {observable.foo}" text node.
 *		// The text of the node will be updated as the "foo" attribute changes.
 *		new Template( {
 *			text: [
 *				'static text: ',
 *				bind.to( 'foo', () => { ... } )
 *			]
 *		} );
 *
 * @typedef module:ui/template~TemplateValueSchema
 * @type {Object|String|Array}
 */

/**
 * Describes an event listener attached to an HTML element. Such listener can propagate DOM events
 * through an {@link module:utils/observablemixin~Observable} instance, execute custom callbacks
 * or both, if necessary.
 *
 * Also see:
 * * {@link module:ui/template~TemplateDefinition} to learn more about template definitions,
 * * {@link module:ui/template~BindChain#to `to()`} method to learn more about bindings.
 *
 * Check out different ways of attaching event listeners below:
 *
 *		// Bind helper will propagate events through the observable.
 *		const bind = Template.bind( observable, emitter );
 *
 *		new Template( {
 *			tag: 'p',
 *			on: {
 *				// An object schema. The observable will fire the "clicked" event upon DOM "click".
 *				click: bind.to( 'clicked' )
 *
 *				// An object schema. It will work for "click" event on "a.foo" children only.
 *				'click@a.foo': bind.to( 'clicked' )
 *
 *				// An array schema, makes the observable propagate multiple events.
 *				click: [
 *					bind.to( 'clicked' ),
 *					bind.to( 'executed' )
 *				],
 *
 *				// An array schema with a custom callback.
 *				'click@a.foo': {
 *					bind.to( 'clicked' ),
 *					bind.to( evt => {
 *						console.log( `${ evt.target } has been clicked!` );
 *					} }
 *				}
 *			}
 *		} );
 *
 * @typedef module:ui/template~TemplateListenerSchema
 * @type {Object|String|Array}
 */

/**
 * The return value of {@link ~Template.bind `Template.bind()`}. It provides `to()` and `if()`
 * methods to create the {@link module:utils/observablemixin~Observable observable} attribute and event bindings.
 *
 * @interface module:ui/template~BindChain
 */

/**
 * Binds an {@link module:utils/observablemixin~Observable observable} to either:
 *
 * * an HTML element attribute or a text node `textContent`, so it remains in sync with the observable
 * attribute as it changes,
 * * or an HTML element DOM event, so the DOM events are propagated through an observable.
 *
 * Some common use cases of `to()` bindings are presented below:
 *
 *		const bind = Template.bind( observable, emitter );
 *
 *		new Template( {
 *			tag: 'p',
 *			attributes: {
 *				// class="..." attribute gets bound to `observable#a`
 *				class: bind.to( 'a' )
 *			},
 *			children: [
 *				// <p>...</p> gets bound to observable#b; always `toUpperCase()`.
 *				{
 *					text: bind.to( 'b', ( value, node ) => value.toUpperCase() )
 *				}
 *			],
 *			on: {
 *				click: [
 *					// An observable will fire "clicked" upon "click" in the DOM.
 *					bind.to( 'clicked' ),
 *
 *					// A custom callback will be executed upon "click" in the DOM.
 *					bind.to( () => {
 *						...
 *					} )
 *				]
 *			}
 *		} ).render();
 *
 * Learn more about using `to()` in the {@link module:ui/template~TemplateValueSchema} and
 * {@link module:ui/template~TemplateListenerSchema}.
 *
 * @method #to
 * @param {String|Function} eventNameOrFunctionOrAttribute An attribute name of
 * {@link module:utils/observablemixin~Observable} or a DOM event name or an event callback.
 * @param {Function} [callback] Allows for processing of the value. Accepts `Node` and `value` as arguments.
 * @returns {module:ui/template~TemplateBinding}
 */

/**
 * Binds an {@link module:utils/observablemixin~Observable observable} to an HTML element attribute or a text
 * node `textContent` so it remains in sync with the observable attribute as it changes.
 *
 * Unlike {@link module:ui/template~BindChain#to}, it controls the presence of the attribute or `textContent`
 * depending on the "falseness" of an {@link module:utils/observablemixin~Observable} attribute.
 *
 *		const bind = Template.bind( observable, emitter );
 *
 *		new Template( {
 *			tag: 'input',
 *			attributes: {
 *				// <input checked> when `observable#a` is not undefined/null/false/''
 *				// <input> when `observable#a` is undefined/null/false
 *				checked: bind.if( 'a' )
 *			},
 *			children: [
 *				{
 *					// <input>"b-is-not-set"</input> when `observable#b` is undefined/null/false/''
 *					// <input></input> when `observable#b` is not "falsy"
 *					text: bind.if( 'b', 'b-is-not-set', ( value, node ) => !value )
 *				}
 *			]
 *		} ).render();
 *
 * Learn more about using `if()` in the {@link module:ui/template~TemplateValueSchema}.
 *
 * @method #if
 * @param {String} attribute An attribute name of {@link module:utils/observablemixin~Observable} used in the binding.
 * @param {String} [valueIfTrue] Value set when the {@link module:utils/observablemixin~Observable} attribute is not
 * undefined/null/false/'' (empty string).
 * @param {Function} [callback] Allows for processing of the value. Accepts `Node` and `value` as arguments.
 * @returns {module:ui/template~TemplateBinding}
 */

/**
 * The {@link module:ui/template~Template#_renderNode} configuration.
 *
 * @private
 * @interface module:ui/template~RenderData
 */

/**
 * Tells {@link module:ui/template~Template#_renderNode} to render
 * children into `DocumentFragment` first and then append the fragment
 * to the parent element. It is a speed optimization.
 *
 * @member {Boolean} #intoFragment
 */

/**
 * A node which is being rendered.
 *
 * @member {HTMLElement|Text} #node
 */

/**
 * Indicates whether the {@module:ui/template~RenderNodeOptions#node} has
 * been provided by {@module:ui/template~Template#apply}.
 *
 * @member {Boolean} #isApplying
 */

/**
 * An object storing the data that helps {@module:ui/template~Template#revert}
 * bringing back an element to its initial state, i.e. before
 * {@module:ui/template~Template#apply} was called.
 *
 * @member {Object} #revertData
 */
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/globals/globals.css
var globals = __webpack_require__("e281");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/view.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/view
 */









/**
 * The basic view class, which represents an HTML element created out of a
 * {@link module:ui/view~View#template}. Views are building blocks of the user interface and handle
 * interaction
 *
 * Views {@link module:ui/view~View#registerChild aggregate} children in
 * {@link module:ui/view~View#createCollection collections} and manage the life cycle of DOM
 * listeners e.g. by handling rendering and destruction.
 *
 * See the {@link module:ui/template~TemplateDefinition} syntax to learn more about shaping view
 * elements, attributes and listeners.
 *
 *		class SampleView extends View {
 *			constructor( locale ) {
 *				super( locale );
 *
 *				const bind = this.bindTemplate;
 *
 *				// Views define their interface (state) using observable attributes.
 *				this.set( 'elementClass', 'bar' );
 *
 *				this.setTemplate( {
 *					tag: 'p',
 *
 *					// The element of the view can be defined with its children.
 *					children: [
 *						'Hello',
 *						{
 *							tag: 'b',
 *							children: [ 'world!' ]
 *						}
 *					],
 *					attributes: {
 *						class: [
 *							'foo',
 *
 *							// Observable attributes control the state of the view in DOM.
 *							bind.to( 'elementClass' )
 *						]
 *					},
 *					on: {
 *						// Views listen to DOM events and propagate them.
 *						click: bind.to( 'clicked' )
 *					}
 *				} );
 *			}
 *		}
 *
 *		const view = new SampleView( locale );
 *
 *		view.render();
 *
 *		// Append <p class="foo bar">Hello<b>world</b></p> to the <body>
 *		document.body.appendChild( view.element );
 *
 *		// Change the class attribute to <p class="foo baz">Hello<b>world</b></p>
 *		view.elementClass = 'baz';
 *
 *		// Respond to the "click" event in DOM by executing a custom action.
 *		view.on( 'clicked', () => {
 *			console.log( 'The view has been clicked!' );
 *		} );
 *
 * @mixes module:utils/observablemixin~ObservableMixin
 */

var src_view_View = /*#__PURE__*/function () {
  /**
   * Creates an instance of the {@link module:ui/view~View} class.
   *
   * Also see {@link #render}.
   *
   * @param {module:utils/locale~Locale} [locale] The localization services instance.
   */
  function View(locale) {
    Object(classCallCheck["a" /* default */])(this, View);

    /**
     * An HTML element of the view. `null` until {@link #render rendered}
     * from the {@link #template}.
     *
     *		class SampleView extends View {
     *			constructor() {
     *				super();
     *
     *				// A template instance the #element will be created from.
     *				this.setTemplate( {
     *					tag: 'p'
     *
     *					// ...
     *				} );
     *			}
     *		}
     *
     *		const view = new SampleView();
     *
     *		// Renders the #template.
     *		view.render();
     *
     *		// Append the HTML element of the view to <body>.
     *		document.body.appendChild( view.element );
     *
     * **Note**: The element of the view can also be assigned directly:
     *
     *		view.element = document.querySelector( '#my-container' );
     *
     * @member {HTMLElement}
     */
    this.element = null;
    /**
     * Set `true` when the view has already been {@link module:ui/view~View#render rendered}.
     *
     * @readonly
     * @member {Boolean} #isRendered
     */

    this.isRendered = false;
    /**
     * A set of tools to localize the user interface.
     *
     * Also see {@link module:core/editor/editor~Editor#locale}.
     *
     * @readonly
     * @member {module:utils/locale~Locale}
     */

    this.locale = locale;
    /**
     * Shorthand for {@link module:utils/locale~Locale#t}.
     *
     * Note: If {@link #locale} instance hasn't been passed to the view this method may not
     * be available.
     *
     * @see module:utils/locale~Locale#t
     * @method
     */

    this.t = locale && locale.t;
    /**
     * Collections registered with {@link #createCollection}.
     *
     * @protected
     * @member {Set.<module:ui/viewcollection~ViewCollection>}
     */

    this._viewCollections = new collection_Collection();
    /**
     * A collection of view instances, which have been added directly
     * into the {@link module:ui/template~Template#children}.
     *
     * @protected
     * @member {module:ui/viewcollection~ViewCollection}
     */

    this._unboundChildren = this.createCollection(); // Pass parent locale to its children.

    this._viewCollections.on('add', function (evt, collection) {
      collection.locale = locale;
    });
    /**
     * Template of this view. It provides the {@link #element} representing
     * the view in DOM, which is {@link #render rendered}.
     *
     * @member {module:ui/template~Template} #template
     */

    /**
     * Cached {@link module:ui/template~BindChain bind chain} object created by the
     * {@link #template}. See {@link #bindTemplate}.
     *
     * @private
     * @member {Object} #_bindTemplate
     */


    this.decorate('render');
  }
  /**
   * Shorthand for {@link module:ui/template~Template.bind}, a binding
   * {@link module:ui/template~BindChain interface} pre–configured for the view instance.
   *
   * It provides {@link module:ui/template~BindChain#to `to()`} and
   * {@link module:ui/template~BindChain#if `if()`} methods that initialize bindings with
   * observable attributes and attach DOM listeners.
   *
   *		class SampleView extends View {
   *			constructor( locale ) {
   *				super( locale );
   *
   *				const bind = this.bindTemplate;
   *
   *				// These {@link module:utils/observablemixin~Observable observable} attributes will control
   *				// the state of the view in DOM.
   *				this.set( {
   *					elementClass: 'foo',
   *				 	isEnabled: true
   *				 } );
   *
   *				this.setTemplate( {
   *					tag: 'p',
   *
   *					attributes: {
   *						// The class HTML attribute will follow elementClass
   *						// and isEnabled view attributes.
   *						class: [
   *							bind.to( 'elementClass' )
   *							bind.if( 'isEnabled', 'present-when-enabled' )
   *						]
   *					},
   *
   *					on: {
   *						// The view will fire the "clicked" event upon clicking <p> in DOM.
   *						click: bind.to( 'clicked' )
   *					}
   *				} );
   *			}
   *		}
   *
   * @method #bindTemplate
   */


  Object(createClass["a" /* default */])(View, [{
    key: "createCollection",

    /**
     * Creates a new collection of views, which can be used as
     * {@link module:ui/template~Template#children} of this view.
     *
     *		class SampleView extends View {
     *			constructor( locale ) {
     *				super( locale );
     *
     *				const child = new ChildView( locale );
     *				this.items = this.createCollection( [ child ] );
    	 *
     *				this.setTemplate( {
     *					tag: 'p',
     *
     *					// `items` collection will render here.
     *					children: this.items
     *				} );
     *			}
     *		}
     *
     *		const view = new SampleView( locale );
     *		view.render();
     *
     *		// It will append <p><child#element></p> to the <body>.
     *		document.body.appendChild( view.element );
     *
     * @param {Iterable.<module:ui/view~View>} [views] Initial views of the collection.
     * @returns {module:ui/viewcollection~ViewCollection} A new collection of view instances.
     */
    value: function createCollection(views) {
      var collection = new viewcollection_ViewCollection(views);

      this._viewCollections.add(collection);

      return collection;
    }
    /**
     * Registers a new child view under the view instance. Once registered, a child
     * view is managed by its parent, including {@link #render rendering}
     * and {@link #destroy destruction}.
     *
     * To revert this, use {@link #deregisterChild}.
     *
     *		class SampleView extends View {
     *			constructor( locale ) {
     *				super( locale );
     *
     *				this.childA = new SomeChildView( locale );
     *				this.childB = new SomeChildView( locale );
     *
     *				this.setTemplate( { tag: 'p' } );
     *
     *				// Register the children.
     *				this.registerChild( [ this.childA, this.childB ] );
     *			}
     *
     *			render() {
     *				super.render();
     *
     *				this.element.appendChild( this.childA.element );
     *				this.element.appendChild( this.childB.element );
     *			}
     *		}
     *
     *		const view = new SampleView( locale );
     *
     *		view.render();
     *
     *		// Will append <p><childA#element><b></b><childB#element></p>.
     *		document.body.appendChild( view.element );
     *
     * **Note**: There's no need to add child views if they're already referenced in the
     * {@link #template}:
     *
     *		class SampleView extends View {
     *			constructor( locale ) {
     *				super( locale );
     *
     *				this.childA = new SomeChildView( locale );
     *				this.childB = new SomeChildView( locale );
     *
     *				this.setTemplate( {
     *					tag: 'p',
     *
    	 *					// These children will be added automatically. There's no
    	 *					// need to call {@link #registerChild} for any of them.
     *					children: [ this.childA, this.childB ]
     *				} );
     *			}
     *
     *			// ...
     *		}
     *
     * @param {module:ui/view~View|Iterable.<module:ui/view~View>} children Children views to be registered.
     */

  }, {
    key: "registerChild",
    value: function registerChild(children) {
      if (!isIterable(children)) {
        children = [children];
      }

      var _iterator = _createForOfIteratorHelper(children),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var child = _step.value;

          this._unboundChildren.add(child);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * The opposite of {@link #registerChild}. Removes a child view from this view instance.
     * Once removed, the child is no longer managed by its parent, e.g. it can safely
     * become a child of another parent view.
     *
     * @see #registerChild
     * @param {module:ui/view~View|Iterable.<module:ui/view~View>} children Child views to be removed.
     */

  }, {
    key: "deregisterChild",
    value: function deregisterChild(children) {
      if (!isIterable(children)) {
        children = [children];
      }

      var _iterator2 = _createForOfIteratorHelper(children),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var child = _step2.value;

          this._unboundChildren.remove(child);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    /**
     * Sets the {@link #template} of the view with with given definition.
     *
     * A shorthand for:
     *
     *		view.setTemplate( definition );
     *
     * @param {module:ui/template~TemplateDefinition} definition Definition of view's template.
     */

  }, {
    key: "setTemplate",
    value: function setTemplate(definition) {
      this.template = new template_Template(definition);
    }
    /**
     * {@link module:ui/template~Template.extend Extends} the {@link #template} of the view with
     * with given definition.
     *
     * A shorthand for:
     *
     *		Template.extend( view.template, definition );
     *
     * **Note**: Is requires the {@link #template} to be already set. See {@link #setTemplate}.
     *
     * @param {module:ui/template~TemplateDefinition} definition Definition which
     * extends the {@link #template}.
     */

  }, {
    key: "extendTemplate",
    value: function extendTemplate(definition) {
      template_Template.extend(this.template, definition);
    }
    /**
     * Recursively renders the view.
     *
     * Once the view is rendered:
     * * the {@link #element} becomes an HTML element out of {@link #template},
     * * the {@link #isRendered} flag is set `true`.
     *
     * **Note**: The children of the view:
     * * defined directly in the {@link #template}
     * * residing in collections created by the {@link #createCollection} method,
     * * and added by {@link #registerChild}
     * are also rendered in the process.
     *
     * In general, `render()` method is the right place to keep the code which refers to the
     * {@link #element} and should be executed at the very beginning of the view's life cycle.
     *
     * It is possible to {@link module:ui/template~Template.extend} the {@link #template} before
     * the view is rendered. To allow an early customization of the view (e.g. by its parent),
     * such references should be done in `render()`.
     *
     *		class SampleView extends View {
     *			constructor() {
     *				this.setTemplate( {
     *					// ...
     *				} );
     *			},
     *
     *			render() {
     *				// View#element becomes available.
     *				super.render();
     *
     *				// The "scroll" listener depends on #element.
     *				this.listenTo( window, 'scroll', () => {
     *					// A reference to #element would render the #template and make it non-extendable.
     *					if ( window.scrollY > 0 ) {
     *						this.element.scrollLeft = 100;
     *					} else {
     *						this.element.scrollLeft = 0;
     *					}
     *				} );
     *			}
     *		}
     *
     *		const view = new SampleView();
     *
     *		// Let's customize the view before it gets rendered.
     *		view.extendTemplate( {
     *			attributes: {
     *				class: [
     *					'additional-class'
     *				]
     *			}
     *		} );
     *
     *		// Late rendering allows customization of the view.
     *		view.render();
     */

  }, {
    key: "render",
    value: function render() {
      if (this.isRendered) {
        /**
         * This View has already been rendered.
         *
         * @error ui-view-render-rendered
         */
        throw new ckeditorerror["b" /* default */]('ui-view-render-already-rendered: This View has already been rendered.', this);
      } // Render #element of the view.


      if (this.template) {
        this.element = this.template.render(); // Auto–register view children from #template.

        this.registerChild(this.template.getViews());
      }

      this.isRendered = true;
    }
    /**
     * Recursively destroys the view instance and child views added by {@link #registerChild} and
     * residing in collections created by the {@link #createCollection}.
     *
     * Destruction disables all event listeners:
     * * created on the view, e.g. `view.on( 'event', () => {} )`,
     * * defined in the {@link #template} for DOM events.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.stopListening();

      this._viewCollections.map(function (c) {
        return c.destroy();
      }); // Template isn't obligatory for views.


      if (this.template && this.template._revertData) {
        this.template.revert(this.element);
      }
    }
    /**
     * Event fired by the {@link #render} method. Actual rendering is executed as a listener to
     * this event with the default priority.
     *
     * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.
     *
     * @event render
     */

  }, {
    key: "bindTemplate",
    get: function get() {
      if (this._bindTemplate) {
        return this._bindTemplate;
      }

      return this._bindTemplate = template_Template.bind(this, this);
    }
  }]);

  return View;
}();


mix(src_view_View, dom_emittermixin);
mix(src_view_View, observablemixin);
// CONCATENATED MODULE: ./node_modules/lodash-es/isString.js




/** `Object#toString` result references. */
var isString_stringTag = '[object String]';

/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */
function isString(value) {
  return typeof value == 'string' ||
    (!lodash_es_isArray(value) && lodash_es_isObjectLike(value) && _baseGetTag(value) == isString_stringTag);
}

/* harmony default export */ var lodash_es_isString = (isString);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/createelement.js


/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/dom/createelement
 */


/**
 * Creates element with attributes and children.
 *
 *		createElement( document, 'p' ); // <p>
 *		createElement( document, 'p', { class: 'foo' } ); // <p class="foo">
 *		createElement( document, 'p', null, 'foo' ); // <p>foo</p>
 *		createElement( document, 'p', null, [ 'foo', createElement( document, 'img' ) ] ); // <p>foo<img></p>
 *
 * @param {Document} doc Document used to create element.
 * @param {String} name Name of the element.
 * @param {Object} [attributes] Object keys will become attributes keys and object values will became attributes values.
 * @param {Node|String|Array.<Node|String>} [children] Child or array of children. Strings will be automatically turned
 * into Text nodes.
 * @returns {Element} Created element.
 */

function createelement_createElement(doc, name) {
  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var children = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
  var namespace = attributes && attributes.xmlns;
  var element = namespace ? doc.createElementNS(namespace, name) : doc.createElement(name);

  for (var key in attributes) {
    element.setAttribute(key, attributes[key]);
  }

  if (lodash_es_isString(children) || !isIterable(children)) {
    children = [children];
  }

  var _iterator = _createForOfIteratorHelper(children),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var child = _step.value;

      if (lodash_es_isString(child)) {
        child = doc.createTextNode(child);
      }

      element.appendChild(child);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return element;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/editorui/bodycollection.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/editorui/bodycollection
 */

/* globals document */



/**
 * This is a special {@link module:ui/viewcollection~ViewCollection} dedicated to elements that are detached
 * from the DOM structure of the editor, like panels, icons, etc.
 *
 * The body collection is available in the {@link module:ui/editorui/editoruiview~EditorUIView#body `editor.ui.view.body`} property.
 * Any plugin can add a {@link module:ui/view~View view} to this collection.
 * These views will render in a container placed directly in the `<body>` element.
 * The editor will detach and destroy this collection when the editor will be {@link module:core/editor/editor~Editor#destroy destroyed}.
 *
 * If you need to control the life cycle of the body collection on your own, you can create your own instance of this class.
 *
 * A body collection will render itself automatically in the DOM body element as soon as you call {@link ~BodyCollection#attachToDom}.
 * If you create multiple body collections, this class will create a special wrapper element in the DOM to limit the number of
 * elements created directly in the body and remove it when the last body collection will be
 * {@link ~BodyCollection#detachFromDom detached}.
 *
 * @extends module:ui/viewcollection~ViewCollection
 */

var bodycollection_BodyCollection = /*#__PURE__*/function (_ViewCollection) {
  Object(inherits["a" /* default */])(BodyCollection, _ViewCollection);

  var _super = Object(createSuper["a" /* default */])(BodyCollection);

  /**
   * Creates a new instance of the {@link module:ui/editorui/bodycollection~BodyCollection}.
   *
   * @param {module:utils/locale~Locale} locale The {@link module:core/editor/editor~Editor editor's locale} instance.
   * @param {Iterable.<module:ui/view~View>} [initialItems] The initial items of the collection.
   */
  function BodyCollection(locale) {
    var _this;

    var initialItems = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    Object(classCallCheck["a" /* default */])(this, BodyCollection);

    _this = _super.call(this, initialItems);
    /**
     * The {@link module:core/editor/editor~Editor#locale editor's locale} instance.
     * See the view {@link module:ui/view~View#locale locale} property.
     *
     * @member {module:utils/locale~Locale}
     */

    _this.locale = locale;
    return _this;
  }
  /**
   * Attaches the body collection to the DOM body element. You need to execute this method to render the content of
   * the body collection.
   */


  Object(createClass["a" /* default */])(BodyCollection, [{
    key: "attachToDom",
    value: function attachToDom() {
      /**
       * The element holding elements of the body region.
       *
       * @protected
       * @member {HTMLElement} #_bodyCollectionContainer
       */
      this._bodyCollectionContainer = new template_Template({
        tag: 'div',
        attributes: {
          class: ['ck', 'ck-reset_all', 'ck-body', 'ck-rounded-corners'],
          dir: this.locale.uiLanguageDirection
        },
        children: this
      }).render();
      var wrapper = document.querySelector('.ck-body-wrapper');

      if (!wrapper) {
        wrapper = createelement_createElement(document, 'div', {
          class: 'ck-body-wrapper'
        });
        document.body.appendChild(wrapper);
      }

      wrapper.appendChild(this._bodyCollectionContainer);
    }
    /**
     * Detaches the collection from the DOM structure. Use this method when you do not need to use the body collection
     * anymore to clean-up the DOM structure.
     */

  }, {
    key: "detachFromDom",
    value: function detachFromDom() {
      get_get(Object(getPrototypeOf["a" /* default */])(BodyCollection.prototype), "destroy", this).call(this);

      if (this._bodyCollectionContainer) {
        this._bodyCollectionContainer.remove();
      }

      var wrapper = document.querySelector('.ck-body-wrapper');

      if (wrapper && wrapper.childElementCount == 0) {
        wrapper.remove();
      }
    }
  }]);

  return BodyCollection;
}(viewcollection_ViewCollection);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/components/editorui/editorui.css
var editorui = __webpack_require__("cf28");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/editorui/editoruiview.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/editorui/editoruiview
 */



/**
 * The editor UI view class. Base class for the editor main views.
 *
 * @extends module:ui/view~View
 */

var editoruiview_EditorUIView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(EditorUIView, _View);

  var _super = Object(createSuper["a" /* default */])(EditorUIView);

  /**
   * Creates an instance of the editor UI view class.
   *
   * @param {module:utils/locale~Locale} [locale] The locale instance.
   */
  function EditorUIView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, EditorUIView);

    _this = _super.call(this, locale);
    /**
     * Collection of the child views, detached from the DOM
     * structure of the editor, like panels, icons etc.
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection} #body
     */

    _this.body = new bodycollection_BodyCollection(locale);
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(EditorUIView, [{
    key: "render",
    value: function render() {
      get_get(Object(getPrototypeOf["a" /* default */])(EditorUIView.prototype), "render", this).call(this);

      this.body.attachToDom();
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.body.detachFromDom();
      return get_get(Object(getPrototypeOf["a" /* default */])(EditorUIView.prototype), "destroy", this).call(this);
    }
  }]);

  return EditorUIView;
}(src_view_View);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/components/label/label.css
var label_label = __webpack_require__("e8dd");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/label/labelview.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/label/labelview
 */



/**
 * The label view class.
 *
 * @extends module:ui/view~View
 */

var labelview_LabelView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(LabelView, _View);

  var _super = Object(createSuper["a" /* default */])(LabelView);

  /**
   * @inheritDoc
   */
  function LabelView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, LabelView);

    _this = _super.call(this, locale);
    /**
     * The text of the label.
     *
     * @observable
     * @member {String} #text
     */

    _this.set('text');
    /**
     * The `for` attribute of the label (i.e. to pair with an `<input>` element).
     *
     * @observable
     * @member {String} #for
     */


    _this.set('for');
    /**
     * An unique id of the label. It can be used by other UI components to reference
     * the label, for instance, using the `aria-describedby` DOM attribute.
     *
     * @member {String} #id
     */


    _this.id = "ck-editor__label_".concat(uid_uid());
    var bind = _this.bindTemplate;

    _this.setTemplate({
      tag: 'label',
      attributes: {
        class: ['ck', 'ck-label'],
        id: _this.id,
        for: bind.to('for')
      },
      children: [{
        text: bind.to('text')
      }]
    });

    return _this;
  }

  return LabelView;
}(src_view_View);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/editorui/boxed/boxededitoruiview.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/editorui/boxed/boxededitoruiview
 */


/**
 * The boxed editor UI view class. This class represents an editor interface
 * consisting of a toolbar and an editable area, enclosed within a box.
 *
 * @extends module:ui/editorui/editoruiview~EditorUIView
 */

var boxededitoruiview_BoxedEditorUIView = /*#__PURE__*/function (_EditorUIView) {
  Object(inherits["a" /* default */])(BoxedEditorUIView, _EditorUIView);

  var _super = Object(createSuper["a" /* default */])(BoxedEditorUIView);

  /**
   * Creates an instance of the boxed editor UI view class.
   *
   * @param {module:utils/locale~Locale} locale The locale instance..
   */
  function BoxedEditorUIView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, BoxedEditorUIView);

    _this = _super.call(this, locale);
    /**
     * Collection of the child views located in the top (`.ck-editor__top`)
     * area of the UI.
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */

    _this.top = _this.createCollection();
    /**
     * Collection of the child views located in the main (`.ck-editor__main`)
     * area of the UI.
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */

    _this.main = _this.createCollection();
    /**
     * Voice label of the UI.
     *
     * @protected
     * @readonly
     * @member {module:ui/view~View} #_voiceLabelView
     */

    _this._voiceLabelView = _this._createVoiceLabel();

    _this.setTemplate({
      tag: 'div',
      attributes: {
        class: ['ck', 'ck-reset', 'ck-editor', 'ck-rounded-corners'],
        role: 'application',
        dir: locale.uiLanguageDirection,
        lang: locale.uiLanguage,
        'aria-labelledby': _this._voiceLabelView.id
      },
      children: [_this._voiceLabelView, {
        tag: 'div',
        attributes: {
          class: ['ck', 'ck-editor__top', 'ck-reset_all'],
          role: 'presentation'
        },
        children: _this.top
      }, {
        tag: 'div',
        attributes: {
          class: ['ck', 'ck-editor__main'],
          role: 'presentation'
        },
        children: _this.main
      }]
    });

    return _this;
  }
  /**
   * Creates a voice label view instance.
   *
   * @private
   * @returns {module:ui/label/labelview~LabelView}
   */


  Object(createClass["a" /* default */])(BoxedEditorUIView, [{
    key: "_createVoiceLabel",
    value: function _createVoiceLabel() {
      var t = this.t;
      var voiceLabel = new labelview_LabelView();
      voiceLabel.text = t('Rich Text Editor');
      voiceLabel.extendTemplate({
        attributes: {
          class: 'ck-voice-label'
        }
      });
      return voiceLabel;
    }
  }]);

  return BoxedEditorUIView;
}(editoruiview_EditorUIView);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/editableui/editableuiview.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/editableui/editableuiview
 */

/**
 * The editable UI view class.
 *
 * @extends module:ui/view~View
 */

var editableuiview_EditableUIView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(EditableUIView, _View);

  var _super = Object(createSuper["a" /* default */])(EditableUIView);

  /**
   * Creates an instance of EditableUIView class.
   *
   * @param {module:utils/locale~Locale} [locale] The locale instance.
   * @param {module:engine/view/view~View} editingView The editing view instance the editable is related to.
   * @param {HTMLElement} [editableElement] The editable element. If not specified, this view
   * should create it. Otherwise, the existing element should be used.
   */
  function EditableUIView(locale, editingView, editableElement) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, EditableUIView);

    _this = _super.call(this, locale);

    _this.setTemplate({
      tag: 'div',
      attributes: {
        class: ['ck', 'ck-content', 'ck-editor__editable', 'ck-rounded-corners'],
        lang: locale.contentLanguage,
        dir: locale.contentLanguageDirection
      }
    });
    /**
     * The name of the editable UI view.
     *
     * @member {String} #name
     */


    _this.name = null;
    /**
     * Controls whether the editable is focused, i.e. the user is typing in it.
     *
     * @observable
     * @member {Boolean} #isFocused
     */

    _this.set('isFocused', false);
    /**
     * The element which is the main editable element (usually the one with `contentEditable="true"`).
     *
     * @private
     * @member {HTMLElement} #_editableElement
     */


    _this._editableElement = editableElement;
    /**
     * Whether an external {@link #_editableElement} was passed into the constructor, which also means
     * the view will not render its {@link #template}.
     *
     * @private
     * @member {Boolean} #_hasExternalElement
     */

    _this._hasExternalElement = !!_this._editableElement;
    /**
     * The editing view instance the editable is related to. Editable uses the editing
     * view to dynamically modify its certain DOM attributes after {@link #render rendering}.
     *
     * **Note**: The DOM attributes are performed by the editing view and not UI
     * {@link module:ui/view~View#bindTemplate template bindings} because once rendered,
     * the editable DOM element must remain under the full control of the engine to work properly.
     *
     * @protected
     * @member {module:engine/view/view~View} #isFocused
     */

    _this._editingView = editingView;
    return _this;
  }
  /**
   * Renders the view by either applying the {@link #template} to the existing
   * {@link #_editableElement} or assigning {@link #element} as {@link #_editableElement}.
   */


  Object(createClass["a" /* default */])(EditableUIView, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      get_get(Object(getPrototypeOf["a" /* default */])(EditableUIView.prototype), "render", this).call(this);

      if (this._hasExternalElement) {
        this.template.apply(this.element = this._editableElement);
      } else {
        this._editableElement = this.element;
      }

      this.on('change:isFocused', function () {
        return _this2._updateIsFocusedClasses();
      });

      this._updateIsFocusedClasses();
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "destroy",
    value: function destroy() {
      if (this._hasExternalElement) {
        this.template.revert(this._editableElement);
      }

      get_get(Object(getPrototypeOf["a" /* default */])(EditableUIView.prototype), "destroy", this).call(this);
    }
    /**
     * Updates the `ck-focused` and `ck-blurred` CSS classes on the {@link #element} according to
     * the {@link #isFocused} property value using the {@link #_editingView editing view} API.
     *
     * @private
     */

  }, {
    key: "_updateIsFocusedClasses",
    value: function _updateIsFocusedClasses() {
      var editingView = this._editingView;

      if (editingView.isRenderingInProgress) {
        updateAfterRender(this);
      } else {
        update(this);
      }

      function update(view) {
        editingView.change(function (writer) {
          var viewRoot = editingView.document.getRoot(view.name);
          writer.addClass(view.isFocused ? 'ck-focused' : 'ck-blurred', viewRoot);
          writer.removeClass(view.isFocused ? 'ck-blurred' : 'ck-focused', viewRoot);
        });
      } // In a case of a multi-root editor, a callback will be attached more than once (one callback for each root).
      // While executing one callback the `isRenderingInProgress` observable is changing what causes executing another
      // callback and render is called inside the already pending render.
      // We need to be sure that callback is executed only when the value has changed from `true` to `false`.
      // See https://github.com/ckeditor/ckeditor5/issues/1676.


      function updateAfterRender(view) {
        editingView.once('change:isRenderingInProgress', function (evt, name, value) {
          if (!value) {
            update(view);
          } else {
            updateAfterRender(view);
          }
        });
      }
    }
  }]);

  return EditableUIView;
}(src_view_View);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/editableui/inline/inlineeditableuiview.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/editableui/inline/inlineeditableuiview
 */

/**
 * The inline editable UI class implementing an inline {@link module:ui/editableui/editableuiview~EditableUIView}.
 *
 * @extends module:ui/editableui/editableuiview~EditableUIView
 */

var inlineeditableuiview_InlineEditableUIView = /*#__PURE__*/function (_EditableUIView) {
  Object(inherits["a" /* default */])(InlineEditableUIView, _EditableUIView);

  var _super = Object(createSuper["a" /* default */])(InlineEditableUIView);

  /**
   * Creates an instance of the InlineEditableUIView class.
   *
   * @param {module:utils/locale~Locale} [locale] The locale instance.
   * @param {module:engine/view/view~View} editingView The editing view instance the editable is related to.
   * @param {HTMLElement} [editableElement] The editable element. If not specified, the
   * {@link module:ui/editableui/editableuiview~EditableUIView}
   * will create it. Otherwise, the existing element will be used.
   */
  function InlineEditableUIView(locale, editingView, editableElement) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, InlineEditableUIView);

    _this = _super.call(this, locale, editingView, editableElement);

    _this.extendTemplate({
      attributes: {
        role: 'textbox',
        class: 'ck-editor__editable_inline'
      }
    });

    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(InlineEditableUIView, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      get_get(Object(getPrototypeOf["a" /* default */])(InlineEditableUIView.prototype), "render", this).call(this);

      var editingView = this._editingView;
      var t = this.t;
      editingView.change(function (writer) {
        var viewRoot = editingView.document.getRoot(_this2.name);
        writer.setAttribute('aria-label', t('Rich Text Editor, %0', [_this2.name]), viewRoot);
      });
    }
  }]);

  return InlineEditableUIView;
}(editableuiview_EditableUIView);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/tounit.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/dom/tounit
 */

/**
 * Returns a helper function, which adds a desired trailing
 * `unit` to the passed value.
 *
 * @param {String} unit An unit like "px" or "em".
 * @returns {module:utils/dom/tounit~helper}
 */
function toUnit(unit) {
  /**
   * A function, which adds a pre–defined trailing `unit`
   * to the passed `value`.
   *
   * @function helper
  	 * @param {*} value A value to be given the unit.
  	 * @returns {String} A value with the trailing unit.
   */
  return function (value) {
    return value + unit;
  };
}
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/stickypanel.css
var stickypanel = __webpack_require__("da97");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/panel/sticky/stickypanelview.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/panel/sticky/stickypanelview
 */





var toPx = toUnit('px');
/**
 * The sticky panel view class.
 */

var stickypanelview_StickyPanelView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(StickyPanelView, _View);

  var _super = Object(createSuper["a" /* default */])(StickyPanelView);

  /**
   * @inheritDoc
   */
  function StickyPanelView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, StickyPanelView);

    _this = _super.call(this, locale);
    var bind = _this.bindTemplate;
    /**
     * Controls whether the sticky panel should be active.
     *
     * @readonly
     * @observable
     * @member {Boolean} #isActive
     */

    _this.set('isActive', false);
    /**
     * Controls whether the sticky panel is in the "sticky" state.
     *
     * @readonly
     * @observable
     * @member {Boolean} #isSticky
     */


    _this.set('isSticky', false);
    /**
     * The limiter element for the sticky panel instance. Its bounding rect limits
     * the "stickyness" of the panel, i.e. when the panel reaches the bottom
     * edge of the limiter, it becomes sticky to that edge and does not float
     * off the limiter. It is mandatory for the panel to work properly and once
     * set, it cannot be changed.
     *
     * @readonly
     * @observable
     * @member {HTMLElement} #limiterElement
     */


    _this.set('limiterElement', null);
    /**
     * The offset from the bottom edge of {@link #limiterElement}
     * which stops the panel from stickying any further to prevent limiter's content
     * from being completely covered.
     *
     * @readonly
     * @observable
     * @default 50
     * @member {Number} #limiterBottomOffset
     */


    _this.set('limiterBottomOffset', 50);
    /**
     * The offset from the top edge of the web browser's viewport which makes the
     * panel become sticky. The default value is `0`, which means the panel becomes
     * sticky when it's upper edge touches the top of the page viewport.
     *
     * This attribute is useful when the web page has UI elements positioned to the top
     * either using `position: fixed` or `position: sticky`, which would cover the
     * sticky panel or vice–versa (depending on the `z-index` hierarchy).
     *
     * @readonly
     * @observable
     * @default 0
     * @member {Number} #viewportTopOffset
     */


    _this.set('viewportTopOffset', 0);
    /**
     * Controls the `margin-left` CSS style of the panel.
     *
     * @protected
     * @readonly
     * @observable
     * @member {String} #_marginLeft
     */


    _this.set('_marginLeft', null);
    /**
     * Set `true` if the sticky panel reached the bottom edge of the
     * {@link #limiterElement}.
     *
     * @protected
     * @readonly
     * @observable
     * @member {Boolean} #_isStickyToTheLimiter
     */


    _this.set('_isStickyToTheLimiter', false);
    /**
     * Set `true` if the sticky panel uses the {@link #viewportTopOffset},
     * i.e. not {@link #_isStickyToTheLimiter} and the {@link #viewportTopOffset}
     * is not `0`.
     *
     * @protected
     * @readonly
     * @observable
     * @member {Boolean} #_hasViewportTopOffset
     */


    _this.set('_hasViewportTopOffset', false);
    /**
     * Collection of the child views which creates balloon panel contents.
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */


    _this.content = _this.createCollection();
    /**
     * The DOM bounding client rect of the {@link module:ui/view~View#element} of the panel.
     *
     * @protected
     * @member {Object} #_panelRect
     */

    /**
     * The DOM bounding client rect of the {@link #limiterElement}
     * of the panel.
     *
     * @protected
     * @member {Object} #_limiterRect
     */

    /**
     * A dummy element which visually fills the space as long as the
     * actual panel is sticky. It prevents flickering of the UI.
     *
     * @protected
     * @property {HTMLElement}
     */

    _this._contentPanelPlaceholder = new template_Template({
      tag: 'div',
      attributes: {
        class: ['ck', 'ck-sticky-panel__placeholder'],
        style: {
          display: bind.to('isSticky', function (isSticky) {
            return isSticky ? 'block' : 'none';
          }),
          height: bind.to('isSticky', function (isSticky) {
            return isSticky ? toPx(_this._panelRect.height) : null;
          })
        }
      }
    }).render();
    /**
     * The panel which accepts children into {@link #content} collection.
     * Also an element which is positioned when {@link #isSticky}.
     *
     * @protected
     * @property {HTMLElement}
     */

    _this._contentPanel = new template_Template({
      tag: 'div',
      attributes: {
        class: ['ck', 'ck-sticky-panel__content', // Toggle class of the panel when "sticky" state changes in the view.
        bind.if('isSticky', 'ck-sticky-panel__content_sticky'), bind.if('_isStickyToTheLimiter', 'ck-sticky-panel__content_sticky_bottom-limit')],
        style: {
          width: bind.to('isSticky', function (isSticky) {
            return isSticky ? toPx(_this._contentPanelPlaceholder.getBoundingClientRect().width) : null;
          }),
          top: bind.to('_hasViewportTopOffset', function (_hasViewportTopOffset) {
            return _hasViewportTopOffset ? toPx(_this.viewportTopOffset) : null;
          }),
          bottom: bind.to('_isStickyToTheLimiter', function (_isStickyToTheLimiter) {
            return _isStickyToTheLimiter ? toPx(_this.limiterBottomOffset) : null;
          }),
          marginLeft: bind.to('_marginLeft')
        }
      },
      children: _this.content
    }).render();

    _this.setTemplate({
      tag: 'div',
      attributes: {
        class: ['ck', 'ck-sticky-panel']
      },
      children: [_this._contentPanelPlaceholder, _this._contentPanel]
    });

    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(StickyPanelView, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      get_get(Object(getPrototypeOf["a" /* default */])(StickyPanelView.prototype), "render", this).call(this); // Check if the panel should go into the sticky state immediately.


      this._checkIfShouldBeSticky(); // Update sticky state of the panel as the window is being scrolled.


      this.listenTo(global.window, 'scroll', function () {
        _this2._checkIfShouldBeSticky();
      }); // Synchronize with `model.isActive` because sticking an inactive panel is pointless.

      this.listenTo(this, 'change:isActive', function () {
        _this2._checkIfShouldBeSticky();
      });
    }
    /**
     * Analyzes the environment to decide whether the panel should
     * be sticky or not.
     *
     * @protected
     */

  }, {
    key: "_checkIfShouldBeSticky",
    value: function _checkIfShouldBeSticky() {
      var panelRect = this._panelRect = this._contentPanel.getBoundingClientRect();

      var limiterRect;

      if (!this.limiterElement) {
        this.isSticky = false;
      } else {
        limiterRect = this._limiterRect = this.limiterElement.getBoundingClientRect(); // The panel must be active to become sticky.

        this.isSticky = this.isActive && // The limiter's top edge must be beyond the upper edge of the visible viewport (+the viewportTopOffset).
        limiterRect.top < this.viewportTopOffset && // The model#limiterElement's height mustn't be smaller than the panel's height and model#limiterBottomOffset.
        // There's no point in entering the sticky mode if the model#limiterElement is very, very small, because
        // it would immediately set model#_isStickyToTheLimiter true and, given model#limiterBottomOffset, the panel
        // would be positioned before the model#limiterElement.
        this._panelRect.height + this.limiterBottomOffset < limiterRect.height;
      } // Stick the panel to the top edge of the viewport simulating CSS position:sticky.
      // TODO: Possibly replaced by CSS in the future http://caniuse.com/#feat=css-sticky


      if (this.isSticky) {
        this._isStickyToTheLimiter = limiterRect.bottom < panelRect.height + this.limiterBottomOffset + this.viewportTopOffset;
        this._hasViewportTopOffset = !this._isStickyToTheLimiter && !!this.viewportTopOffset;
        this._marginLeft = this._isStickyToTheLimiter ? null : toPx(-global.window.scrollX);
      } // Detach the panel from the top edge of the viewport.
      else {
          this._isStickyToTheLimiter = false;
          this._hasViewportTopOffset = false;
          this._marginLeft = null;
        }
    }
  }]);

  return StickyPanelView;
}(src_view_View);


// EXTERNAL MODULE: ./node_modules/core-js/modules/es.number.parse-int.js
var es_number_parse_int = __webpack_require__("25eb");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/focuscycler.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/focuscycler
 */

/**
 * A utility class that helps cycling over focusable {@link module:ui/view~View views} in a
 * {@link module:ui/viewcollection~ViewCollection} when the focus is tracked by the
 * {@link module:utils/focustracker~FocusTracker} instance. It helps implementing keyboard
 * navigation in HTML forms, toolbars, lists and the like.
 *
 * To work properly it requires:
 * * a collection of focusable (HTML `tabindex` attribute) views that implement the `focus()` method,
 * * an associated focus tracker to determine which view is focused.
 *
 * A simple cycler setup can look like this:
 *
 *		const focusables = new ViewCollection();
 *		const focusTracker = new FocusTracker();
 *
 *		// Add focusable views to the focus tracker.
 *		focusTracker.add( ... );
 *
 * Then, the cycler can be used manually:
 *
 *		const cycler = new FocusCycler( { focusables, focusTracker } );
 *
 *		// Will focus the first focusable view in #focusables.
 *		cycler.focusFirst();
 *
 *		// Will log the next focusable item in #focusables.
 *		console.log( cycler.next );
 *
 * Alternatively, it can work side by side with the {@link module:utils/keystrokehandler~KeystrokeHandler}:
 *
 *		const keystrokeHandler = new KeystrokeHandler();
 *
 *		// Activate the keystroke handler.
 *		keystrokeHandler.listenTo( sourceOfEvents );
 *
 *		const cycler = new FocusCycler( {
 *			focusables, focusTracker, keystrokeHandler,
 *			actions: {
 *				// When arrowup of arrowleft is detected by the #keystrokeHandler,
 *				// focusPrevious() will be called on the cycler.
 *				focusPrevious: [ 'arrowup', 'arrowleft' ],
 *			}
 *		} );
 *
 * Check out the {@glink framework/guides/deep-dive/ui/focus-tracking "Deep dive into focus tracking" guide} to learn more.
 */

var focuscycler_FocusCycler = /*#__PURE__*/function () {
  /**
   * Creates an instance of the focus cycler utility.
   *
   * @param {Object} options Configuration options.
   * @param {module:utils/collection~Collection|Object} options.focusables
   * @param {module:utils/focustracker~FocusTracker} options.focusTracker
   * @param {module:utils/keystrokehandler~KeystrokeHandler} [options.keystrokeHandler]
   * @param {Object} [options.actions]
   */
  function FocusCycler(options) {
    var _this = this;

    Object(classCallCheck["a" /* default */])(this, FocusCycler);

    Object.assign(this, options);
    /**
     * A {@link module:ui/view~View view} collection that the cycler operates on.
     *
     * @readonly
     * @member {module:utils/collection~Collection} #focusables
     */

    /**
     * A focus tracker instance that the cycler uses to determine the current focus
     * state in {@link #focusables}.
     *
     * @readonly
     * @member {module:utils/focustracker~FocusTracker} #focusTracker
     */

    /**
     * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}
     * which can respond to certain keystrokes and cycle the focus.
     *
     * @readonly
     * @member {module:utils/keystrokehandler~KeystrokeHandler} #keystrokeHandler
     */

    /**
     * Actions that the cycler can take when a keystroke is pressed. Requires
     * `options.keystrokeHandler` to be passed and working. When an action is
     * performed, `preventDefault` and `stopPropagation` will be called on the event
     * the keystroke fired in the DOM.
     *
     *		actions: {
     *			// Will call #focusPrevious() when arrowleft or arrowup is pressed.
     *			focusPrevious: [ 'arrowleft', 'arrowup' ],
     *
     *			// Will call #focusNext() when arrowdown is pressed.
     *			focusNext: 'arrowdown'
     *		}
     *
     * @readonly
     * @member {Object} #actions
     */

    if (options.actions && options.keystrokeHandler) {
      var _loop = function _loop(methodName) {
        var actions = options.actions[methodName];

        if (typeof actions == 'string') {
          actions = [actions];
        }

        var _iterator = _createForOfIteratorHelper(actions),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var keystroke = _step.value;
            options.keystrokeHandler.set(keystroke, function (data, cancel) {
              _this[methodName]();

              cancel();
            });
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      };

      for (var methodName in options.actions) {
        _loop(methodName);
      }
    }
  }
  /**
   * Returns the first focusable view in {@link #focusables}.
   * Returns `null` if there is none.
   *
   * @readonly
   * @member {module:ui/view~View|null} #first
   */


  Object(createClass["a" /* default */])(FocusCycler, [{
    key: "focusFirst",

    /**
     * Focuses the {@link #first} item in {@link #focusables}.
     */
    value: function focusFirst() {
      this._focus(this.first);
    }
    /**
     * Focuses the {@link #last} item in {@link #focusables}.
     */

  }, {
    key: "focusLast",
    value: function focusLast() {
      this._focus(this.last);
    }
    /**
     * Focuses the {@link #next} item in {@link #focusables}.
     */

  }, {
    key: "focusNext",
    value: function focusNext() {
      this._focus(this.next);
    }
    /**
     * Focuses the {@link #previous} item in {@link #focusables}.
     */

  }, {
    key: "focusPrevious",
    value: function focusPrevious() {
      this._focus(this.previous);
    }
    /**
     * Focuses the given view if it exists.
     *
     * @protected
     * @param {module:ui/view~View} view
     */

  }, {
    key: "_focus",
    value: function _focus(view) {
      if (view) {
        view.focus();
      }
    }
    /**
     * Returns the next or previous focusable view in {@link #focusables} with respect
     * to {@link #current}.
     *
     * @protected
     * @param {Number} step Either `1` for checking forward from {@link #current} or
     * `-1` for checking backwards.
     * @returns {module:ui/view~View|null}
     */

  }, {
    key: "_getFocusableItem",
    value: function _getFocusableItem(step) {
      // Cache for speed.
      var current = this.current;
      var collectionLength = this.focusables.length;

      if (!collectionLength) {
        return null;
      } // Start from the beginning if no view is focused.
      // https://github.com/ckeditor/ckeditor5-ui/issues/206


      if (current === null) {
        return this[step === 1 ? 'first' : 'last'];
      } // Cycle in both directions.


      var index = (current + collectionLength + step) % collectionLength;

      do {
        var view = this.focusables.get(index); // TODO: Check if view is visible.

        if (isFocusable(view)) {
          return view;
        } // Cycle in both directions.


        index = (index + collectionLength + step) % collectionLength;
      } while (index !== current);

      return null;
    }
  }, {
    key: "first",
    get: function get() {
      return this.focusables.find(isFocusable) || null;
    }
    /**
     * Returns the last focusable view in {@link #focusables}.
     * Returns `null` if there is none.
     *
     * @readonly
     * @member {module:ui/view~View|null} #last
     */

  }, {
    key: "last",
    get: function get() {
      return this.focusables.filter(isFocusable).slice(-1)[0] || null;
    }
    /**
     * Returns the next focusable view in {@link #focusables} based on {@link #current}.
     * Returns `null` if there is none.
     *
     * @readonly
     * @member {module:ui/view~View|null} #next
     */

  }, {
    key: "next",
    get: function get() {
      return this._getFocusableItem(1);
    }
    /**
     * Returns the previous focusable view in {@link #focusables} based on {@link #current}.
     * Returns `null` if there is none.
     *
     * @readonly
     * @member {module:ui/view~View|null} #previous
     */

  }, {
    key: "previous",
    get: function get() {
      return this._getFocusableItem(-1);
    }
    /**
     * An index of the view in the {@link #focusables} which is focused according
     * to {@link #focusTracker}. Returns `null` when there is no such view.
     *
     * @readonly
     * @member {Number|null} #current
     */

  }, {
    key: "current",
    get: function get() {
      var _this2 = this;

      var index = null; // There's no focused view in the focusables.

      if (this.focusTracker.focusedElement === null) {
        return null;
      }

      this.focusables.find(function (view, viewIndex) {
        var focused = view.element === _this2.focusTracker.focusedElement;

        if (focused) {
          index = viewIndex;
        }

        return focused;
      });
      return index;
    }
  }]);

  return FocusCycler;
}(); // Checks whether a view is focusable.
//
// @private
// @param {module:ui/view~View} view A view to be checked.
// @returns {Boolean}




function isFocusable(view) {
  return !!(view.focus && global.window.getComputedStyle(view.element).display != 'none');
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/toolbar/toolbarseparatorview.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/toolbar/toolbarseparatorview
 */

/**
 * The toolbar separator view class.
 *
 * @extends module:ui/view~View
 */

var toolbarseparatorview_ToolbarSeparatorView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(ToolbarSeparatorView, _View);

  var _super = Object(createSuper["a" /* default */])(ToolbarSeparatorView);

  /**
   * @inheritDoc
   */
  function ToolbarSeparatorView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, ToolbarSeparatorView);

    _this = _super.call(this, locale);

    _this.setTemplate({
      tag: 'span',
      attributes: {
        class: ['ck', 'ck-toolbar__separator']
      }
    });

    return _this;
  }

  return ToolbarSeparatorView;
}(src_view_View);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/resizeobserver.js










/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/dom/resizeobserver
 */

/* globals setTimeout, clearTimeout */




var RESIZE_CHECK_INTERVAL = 100;
/**
 * A helper class which instances allow performing custom actions when native DOM elements are resized.
 *
 *		const editableElement = editor.editing.view.getDomRoot();
 *
 *		const observer = new ResizeObserver( editableElement, entry => {
 *			console.log( 'The editable element has been resized in DOM.' );
 *			console.log( entry.target ); // -> editableElement
 *			console.log( entry.contentRect.width ); // -> e.g. '423px'
 *		} );
 *
 * By default, it uses the [native DOM resize observer](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver)
 * under the hood and in browsers that do not support the native API yet, a polyfilled observer is
 * used instead.
 */

var resizeobserver_ResizeObserver = /*#__PURE__*/function () {
  /**
   * Creates an instance of the `ResizeObserver` class.
   *
   * @param {HTMLElement} element A DOM element that is to be observed for resizing. Note that
   * the element must be visible (i.e. not detached from DOM) for the observer to work.
   * @param {Function} callback A function called when the observed element was resized. It passes
   * the [`ResizeObserverEntry`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserverEntry)
   * object with information about the resize event.
   */
  function ResizeObserver(element, callback) {
    Object(classCallCheck["a" /* default */])(this, ResizeObserver);

    // **Note**: For the maximum performance, this class ensures only a single instance of the native
    // (or polyfilled) observer is used no matter how many instances of this class were created.
    if (!ResizeObserver._observerInstance) {
      ResizeObserver._createObserver();
    }
    /**
     * The element observer by this observer.
     *
     * @readonly
     * @private
     * @member {HTMLElement}
     */


    this._element = element;
    /**
     * The callback executed each time {@link #_element} is resized.
     *
     * @readonly
     * @private
     * @member {Function}
     */

    this._callback = callback;

    ResizeObserver._addElementCallback(element, callback);

    ResizeObserver._observerInstance.observe(element);
  }
  /**
   * Destroys the observer which disables the `callback` passed to the {@link #constructor}.
   */


  Object(createClass["a" /* default */])(ResizeObserver, [{
    key: "destroy",
    value: function destroy() {
      ResizeObserver._deleteElementCallback(this._element, this._callback);
    }
    /**
     * Registers a new resize callback for the DOM element.
     *
     * @private
     * @static
     * @param {HTMLElement} element
     * @param {Function} callback
     */

  }], [{
    key: "_addElementCallback",
    value: function _addElementCallback(element, callback) {
      if (!ResizeObserver._elementCallbacks) {
        ResizeObserver._elementCallbacks = new Map();
      }

      var callbacks = ResizeObserver._elementCallbacks.get(element);

      if (!callbacks) {
        callbacks = new Set();

        ResizeObserver._elementCallbacks.set(element, callbacks);
      }

      callbacks.add(callback);
    }
    /**
     * Removes a resize callback from the DOM element. If no callbacks are left
     * for the element, it removes the element from the native observer.
     *
     * @private
     * @static
     * @param {HTMLElement} element
     * @param {Function} callback
     */

  }, {
    key: "_deleteElementCallback",
    value: function _deleteElementCallback(element, callback) {
      var callbacks = ResizeObserver._getElementCallbacks(element); // Remove the element callback. Check if exist first in case someone
      // called destroy() twice.


      if (callbacks) {
        callbacks.delete(callback); // If no callbacks left for the element, also remove the element.

        if (!callbacks.size) {
          ResizeObserver._elementCallbacks.delete(element);

          ResizeObserver._observerInstance.unobserve(element);
        }
      }

      if (ResizeObserver._elementCallbacks && !ResizeObserver._elementCallbacks.size) {
        ResizeObserver._observerInstance = null;
        ResizeObserver._elementCallbacks = null;
      }
    }
    /**
     * Returns are registered resize callbacks for the DOM element.
     *
     * @private
     * @static
     * @param {HTMLElement} element
     * @returns {Set.<HTMLElement>|null}
     */

  }, {
    key: "_getElementCallbacks",
    value: function _getElementCallbacks(element) {
      if (!ResizeObserver._elementCallbacks) {
        return null;
      }

      return ResizeObserver._elementCallbacks.get(element);
    }
    /**
     * Creates the single native observer shared across all `ResizeObserver` instances.
     * If the browser does not support the native API, it creates a polyfill.
     *
     * @private
     * @static
     */

  }, {
    key: "_createObserver",
    value: function _createObserver() {
      var ObserverConstructor; // TODO: One day, the `ResizeObserver` API will be supported in all modern web browsers.
      // When it happens, this module will no longer make sense and should be removed and
      // the native implementation should be used across the project to save bytes.
      // Check out https://caniuse.com/#feat=resizeobserver.

      if (typeof global.window.ResizeObserver === 'function') {
        ObserverConstructor = global.window.ResizeObserver;
      } else {
        ObserverConstructor = resizeobserver_ResizeObserverPolyfill;
      }

      ResizeObserver._observerInstance = new ObserverConstructor(function (entries) {
        var _iterator = _createForOfIteratorHelper(entries),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var entry = _step.value;

            // Do not execute callbacks for elements that are invisible.
            // https://github.com/ckeditor/ckeditor5/issues/6570
            if (!entry.target.offsetParent) {
              continue;
            }

            var callbacks = ResizeObserver._getElementCallbacks(entry.target);

            if (callbacks) {
              var _iterator2 = _createForOfIteratorHelper(callbacks),
                  _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var callback = _step2.value;
                  callback(entry);
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
    }
  }]);

  return ResizeObserver;
}();
/**
 * The single native observer instance (or polyfill in browsers that do not support the API)
 * shared across all {@link module:utils/dom/resizeobserver~ResizeObserver} instances.
 *
 * @static
 * @protected
 * @readonly
 * @property {Object|null} module:utils/dom/resizeobserver~ResizeObserver#_observerInstance
 */



resizeobserver_ResizeObserver._observerInstance = null;
/**
 * A mapping of native DOM elements and their callbacks shared across all
 * {@link module:utils/dom/resizeobserver~ResizeObserver} instances.
 *
 * @static
 * @private
 * @readonly
 * @property {Map.<HTMLElement,Set>|null} module:utils/dom/resizeobserver~ResizeObserver#_elementCallbacks
 */

resizeobserver_ResizeObserver._elementCallbacks = null;
/**
 * A polyfill class for the native [`ResizeObserver`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver).
 *
 * @private
 * @mixes module:utils/domemittermixin~DomEmitterMixin
 */

var resizeobserver_ResizeObserverPolyfill = /*#__PURE__*/function () {
  /**
   * Creates an instance of the {@link module:utils/dom/resizeobserver~ResizeObserverPolyfill} class.
   *
   * It synchronously reacts to resize of the window to check if observed elements' geometry changed.
   *
   * Additionally, the polyfilled observer uses a timeout to check if observed elements' geometry has changed
   * in some other way (dynamic layouts, scrollbars showing up, etc.), so its response can also be asynchronous.
   *
   * @param {Function} callback A function called when any observed element was resized. Refer to the
   * native [`ResizeObserver`](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver) API to
   * learn more.
   */
  function ResizeObserverPolyfill(callback) {
    Object(classCallCheck["a" /* default */])(this, ResizeObserverPolyfill);

    /**
     * A function called when any observed {@link #_elements element} was resized.
     *
     * @readonly
     * @protected
     * @member {Function}
     */
    this._callback = callback;
    /**
     * DOM elements currently observed by the observer instance.
     *
     * @readonly
     * @protected
     * @member {Set}
     */

    this._elements = new Set();
    /**
     * Cached DOM {@link #_elements elements} bounding rects to compare to upon the next check.
     *
     * @readonly
     * @protected
     * @member {Map.<HTMLElement,module:utils/dom/rect~Rect>}
     */

    this._previousRects = new Map();
    /**
     * An UID of the current timeout upon which the observed elements rects
     * will be compared to the {@link #_previousRects previous rects} from the past.
     *
     * @readonly
     * @protected
     * @member {Map.<HTMLElement,module:utils/dom/rect~Rect>}
     */

    this._periodicCheckTimeout = null;
  }
  /**
   * Starts observing a DOM element.
   *
   * Learn more in the
   * [native method documentation](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/observe).
   *
   * @param {HTMLElement} element
   */


  Object(createClass["a" /* default */])(ResizeObserverPolyfill, [{
    key: "observe",
    value: function observe(element) {
      this._elements.add(element);

      this._checkElementRectsAndExecuteCallback();

      if (this._elements.size === 1) {
        this._startPeriodicCheck();
      }
    }
    /**
     * Stops observing a DOM element.
     *
     * Learn more in the
     * [native method documentation](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver/unobserve).
     *
     * @param {HTMLElement} element
     */

  }, {
    key: "unobserve",
    value: function unobserve(element) {
      this._elements.delete(element);

      this._previousRects.delete(element);

      if (!this._elements.size) {
        this._stopPeriodicCheck();
      }
    }
    /**
     * When called, the observer calls the {@link #_callback resize callback} for all observed
     * {@link #_elements elements} but also starts checking periodically for changes in the elements' geometry.
     * If some are detected, {@link #_callback resize callback} is called for relevant elements that were resized.
     *
     * @protected
     */

  }, {
    key: "_startPeriodicCheck",
    value: function _startPeriodicCheck() {
      var _this = this;

      var periodicCheck = function periodicCheck() {
        _this._checkElementRectsAndExecuteCallback();

        _this._periodicCheckTimeout = setTimeout(periodicCheck, RESIZE_CHECK_INTERVAL);
      };

      this.listenTo(global.window, 'resize', function () {
        _this._checkElementRectsAndExecuteCallback();
      });
      this._periodicCheckTimeout = setTimeout(periodicCheck, RESIZE_CHECK_INTERVAL);
    }
    /**
     * Stops checking for changes in all observed {@link #_elements elements} geometry.
     *
     * @protected
     */

  }, {
    key: "_stopPeriodicCheck",
    value: function _stopPeriodicCheck() {
      clearTimeout(this._periodicCheckTimeout);
      this.stopListening();

      this._previousRects.clear();
    }
    /**
     * Checks if the geometry of any of the {@link #_elements element} has changed. If so, executes
     * the {@link #_callback resize callback} with element geometry data.
     *
     * @protected
     */

  }, {
    key: "_checkElementRectsAndExecuteCallback",
    value: function _checkElementRectsAndExecuteCallback() {
      var entries = [];

      var _iterator3 = _createForOfIteratorHelper(this._elements),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var element = _step3.value;

          if (this._hasRectChanged(element)) {
            entries.push({
              target: element,
              contentRect: this._previousRects.get(element)
            });
          }
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      if (entries.length) {
        this._callback(entries);
      }
    }
    /**
     * Compares the DOM element geometry to the {@link #_previousRects cached geometry} from the past.
     * Returns `true` if geometry has changed or the element is checked for the first time.
     *
     * @protected
     * @param {HTMLElement} element
     * @returns {Boolean}
     */

  }, {
    key: "_hasRectChanged",
    value: function _hasRectChanged(element) {
      if (!element.ownerDocument.body.contains(element)) {
        return false;
      }

      var currentRect = new rect_Rect(element);

      var previousRect = this._previousRects.get(element); // The first check should always yield true despite no Previous rect to compare to.
      // The native ResizeObserver does that and... that makes sense. Sort of.


      var hasChanged = !previousRect || !previousRect.isEqual(currentRect);

      this._previousRects.set(element, currentRect);

      return hasChanged;
    }
  }]);

  return ResizeObserverPolyfill;
}();

mix(resizeobserver_ResizeObserverPolyfill, dom_emittermixin);
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/bindings/preventdefault.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/bindings/preventdefault
 */

/**
 * A helper which executes a native `Event.preventDefault()` if the target of an event equals the
 * {@link module:ui/view~View#element element of the view}. It shortens the definition of a
 * {@link module:ui/view~View#template template}.
 *
 *		// In a class extending View.
 *		import preventDefault from '@ckeditor/ckeditor5-ui/src/bindings/preventdefault';
 *
 *		// ...
 *
 *		this.setTemplate( {
 *			tag: 'div',
 *
 *			on: {
 *				// Prevent the default mousedown action on this view.
 *				mousedown: preventDefault( this )
 *			}
 *		} );
 *
 * @param {module:ui/view~View} view View instance that defines the template.
 * @returns {module:ui/template~TemplateToBinding}
 */
function preventDefault(view) {
  return view.bindTemplate.to(function (evt) {
    if (evt.target === view.element) {
      evt.preventDefault();
    }
  });
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/dropdown/dropdownpanelview.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/dropdown/dropdownpanelview
 */

/**
 * The dropdown panel view class.
 *
 * See {@link module:ui/dropdown/dropdownview~DropdownView} to learn about the common usage.
 *
 * @extends module:ui/view~View
 */

var dropdownpanelview_DropdownPanelView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(DropdownPanelView, _View);

  var _super = Object(createSuper["a" /* default */])(DropdownPanelView);

  /**
   * @inheritDoc
   */
  function DropdownPanelView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, DropdownPanelView);

    _this = _super.call(this, locale);
    var bind = _this.bindTemplate;
    /**
     * Controls whether the panel is visible.
     *
     * @observable
     * @member {Boolean} #isVisible
     */

    _this.set('isVisible', false);
    /**
     * The position of the panel, relative to the parent.
     *
     * This property is reflected in the CSS class set to {@link #element} that controls
     * the position of the panel.
     *
     * @observable
     * @default 'se'
     * @member {'se'|'sw'|'ne'|'nw'} #position
     */


    _this.set('position', 'se');
    /**
     * Collection of the child views in this panel.
     *
     * A common child type is the {@link module:ui/list/listview~ListView} and {@link module:ui/toolbar/toolbarview~ToolbarView}.
     * See {@link module:ui/dropdown/utils~addListToDropdown} and
     * {@link module:ui/dropdown/utils~addToolbarToDropdown} to learn more about child views of dropdowns.
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */


    _this.children = _this.createCollection();

    _this.setTemplate({
      tag: 'div',
      attributes: {
        class: ['ck', 'ck-reset', 'ck-dropdown__panel', bind.to('position', function (value) {
          return "ck-dropdown__panel_".concat(value);
        }), bind.if('isVisible', 'ck-dropdown__panel-visible')]
      },
      children: _this.children,
      on: {
        // Drag and drop in the panel should not break the selection in the editor.
        // https://github.com/ckeditor/ckeditor5-ui/issues/228
        selectstart: bind.to(function (evt) {
          return evt.preventDefault();
        })
      }
    });

    return _this;
  }
  /**
   * Focuses the view element or first item in view collection on opening dropdown's panel.
   *
   * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.
   */


  Object(createClass["a" /* default */])(DropdownPanelView, [{
    key: "focus",
    value: function focus() {
      if (this.children.length) {
        this.children.first.focus();
      }
    }
    /**
     * Focuses the view element or last item in view collection on opening dropdown's panel.
     *
     * See also {@link module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable}.
     */

  }, {
    key: "focusLast",
    value: function focusLast() {
      if (this.children.length) {
        var lastChild = this.children.last;

        if (typeof lastChild.focusLast === 'function') {
          lastChild.focusLast();
        } else {
          lastChild.focus();
        }
      }
    }
  }]);

  return DropdownPanelView;
}(src_view_View);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/dropdown.css
var dropdown_dropdown = __webpack_require__("0a06");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/getpositionedancestor.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/dom/getpositionedancestor
 */

/**
 * For a given element, returns the nearest ancestor element which CSS position is not "static".
 *
 * @param {HTMLElement} element The native DOM element to be checked.
 * @returns {HTMLElement|null}
 */

function getPositionedAncestor(element) {
  if (!element || !element.parentNode) {
    return null;
  }

  if (element.offsetParent === global.document.body) {
    return null;
  }

  return element.offsetParent;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/position.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/dom/position
 */





/**
 * Calculates the `position: absolute` coordinates of a given element so it can be positioned with respect to the
 * target in the visually most efficient way, taking various restrictions like viewport or limiter geometry
 * into consideration.
 *
 *		// The element which is to be positioned.
 *		const element = document.body.querySelector( '#toolbar' );
 *
 *		// A target to which the element is positioned relatively.
 *		const target = document.body.querySelector( '#container' );
 *
 *		// Finding the optimal coordinates for the positioning.
 *		const { left, top, name } = getOptimalPosition( {
 *			element: element,
 *			target: target,
 *
 * 			// The algorithm will chose among these positions to meet the requirements such
 * 			// as "limiter" element or "fitInViewport", set below. The positions are considered
 * 			// in the order of the array.
 *			positions: [
 *				//
 *			 	//	[ Target ]
 *				//	+-----------------+
 *				//	|     Element     |
 *				//	+-----------------+
 *				//
 *				targetRect => ( {
 *					top: targetRect.bottom,
 *					left: targetRect.left,
 *					name: 'mySouthEastPosition'
 *				} ),
 *
 *				//
 *				//	+-----------------+
 *				//	|     Element     |
 *				//	+-----------------+
 *				//	[ Target ]
 *				//
 *				( targetRect, elementRect ) => ( {
 *					top: targetRect.top - elementRect.height,
 *					left: targetRect.left,
 *					name: 'myNorthEastPosition'
 *				} )
 *			],
 *
 *			// Find a position such guarantees the element remains within visible boundaries of <body>.
 *			limiter: document.body,
 *
 *			// Find a position such guarantees the element remains within visible boundaries of the browser viewport.
 *			fitInViewport: true
 *		} );
 *
 *		// The best position which fits into document.body and the viewport. May be useful
 *		// to set proper class on the `element`.
 *		console.log( name ); // -> "myNorthEastPosition"
 *
 *		// Using the absolute coordinates which has been found to position the element
 *		// as in the diagram depicting the "myNorthEastPosition" position.
 *		element.style.top = top;
 *		element.style.left = left;
 *
 * @param {module:utils/dom/position~Options} options Positioning options object.
 * @returns {module:utils/dom/position~Position}
 */

function getOptimalPosition(_ref) {
  var element = _ref.element,
      target = _ref.target,
      positions = _ref.positions,
      limiter = _ref.limiter,
      fitInViewport = _ref.fitInViewport;

  // If the {@link module:utils/dom/position~Options#target} is a function, use what it returns.
  // https://github.com/ckeditor/ckeditor5-utils/issues/157
  if (lodash_es_isFunction(target)) {
    target = target();
  } // If the {@link module:utils/dom/position~Options#limiter} is a function, use what it returns.
  // https://github.com/ckeditor/ckeditor5-ui/issues/260


  if (lodash_es_isFunction(limiter)) {
    limiter = limiter();
  }

  var positionedElementAncestor = getPositionedAncestor(element);
  var elementRect = new rect_Rect(element);
  var targetRect = new rect_Rect(target);
  var bestPositionRect;
  var bestPositionName; // If there are no limits, just grab the very first position and be done with that drama.

  if (!limiter && !fitInViewport) {
    var _getPositionNameAndRe = getPositionNameAndRect(positions[0], targetRect, elementRect);

    var _getPositionNameAndRe2 = _slicedToArray(_getPositionNameAndRe, 2);

    bestPositionName = _getPositionNameAndRe2[0];
    bestPositionRect = _getPositionNameAndRe2[1];
  } else {
    var limiterRect = limiter && new rect_Rect(limiter).getVisible();
    var viewportRect = fitInViewport && new rect_Rect(global.window);
    var bestPosition = getBestPositionNameAndRect(positions, {
      targetRect: targetRect,
      elementRect: elementRect,
      limiterRect: limiterRect,
      viewportRect: viewportRect
    }); // If there's no best position found, i.e. when all intersections have no area because
    // rects have no width or height, then just use the first available position.

    var _ref2 = bestPosition || getPositionNameAndRect(positions[0], targetRect, elementRect);

    var _ref3 = _slicedToArray(_ref2, 2);

    bestPositionName = _ref3[0];
    bestPositionRect = _ref3[1];
  }

  var absoluteRectCoordinates = getAbsoluteRectCoordinates(bestPositionRect);

  if (positionedElementAncestor) {
    absoluteRectCoordinates = shiftRectCoordinatesDueToPositionedAncestor(absoluteRectCoordinates, positionedElementAncestor);
  }

  return {
    left: absoluteRectCoordinates.left,
    top: absoluteRectCoordinates.top,
    name: bestPositionName
  };
} // For given position function, returns a corresponding `Rect` instance.
//
// @private
// @param {Function} position A function returning {@link module:utils/dom/position~Position}.
// @param {utils/dom/rect~Rect} targetRect A rect of the target.
// @param {utils/dom/rect~Rect} elementRect A rect of positioned element.
// @returns {Array|null} An array containing position name and its Rect (or null if position should be ignored).

function getPositionNameAndRect(position, targetRect, elementRect) {
  var positionData = position(targetRect, elementRect);

  if (!positionData) {
    return null;
  }

  var left = positionData.left,
      top = positionData.top,
      name = positionData.name;
  return [name, elementRect.clone().moveTo(left, top)];
} // For a given array of positioning functions, returns such that provides the best
// fit of the `elementRect` into the `limiterRect` and `viewportRect`.
//
// @private
//
// @param {Object} options
// @param {module:utils/dom/position~Options#positions} positions Functions returning {@link module:utils/dom/position~Position}
// to be checked, in the order of preference.
// @param {Object} options
// @param {utils/dom/rect~Rect} options.targetRect A rect of the {@link module:utils/dom/position~Options#target}.
// @param {utils/dom/rect~Rect} options.elementRect A rect of positioned {@link module:utils/dom/position~Options#element}.
// @param {utils/dom/rect~Rect} options.limiterRect A rect of the {@link module:utils/dom/position~Options#limiter}.
// @param {utils/dom/rect~Rect} options.viewportRect A rect of the viewport.
//
// @returns {Array} An array containing the name of the position and it's rect.


function getBestPositionNameAndRect(positions, options) {
  var elementRect = options.elementRect,
      viewportRect = options.viewportRect; // This is when element is fully visible.

  var elementRectArea = elementRect.getArea(); // Let's calculate intersection areas for positions. It will end early if best match is found.

  var processedPositions = processPositionsToAreas(positions, options); // First let's check all positions that fully fit in the viewport.

  if (viewportRect) {
    var processedPositionsInViewport = processedPositions.filter(function (_ref4) {
      var viewportIntersectArea = _ref4.viewportIntersectArea;
      return viewportIntersectArea === elementRectArea;
    }); // Try to find best position from those which fit completely in viewport.

    var bestPositionData = getBestOfProcessedPositions(processedPositionsInViewport, elementRectArea);

    if (bestPositionData) {
      return bestPositionData;
    }
  } // Either there is no viewportRect or there is no position that fits completely in the viewport.


  return getBestOfProcessedPositions(processedPositions, elementRectArea);
} // For a given array of positioning functions, calculates intersection areas for them.
//
// Note: If some position fully fits into the `limiterRect`, it will be returned early, without further consideration
// of other positions.
//
// @private
//
// @param {module:utils/dom/position~Options#positions} positions Functions returning {@link module:utils/dom/position~Position}
// to be checked, in the order of preference.
// @param {Object} options
// @param {utils/dom/rect~Rect} options.targetRect A rect of the {@link module:utils/dom/position~Options#target}.
// @param {utils/dom/rect~Rect} options.elementRect A rect of positioned {@link module:utils/dom/position~Options#element}.
// @param {utils/dom/rect~Rect} options.limiterRect A rect of the {@link module:utils/dom/position~Options#limiter}.
// @param {utils/dom/rect~Rect} options.viewportRect A rect of the viewport.
//
// @returns {Array.<Object>} Array of positions with calculated intersection areas. Each item is an object containing:
// * {String} positionName Name of position.
// * {utils/dom/rect~Rect} positionRect Rect of position.
// * {Number} limiterIntersectArea Area of intersection of the position with limiter part that is in the viewport.
// * {Number} viewportIntersectArea Area of intersection of the position with viewport.


function processPositionsToAreas(positions, _ref5) {
  var targetRect = _ref5.targetRect,
      elementRect = _ref5.elementRect,
      limiterRect = _ref5.limiterRect,
      viewportRect = _ref5.viewportRect;
  var processedPositions = []; // This is when element is fully visible.

  var elementRectArea = elementRect.getArea();

  var _iterator = _createForOfIteratorHelper(positions),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var position = _step.value;
      var positionData = getPositionNameAndRect(position, targetRect, elementRect);

      if (!positionData) {
        continue;
      }

      var _positionData = _slicedToArray(positionData, 2),
          positionName = _positionData[0],
          positionRect = _positionData[1];

      var limiterIntersectArea = 0;
      var viewportIntersectArea = 0;

      if (limiterRect) {
        if (viewportRect) {
          // Consider only the part of the limiter which is visible in the viewport. So the limiter is getting limited.
          var limiterViewportIntersectRect = limiterRect.getIntersection(viewportRect);

          if (limiterViewportIntersectRect) {
            // If the limiter is within the viewport, then check the intersection between that part of the
            // limiter and actual position.
            limiterIntersectArea = limiterViewportIntersectRect.getIntersectionArea(positionRect);
          }
        } else {
          limiterIntersectArea = limiterRect.getIntersectionArea(positionRect);
        }
      }

      if (viewportRect) {
        viewportIntersectArea = viewportRect.getIntersectionArea(positionRect);
      }

      var processedPosition = {
        positionName: positionName,
        positionRect: positionRect,
        limiterIntersectArea: limiterIntersectArea,
        viewportIntersectArea: viewportIntersectArea
      }; // If a such position is found that element is fully contained by the limiter then, obviously,
      // there will be no better one, so finishing.

      if (limiterIntersectArea === elementRectArea) {
        return [processedPosition];
      }

      processedPositions.push(processedPosition);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return processedPositions;
} // For a given array of processed position data (with calculated Rects for positions and intersection areas)
// returns such that provides the best fit of the `elementRect` into the `limiterRect` and `viewportRect` at the same time.
//
// **Note**: It will return early if some position fully fits into the `limiterRect`.
//
// @private
// @param {Array.<Object>} Array of positions with calculated intersection areas (in order of preference).
// Each item is an object containing:
//
//	* {String} positionName Name of position.
//	* {utils/dom/rect~Rect} positionRect Rect of position.
//	* {Number} limiterIntersectArea Area of intersection of the position with limiter part that is in the viewport.
//	* {Number} viewportIntersectArea Area of intersection of the position with viewport.
//
// @param {Number} elementRectArea Area of positioned {@link module:utils/dom/position~Options#element}.
// @returns {Array|null} An array containing the name of the position and it's rect, or null if not found.


function getBestOfProcessedPositions(processedPositions, elementRectArea) {
  var maxFitFactor = 0;
  var bestPositionRect;
  var bestPositionName;

  var _iterator2 = _createForOfIteratorHelper(processedPositions),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var _step2$value = _step2.value,
          positionName = _step2$value.positionName,
          positionRect = _step2$value.positionRect,
          limiterIntersectArea = _step2$value.limiterIntersectArea,
          viewportIntersectArea = _step2$value.viewportIntersectArea;

      // If a such position is found that element is fully container by the limiter then, obviously,
      // there will be no better one, so finishing.
      if (limiterIntersectArea === elementRectArea) {
        return [positionName, positionRect];
      } // To maximize both viewport and limiter intersection areas we use distance on viewportIntersectArea
      // and limiterIntersectArea plane (without sqrt because we are looking for max value).


      var fitFactor = Math.pow(viewportIntersectArea, 2) + Math.pow(limiterIntersectArea, 2);

      if (fitFactor > maxFitFactor) {
        maxFitFactor = fitFactor;
        bestPositionRect = positionRect;
        bestPositionName = positionName;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return bestPositionRect ? [bestPositionName, bestPositionRect] : null;
} // For a given absolute Rect coordinates object and a positioned element ancestor, it returns an object with
// new Rect coordinates that make up for the position and the scroll of the ancestor.
//
// This is necessary because while Rects (and DOMRects) are relative to the browser's viewport, their coordinates
// are used in real–life to position elements with `position: absolute`, which are scoped by any positioned
// (and scrollable) ancestors.
//
// @private
//
// @param {Object} absoluteRectCoordinates An object with absolute rect coordinates.
// @param {Object} absoluteRectCoordinates.top
// @param {Object} absoluteRectCoordinates.left
// @param {HTMLElement} positionedElementAncestor An ancestor element that should be considered.
//
// @returns {Object} An object corresponding to `absoluteRectCoordinates` input but with values shifted
// to make up for the positioned element ancestor.


function shiftRectCoordinatesDueToPositionedAncestor(_ref6, positionedElementAncestor) {
  var left = _ref6.left,
      top = _ref6.top;
  var ancestorPosition = getAbsoluteRectCoordinates(new rect_Rect(positionedElementAncestor));
  var ancestorBorderWidths = getBorderWidths(positionedElementAncestor); // (https://github.com/ckeditor/ckeditor5-ui-default/issues/126)
  // If there's some positioned ancestor of the panel, then its `Rect` must be taken into
  // consideration. `Rect` is always relative to the viewport while `position: absolute` works
  // with respect to that positioned ancestor.

  left -= ancestorPosition.left;
  top -= ancestorPosition.top; // (https://github.com/ckeditor/ckeditor5-utils/issues/139)
  // If there's some positioned ancestor of the panel, not only its position must be taken into
  // consideration (see above) but also its internal scrolls. Scroll have an impact here because `Rect`
  // is relative to the viewport (it doesn't care about scrolling), while `position: absolute`
  // must compensate that scrolling.

  left += positionedElementAncestor.scrollLeft;
  top += positionedElementAncestor.scrollTop; // (https://github.com/ckeditor/ckeditor5-utils/issues/139)
  // If there's some positioned ancestor of the panel, then its `Rect` includes its CSS `borderWidth`
  // while `position: absolute` positioning does not consider it.
  // E.g. `{ position: absolute, top: 0, left: 0 }` means upper left corner of the element,
  // not upper-left corner of its border.

  left -= ancestorBorderWidths.left;
  top -= ancestorBorderWidths.top;
  return {
    left: left,
    top: top
  };
} // DOMRect (also Rect) works in a scroll–independent geometry but `position: absolute` doesn't.
// This function converts Rect to `position: absolute` coordinates.
//
// @private
// @param {utils/dom/rect~Rect} rect A rect to be converted.
// @returns {Object} Object containing `left` and `top` properties, in absolute coordinates.


function getAbsoluteRectCoordinates(_ref7) {
  var left = _ref7.left,
      top = _ref7.top;
  var _global$window = global.window,
      scrollX = _global$window.scrollX,
      scrollY = _global$window.scrollY;
  return {
    left: left + scrollX,
    top: top + scrollY
  };
}
/**
 * The `getOptimalPosition()` helper options.
 *
 * @interface module:utils/dom/position~Options
 */

/**
 * Element that is to be positioned.
 *
 * @member {HTMLElement} #element
 */

/**
 * Target with respect to which the `element` is to be positioned.
 *
 * @member {HTMLElement|Range|ClientRect|Rect|Function} #target
 */

/**
 * An array of functions which return {@link module:utils/dom/position~Position} relative
 * to the `target`, in the order of preference.
 *
 * **Note**: If a function returns `null`, it is ignored by the `getOptimalPosition()`.
 *
 * @member {Array.<Function>} #positions
 */

/**
 * When set, the algorithm will chose position which fits the most in the
 * limiter's bounding rect.
 *
 * @member {HTMLElement|Range|ClientRect|Rect|Function} #limiter
 */

/**
 * When set, the algorithm will chose such a position which fits `element`
 * the most inside visible viewport.
 *
 * @member {Boolean} #fitInViewport
 */

/**
 * An object describing a position in `position: absolute` coordinate
 * system, along with position name.
 *
 * @typedef {Object} module:utils/dom/position~Position
 *
 * @property {Number} top Top position offset.
 * @property {Number} left Left position offset.
 * @property {String} name Name of the position.
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/dropdown/dropdownview.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/dropdown/dropdownview
 */




/**
 * The dropdown view class. It manages the dropdown button and dropdown panel.
 *
 * In most cases, the easiest way to create a dropdown is by using the {@link module:ui/dropdown/utils~createDropdown}
 * util:
 *
 *		const dropdown = createDropdown( locale );
 *
 *		// Configure dropdown's button properties:
 *		dropdown.buttonView.set( {
 *			label: 'A dropdown',
 *			withText: true
 *		} );
 *
 *		dropdown.render();
 *
 *		dropdown.panelView.element.textContent = 'Content of the panel';
 *
 *		// Will render a dropdown with a panel containing a "Content of the panel" text.
 *		document.body.appendChild( dropdown.element );
 *
 * If you want to add a richer content to the dropdown panel, you can use the {@link module:ui/dropdown/utils~addListToDropdown}
 * and {@link module:ui/dropdown/utils~addToolbarToDropdown} helpers. See more examples in
 * {@link module:ui/dropdown/utils~createDropdown} documentation.
 *
 * If you want to create a completely custom dropdown, then you can compose it manually:
 *
 *		const button = new DropdownButtonView( locale );
 *		const panel = new DropdownPanelView( locale );
 *		const dropdown = new DropdownView( locale, button, panel );
 *
 *		button.set( {
 *			label: 'A dropdown',
 *			withText: true
 *		} );
 *
 *		dropdown.render();
 *
 *		panel.element.textContent = 'Content of the panel';
 *
 *		// Will render a dropdown with a panel containing a "Content of the panel" text.
 *		document.body.appendChild( dropdown.element );
 *
 * However, dropdown created this way will contain little behavior. You will need to implement handlers for actions
 * such as {@link module:ui/bindings/clickoutsidehandler~clickOutsideHandler clicking outside an open dropdown}
 * (which should close it) and support for arrow keys inside the panel. Therefore, unless you really know what
 * you do and you really need to do it, it is recommended to use the {@link module:ui/dropdown/utils~createDropdown} helper.
 *
 * @extends module:ui/view~View
 */

var dropdownview_DropdownView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(DropdownView, _View);

  var _super = Object(createSuper["a" /* default */])(DropdownView);

  /**
   * Creates an instance of the dropdown.
   *
   * Also see {@link #render}.
   *
   * @param {module:utils/locale~Locale} [locale] The localization services instance.
   * @param {module:ui/dropdown/button/dropdownbutton~DropdownButton} buttonView
   * @param {module:ui/dropdown/dropdownpanelview~DropdownPanelView} panelView
   */
  function DropdownView(locale, buttonView, panelView) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, DropdownView);

    _this = _super.call(this, locale);
    var bind = _this.bindTemplate;
    /**
     * Button of the dropdown view. Clicking the button opens the {@link #panelView}.
     *
     * @readonly
     * @member {module:ui/button/buttonview~ButtonView} #buttonView
     */

    _this.buttonView = buttonView;
    /**
     * Panel of the dropdown. It opens when the {@link #buttonView} is
     * {@link module:ui/button/buttonview~ButtonView#event:execute executed} (i.e. clicked).
     *
     * Child views can be added to the panel's `children` collection:
     *
     *		dropdown.panelView.children.add( childView );
     *
     * See {@link module:ui/dropdown/dropdownpanelview~DropdownPanelView#children} and
     * {@link module:ui/viewcollection~ViewCollection#add}.
     *
     * @readonly
     * @member {module:ui/dropdown/dropdownpanelview~DropdownPanelView} #panelView
     */

    _this.panelView = panelView;
    /**
     * Controls whether the dropdown view is open, i.e. shows or hides the {@link #panelView panel}.
     *
     * @observable
     * @member {Boolean} #isOpen
     */

    _this.set('isOpen', false);
    /**
     * Controls whether the dropdown is enabled, i.e. it can be clicked and execute an action.
     *
     * See {@link module:ui/button/buttonview~ButtonView#isEnabled}.
     *
     * @observable
     * @member {Boolean} #isEnabled
     */


    _this.set('isEnabled', true);
    /**
     * (Optional) The additional CSS class set on the dropdown {@link #element}.
     *
     * @observable
     * @member {String} #class
     */


    _this.set('class');
    /**
     * (Optional) The `id` attribute of the dropdown (i.e. to pair with a `<label>` element).
     *
     * @observable
     * @member {String} #id
     */


    _this.set('id');
    /**
     * The position of the panel, relative to the dropdown.
     *
     * **Note**: When `'auto'`, the panel will use one of the remaining positions to stay
     * in the viewport, visible to the user. The positions correspond directly to
     * {@link module:ui/dropdown/dropdownview~DropdownView.defaultPanelPositions default panel positions}.
     *
     * **Note**: This value has an impact on the
     * {@link module:ui/dropdown/dropdownpanelview~DropdownPanelView#position} property
     * each time the panel becomes {@link #isOpen open}.
     *
     * @observable
     * @default 'auto'
     * @member {'auto'|'se'|'sw'|'ne'|'nw'} #panelPosition
     */


    _this.set('panelPosition', 'auto');
    /**
     * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}. It manages
     * keystrokes of the dropdown:
     *
     * * <kbd>▼</kbd> opens the dropdown,
     * * <kbd>◀</kbd> and <kbd>Esc</kbd> closes the dropdown.
     *
     * @readonly
     * @member {module:utils/keystrokehandler~KeystrokeHandler}
     */


    _this.keystrokes = new keystrokehandler_KeystrokeHandler();

    _this.setTemplate({
      tag: 'div',
      attributes: {
        class: ['ck', 'ck-dropdown', bind.to('class'), bind.if('isEnabled', 'ck-disabled', function (value) {
          return !value;
        })],
        id: bind.to('id'),
        'aria-describedby': bind.to('ariaDescribedById')
      },
      children: [buttonView, panelView]
    });

    buttonView.extendTemplate({
      attributes: {
        class: ['ck-dropdown__button']
      }
    });
    /**
     * A child {@link module:ui/list/listview~ListView list view} of the dropdown located
     * in its {@link module:ui/dropdown/dropdownview~DropdownView#panelView panel}.
     *
     * **Note**: Only supported when dropdown has list view added using {@link module:ui/dropdown/utils~addListToDropdown}.
     *
     * @readonly
     * @member {module:ui/list/listview~ListView} #listView
     */

    /**
     * A child toolbar of the dropdown located in the
     * {@link module:ui/dropdown/dropdownview~DropdownView#panelView panel}.
     *
     * **Note**: Only supported when dropdown has list view added using {@link module:ui/dropdown/utils~addToolbarToDropdown}.
     *
     * @readonly
     * @member {module:ui/toolbar/toolbarview~ToolbarView} #toolbarView
     */

    /**
     * Fired when the toolbar button or list item is executed.
     *
     * For {@link #listView} It fires when a child of some {@link module:ui/list/listitemview~ListItemView}
     * fired `execute`.
     *
     * For {@link #toolbarView} It fires when one of the buttons has been
     * {@link module:ui/button/buttonview~ButtonView#event:execute executed}.
     *
     * **Note**: Only supported when dropdown has list view added using {@link module:ui/dropdown/utils~addListToDropdown}
     * or {@link module:ui/dropdown/utils~addToolbarToDropdown}.
     *
     * @event execute
     */

    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(DropdownView, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      get_get(Object(getPrototypeOf["a" /* default */])(DropdownView.prototype), "render", this).call(this); // Toggle the dropdown when its button has been clicked.


      this.listenTo(this.buttonView, 'open', function () {
        _this2.isOpen = !_this2.isOpen;
      }); // Toggle the visibility of the panel when the dropdown becomes open.

      this.panelView.bind('isVisible').to(this, 'isOpen'); // Let the dropdown control the position of the panel. The position must
      // be updated every time the dropdown is open.

      this.on('change:isOpen', function () {
        if (!_this2.isOpen) {
          return;
        } // If "auto", find the best position of the panel to fit into the viewport.
        // Otherwise, simply assign the static position.


        if (_this2.panelPosition === 'auto') {
          _this2.panelView.position = DropdownView._getOptimalPosition({
            element: _this2.panelView.element,
            target: _this2.buttonView.element,
            fitInViewport: true,
            positions: _this2._panelPositions
          }).name;
        } else {
          _this2.panelView.position = _this2.panelPosition;
        }
      }); // Listen for keystrokes coming from within #element.

      this.keystrokes.listenTo(this.element);

      var closeDropdown = function closeDropdown(data, cancel) {
        if (_this2.isOpen) {
          _this2.buttonView.focus();

          _this2.isOpen = false;
          cancel();
        }
      }; // Open the dropdown panel using the arrow down key, just like with return or space.


      this.keystrokes.set('arrowdown', function (data, cancel) {
        // Don't open if the dropdown is disabled or already open.
        if (_this2.buttonView.isEnabled && !_this2.isOpen) {
          _this2.isOpen = true;
          cancel();
        }
      }); // Block the right arrow key (until nested dropdowns are implemented).

      this.keystrokes.set('arrowright', function (data, cancel) {
        if (_this2.isOpen) {
          cancel();
        }
      }); // Close the dropdown using the arrow left/escape key.

      this.keystrokes.set('arrowleft', closeDropdown);
      this.keystrokes.set('esc', closeDropdown);
    }
    /**
     * Focuses the {@link #buttonView}.
     */

  }, {
    key: "focus",
    value: function focus() {
      this.buttonView.focus();
    }
    /**
     * Returns {@link #panelView panel} positions to be used by the
     * {@link module:utils/dom/position~getOptimalPosition `getOptimalPosition()`}
     * utility considering the direction of the language the UI of the editor is displayed in.
     *
     * @type {module:utils/dom/position~Options#positions}
     * @private
     */

  }, {
    key: "_panelPositions",
    get: function get() {
      var _DropdownView$default = DropdownView.defaultPanelPositions,
          southEast = _DropdownView$default.southEast,
          southWest = _DropdownView$default.southWest,
          northEast = _DropdownView$default.northEast,
          northWest = _DropdownView$default.northWest;

      if (this.locale.uiLanguageDirection === 'ltr') {
        return [southEast, southWest, northEast, northWest];
      } else {
        return [southWest, southEast, northWest, northEast];
      }
    }
  }]);

  return DropdownView;
}(src_view_View);
/**
 * A set of positioning functions used by the dropdown view to determine
 * the optimal position (i.e. fitting into the browser viewport) of its
 * {@link module:ui/dropdown/dropdownview~DropdownView#panelView panel} when
 * {@link module:ui/dropdown/dropdownview~DropdownView#panelPosition} is set to 'auto'`.
 *
 * The available positioning functions are as follow:
 *
 * **South**
 *
 * * `southEast`
 *
 *		[ Button ]
 *		+-----------------+
 *		|      Panel      |
 *		+-----------------+
 *
 * * `southWest`
 *
 *		         [ Button ]
 *		+-----------------+
 *		|      Panel      |
 *		+-----------------+
 *
 * **North**
 *
 * * `northEast`
 *
 *		+-----------------+
 *		|      Panel      |
 *		+-----------------+
 *		[ Button ]
 *
 * * `northWest`
 *
 *		+-----------------+
 *		|      Panel      |
 *		+-----------------+
 *		         [ Button ]
 *
 * Positioning functions are compatible with {@link module:utils/dom/position~Position}.
 *
 * The name that position function returns will be reflected in dropdown panel's class that
 * controls its placement. See {@link module:ui/dropdown/dropdownview~DropdownView#panelPosition}
 * to learn more.
 *
 * @member {Object} module:ui/dropdown/dropdownview~DropdownView.defaultPanelPositions
 */



dropdownview_DropdownView.defaultPanelPositions = {
  southEast: function southEast(buttonRect) {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left,
      name: 'se'
    };
  },
  southWest: function southWest(buttonRect, panelRect) {
    return {
      top: buttonRect.bottom,
      left: buttonRect.left - panelRect.width + buttonRect.width,
      name: 'sw'
    };
  },
  northEast: function northEast(buttonRect, panelRect) {
    return {
      top: buttonRect.top - panelRect.height,
      left: buttonRect.left,
      name: 'ne'
    };
  },
  northWest: function northWest(buttonRect, panelRect) {
    return {
      top: buttonRect.bottom - panelRect.height,
      left: buttonRect.left - panelRect.width + buttonRect.width,
      name: 'nw'
    };
  }
};
/**
 * A function used to calculate the optimal position for the dropdown panel.
 *
 * @protected
 * @member {Function} module:ui/dropdown/dropdownview~DropdownView._getOptimalPosition
 */

dropdownview_DropdownView._getOptimalPosition = getOptimalPosition;
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/components/icon/icon.css
var icon_icon = __webpack_require__("ffa0");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/icon/iconview.js











/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* global DOMParser */

/**
 * @module ui/icon/iconview
 */


/**
 * The icon view class.
 *
 * @extends module:ui/view~View
 */

var iconview_IconView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(IconView, _View);

  var _super = Object(createSuper["a" /* default */])(IconView);

  /**
   * @inheritDoc
   */
  function IconView() {
    var _this;

    Object(classCallCheck["a" /* default */])(this, IconView);

    _this = _super.call(this);
    var bind = _this.bindTemplate;
    /**
     * The SVG source of the icon.
     *
     * @observable
     * @member {String} #content
     */

    _this.set('content', '');
    /**
     * This attribute specifies the boundaries to which the
     * icon content should stretch.
     *
     * @observable
     * @default '0 0 20 20'
     * @member {String} #viewBox
     */


    _this.set('viewBox', '0 0 20 20');
    /**
     * The fill color of the child `path.ck-icon__fill`.
     *
     * @observable
     * @default ''
     * @member {String} #fillColor
     */


    _this.set('fillColor', '');

    _this.setTemplate({
      tag: 'svg',
      ns: 'http://www.w3.org/2000/svg',
      attributes: {
        class: ['ck', 'ck-icon'],
        viewBox: bind.to('viewBox')
      }
    });

    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(IconView, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      get_get(Object(getPrototypeOf["a" /* default */])(IconView.prototype), "render", this).call(this);

      this._updateXMLContent();

      this._colorFillPaths(); // This is a hack for lack of innerHTML binding.
      // See: https://github.com/ckeditor/ckeditor5-ui/issues/99.


      this.on('change:content', function () {
        _this2._updateXMLContent();

        _this2._colorFillPaths();
      });
      this.on('change:fillColor', function () {
        _this2._colorFillPaths();
      });
    }
    /**
     * Updates the {@link #element} with the value of {@link #content}.
     *
     * @private
     */

  }, {
    key: "_updateXMLContent",
    value: function _updateXMLContent() {
      if (this.content) {
        var parsed = new DOMParser().parseFromString(this.content.trim(), 'image/svg+xml');
        var svg = parsed.querySelector('svg');
        var viewBox = svg.getAttribute('viewBox');

        if (viewBox) {
          this.viewBox = viewBox;
        }

        this.element.innerHTML = '';

        while (svg.childNodes.length > 0) {
          this.element.appendChild(svg.childNodes[0]);
        }
      }
    }
    /**
     * Fills all child `path.ck-icon__fill` with the `#fillColor`.
     *
     * @private
     */

  }, {
    key: "_colorFillPaths",
    value: function _colorFillPaths() {
      var _this3 = this;

      if (this.fillColor) {
        this.element.querySelectorAll('.ck-icon__fill').forEach(function (path) {
          path.style.fill = _this3.fillColor;
        });
      }
    }
  }]);

  return IconView;
}(src_view_View);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/components/tooltip/tooltip.css
var tooltip_tooltip = __webpack_require__("b0d6");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/tooltip/tooltipview.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/tooltip/tooltipview
 */


/**
 * The tooltip view class.
 *
 * @extends module:ui/view~View
 */

var tooltipview_TooltipView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(TooltipView, _View);

  var _super = Object(createSuper["a" /* default */])(TooltipView);

  /**
   * @inheritDoc
   */
  function TooltipView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, TooltipView);

    _this = _super.call(this, locale);
    /**
     * The text of the tooltip visible to the user.
     *
     * @observable
     * @member {String} #text
     */

    _this.set('text', '');
    /**
     * The position of the tooltip (south or north).
     *
     *		+-----------+
     *		|   north   |
     *		+-----------+
     *		      V
     *		  [element]
     *
     *		  [element]
     *		      ^
     *		+-----------+
     *		|   south   |
     *		+-----------+
     *
     * @observable
     * @default 's'
     * @member {'s'|'n'} #position
     */


    _this.set('position', 's');

    var bind = _this.bindTemplate;

    _this.setTemplate({
      tag: 'span',
      attributes: {
        class: ['ck', 'ck-tooltip', bind.to('position', function (position) {
          return 'ck-tooltip_' + position;
        }), bind.if('text', 'ck-hidden', function (value) {
          return !value.trim();
        })]
      },
      children: [{
        tag: 'span',
        attributes: {
          class: ['ck', 'ck-tooltip__text']
        },
        children: [{
          text: bind.to('text')
        }]
      }]
    });

    return _this;
  }

  return TooltipView;
}(src_view_View);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/button.css
var button_button = __webpack_require__("43ae");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/button/buttonview.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/button/buttonview
 */






/**
 * The button view class.
 *
 *		const view = new ButtonView();
 *
 *		view.set( {
 *			label: 'A button',
 *			keystroke: 'Ctrl+B',
 *			tooltip: true,
 *			withText: true
 *		} );
 *
 *		view.render();
 *
 *		document.body.append( view.element );
 *
 * @extends module:ui/view~View
 * @implements module:ui/button/button~Button
 */

var buttonview_ButtonView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(ButtonView, _View);

  var _super = Object(createSuper["a" /* default */])(ButtonView);

  /**
   * @inheritDoc
   */
  function ButtonView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, ButtonView);

    _this = _super.call(this, locale);
    var bind = _this.bindTemplate;
    var ariaLabelUid = uid_uid(); // Implement the Button interface.

    _this.set('class');

    _this.set('labelStyle');

    _this.set('icon');

    _this.set('isEnabled', true);

    _this.set('isOn', false);

    _this.set('isVisible', true);

    _this.set('isToggleable', false);

    _this.set('keystroke');

    _this.set('label');

    _this.set('tabindex', -1);

    _this.set('tooltip');

    _this.set('tooltipPosition', 's');

    _this.set('type', 'button');

    _this.set('withText', false);

    _this.set('withKeystroke', false);
    /**
     * Collection of the child views inside of the button {@link #element}.
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */


    _this.children = _this.createCollection();
    /**
     * Tooltip of the button view. It is configurable using the {@link #tooltip tooltip attribute}.
     *
     * @readonly
     * @member {module:ui/tooltip/tooltipview~TooltipView} #tooltipView
     */

    _this.tooltipView = _this._createTooltipView();
    /**
     * Label of the button view. It is configurable using the {@link #label label attribute}.
     *
     * @readonly
     * @member {module:ui/view~View} #labelView
     */

    _this.labelView = _this._createLabelView(ariaLabelUid);
    /**
     * The icon view of the button. Will be added to {@link #children} when the
     * {@link #icon icon attribute} is defined.
     *
     * @readonly
     * @member {module:ui/icon/iconview~IconView} #iconView
     */

    _this.iconView = new iconview_IconView();

    _this.iconView.extendTemplate({
      attributes: {
        class: 'ck-button__icon'
      }
    });
    /**
     * A view displaying the keystroke of the button next to the {@link #labelView label}.
     * Added to {@link #children} when the {@link #withKeystroke `withKeystroke` attribute}
     * is defined.
     *
     * @readonly
     * @member {module:ui/view/view~View} #keystrokeView
     */


    _this.keystrokeView = _this._createKeystrokeView();
    /**
     * Tooltip of the button bound to the template.
     *
     * @see #tooltip
     * @see #_getTooltipString
     * @private
     * @observable
     * @member {Boolean} #_tooltipString
     */

    _this.bind('_tooltipString').to(Object(assertThisInitialized["a" /* default */])(_this), 'tooltip', Object(assertThisInitialized["a" /* default */])(_this), 'label', Object(assertThisInitialized["a" /* default */])(_this), 'keystroke', _this._getTooltipString.bind(Object(assertThisInitialized["a" /* default */])(_this)));

    _this.setTemplate({
      tag: 'button',
      attributes: {
        class: ['ck', 'ck-button', bind.to('class'), bind.if('isEnabled', 'ck-disabled', function (value) {
          return !value;
        }), bind.if('isVisible', 'ck-hidden', function (value) {
          return !value;
        }), bind.to('isOn', function (value) {
          return value ? 'ck-on' : 'ck-off';
        }), bind.if('withText', 'ck-button_with-text'), bind.if('withKeystroke', 'ck-button_with-keystroke')],
        type: bind.to('type', function (value) {
          return value ? value : 'button';
        }),
        tabindex: bind.to('tabindex'),
        'aria-labelledby': "ck-editor__aria-label_".concat(ariaLabelUid),
        'aria-disabled': bind.if('isEnabled', true, function (value) {
          return !value;
        }),
        'aria-pressed': bind.to('isOn', function (value) {
          return _this.isToggleable ? String(value) : false;
        })
      },
      children: _this.children,
      on: {
        mousedown: bind.to(function (evt) {
          evt.preventDefault();
        }),
        click: bind.to(function (evt) {
          // We can't make the button disabled using the disabled attribute, because it won't be focusable.
          // Though, shouldn't this condition be moved to the button controller?
          if (_this.isEnabled) {
            _this.fire('execute');
          } else {
            // Prevent the default when button is disabled, to block e.g.
            // automatic form submitting. See ckeditor/ckeditor5-link#74.
            evt.preventDefault();
          }
        })
      }
    });

    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(ButtonView, [{
    key: "render",
    value: function render() {
      get_get(Object(getPrototypeOf["a" /* default */])(ButtonView.prototype), "render", this).call(this);

      if (this.icon) {
        this.iconView.bind('content').to(this, 'icon');
        this.children.add(this.iconView);
      }

      this.children.add(this.tooltipView);
      this.children.add(this.labelView);

      if (this.withKeystroke) {
        this.children.add(this.keystrokeView);
      }
    }
    /**
     * Focuses the {@link #element} of the button.
     */

  }, {
    key: "focus",
    value: function focus() {
      this.element.focus();
    }
    /**
     * Creates a {@link module:ui/tooltip/tooltipview~TooltipView} instance and binds it with button
     * attributes.
     *
     * @private
     * @returns {module:ui/tooltip/tooltipview~TooltipView}
     */

  }, {
    key: "_createTooltipView",
    value: function _createTooltipView() {
      var tooltipView = new tooltipview_TooltipView();
      tooltipView.bind('text').to(this, '_tooltipString');
      tooltipView.bind('position').to(this, 'tooltipPosition');
      return tooltipView;
    }
    /**
     * Creates a label view instance and binds it with button attributes.
     *
     * @private
     * @param {String} ariaLabelUid The aria label UID.
     * @returns {module:ui/view~View}
     */

  }, {
    key: "_createLabelView",
    value: function _createLabelView(ariaLabelUid) {
      var labelView = new src_view_View();
      var bind = this.bindTemplate;
      labelView.setTemplate({
        tag: 'span',
        attributes: {
          class: ['ck', 'ck-button__label'],
          style: bind.to('labelStyle'),
          id: "ck-editor__aria-label_".concat(ariaLabelUid)
        },
        children: [{
          text: this.bindTemplate.to('label')
        }]
      });
      return labelView;
    }
    /**
     * Creates a view that displays a keystroke next to a {@link #labelView label }
     * and binds it with button attributes.
     *
     * @private
     * @returns {module:ui/view~View}
     */

  }, {
    key: "_createKeystrokeView",
    value: function _createKeystrokeView() {
      var keystrokeView = new src_view_View();
      keystrokeView.setTemplate({
        tag: 'span',
        attributes: {
          class: ['ck', 'ck-button__keystroke']
        },
        children: [{
          text: this.bindTemplate.to('keystroke', function (text) {
            return getEnvKeystrokeText(text);
          })
        }]
      });
      return keystrokeView;
    }
    /**
     * Gets the text for the {@link #tooltipView} from the combination of
     * {@link #tooltip}, {@link #label} and {@link #keystroke} attributes.
     *
     * @private
     * @see #tooltip
     * @see #_tooltipString
     * @param {Boolean|String|Function} tooltip Button tooltip.
     * @param {String} label Button label.
     * @param {String} keystroke Button keystroke.
     * @returns {String}
     */

  }, {
    key: "_getTooltipString",
    value: function _getTooltipString(tooltip, label, keystroke) {
      if (tooltip) {
        if (typeof tooltip == 'string') {
          return tooltip;
        } else {
          if (keystroke) {
            keystroke = getEnvKeystrokeText(keystroke);
          }

          if (tooltip instanceof Function) {
            return tooltip(label, keystroke);
          } else {
            return "".concat(label).concat(keystroke ? " (".concat(keystroke, ")") : '');
          }
        }
      }

      return '';
    }
  }]);

  return ButtonView;
}(src_view_View);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/icons/dropdown-arrow.svg
var dropdown_arrow = __webpack_require__("4ca4");
var dropdown_arrow_default = /*#__PURE__*/__webpack_require__.n(dropdown_arrow);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/dropdown/button/dropdownbuttonview.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/dropdown/button/dropdownbuttonview
 */



/**
 * The default dropdown button view class.
 *
 *		const view = new DropdownButtonView();
 *
 *		view.set( {
 *			label: 'A button',
 *			keystroke: 'Ctrl+B',
 *			tooltip: true
 *		} );
 *
 *		view.render();
 *
 *		document.body.append( view.element );
 *
 * Also see the {@link module:ui/dropdown/utils~createDropdown `createDropdown()` util}.
 *
 * @implements module:ui/dropdown/button/dropdownbutton~DropdownButton
 * @extends module:ui/button/buttonview~ButtonView
 */

var dropdownbuttonview_DropdownButtonView = /*#__PURE__*/function (_ButtonView) {
  Object(inherits["a" /* default */])(DropdownButtonView, _ButtonView);

  var _super = Object(createSuper["a" /* default */])(DropdownButtonView);

  /**
   * @inheritDoc
   */
  function DropdownButtonView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, DropdownButtonView);

    _this = _super.call(this, locale);
    /**
     * An icon that displays arrow to indicate a dropdown button.
     *
     * @readonly
     * @member {module:ui/icon/iconview~IconView}
     */

    _this.arrowView = _this._createArrowView();

    _this.extendTemplate({
      attributes: {
        'aria-haspopup': true
      }
    }); // The DropdownButton interface expects the open event upon which will open the dropdown.


    _this.delegate('execute').to(Object(assertThisInitialized["a" /* default */])(_this), 'open');

    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(DropdownButtonView, [{
    key: "render",
    value: function render() {
      get_get(Object(getPrototypeOf["a" /* default */])(DropdownButtonView.prototype), "render", this).call(this);

      this.children.add(this.arrowView);
    }
    /**
     * Creates a {@link module:ui/icon/iconview~IconView} instance as {@link #arrowView}.
     *
     * @private
     * @returns {module:ui/icon/iconview~IconView}
     */

  }, {
    key: "_createArrowView",
    value: function _createArrowView() {
      var arrowView = new iconview_IconView();
      arrowView.content = dropdown_arrow_default.a;
      arrowView.extendTemplate({
        attributes: {
          class: 'ck-dropdown__arrow'
        }
      });
      return arrowView;
    }
  }]);

  return DropdownButtonView;
}(buttonview_ButtonView);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/components/list/list.css
var list = __webpack_require__("3a7f");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/list/listview.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/list/listview
 */





/**
 * The list view class.
 *
 * @extends module:ui/view~View
 * @implements module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable
 */

var listview_ListView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(ListView, _View);

  var _super = Object(createSuper["a" /* default */])(ListView);

  /**
   * @inheritDoc
   */
  function ListView() {
    var _this;

    Object(classCallCheck["a" /* default */])(this, ListView);

    _this = _super.call(this);
    /**
     * Collection of the child list views.
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */

    _this.items = _this.createCollection();
    /**
     * Tracks information about DOM focus in the list.
     *
     * @readonly
     * @member {module:utils/focustracker~FocusTracker}
     */

    _this.focusTracker = new focustracker_FocusTracker();
    /**
     * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
     *
     * @readonly
     * @member {module:utils/keystrokehandler~KeystrokeHandler}
     */

    _this.keystrokes = new keystrokehandler_KeystrokeHandler();
    /**
     * Helps cycling over focusable {@link #items} in the list.
     *
     * @readonly
     * @protected
     * @member {module:ui/focuscycler~FocusCycler}
     */

    _this._focusCycler = new focuscycler_FocusCycler({
      focusables: _this.items,
      focusTracker: _this.focusTracker,
      keystrokeHandler: _this.keystrokes,
      actions: {
        // Navigate list items backwards using the arrowup key.
        focusPrevious: 'arrowup',
        // Navigate toolbar items forwards using the arrowdown key.
        focusNext: 'arrowdown'
      }
    });

    _this.setTemplate({
      tag: 'ul',
      attributes: {
        class: ['ck', 'ck-reset', 'ck-list']
      },
      children: _this.items
    });

    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(ListView, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      get_get(Object(getPrototypeOf["a" /* default */])(ListView.prototype), "render", this).call(this); // Items added before rendering should be known to the #focusTracker.


      var _iterator = _createForOfIteratorHelper(this.items),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var item = _step.value;
          this.focusTracker.add(item.element);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.items.on('add', function (evt, item) {
        _this2.focusTracker.add(item.element);
      });
      this.items.on('remove', function (evt, item) {
        _this2.focusTracker.remove(item.element);
      }); // Start listening for the keystrokes coming from #element.

      this.keystrokes.listenTo(this.element);
    }
    /**
     * Focuses the first focusable in {@link #items}.
     */

  }, {
    key: "focus",
    value: function focus() {
      this._focusCycler.focusFirst();
    }
    /**
     * Focuses the last focusable in {@link #items}.
     */

  }, {
    key: "focusLast",
    value: function focusLast() {
      this._focusCycler.focusLast();
    }
  }]);

  return ListView;
}(src_view_View);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/list/listitemview.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/list/listitemview
 */

/**
 * The list item view class.
 *
 * @extends module:ui/view~View
 */

var listitemview_ListItemView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(ListItemView, _View);

  var _super = Object(createSuper["a" /* default */])(ListItemView);

  /**
   * @inheritDoc
   */
  function ListItemView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, ListItemView);

    _this = _super.call(this, locale);
    /**
     * Collection of the child views inside of the list item {@link #element}.
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */

    _this.children = _this.createCollection();

    _this.setTemplate({
      tag: 'li',
      attributes: {
        class: ['ck', 'ck-list__item']
      },
      children: _this.children
    });

    return _this;
  }
  /**
   * Focuses the list item.
   */


  Object(createClass["a" /* default */])(ListItemView, [{
    key: "focus",
    value: function focus() {
      this.children.first.focus();
    }
  }]);

  return ListItemView;
}(src_view_View);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/list/listseparatorview.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/list/listseparatorview
 */

/**
 * The list separator view class.
 *
 * @extends module:ui/view~View
 */

var listseparatorview_ListSeparatorView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(ListSeparatorView, _View);

  var _super = Object(createSuper["a" /* default */])(ListSeparatorView);

  /**
   * @inheritDoc
   */
  function ListSeparatorView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, ListSeparatorView);

    _this = _super.call(this, locale);

    _this.setTemplate({
      tag: 'li',
      attributes: {
        class: ['ck', 'ck-list__separator']
      }
    });

    return _this;
  }

  return ListSeparatorView;
}(src_view_View);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/components/button/switchbutton.css
var switchbutton = __webpack_require__("ff23");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/button/switchbuttonview.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/button/switchbuttonview
 */



/**
 * The switch button view class.
 *
 *		const view = new SwitchButtonView();
 *
 *		view.set( {
 *			withText: true,
 *			label: 'Switch me!'
 *		} );
 *
 *		view.render();
 *
 *		document.body.append( view.element );
 *
 * @extends module:ui/button/buttonview~ButtonView
 */

var switchbuttonview_SwitchButtonView = /*#__PURE__*/function (_ButtonView) {
  Object(inherits["a" /* default */])(SwitchButtonView, _ButtonView);

  var _super = Object(createSuper["a" /* default */])(SwitchButtonView);

  /**
   * @inheritDoc
   */
  function SwitchButtonView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, SwitchButtonView);

    _this = _super.call(this, locale);
    _this.isToggleable = true;
    /**
     * The toggle switch of the button.
     *
     * @readonly
     * @member {module:ui/view~View} #toggleSwitchView
     */

    _this.toggleSwitchView = _this._createToggleView();

    _this.extendTemplate({
      attributes: {
        class: 'ck-switchbutton'
      }
    });

    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(SwitchButtonView, [{
    key: "render",
    value: function render() {
      get_get(Object(getPrototypeOf["a" /* default */])(SwitchButtonView.prototype), "render", this).call(this);

      this.children.add(this.toggleSwitchView);
    }
    /**
     * Creates a toggle child view.
     *
     * @private
     * @returns {module:ui/view~View}
     */

  }, {
    key: "_createToggleView",
    value: function _createToggleView() {
      var toggleSwitchView = new src_view_View();
      toggleSwitchView.setTemplate({
        tag: 'span',
        attributes: {
          class: ['ck', 'ck-button__toggle']
        },
        children: [{
          tag: 'span',
          attributes: {
            class: ['ck', 'ck-button__toggle__inner']
          }
        }]
      });
      return toggleSwitchView;
    }
  }]);

  return SwitchButtonView;
}(buttonview_ButtonView);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/bindings/clickoutsidehandler.js


/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/bindings/clickoutsidehandler
 */

/* global document */

/**
 * Handles clicking **outside** of a specified set of elements, then fires an action.
 *
 * **Note**: Actually, the action is executed upon `mousedown`, not `click`. It prevents
 * certain issues when the user keeps holding the mouse button and the UI cannot react
 * properly.
 *
 * @param {Object} options Configuration options.
 * @param {module:utils/dom/emittermixin~Emitter} options.emitter The emitter to which this behavior
 * should be added.
 * @param {Function} options.activator Function returning a `Boolean`, to determine whether the handler is active.
 * @param {Array.<HTMLElement>} options.contextElements HTML elements that determine the scope of the
 * handler. Clicking any of them or their descendants will **not** fire the callback.
 * @param {Function} options.callback An action executed by the handler.
 */
function clickOutsideHandler(_ref) {
  var emitter = _ref.emitter,
      activator = _ref.activator,
      callback = _ref.callback,
      contextElements = _ref.contextElements;
  emitter.listenTo(document, 'mousedown', function (evt, _ref2) {
    var target = _ref2.target;

    if (!activator()) {
      return;
    }

    var _iterator = _createForOfIteratorHelper(contextElements),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var contextElement = _step.value;

        if (contextElement.contains(target)) {
          return;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    callback();
  });
}
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/toolbardropdown.css
var toolbardropdown = __webpack_require__("2a21");

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/listdropdown.css
var listdropdown = __webpack_require__("f5e9");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/dropdown/utils.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/dropdown/utils
 */












/**
 * A helper for creating dropdowns. It creates an instance of a {@link module:ui/dropdown/dropdownview~DropdownView dropdown},
 * with a {@link module:ui/dropdown/button/dropdownbutton~DropdownButton button},
 * {@link module:ui/dropdown/dropdownpanelview~DropdownPanelView panel} and all standard dropdown's behaviors.
 *
 * # Creating dropdowns
 *
 * By default, the default {@link module:ui/dropdown/button/dropdownbuttonview~DropdownButtonView} class is used as
 * definition of the button:
 *
 *		const dropdown = createDropdown( model );
 *
 *		// Configure dropdown's button properties:
 *		dropdown.buttonView.set( {
 *			label: 'A dropdown',
 *			withText: true
 *		} );
 *
 *		dropdown.render();
 *
 *		// Will render a dropdown labeled "A dropdown" with an empty panel.
 *		document.body.appendChild( dropdown.element );
 *
 * You can also provide other button views (they need to implement the
 * {@link module:ui/dropdown/button/dropdownbutton~DropdownButton} interface). For instance, you can use
 * {@link module:ui/dropdown/button/splitbuttonview~SplitButtonView} to create a dropdown with a split button.
 *
 *		const dropdown = createDropdown( model, SplitButtonView );
 *
 *		// Configure dropdown's button properties:
 *		dropdown.buttonView.set( {
 *			label: 'A dropdown',
 *			withText: true
 *		} );
 *
 *		dropdown.buttonView.on( 'execute', () => {
 *			// Add the behavior of the "action part" of the split button.
 *			// Split button consists of the "action part" and "arrow part".
 *			// The arrow opens the dropdown while the action part can have some other behavior.
 * 		} );
 *
 *		dropdown.render();
 *
 *		// Will render a dropdown labeled "A dropdown" with an empty panel.
 *		document.body.appendChild( dropdown.element );
 *
 * # Adding content to the dropdown's panel
 *
 * The content of the panel can be inserted directly into the `dropdown.panelView.element`:
 *
 *		dropdown.panelView.element.textContent = 'Content of the panel';
 *
 * However, most of the time you will want to add there either a {@link module:ui/list/listview~ListView list of options}
 * or a list of buttons (i.e. a {@link module:ui/toolbar/toolbarview~ToolbarView toolbar}).
 * To simplify the task, you can use, respectively, {@link module:ui/dropdown/utils~addListToDropdown} or
 * {@link module:ui/dropdown/utils~addToolbarToDropdown} utils.
 *
 * @param {module:utils/locale~Locale} locale The locale instance.
 * @param {Function} ButtonClass The dropdown button view class. Needs to implement the
 * {@link module:ui/dropdown/button/dropdownbutton~DropdownButton} interface.
 * @returns {module:ui/dropdown/dropdownview~DropdownView} The dropdown view instance.
 */

function createDropdown(locale) {
  var ButtonClass = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : dropdownbuttonview_DropdownButtonView;
  var buttonView = new ButtonClass(locale);
  var panelView = new dropdownpanelview_DropdownPanelView(locale);
  var dropdownView = new dropdownview_DropdownView(locale, buttonView, panelView);
  buttonView.bind('isEnabled').to(dropdownView);

  if (buttonView instanceof dropdownbuttonview_DropdownButtonView) {
    buttonView.bind('isOn').to(dropdownView, 'isOpen');
  } else {
    buttonView.arrowView.bind('isOn').to(dropdownView, 'isOpen');
  }

  addDefaultBehavior(dropdownView);
  return dropdownView;
}
/**
 * Adds an instance of {@link module:ui/toolbar/toolbarview~ToolbarView} to a dropdown.
 *
 *		const buttons = [];
 *
 *		// Either create a new ButtonView instance or create existing.
 *		buttons.push( new ButtonView() );
 *		buttons.push( editor.ui.componentFactory.get( 'someButton' ) );
 *
 *		const dropdown = createDropdown( locale );
 *
 *		addToolbarToDropdown( dropdown, buttons );
 *
 *		dropdown.toolbarView.isVertical = true;
 *
 *		// Will render a vertical button dropdown labeled "A button dropdown"
 *		// with a button group in the panel containing two buttons.
 *		dropdown.render()
 *		document.body.appendChild( dropdown.element );
 *
 * See {@link module:ui/dropdown/utils~createDropdown} and {@link module:ui/toolbar/toolbarview~ToolbarView}.
 *
 * @param {module:ui/dropdown/dropdownview~DropdownView} dropdownView A dropdown instance to which `ToolbarView` will be added.
 * @param {Iterable.<module:ui/button/buttonview~ButtonView>} buttons
 */

function addToolbarToDropdown(dropdownView, buttons) {
  var locale = dropdownView.locale;
  var t = locale.t;
  var toolbarView = dropdownView.toolbarView = new toolbarview_ToolbarView(locale);
  toolbarView.set('ariaLabel', t('Dropdown toolbar'));
  dropdownView.extendTemplate({
    attributes: {
      class: ['ck-toolbar-dropdown']
    }
  });
  buttons.map(function (view) {
    return toolbarView.items.add(view);
  });
  dropdownView.panelView.children.add(toolbarView);
  toolbarView.items.delegate('execute').to(dropdownView);
}
/**
 * Adds an instance of {@link module:ui/list/listview~ListView} to a dropdown.
 *
 *		const items = new Collection();
 *
 *		items.add( {
 *			type: 'button',
 *			model: new Model( {
 *				withText: true,
 *				label: 'First item',
 *				labelStyle: 'color: red'
 *			} )
 *		} );
 *
 *		items.add( {
 *			 type: 'button',
 *			 model: new Model( {
 *				withText: true,
 *				label: 'Second item',
 *				labelStyle: 'color: green',
 *				class: 'foo'
 *			} )
 *		} );
 *
 *		const dropdown = createDropdown( locale );
 *
 *		addListToDropdown( dropdown, items );
 *
 *		// Will render a dropdown with a list in the panel containing two items.
 *		dropdown.render()
 *		document.body.appendChild( dropdown.element );
 *
 * The `items` collection passed to this methods controls the presence and attributes of respective
 * {@link module:ui/list/listitemview~ListItemView list items}.
 *
 *
 * See {@link module:ui/dropdown/utils~createDropdown} and {@link module:list/list~List}.
 *
 * @param {module:ui/dropdown/dropdownview~DropdownView} dropdownView A dropdown instance to which `ListVIew` will be added.
 * @param {Iterable.<module:ui/dropdown/utils~ListDropdownItemDefinition>} items
 * A collection of the list item definitions to populate the list.
 */

function addListToDropdown(dropdownView, items) {
  var locale = dropdownView.locale;
  var listView = dropdownView.listView = new listview_ListView(locale);
  listView.items.bindTo(items).using(function (_ref) {
    var type = _ref.type,
        model = _ref.model;

    if (type === 'separator') {
      return new listseparatorview_ListSeparatorView(locale);
    } else if (type === 'button' || type === 'switchbutton') {
      var _buttonView;

      var listItemView = new listitemview_ListItemView(locale);
      var buttonView;

      if (type === 'button') {
        buttonView = new buttonview_ButtonView(locale);
      } else {
        buttonView = new switchbuttonview_SwitchButtonView(locale);
      } // Bind all model properties to the button view.


      (_buttonView = buttonView).bind.apply(_buttonView, _toConsumableArray(Object.keys(model))).to(model);

      buttonView.delegate('execute').to(listItemView);
      listItemView.children.add(buttonView);
      return listItemView;
    }
  });
  dropdownView.panelView.children.add(listView);
  listView.items.delegate('execute').to(dropdownView);
} // Add a set of default behaviors to dropdown view.
//
// @param {module:ui/dropdown/dropdownview~DropdownView} dropdownView

function addDefaultBehavior(dropdownView) {
  closeDropdownOnBlur(dropdownView);
  closeDropdownOnExecute(dropdownView);
  focusDropdownContentsOnArrows(dropdownView);
} // Adds a behavior to a dropdownView that closes opened dropdown when user clicks outside the dropdown.
//
// @param {module:ui/dropdown/dropdownview~DropdownView} dropdownView


function closeDropdownOnBlur(dropdownView) {
  dropdownView.on('render', function () {
    clickOutsideHandler({
      emitter: dropdownView,
      activator: function activator() {
        return dropdownView.isOpen;
      },
      callback: function callback() {
        dropdownView.isOpen = false;
      },
      contextElements: [dropdownView.element]
    });
  });
} // Adds a behavior to a dropdownView that closes the dropdown view on "execute" event.
//
// @param {module:ui/dropdown/dropdownview~DropdownView} dropdownView


function closeDropdownOnExecute(dropdownView) {
  // Close the dropdown when one of the list items has been executed.
  dropdownView.on('execute', function (evt) {
    // Toggling a switch button view should not close the dropdown.
    if (evt.source instanceof switchbuttonview_SwitchButtonView) {
      return;
    }

    dropdownView.isOpen = false;
  });
} // Adds a behavior to a dropdownView that focuses the dropdown's panel view contents on keystrokes.
//
// @param {module:ui/dropdown/dropdownview~DropdownView} dropdownView


function focusDropdownContentsOnArrows(dropdownView) {
  // If the dropdown panel is already open, the arrow down key should focus the first child of the #panelView.
  dropdownView.keystrokes.set('arrowdown', function (data, cancel) {
    if (dropdownView.isOpen) {
      dropdownView.panelView.focus();
      cancel();
    }
  }); // If the dropdown panel is already open, the arrow up key should focus the last child of the #panelView.

  dropdownView.keystrokes.set('arrowup', function (data, cancel) {
    if (dropdownView.isOpen) {
      dropdownView.panelView.focusLast();
      cancel();
    }
  });
}
/**
 * A definition of the list item used by the {@link module:ui/dropdown/utils~addListToDropdown}
 * utility.
 *
 * @typedef {Object} module:ui/dropdown/utils~ListDropdownItemDefinition
 *
 * @property {String} type Either `'separator'`, `'button'` or `'switchbutton'`.
 * @property {module:ui/model~Model} [model] Model of the item (when **not** `'separator'`).
 * Its properties fuel the newly created list item (or its children, depending on the `type`).
 */
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-core/theme/icons/three-vertical-dots.svg
var three_vertical_dots = __webpack_require__("1cb8");
var three_vertical_dots_default = /*#__PURE__*/__webpack_require__.n(three_vertical_dots);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/components/toolbar/toolbar.css
var toolbar = __webpack_require__("7def");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/toolbar/toolbarview.js












/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/toolbar/toolbarview
 */

/* globals console */













/**
 * The toolbar view class.
 *
 * @extends module:ui/view~View
 * @implements module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable
 */

var toolbarview_ToolbarView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(ToolbarView, _View);

  var _super = Object(createSuper["a" /* default */])(ToolbarView);

  /**
   * Creates an instance of the {@link module:ui/toolbar/toolbarview~ToolbarView} class.
   *
   * Also see {@link #render}.
   *
   * @param {module:utils/locale~Locale} locale The localization services instance.
   * @param {module:ui/toolbar/toolbarview~ToolbarOptions} [options] Configuration options of the toolbar.
   */
  function ToolbarView(locale, options) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, ToolbarView);

    _this = _super.call(this, locale);
    var bind = _this.bindTemplate;
    var t = _this.t;
    /**
     * A reference to the options object passed to the constructor.
     *
     * @readonly
     * @member {module:ui/toolbar/toolbarview~ToolbarOptions}
     */

    _this.options = options || {};
    /**
     * Label used by assistive technologies to describe this toolbar element.
     *
     * @default 'Editor toolbar'
     * @member {String} #ariaLabel
     */

    _this.set('ariaLabel', t('Editor toolbar'));
    /**
     * The maximum width of the toolbar element.
     *
     * **Note**: When set to a specific value (e.g. `'200px'`), the value will affect the behavior of the
     * {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull}
     * option by changing the number of {@link #items} that will be displayed in the toolbar at a time.
     *
     * @observable
     * @default 'auto'
     * @member {String} #maxWidth
     */


    _this.set('maxWidth', 'auto');
    /**
     * A collection of toolbar items (buttons, dropdowns, etc.).
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */


    _this.items = _this.createCollection();
    /**
     * Tracks information about the DOM focus in the toolbar.
     *
     * @readonly
     * @member {module:utils/focustracker~FocusTracker}
     */

    _this.focusTracker = new focustracker_FocusTracker();
    /**
     * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}
     * to handle keyboard navigation in the toolbar.
     *
     * @readonly
     * @member {module:utils/keystrokehandler~KeystrokeHandler}
     */

    _this.keystrokes = new keystrokehandler_KeystrokeHandler();
    /**
     * An additional CSS class added to the {@link #element}.
     *
     * @observable
     * @member {String} #class
     */

    _this.set('class');
    /**
     * When set true, makes the toolbar look compact with {@link #element}.
     *
     * @observable
     * @default false
     * @member {String} #isCompact
     */


    _this.set('isCompact', false);
    /**
     * A (child) view containing {@link #items toolbar items}.
     *
     * @readonly
     * @member {module:ui/toolbar/toolbarview~ItemsView}
     */


    _this.itemsView = new toolbarview_ItemsView(locale);
    /**
     * A top–level collection aggregating building blocks of the toolbar.
     *
     *	┌───────────────── ToolbarView ─────────────────┐
     *	| ┌──────────────── #children ────────────────┐ |
     *	| |   ┌──────────── #itemsView ───────────┐   | |
     *	| |   | [ item1 ] [ item2 ] ... [ itemN ] |   | |
     *	| |   └──────────────────────────────────-┘   | |
     *	| └───────────────────────────────────────────┘ |
     *	└───────────────────────────────────────────────┘
     *
     * By default, it contains the {@link #itemsView} but it can be extended with additional
     * UI elements when necessary.
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */

    _this.children = _this.createCollection();

    _this.children.add(_this.itemsView);
    /**
     * A collection of {@link #items} that take part in the focus cycling
     * (i.e. navigation using the keyboard). Usually, it contains a subset of {@link #items} with
     * some optional UI elements that also belong to the toolbar and should be focusable
     * by the user.
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */


    _this.focusables = _this.createCollection();
    /**
     * Controls the orientation of toolbar items. Only available when
     * {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull dynamic items grouping}
     * is **disabled**.
     *
     * @observable
     * @member {Boolean} #isVertical
     */

    /**
     * Helps cycling over {@link #focusables focusable items} in the toolbar.
     *
     * @readonly
     * @protected
     * @member {module:ui/focuscycler~FocusCycler}
     */

    _this._focusCycler = new focuscycler_FocusCycler({
      focusables: _this.focusables,
      focusTracker: _this.focusTracker,
      keystrokeHandler: _this.keystrokes,
      actions: {
        // Navigate toolbar items backwards using the arrow[left,up] keys.
        focusPrevious: ['arrowleft', 'arrowup'],
        // Navigate toolbar items forwards using the arrow[right,down] keys.
        focusNext: ['arrowright', 'arrowdown']
      }
    });

    _this.setTemplate({
      tag: 'div',
      attributes: {
        class: ['ck', 'ck-toolbar', bind.to('class'), bind.if('isCompact', 'ck-toolbar_compact')],
        role: 'toolbar',
        'aria-label': bind.to('ariaLabel'),
        style: {
          maxWidth: bind.to('maxWidth')
        }
      },
      children: _this.children,
      on: {
        // https://github.com/ckeditor/ckeditor5-ui/issues/206
        mousedown: preventDefault(Object(assertThisInitialized["a" /* default */])(_this))
      }
    });
    /**
     * An instance of the active toolbar behavior that shapes its look and functionality.
     *
     * See {@link module:ui/toolbar/toolbarview~ToolbarBehavior} to learn more.
     *
     * @protected
     * @readonly
     * @member {module:ui/toolbar/toolbarview~ToolbarBehavior}
     */


    _this._behavior = _this.options.shouldGroupWhenFull ? new toolbarview_DynamicGrouping(Object(assertThisInitialized["a" /* default */])(_this)) : new toolbarview_StaticLayout(Object(assertThisInitialized["a" /* default */])(_this));
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(ToolbarView, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      get_get(Object(getPrototypeOf["a" /* default */])(ToolbarView.prototype), "render", this).call(this); // Children added before rendering should be known to the #focusTracker.


      var _iterator = _createForOfIteratorHelper(this.items),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var item = _step.value;
          this.focusTracker.add(item.element);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.items.on('add', function (evt, item) {
        _this2.focusTracker.add(item.element);
      });
      this.items.on('remove', function (evt, item) {
        _this2.focusTracker.remove(item.element);
      }); // Start listening for the keystrokes coming from #element.

      this.keystrokes.listenTo(this.element);

      this._behavior.render(this);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this._behavior.destroy();

      return get_get(Object(getPrototypeOf["a" /* default */])(ToolbarView.prototype), "destroy", this).call(this);
    }
    /**
     * Focuses the first focusable in {@link #focusables}.
     */

  }, {
    key: "focus",
    value: function focus() {
      this._focusCycler.focusFirst();
    }
    /**
     * Focuses the last focusable in {@link #focusables}.
     */

  }, {
    key: "focusLast",
    value: function focusLast() {
      this._focusCycler.focusLast();
    }
    /**
     * A utility that expands the plain toolbar configuration into
     * {@link module:ui/toolbar/toolbarview~ToolbarView#items} using a given component factory.
     *
     * @param {Array.<String>} config The toolbar items configuration.
     * @param {module:ui/componentfactory~ComponentFactory} factory A factory producing toolbar items.
     */

  }, {
    key: "fillFromConfig",
    value: function fillFromConfig(config, factory) {
      var _this3 = this;

      config.map(function (name) {
        if (name == '|') {
          _this3.items.add(new toolbarseparatorview_ToolbarSeparatorView());
        } else if (factory.has(name)) {
          _this3.items.add(factory.create(name));
        } else {
          /**
           * There was a problem processing the configuration of the toolbar. The item with the given
           * name does not exist so it was omitted when rendering the toolbar.
           *
           * This warning usually shows up when the {@link module:core/plugin~Plugin} which is supposed
           * to provide a toolbar item has not been loaded or there is a typo in the configuration.
           *
           * Make sure the plugin responsible for this toolbar item is loaded and the toolbar configuration
           * is correct, e.g. {@link module:basic-styles/bold~Bold} is loaded for the `'bold'` toolbar item.
           *
           * You can use the following snippet to retrieve all available toolbar items:
           *
           *		Array.from( editor.ui.componentFactory.names() );
           *
           * @error toolbarview-item-unavailable
           * @param {String} name The name of the component.
           */
          console.warn(Object(ckeditorerror["a" /* attachLinkToDocumentation */])('toolbarview-item-unavailable: The requested toolbar item is unavailable.'), {
            name: name
          });
        }
      });
    }
  }]);

  return ToolbarView;
}(src_view_View);
/**
 * An inner block of the {@link module:ui/toolbar/toolbarview~ToolbarView} hosting its
 * {@link module:ui/toolbar/toolbarview~ToolbarView#items}.
 *
 * @private
 * @extends module:ui/view~View
 */




var toolbarview_ItemsView = /*#__PURE__*/function (_View2) {
  Object(inherits["a" /* default */])(ItemsView, _View2);

  var _super2 = Object(createSuper["a" /* default */])(ItemsView);

  /**
   * @inheritDoc
   */
  function ItemsView(locale) {
    var _this4;

    Object(classCallCheck["a" /* default */])(this, ItemsView);

    _this4 = _super2.call(this, locale);
    /**
     * A collection of items (buttons, dropdowns, etc.).
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */

    _this4.children = _this4.createCollection();

    _this4.setTemplate({
      tag: 'div',
      attributes: {
        class: ['ck', 'ck-toolbar__items']
      },
      children: _this4.children
    });

    return _this4;
  }

  return ItemsView;
}(src_view_View);
/**
 * A toolbar behavior that makes it static and unresponsive to the changes of the environment.
 * At the same time, it also makes it possible to display a toolbar with a vertical layout
 * using the {@link module:ui/toolbar/toolbarview~ToolbarView#isVertical} property.
 *
 * @private
 * @implements module:ui/toolbar/toolbarview~ToolbarBehavior
 */


var toolbarview_StaticLayout = /*#__PURE__*/function () {
  /**
   * Creates an instance of the {@link module:ui/toolbar/toolbarview~StaticLayout} toolbar
   * behavior.
   *
   * @param {module:ui/toolbar/toolbarview~ToolbarView} view An instance of the toolbar that this behavior
   * is added to.
   */
  function StaticLayout(view) {
    Object(classCallCheck["a" /* default */])(this, StaticLayout);

    var bind = view.bindTemplate; // Static toolbar can be vertical when needed.

    view.set('isVertical', false); // 1:1 pass–through binding, all ToolbarView#items are visible.

    view.itemsView.children.bindTo(view.items).using(function (item) {
      return item;
    }); // 1:1 pass–through binding, all ToolbarView#items are focusable.

    view.focusables.bindTo(view.items).using(function (item) {
      return item;
    });
    view.extendTemplate({
      attributes: {
        class: [// When vertical, the toolbar has an additional CSS class.
        bind.if('isVertical', 'ck-toolbar_vertical')]
      }
    });
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(StaticLayout, [{
    key: "render",
    value: function render() {}
    /**
     * @inheritDoc
     */

  }, {
    key: "destroy",
    value: function destroy() {}
  }]);

  return StaticLayout;
}();
/**
 * A toolbar behavior that makes the items respond to changes in the geometry.
 *
 * In a nutshell, it groups {@link module:ui/toolbar/toolbarview~ToolbarView#items}
 * that do not fit visually into a single row of the toolbar (due to limited space).
 * Items that do not fit are aggregated in a dropdown displayed at the end of the toolbar.
 *
 *	┌──────────────────────────────────────── ToolbarView ──────────────────────────────────────────┐
 *	| ┌─────────────────────────────────────── #children ─────────────────────────────────────────┐ |
 *	| |   ┌─────── #itemsView ────────┐ ┌──────────────────────┐ ┌── #groupedItemsDropdown ───┐   | |
 *	| |   |       #ungroupedItems     | | ToolbarSeparatorView | |        #groupedItems       |   | |
 *	| |   └──────────────────────────-┘ └──────────────────────┘ └────────────────────────────┘   | |
 *	| |                                  \---------- only when toolbar items overflow --------/    | |
 *	| └───────────────────────────────────────────────────────────────────────────────────────────┘ |
 *	└───────────────────────────────────────────────────────────────────────────────────────────────┘
 *
 * @private
 * @implements module:ui/toolbar/toolbarview~ToolbarBehavior
 */


var toolbarview_DynamicGrouping = /*#__PURE__*/function () {
  /**
   * Creates an instance of the {@link module:ui/toolbar/toolbarview~DynamicGrouping} toolbar
   * behavior.
   *
   * @param {module:ui/toolbar/toolbarview~ToolbarView} view An instance of the toolbar that this behavior
   * is added to.
   */
  function DynamicGrouping(view) {
    var _this5 = this;

    Object(classCallCheck["a" /* default */])(this, DynamicGrouping);

    /**
     * A collection of toolbar children.
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */
    this.viewChildren = view.children;
    /**
     * A collection of focusable toolbar elements.
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */

    this.viewFocusables = view.focusables;
    /**
     * A view containing toolbar items.
     *
     * @readonly
     * @member {module:ui/toolbar/toolbarview~ItemsView}
     */

    this.viewItemsView = view.itemsView;
    /**
     * Toolbar focus tracker.
     *
     * @readonly
     * @member {module:utils/focustracker~FocusTracker}
     */

    this.viewFocusTracker = view.focusTracker;
    /**
     * Toolbar locale.
     *
     * @readonly
     * @member {module:utils/locale~Locale}
     */

    this.viewLocale = view.locale;
    /**
     * Toolbar element.
     *
     * @readonly
     * @member {HTMLElement} #viewElement
     */

    /**
     * A subset of toolbar {@link module:ui/toolbar/toolbarview~ToolbarView#items}.
     * Aggregates items that fit into a single row of the toolbar and were not {@link #groupedItems grouped}
     * into a {@link #groupedItemsDropdown dropdown}. Items of this collection are displayed in the
     * {@link module:ui/toolbar/toolbarview~ToolbarView#itemsView}.
     *
     * When none of the {@link module:ui/toolbar/toolbarview~ToolbarView#items} were grouped, it
     * matches the {@link module:ui/toolbar/toolbarview~ToolbarView#items} collection in size and order.
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */

    this.ungroupedItems = view.createCollection();
    /**
     * A subset of toolbar {@link module:ui/toolbar/toolbarview~ToolbarView#items}.
     * A collection of the toolbar items that do not fit into a single row of the toolbar.
     * Grouped items are displayed in a dedicated {@link #groupedItemsDropdown dropdown}.
     *
     * When none of the {@link module:ui/toolbar/toolbarview~ToolbarView#items} were grouped,
     * this collection is empty.
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */

    this.groupedItems = view.createCollection();
    /**
     * The dropdown that aggregates {@link #groupedItems grouped items} that do not fit into a single
     * row of the toolbar. It is displayed on demand as the last of
     * {@link module:ui/toolbar/toolbarview~ToolbarView#children toolbar children} and offers another
     * (nested) toolbar which displays items that would normally overflow.
     *
     * @readonly
     * @member {module:ui/dropdown/dropdownview~DropdownView}
     */

    this.groupedItemsDropdown = this._createGroupedItemsDropdown();
    /**
     * An instance of the resize observer that helps dynamically determine the geometry of the toolbar
     * and manage items that do not fit into a single row.
     *
     * **Note:** Created in {@link #_enableGroupingOnResize}.
     *
     * @readonly
     * @member {module:utils/dom/resizeobserver~ResizeObserver}
     */

    this.resizeObserver = null;
    /**
     * A cached value of the horizontal padding style used by {@link #_updateGrouping}
     * to manage the {@link module:ui/toolbar/toolbarview~ToolbarView#items} that do not fit into
     * a single toolbar line. This value can be reused between updates because it is unlikely that
     * the padding will change and re–using `Window.getComputedStyle()` is expensive.
     *
     * @readonly
     * @member {Number}
     */

    this.cachedPadding = null;
    /**
     * A flag indicating that an items grouping update has been queued (e.g. due to the toolbar being visible)
     * and should be executed immediately the next time the toolbar shows up.
     *
     * @readonly
     * @member {Boolean}
     */

    this.shouldUpdateGroupingOnNextResize = false; // Only those items that were not grouped are visible to the user.

    view.itemsView.children.bindTo(this.ungroupedItems).using(function (item) {
      return item;
    }); // Make sure all #items visible in the main space of the toolbar are "focuscycleable".

    this.ungroupedItems.on('add', this._updateFocusCycleableItems.bind(this));
    this.ungroupedItems.on('remove', this._updateFocusCycleableItems.bind(this)); // Make sure the #groupedItemsDropdown is also included in cycling when it appears.

    view.children.on('add', this._updateFocusCycleableItems.bind(this));
    view.children.on('remove', this._updateFocusCycleableItems.bind(this)); // ToolbarView#items is dynamic. When an item is added, it should be automatically
    // represented in either grouped or ungrouped items at the right index.
    // In other words #items == concat( #ungroupedItems, #groupedItems )
    // (in length and order).

    view.items.on('add', function (evt, item, index) {
      if (index > _this5.ungroupedItems.length) {
        _this5.groupedItems.add(item, index - _this5.ungroupedItems.length);
      } else {
        _this5.ungroupedItems.add(item, index);
      } // When a new ungrouped item joins in and lands in #ungroupedItems, there's a chance it causes
      // the toolbar to overflow.


      _this5._updateGrouping();
    }); // When an item is removed from ToolbarView#items, it should be automatically
    // removed from either grouped or ungrouped items.

    view.items.on('remove', function (evt, item, index) {
      if (index > _this5.ungroupedItems.length) {
        _this5.groupedItems.remove(item);
      } else {
        _this5.ungroupedItems.remove(item);
      } // Whether removed from grouped or ungrouped items, there is a chance
      // some new space is available and we could do some ungrouping.


      _this5._updateGrouping();
    });
    view.extendTemplate({
      attributes: {
        class: [// To group items dynamically, the toolbar needs a dedicated CSS class.
        'ck-toolbar_grouping']
      }
    });
  }
  /**
   * Enables dynamic items grouping based on the dimensions of the toolbar.
   *
   * @param {module:ui/toolbar/toolbarview~ToolbarView} view An instance of the toolbar that this behavior
   * is added to.
   */


  Object(createClass["a" /* default */])(DynamicGrouping, [{
    key: "render",
    value: function render(view) {
      this.viewElement = view.element;

      this._enableGroupingOnResize();

      this._enableGroupingOnMaxWidthChange(view);
    }
    /**
     * Cleans up the internals used by this behavior.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      // The dropdown may not be in ToolbarView#children at the moment of toolbar destruction
      // so let's make sure it's actually destroyed along with the toolbar.
      this.groupedItemsDropdown.destroy();
      this.resizeObserver.destroy();
    }
    /**
     * When called, it will check if any of the {@link #ungroupedItems} do not fit into a single row of the toolbar,
     * and it will move them to the {@link #groupedItems} when it happens.
     *
     * At the same time, it will also check if there is enough space in the toolbar for the first of the
     * {@link #groupedItems} to be returned back to {@link #ungroupedItems} and still fit into a single row
     * without the toolbar wrapping.
     *
     * @protected
     */

  }, {
    key: "_updateGrouping",
    value: function _updateGrouping() {
      // Do no grouping–related geometry analysis when the toolbar is detached from visible DOM,
      // for instance before #render(), or after render but without a parent or a parent detached
      // from DOM. DOMRects won't work anyway and there will be tons of warning in the console and
      // nothing else. This happens, for instance, when the toolbar is detached from DOM and
      // some logic adds or removes its #items.
      if (!this.viewElement.ownerDocument.body.contains(this.viewElement)) {
        return;
      } // Do not update grouping when the element is invisible. Such toolbar has DOMRect filled with zeros
      // and that would cause all items to be grouped. Instead, queue the grouping so it runs next time
      // the toolbar is visible (the next ResizeObserver callback execution). This is handy because
      // the grouping could be caused by increasing the #maxWidth when the toolbar was invisible and the next
      // time it shows up, some items could actually be ungrouped (https://github.com/ckeditor/ckeditor5/issues/6575).


      if (!this.viewElement.offsetParent) {
        this.shouldUpdateGroupingOnNextResize = true;
        return;
      }

      var wereItemsGrouped; // Group #items as long as some wrap to the next row. This will happen, for instance,
      // when the toolbar is getting narrow and there is not enough space to display all items in
      // a single row.

      while (this._areItemsOverflowing) {
        this._groupLastItem();

        wereItemsGrouped = true;
      } // If none were grouped now but there were some items already grouped before,
      // then, what the hell, maybe let's see if some of them can be ungrouped. This happens when,
      // for instance, the toolbar is stretching and there's more space in it than before.


      if (!wereItemsGrouped && this.groupedItems.length) {
        // Ungroup items as long as none are overflowing or there are none to ungroup left.
        while (this.groupedItems.length && !this._areItemsOverflowing) {
          this._ungroupFirstItem();
        } // If the ungrouping ended up with some item wrapping to the next row,
        // put it back to the group toolbar ("undo the last ungroup"). We don't know whether
        // an item will wrap or not until we ungroup it (that's a DOM/CSS thing) so this
        // clean–up is vital for the algorithm.


        if (this._areItemsOverflowing) {
          this._groupLastItem();
        }
      }
    }
    /**
     * Returns `true` when {@link module:ui/toolbar/toolbarview~ToolbarView#element} children visually overflow,
     * for instance if the toolbar is narrower than its members. Returns `false` otherwise.
     *
     * @private
     * @type {Boolean}
     */

  }, {
    key: "_enableGroupingOnResize",

    /**
     * Enables the functionality that prevents {@link #ungroupedItems} from overflowing (wrapping to the next row)
     * upon resize when there is little space available. Instead, the toolbar items are moved to the
     * {@link #groupedItems} collection and displayed in a dropdown at the end of the row (which has its own nested toolbar).
     *
     * When called, the toolbar will automatically analyze the location of its {@link #ungroupedItems} and "group"
     * them in the dropdown if necessary. It will also observe the browser window for size changes in
     * the future and respond to them by grouping more items or reverting already grouped back, depending
     * on the visual space available.
     *
     * @private
     */
    value: function _enableGroupingOnResize() {
      var _this6 = this;

      var previousWidth; // TODO: Consider debounce.

      this.resizeObserver = new resizeobserver_ResizeObserver(this.viewElement, function (entry) {
        if (!previousWidth || previousWidth !== entry.contentRect.width || _this6.shouldUpdateGroupingOnNextResize) {
          _this6.shouldUpdateGroupingOnNextResize = false;

          _this6._updateGrouping();

          previousWidth = entry.contentRect.width;
        }
      });

      this._updateGrouping();
    }
    /**
     * Enables the grouping functionality, just like {@link #_enableGroupingOnResize} but the difference is that
     * it listens to the changes of {@link module:ui/toolbar/toolbarview~ToolbarView#maxWidth} instead.
     *
     * @private
     */

  }, {
    key: "_enableGroupingOnMaxWidthChange",
    value: function _enableGroupingOnMaxWidthChange(view) {
      var _this7 = this;

      view.on('change:maxWidth', function () {
        _this7._updateGrouping();
      });
    }
    /**
     * When called, it will remove the last item from {@link #ungroupedItems} and move it back
     * to the {@link #groupedItems} collection.
     *
     * The opposite of {@link #_ungroupFirstItem}.
     *
     * @private
     */

  }, {
    key: "_groupLastItem",
    value: function _groupLastItem() {
      if (!this.groupedItems.length) {
        this.viewChildren.add(new toolbarseparatorview_ToolbarSeparatorView());
        this.viewChildren.add(this.groupedItemsDropdown);
        this.viewFocusTracker.add(this.groupedItemsDropdown.element);
      }

      this.groupedItems.add(this.ungroupedItems.remove(this.ungroupedItems.last), 0);
    }
    /**
     * Moves the very first item belonging to {@link #groupedItems} back
     * to the {@link #ungroupedItems} collection.
     *
     * The opposite of {@link #_groupLastItem}.
     *
     * @private
     */

  }, {
    key: "_ungroupFirstItem",
    value: function _ungroupFirstItem() {
      this.ungroupedItems.add(this.groupedItems.remove(this.groupedItems.first));

      if (!this.groupedItems.length) {
        this.viewChildren.remove(this.groupedItemsDropdown);
        this.viewChildren.remove(this.viewChildren.last);
        this.viewFocusTracker.remove(this.groupedItemsDropdown.element);
      }
    }
    /**
     * Creates the {@link #groupedItemsDropdown} that hosts the members of the {@link #groupedItems}
     * collection when there is not enough space in the toolbar to display all items in a single row.
     *
     * @private
     * @returns {module:ui/dropdown/dropdownview~DropdownView}
     */

  }, {
    key: "_createGroupedItemsDropdown",
    value: function _createGroupedItemsDropdown() {
      var locale = this.viewLocale;
      var t = locale.t;
      var dropdown = createDropdown(locale);
      dropdown.class = 'ck-toolbar__grouped-dropdown'; // Make sure the dropdown never sticks out to the left/right. It should be under the main toolbar.
      // (https://github.com/ckeditor/ckeditor5/issues/5608)

      dropdown.panelPosition = locale.uiLanguageDirection === 'ltr' ? 'sw' : 'se';
      addToolbarToDropdown(dropdown, []);
      dropdown.buttonView.set({
        label: t('Show more items'),
        tooltip: true,
        icon: three_vertical_dots_default.a
      }); // 1:1 pass–through binding.

      dropdown.toolbarView.items.bindTo(this.groupedItems).using(function (item) {
        return item;
      });
      return dropdown;
    }
    /**
     * Updates the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables focus–cycleable items}
     * collection so it represents the up–to–date state of the UI from the perspective of the user.
     *
     * For instance, the {@link #groupedItemsDropdown} can show up and hide but when it is visible,
     * it must be subject to focus cycling in the toolbar.
     *
     * See the {@link module:ui/toolbar/toolbarview~ToolbarView#focusables collection} documentation
     * to learn more about the purpose of this method.
     *
     * @private
     */

  }, {
    key: "_updateFocusCycleableItems",
    value: function _updateFocusCycleableItems() {
      var _this8 = this;

      this.viewFocusables.clear();
      this.ungroupedItems.map(function (item) {
        _this8.viewFocusables.add(item);
      });

      if (this.groupedItems.length) {
        this.viewFocusables.add(this.groupedItemsDropdown);
      }
    }
  }, {
    key: "_areItemsOverflowing",
    get: function get() {
      // An empty toolbar cannot overflow.
      if (!this.ungroupedItems.length) {
        return false;
      }

      var element = this.viewElement;
      var uiLanguageDirection = this.viewLocale.uiLanguageDirection;
      var lastChildRect = new rect_Rect(element.lastChild);
      var toolbarRect = new rect_Rect(element);

      if (!this.cachedPadding) {
        var computedStyle = global.window.getComputedStyle(element);
        var paddingProperty = uiLanguageDirection === 'ltr' ? 'paddingRight' : 'paddingLeft'; // parseInt() is essential because of quirky floating point numbers logic and DOM.
        // If the padding turned out too big because of that, the grouped items dropdown would
        // always look (from the Rect perspective) like it overflows (while it's not).

        this.cachedPadding = Number.parseInt(computedStyle[paddingProperty]);
      }

      if (uiLanguageDirection === 'ltr') {
        return lastChildRect.right > toolbarRect.right - this.cachedPadding;
      } else {
        return lastChildRect.left < toolbarRect.left + this.cachedPadding;
      }
    }
  }]);

  return DynamicGrouping;
}();
/**
 * Options passed to the {@link module:ui/toolbar/toolbarview~ToolbarView#constructor} of the toolbar.
 *
 * @interface module:ui/toolbar/toolbarview~ToolbarOptions
 */

/**
 * When set to `true`, the toolbar will automatically group {@link module:ui/toolbar/toolbarview~ToolbarView#items} that
 * would normally wrap to the next line when there is not enough space to display them in a single row, for
 * instance, if the parent container of the toolbar is narrow.
 *
 * Also see: {@link module:ui/toolbar/toolbarview~ToolbarView#maxWidth}.
 *
 * @member {Boolean} module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull
 */

/**
 * A class interface defining the behavior of the {@link module:ui/toolbar/toolbarview~ToolbarView}.
 *
 * Toolbar behaviors extend its look and functionality and have an impact on the
 * {@link module:ui/toolbar/toolbarview~ToolbarView#element} template or
 * {@link module:ui/toolbar/toolbarview~ToolbarView#render rendering}. They can be enabled
 * conditionally, e.g. depending on the configuration of the toolbar.
 *
 * @private
 * @interface module:ui/toolbar/toolbarview~ToolbarBehavior
 */

/**
 * Creates a new toolbar behavior instance.
 *
 * The instance is created in the {@link module:ui/toolbar/toolbarview~ToolbarView#constructor} of the toolbar.
 * This is the right place to extend the {@link module:ui/toolbar/toolbarview~ToolbarView#template} of
 * the toolbar, define extra toolbar properties, etc.
 *
 * @method #constructor
 * @param {module:ui/toolbar/toolbarview~ToolbarView} view An instance of the toolbar that this behavior is added to.
 */

/**
 * A method called after the toolbar has been {@link module:ui/toolbar/toolbarview~ToolbarView#render rendered}.
 * It can be used to, for example, customize the behavior of the toolbar when its {@link module:ui/toolbar/toolbarview~ToolbarView#element}
 * is available.
 *
 * @readonly
 * @member {Function} #render
 * @param {module:ui/toolbar/toolbarview~ToolbarView} view An instance of the toolbar being rendered.
 */

/**
 * A method called after the toolbar has been {@link module:ui/toolbar/toolbarview~ToolbarView#destroy destroyed}.
 * It allows cleaning up after the toolbar behavior, for instance, this is the right place to detach
 * event listeners, free up references, etc.
 *
 * @readonly
 * @member {Function} #destroy
 */
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-editor-classic/theme/classiceditor.css
var classiceditor = __webpack_require__("6134");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-editor-classic/src/classiceditoruiview.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module editor-classic/classiceditoruiview
 */





/**
 * Classic editor UI view. Uses an inline editable and a sticky toolbar, all
 * enclosed in a boxed UI view.
 *
 * @extends module:ui/editorui/boxed/boxededitoruiview~BoxedEditorUIView
 */

var classiceditoruiview_ClassicEditorUIView = /*#__PURE__*/function (_BoxedEditorUIView) {
  Object(inherits["a" /* default */])(ClassicEditorUIView, _BoxedEditorUIView);

  var _super = Object(createSuper["a" /* default */])(ClassicEditorUIView);

  /**
   * Creates an instance of the classic editor UI view.
   *
   * @param {module:utils/locale~Locale} locale The {@link module:core/editor/editor~Editor#locale} instance.
   * @param {module:engine/view/view~View} editingView The editing view instance this view is related to.
   * @param {Object} [options={}] Configuration options fo the view instance.
   * @param {Boolean} [options.shouldToolbarGroupWhenFull] When set `true` enables automatic items grouping
   * in the main {@link module:editor-classic/classiceditoruiview~ClassicEditorUIView#toolbar toolbar}.
   * See {@link module:ui/toolbar/toolbarview~ToolbarOptions#shouldGroupWhenFull} to learn more.
   */
  function ClassicEditorUIView(locale, editingView) {
    var _this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    Object(classCallCheck["a" /* default */])(this, ClassicEditorUIView);

    _this = _super.call(this, locale);
    /**
     * Sticky panel view instance. This is a parent view of a {@link #toolbar}
     * that makes toolbar sticky.
     *
     * @readonly
     * @member {module:ui/panel/sticky/stickypanelview~StickyPanelView}
     */

    _this.stickyPanel = new stickypanelview_StickyPanelView(locale);
    /**
     * Toolbar view instance.
     *
     * @readonly
     * @member {module:ui/toolbar/toolbarview~ToolbarView}
     */

    _this.toolbar = new toolbarview_ToolbarView(locale, {
      shouldGroupWhenFull: options.shouldToolbarGroupWhenFull
    });
    /**
     * Editable UI view.
     *
     * @readonly
     * @member {module:ui/editableui/inline/inlineeditableuiview~InlineEditableUIView}
     */

    _this.editable = new inlineeditableuiview_InlineEditableUIView(locale, editingView);
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(ClassicEditorUIView, [{
    key: "render",
    value: function render() {
      get_get(Object(getPrototypeOf["a" /* default */])(ClassicEditorUIView.prototype), "render", this).call(this); // Set toolbar as a child of a stickyPanel and makes toolbar sticky.


      this.stickyPanel.content.add(this.toolbar);
      this.top.add(this.stickyPanel);
      this.main.add(this.editable);
    }
  }]);

  return ClassicEditorUIView;
}(boxededitoruiview_BoxedEditorUIView);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/dom/getdatafromelement.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* globals HTMLTextAreaElement */

/**
 * @module utils/dom/getdatafromelement
 */

/**
 * Gets data from a given source element.
 *
 * @param {HTMLElement} el The element from which the data will be retrieved.
 * @returns {String} The data string.
 */
function getDataFromElement(el) {
  if (el instanceof HTMLTextAreaElement) {
    return el.value;
  }

  return el.innerHTML;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-editor-classic/src/classiceditor.js










/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module editor-classic/classiceditor
 */











/**
 * The {@glink builds/guides/overview#classic-editor classic editor} implementation.
 * It uses an inline editable and a sticky toolbar, all enclosed in a boxed UI.
 * See the {@glink examples/builds/classic-editor demo}.
 *
 * In order to create a classic editor instance, use the static
 * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`} method.
 *
 * # Classic editor and classic build
 *
 * The classic editor can be used directly from source (if you installed the
 * [`@ckeditor/ckeditor5-editor-classic`](https://www.npmjs.com/package/@ckeditor/ckeditor5-editor-classic) package)
 * but it is also available in the {@glink builds/guides/overview#classic-editor classic build}.
 *
 * {@glink builds/guides/overview Builds} are ready-to-use editors with plugins bundled in. When using the editor from
 * source you need to take care of loading all plugins by yourself
 * (through the {@link module:core/editor/editorconfig~EditorConfig#plugins `config.plugins`} option).
 * Using the editor from source gives much better flexibility and allows easier customization.
 *
 * Read more about initializing the editor from source or as a build in
 * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}.
 *
 * @mixes module:core/editor/utils/dataapimixin~DataApiMixin
 * @mixes module:core/editor/utils/elementapimixin~ElementApiMixin
 * @implements module:core/editor/editorwithui~EditorWithUI
 * @extends module:core/editor/editor~Editor
 */

var classiceditor_ClassicEditor = /*#__PURE__*/function (_Editor) {
  Object(inherits["a" /* default */])(ClassicEditor, _Editor);

  var _super = Object(createSuper["a" /* default */])(ClassicEditor);

  /**
   * Creates an instance of the classic editor.
   *
   * **Note:** do not use the constructor to create editor instances. Use the static
   * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`} method instead.
   *
   * @protected
   * @param {HTMLElement|String} sourceElementOrData The DOM element that will be the source for the created editor
   * or the editor's initial data. For more information see
   * {@link module:editor-classic/classiceditor~ClassicEditor.create `ClassicEditor.create()`}.
   * @param {module:core/editor/editorconfig~EditorConfig} config The editor configuration.
   */
  function ClassicEditor(sourceElementOrData, config) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, ClassicEditor);

    _this = _super.call(this, config);

    if (lodash_es_isElement(sourceElementOrData)) {
      _this.sourceElement = sourceElementOrData;
    }

    _this.data.processor = new htmldataprocessor_HtmlDataProcessor(_this.data.viewDocument);

    _this.model.document.createRoot();

    var shouldToolbarGroupWhenFull = !_this.config.get('toolbar.shouldNotGroupWhenFull');
    var view = new classiceditoruiview_ClassicEditorUIView(_this.locale, _this.editing.view, {
      shouldToolbarGroupWhenFull: shouldToolbarGroupWhenFull
    });
    _this.ui = new classiceditorui_ClassicEditorUI(Object(assertThisInitialized["a" /* default */])(_this), view);
    attachToForm(Object(assertThisInitialized["a" /* default */])(_this));
    return _this;
  }
  /**
   * Destroys the editor instance, releasing all resources used by it.
   *
   * Updates the editor's source element with the data.
   *
   * @returns {Promise}
   */


  Object(createClass["a" /* default */])(ClassicEditor, [{
    key: "destroy",
    value: function destroy() {
      if (this.sourceElement) {
        this.updateSourceElement();
      }

      this.ui.destroy();
      return get_get(Object(getPrototypeOf["a" /* default */])(ClassicEditor.prototype), "destroy", this).call(this);
    }
    /**
     * Creates a new classic editor instance.
     *
     * There are three ways how the editor can be initialized.
     *
     * # Replacing a DOM element (and loading data from it)
     *
     * You can initialize the editor using an existing DOM element:
     *
     *		ClassicEditor
     *			.create( document.querySelector( '#editor' ) )
     *			.then( editor => {
     *				console.log( 'Editor was initialized', editor );
     *			} )
     *			.catch( err => {
     *				console.error( err.stack );
     *			} );
     *
     * The element's content will be used as the editor data and the element will be replaced by the editor UI.
     *
     * # Creating a detached editor
     *
     * Alternatively, you can initialize the editor by passing the initial data directly as a string.
     * In this case, the editor will render an element that must be inserted into the DOM:
     *
     *		ClassicEditor
     *			.create( '<p>Hello world!</p>' )
     *			.then( editor => {
     *				console.log( 'Editor was initialized', editor );
     *
     *				// Initial data was provided so the editor UI element needs to be added manually to the DOM.
     *				document.body.appendChild( editor.ui.element );
     *			} )
     *			.catch( err => {
     *				console.error( err.stack );
     *			} );
     *
     * This lets you dynamically append the editor to your web page whenever it is convenient for you. You may use this method if your
     * web page content is generated on the client side and the DOM structure is not ready at the moment when you initialize the editor.
     *
     * # Replacing a DOM element (and data provided in `config.initialData`)
     *
     * You can also mix these two ways by providing a DOM element to be used and passing the initial data through the configuration:
     *
     *		ClassicEditor
     *			.create( document.querySelector( '#editor' ), {
     *				initialData: '<h2>Initial data</h2><p>Foo bar.</p>'
     *			} )
     *			.then( editor => {
     *				console.log( 'Editor was initialized', editor );
     *			} )
     *			.catch( err => {
     *				console.error( err.stack );
     *			} );
     *
     * This method can be used to initialize the editor on an existing element with the specified content in case if your integration
     * makes it difficult to set the content of the source element.
     *
     * Note that an error will be thrown if you pass the initial data both as the first parameter and also in the configuration.
     *
     * # Configuring the editor
     *
     * See the {@link module:core/editor/editorconfig~EditorConfig editor configuration documentation} to learn more about
     * customizing plugins, toolbar and more.
     *
     * # Using the editor from source
     *
     * The code samples listed in the previous sections of this documentation assume that you are using an
     * {@glink builds/guides/overview editor build} (for example – `@ckeditor/ckeditor5-build-classic`).
     *
     * If you want to use the classic editor from source (`@ckeditor/ckeditor5-editor-classic/src/classiceditor`),
     * you need to define the list of
     * {@link module:core/editor/editorconfig~EditorConfig#plugins plugins to be initialized} and
     * {@link module:core/editor/editorconfig~EditorConfig#toolbar toolbar items}. Read more about using the editor from
     * source in the {@glink builds/guides/integration/advanced-setup "Advanced setup" guide}.
     *
     * @param {HTMLElement|String} sourceElementOrData The DOM element that will be the source for the created editor
     * or the editor's initial data.
     *
     * If a DOM element is passed, its content will be automatically loaded to the editor upon initialization
     * and the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element editor element} will replace the passed element
     * in the DOM (the original one will be hidden and the editor will be injected next to it).
     *
     * Moreover, the editor data will be set back to the original element once the editor is destroyed and when a form, in which
     * this element is contained, is submitted (if the original element is a `<textarea>`). This ensures seamless integration with native
     * web forms.
     *
     * If the initial data is passed, a detached editor will be created. In this case you need to insert it into the DOM manually.
     * It is available under the {@link module:editor-classic/classiceditorui~ClassicEditorUI#element `editor.ui.element`} property.
     *
     * @param {module:core/editor/editorconfig~EditorConfig} [config] The editor configuration.
     * @returns {Promise} A promise resolved once the editor is ready. The promise resolves with the created editor instance.
     */

  }], [{
    key: "create",
    value: function create(sourceElementOrData) {
      var _this2 = this;

      var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return new Promise(function (resolve) {
        var editor = new _this2(sourceElementOrData, config);
        resolve(editor.initPlugins().then(function () {
          return editor.ui.init(lodash_es_isElement(sourceElementOrData) ? sourceElementOrData : null);
        }).then(function () {
          if (!lodash_es_isElement(sourceElementOrData) && config.initialData) {
            // Documented in core/editor/editorconfig.jdoc.
            throw new ckeditorerror["b" /* default */]('editor-create-initial-data: ' + 'The config.initialData option cannot be used together with initial data passed in Editor.create().', null);
          }

          var initialData = config.initialData || getInitialData(sourceElementOrData);
          return editor.data.init(initialData);
        }).then(function () {
          return editor.fire('ready');
        }).then(function () {
          return editor;
        }));
      });
    }
  }]);

  return ClassicEditor;
}(editor_Editor);


mix(classiceditor_ClassicEditor, dataapimixin);
mix(classiceditor_ClassicEditor, elementapimixin);

function getInitialData(sourceElementOrData) {
  return lodash_es_isElement(sourceElementOrData) ? getDataFromElement(sourceElementOrData) : sourceElementOrData;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-core/src/plugin.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module core/plugin
 */


/**
 * The base class for CKEditor plugin classes.
 *
 * @implements module:core/plugin~PluginInterface
 * @mixes module:utils/observablemixin~ObservableMixin
 */

var plugin_Plugin = /*#__PURE__*/function () {
  /**
   * @inheritDoc
   */
  function Plugin(editor) {
    Object(classCallCheck["a" /* default */])(this, Plugin);

    /**
     * The editor instance.
     *
     * Note that most editors implement the {@link module:core/editor/editorwithui~EditorWithUI} interface in addition
     * to the base {@link module:core/editor/editor~Editor} interface. However, editors with an external UI
     * (i.e. Bootstrap-based) or a headless editor may not implement the {@link module:core/editor/editorwithui~EditorWithUI}
     * interface.
     *
     * Because of above, to make plugins more universal, it is recommended to split features into:
     *  - The "editing" part that only uses the {@link module:core/editor/editor~Editor} interface.
     *  - The "UI" part that uses both the {@link module:core/editor/editor~Editor} interface and
     *  the {@link module:core/editor/editorwithui~EditorWithUI} interface.
     *
     * @readonly
     * @member {module:core/editor/editor~Editor} #editor
     */
    this.editor = editor;
    /**
     * Flag indicating whether a plugin is enabled or disabled.
     * A disabled plugin will not transform text.
     *
     * Plugin can be simply disabled like that:
     *
     *		// Disable the plugin so that no toolbars are visible.
     *		editor.plugins.get( 'TextTransformation' ).isEnabled = false;
     *
     * You can also use {@link #forceDisabled} method.
     *
     * @observable
     * @readonly
     * @member {Boolean} #isEnabled
     */

    this.set('isEnabled', true);
    /**
     * Holds identifiers for {@link #forceDisabled} mechanism.
     *
     * @type {Set.<String>}
     * @private
     */

    this._disableStack = new Set();
  }
  /**
   * Disables the plugin.
   *
   * Plugin may be disabled by multiple features or algorithms (at once). When disabling a plugin, unique id should be passed
   * (e.g. feature name). The same identifier should be used when {@link #clearForceDisabled enabling back} the plugin.
   * The plugin becomes enabled only after all features {@link #clearForceDisabled enabled it back}.
   *
   * Disabling and enabling a plugin:
   *
   *		plugin.isEnabled; // -> true
   *		plugin.forceDisabled( 'MyFeature' );
   *		plugin.isEnabled; // -> false
   *		plugin.clearForceDisabled( 'MyFeature' );
   *		plugin.isEnabled; // -> true
   *
   * Plugin disabled by multiple features:
   *
   *		plugin.forceDisabled( 'MyFeature' );
   *		plugin.forceDisabled( 'OtherFeature' );
   *		plugin.clearForceDisabled( 'MyFeature' );
   *		plugin.isEnabled; // -> false
   *		plugin.clearForceDisabled( 'OtherFeature' );
   *		plugin.isEnabled; // -> true
   *
   * Multiple disabling with the same identifier is redundant:
   *
   *		plugin.forceDisabled( 'MyFeature' );
   *		plugin.forceDisabled( 'MyFeature' );
   *		plugin.clearForceDisabled( 'MyFeature' );
   *		plugin.isEnabled; // -> true
   *
   * **Note:** some plugins or algorithms may have more complex logic when it comes to enabling or disabling certain plugins,
   * so the plugin might be still disabled after {@link #clearForceDisabled} was used.
   *
   * @param {String} id Unique identifier for disabling. Use the same id when {@link #clearForceDisabled enabling back} the plugin.
   */


  Object(createClass["a" /* default */])(Plugin, [{
    key: "forceDisabled",
    value: function forceDisabled(id) {
      this._disableStack.add(id);

      if (this._disableStack.size == 1) {
        this.on('set:isEnabled', forceDisable, {
          priority: 'highest'
        });
        this.isEnabled = false;
      }
    }
    /**
     * Clears forced disable previously set through {@link #forceDisabled}. See {@link #forceDisabled}.
     *
     * @param {String} id Unique identifier, equal to the one passed in {@link #forceDisabled} call.
     */

  }, {
    key: "clearForceDisabled",
    value: function clearForceDisabled(id) {
      this._disableStack.delete(id);

      if (this._disableStack.size == 0) {
        this.off('set:isEnabled', forceDisable);
        this.isEnabled = true;
      }
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.stopListening();
    }
    /**
     * @inheritDoc
     */

  }], [{
    key: "isContextPlugin",
    get: function get() {
      return false;
    }
  }]);

  return Plugin;
}();


mix(plugin_Plugin, observablemixin);
/**
 * The base interface for CKEditor plugins.
 *
 * In its minimal form a plugin can be a simple function that accepts {@link module:core/editor/editor~Editor the editor}
 * as a parameter:
 *
 *		// A simple plugin that enables a data processor.
 *		function MyPlugin( editor ) {
 *			editor.data.processor = new MyDataProcessor();
 *		}
 *
 * In most cases however, you will want to inherit from the {@link module:core/plugin~Plugin} class which implements the
 * {@link module:utils/observablemixin~ObservableMixin} and is, therefore, more convenient:
 *
 *		class MyPlugin extends Plugin {
 *			init() {
 *				// `listenTo()` and `editor` are available thanks to `Plugin`.
 *				// By using `listenTo()` you will ensure that the listener is removed when
 *				// the plugin is destroyed.
 *				this.listenTo( this.editor.data, 'ready', () => {
 *					// Do something when the data is ready.
 *				} );
 *			}
 *		}
 *
 * The plugin can also implement methods (e.g. {@link module:core/plugin~PluginInterface#init `init()`} or
 * {@link module:core/plugin~PluginInterface#destroy `destroy()`}) which, when present, will be used to properly
 * initialize and destroy the plugin.
 *
 * **Note:** When defined as a plain function, the plugin acts as a constructor and will be
 * called in parallel with other plugins' {@link module:core/plugin~PluginInterface#constructor constructors}.
 * This means the code of that plugin will be executed **before** {@link module:core/plugin~PluginInterface#init `init()`} and
 * {@link module:core/plugin~PluginInterface#afterInit `afterInit()`} methods of other plugins and, for instance,
 * you cannot use it to extend other plugins' {@glink framework/guides/architecture/editing-engine#schema schema}
 * rules as they are defined later on during the `init()` stage.
 *
 * @interface PluginInterface
 */

/**
 * Creates a new plugin instance. This is the first step of the plugin initialization.
 * See also {@link #init} and {@link #afterInit}.
 *
 * A plugin is always instantiated after its {@link module:core/plugin~PluginInterface.requires dependencies} and the
 * {@link #init} and {@link #afterInit} methods are called in the same order.
 *
 * Usually, you will want to put your plugin's initialization code in the {@link #init} method.
 * The constructor can be understood as "before init" and used in special cases, just like
 * {@link #afterInit} serves the special "after init" scenarios (e.g.the code which depends on other
 * plugins, but which does not {@link module:core/plugin~PluginInterface.requires explicitly require} them).
 *
 * @method #constructor
 * @param {module:core/editor/editor~Editor} editor
 */

/**
 * An array of plugins required by this plugin.
 *
 * To keep the plugin class definition tight it is recommended to define this property as a static getter:
 *
 *		import Image from './image.js';
 *
 *		export default class ImageCaption {
 *			static get requires() {
 *				return [ Image ];
 *			}
 *		}
 *
 * @static
 * @readonly
 * @member {Array.<Function>|undefined} module:core/plugin~PluginInterface.requires
 */

/**
 * An optional name of the plugin. If set, the plugin will be available in
 * {@link module:core/plugincollection~PluginCollection#get} by its
 * name and its constructor. If not, then only by its constructor.
 *
 * The name should reflect the constructor name.
 *
 * To keep the plugin class definition tight, it is recommended to define this property as a static getter:
 *
 *		export default class ImageCaption {
 *			static get pluginName() {
 *				return 'ImageCaption';
 *			}
 *		}
 *
 * Note: The native `Function.name` property could not be used to keep the plugin name because
 * it will be mangled during code minification.
 *
 * Naming a plugin is necessary to enable removing it through the
 * {@link module:core/editor/editorconfig~EditorConfig#removePlugins `config.removePlugins`} option.
 *
 * @static
 * @readonly
 * @member {String|undefined} module:core/plugin~PluginInterface.pluginName
 */

/**
 * The second stage (after plugin {@link #constructor}) of the plugin initialization.
 * Unlike the plugin constructor this method can be asynchronous.
 *
 * A plugin's `init()` method is called after its {@link module:core/plugin~PluginInterface.requires dependencies} are initialized,
 * so in the same order as the constructors of these plugins.
 *
 * **Note:** This method is optional. A plugin instance does not need to have it defined.
 *
 * @method #init
 * @returns {null|Promise}
 */

/**
 * The third (and last) stage of the plugin initialization. See also {@link #constructor} and {@link #init}.
 *
 * **Note:** This method is optional. A plugin instance does not need to have it defined.
 *
 * @method #afterInit
 * @returns {null|Promise}
 */

/**
 * Destroys the plugin.
 *
 * **Note:** This method is optional. A plugin instance does not need to have it defined.
 *
 * @method #destroy
 * @returns {null|Promise}
 */

/**
 * A flag which defines if a plugin is allowed or not allowed to be used directly by a {@link module:core/context~Context}.
 *
 * @static
 * @readonly
 * @member {Boolean} module:core/plugin~PluginInterface.isContextPlugin
 */

/**
 * An array of loaded plugins.
 *
 * @typedef {Array.<module:core/plugin~PluginInterface>} module:core/plugin~LoadedPlugins
 */
// Helper function that forces plugin to be disabled.

function forceDisable(evt) {
  evt.return = false;
  evt.stop();
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-clipboard/src/datatransfer.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module clipboard/datatransfer
 */

/**
 * Facade over the native [`DataTransfer`](https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer) object.
 */
var datatransfer_DataTransfer = /*#__PURE__*/function () {
  function DataTransfer(nativeDataTransfer) {
    Object(classCallCheck["a" /* default */])(this, DataTransfer);

    /**
     * The array of files created from the native `DataTransfer#files` or `DataTransfer#items`.
     *
     * @readonly
     * @member {Array.<File>} #files
     */
    this.files = getFiles(nativeDataTransfer);
    /**
     * The native DataTransfer object.
     *
     * @private
     * @member {DataTransfer} #_native
     */

    this._native = nativeDataTransfer;
  }
  /**
   * Returns an array of available native content types.
   *
   * @returns {Array.<String>}
   */


  Object(createClass["a" /* default */])(DataTransfer, [{
    key: "getData",

    /**
     * Gets data from the data transfer by its mime type.
     *
     *		dataTransfer.getData( 'text/plain' );
     *
     * @param {String} type The mime type. E.g. `text/html` or `text/plain`.
     * @returns {String}
     */
    value: function getData(type) {
      return this._native.getData(type);
    }
    /**
     * Sets data in the data transfer.
     *
     * @param {String} type The mime type. E.g. `text/html` or `text/plain`.
     * @param {String} data
     */

  }, {
    key: "setData",
    value: function setData(type, data) {
      this._native.setData(type, data);
    }
  }, {
    key: "types",
    get: function get() {
      return this._native.types;
    }
  }]);

  return DataTransfer;
}();



function getFiles(nativeDataTransfer) {
  // DataTransfer.files and items are Array-like and might not have an iterable interface.
  var files = nativeDataTransfer.files ? Array.from(nativeDataTransfer.files) : [];
  var items = nativeDataTransfer.items ? Array.from(nativeDataTransfer.items) : [];

  if (files.length) {
    return files;
  } // Chrome have empty DataTransfer.files, but let get files through the items interface.


  return items.filter(function (item) {
    return item.kind === 'file';
  }).map(function (item) {
    return item.getAsFile();
  });
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-clipboard/src/clipboardobserver.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module clipboard/clipboardobserver
 */



/**
 * Clipboard events observer.
 *
 * Fires the following events:
 *
 * * {@link module:engine/view/document~Document#event:clipboardInput}
 * * {@link module:engine/view/document~Document#event:dragover}
 * * {@link module:engine/view/document~Document#event:drop}
 * * {@link module:engine/view/document~Document#event:paste}
 * * {@link module:engine/view/document~Document#event:copy}
 * * {@link module:engine/view/document~Document#event:cut}
 *
 * Note that this observer is not available by default (it is not added by the engine).
 * To make it available it needs to be added to {@link module:engine/view/document~Document} by
 * the {@link module:engine/view/view~View#addObserver `View#addObserver()`} method. You can also load the
 * {@link module:clipboard/clipboard~Clipboard} plugin which adds this observer automatically (because it uses it).
 *
 * @extends module:engine/view/observer/domeventobserver~DomEventObserver
 */

var clipboardobserver_ClipboardObserver = /*#__PURE__*/function (_DomEventObserver) {
  Object(inherits["a" /* default */])(ClipboardObserver, _DomEventObserver);

  var _super = Object(createSuper["a" /* default */])(ClipboardObserver);

  function ClipboardObserver(view) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, ClipboardObserver);

    _this = _super.call(this, view);
    var viewDocument = _this.document;
    _this.domEventType = ['paste', 'copy', 'cut', 'drop', 'dragover'];

    _this.listenTo(viewDocument, 'paste', handleInput, {
      priority: 'low'
    });

    _this.listenTo(viewDocument, 'drop', handleInput, {
      priority: 'low'
    });

    function handleInput(evt, data) {
      data.preventDefault();
      var targetRanges = data.dropRange ? [data.dropRange] : Array.from(viewDocument.selection.getRanges());
      var eventInfo = new eventinfo_EventInfo(viewDocument, 'clipboardInput');
      viewDocument.fire(eventInfo, {
        dataTransfer: data.dataTransfer,
        targetRanges: targetRanges
      }); // If CKEditor handled the input, do not bubble the original event any further.
      // This helps external integrations recognize that fact and act accordingly.
      // https://github.com/ckeditor/ckeditor5-upload/issues/92

      if (eventInfo.stop.called) {
        data.stopPropagation();
      }
    }

    return _this;
  }

  Object(createClass["a" /* default */])(ClipboardObserver, [{
    key: "onDomEvent",
    value: function onDomEvent(domEvent) {
      var evtData = {
        dataTransfer: new datatransfer_DataTransfer(domEvent.clipboardData ? domEvent.clipboardData : domEvent.dataTransfer)
      };

      if (domEvent.type == 'drop') {
        evtData.dropRange = getDropViewRange(this.view, domEvent);
      }

      this.fire(domEvent.type, domEvent, evtData);
    }
  }]);

  return ClipboardObserver;
}(domeventobserver_DomEventObserver);



function getDropViewRange(view, domEvent) {
  var domDoc = domEvent.target.ownerDocument;
  var x = domEvent.clientX;
  var y = domEvent.clientY;
  var domRange; // Webkit & Blink.

  if (domDoc.caretRangeFromPoint && domDoc.caretRangeFromPoint(x, y)) {
    domRange = domDoc.caretRangeFromPoint(x, y);
  } // FF.
  else if (domEvent.rangeParent) {
      domRange = domDoc.createRange();
      domRange.setStart(domEvent.rangeParent, domEvent.rangeOffset);
      domRange.collapse(true);
    }

  if (domRange) {
    return view.domConverter.domRangeToView(domRange);
  } else {
    return view.document.selection.getFirstRange();
  }
}
/**
 * Fired as a continuation of {@link #event:paste} and {@link #event:drop} events.
 *
 * It is a part of the {@glink framework/guides/deep-dive/clipboard#input-pipeline "clipboard input pipeline"}.
 *
 * Fired with a `dataTransfer` which comes from the clipboard and which content should be processed
 * and inserted into the editor.
 *
 * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}
 * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/view~View#addObserver} method.
 * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.
 *
 * @see module:clipboard/clipboardobserver~ClipboardObserver
 * @see module:clipboard/clipboard~Clipboard
 * @event module:engine/view/document~Document#event:clipboardInput
 * @param {Object} data Event data.
 * @param {module:clipboard/datatransfer~DataTransfer} data.dataTransfer Data transfer instance.
 * @param {Array.<module:engine/view/range~Range>} data.targetRanges Ranges which are the target of the operation
 * (usually – into which the content should be inserted).
 * If clipboard input was triggered by a paste operation, then these are the selection ranges. If by a drop operation,
 * then it's the drop position (which can be different than the selection at the moment of drop).
 */

/**
 * Fired when user drags content over one of the editables.
 *
 * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.
 *
 * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}
 * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/view~View#addObserver} method.
 * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.
 *
 * @see module:engine/view/document~Document#event:clipboardInput
 * @event module:engine/view/document~Document#event:dragover
 * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.
 */

/**
 * Fired when user dropped content into one of the editables.
 *
 * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.
 *
 * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}
 * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/view~View#addObserver} method.
 * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.
 *
 * @see module:engine/view/document~Document#event:clipboardInput
 * @event module:engine/view/document~Document#event:drop
 * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.
 * @param {module:engine/view/range~Range} dropRange The position into which the content is dropped.
 */

/**
 * Fired when user pasted content into one of the editables.
 *
 * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.
 *
 * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}
 * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/view~View#addObserver} method.
 * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.
 *
 * @see module:engine/view/document~Document#event:clipboardInput
 * @event module:engine/view/document~Document#event:paste
 * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.
 */

/**
 * Fired when user copied content from one of the editables.
 *
 * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.
 *
 * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}
 * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/view~View#addObserver} method.
 * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.
 *
 * @see module:clipboard/clipboardobserver~ClipboardObserver
 * @event module:engine/view/document~Document#event:copy
 * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.
 */

/**
 * Fired when user cut content from one of the editables.
 *
 * Introduced by {@link module:clipboard/clipboardobserver~ClipboardObserver}.
 *
 * Note that this event is not available by default. To make it available {@link module:clipboard/clipboardobserver~ClipboardObserver}
 * needs to be added to {@link module:engine/view/document~Document} by the {@link module:engine/view/view~View#addObserver} method.
 * It's done by the {@link module:clipboard/clipboard~Clipboard} feature. If it's not loaded, it must be done manually.
 *
 * @see module:clipboard/clipboardobserver~ClipboardObserver
 * @event module:engine/view/document~Document#event:cut
 * @param {module:clipboard/clipboardobserver~ClipboardEventData} data Event data.
 */

/**
 * The value of the {@link module:engine/view/document~Document#event:paste},
 * {@link module:engine/view/document~Document#event:copy} and {@link module:engine/view/document~Document#event:cut} events.
 *
 * In order to access clipboard data use `dataTransfer` property.
 *
 * @class module:clipboard/clipboardobserver~ClipboardEventData
 * @extends module:engine/view/observer/domeventdata~DomEventData
 */

/**
 * Data transfer instance.
 *
 * @readonly
 * @member {module:clipboard/datatransfer~DataTransfer} module:clipboard/clipboardobserver~ClipboardEventData#dataTransfer
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-clipboard/src/utils/plaintexttohtml.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module clipboard/utils/plaintexttohtml
 */

/**
 * Converts plain text to its HTML-ized version.
 *
 * @param {String} text The plain text to convert.
 * @returns {String} HTML generated from the plain text.
 */
function plainTextToHtml(text) {
  text = text // Encode <>.
  .replace(/</g, '&lt;').replace(/>/g, '&gt;') // Creates paragraphs for every line breaks.
  .replace(/\n/g, '</p><p>') // Preserve trailing spaces (only the first and last one – the rest is handled below).
  .replace(/^\s/, '&nbsp;').replace(/\s$/, '&nbsp;') // Preserve other subsequent spaces now.
  .replace(/\s\s/g, ' &nbsp;');

  if (text.indexOf('</p><p>') > -1) {
    // If we created paragraphs above, add the trailing ones.
    text = "<p>".concat(text, "</p>");
  } // TODO:
  // * What about '\nfoo' vs ' foo'?


  return text;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-clipboard/src/utils/normalizeclipboarddata.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module clipboard/utils/normalizeclipboarddata
 */

/**
 * Removes some popular browser quirks out of the clipboard data (HTML).
 *
 * @param {String} data The HTML data to normalize.
 * @returns {String} Normalized HTML.
 */
function normalizeClipboardData(data) {
  return data.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, function (fullMatch, spaces) {
    // Handle the most popular and problematic case when even a single space becomes an nbsp;.
    // Decode those to normal spaces. Read more in https://github.com/ckeditor/ckeditor5-clipboard/issues/2.
    if (spaces.length == 1) {
      return ' ';
    }

    return spaces;
  });
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-clipboard/src/utils/viewtoplaintext.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module clipboard/utils/viewtoplaintext
 */
// Elements which should not have empty-line padding.
// Most `view.ContainerElement` want to be separate by new-line, but some are creating one structure
// together (like `<li>`) so it is better to separate them by only one "\n".
var smallPaddingElements = ['figcaption', 'li'];
/**
 * Converts {@link module:engine/view/item~Item view item} and all of its children to plain text.
 *
 * @param {module:engine/view/item~Item} viewItem View item to convert.
 * @returns {String} Plain text representation of `viewItem`.
 */

function viewToPlainText(viewItem) {
  var text = '';

  if (viewItem.is('text') || viewItem.is('textProxy')) {
    // If item is `Text` or `TextProxy` simple take its text data.
    text = viewItem.data;
  } else if (viewItem.is('img') && viewItem.hasAttribute('alt')) {
    // Special case for images - use alt attribute if it is provided.
    text = viewItem.getAttribute('alt');
  } else {
    // Other elements are document fragments, attribute elements or container elements.
    // They don't have their own text value, so convert their children.
    var prev = null;

    var _iterator = _createForOfIteratorHelper(viewItem.getChildren()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var child = _step.value;
        var childText = viewToPlainText(child); // Separate container element children with one or more new-line characters.

        if (prev && (prev.is('containerElement') || child.is('containerElement'))) {
          if (smallPaddingElements.includes(prev.name) || smallPaddingElements.includes(child.name)) {
            text += '\n';
          } else {
            text += '\n\n';
          }
        }

        text += childText;
        prev = child;
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }

  return text;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-clipboard/src/clipboard.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module clipboard/clipboard
 */







/**
 * The clipboard feature. It is responsible for intercepting the `paste` and `drop` events and
 * passing the pasted content through the clipboard pipeline in order to insert it into the editor's content.
 * It also handles the `cut` and `copy` events to fill the native clipboard with serialized editor's data.
 *
 * Read more about the clipboard integration in {@glink framework/guides/deep-dive/clipboard "Clipboard" deep dive} guide.
 *
 * @extends module:core/plugin~Plugin
 */

var clipboard_Clipboard = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(Clipboard, _Plugin);

  var _super = Object(createSuper["a" /* default */])(Clipboard);

  function Clipboard() {
    Object(classCallCheck["a" /* default */])(this, Clipboard);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Clipboard, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this = this;

      var editor = this.editor;
      var modelDocument = editor.model.document;
      var view = editor.editing.view;
      var viewDocument = view.document;
      /**
       * Data processor used to convert pasted HTML to a view structure.
       *
       * @private
       * @member {module:engine/dataprocessor/htmldataprocessor~HtmlDataProcessor} #_htmlDataProcessor
       */

      this._htmlDataProcessor = new htmldataprocessor_HtmlDataProcessor(viewDocument);
      view.addObserver(clipboardobserver_ClipboardObserver); // The clipboard paste pipeline.
      // Pasting and dropping is disabled when editor is read-only.
      // See: https://github.com/ckeditor/ckeditor5-clipboard/issues/26.

      this.listenTo(viewDocument, 'clipboardInput', function (evt) {
        if (editor.isReadOnly) {
          evt.stop();
        }
      }, {
        priority: 'highest'
      });
      this.listenTo(viewDocument, 'clipboardInput', function (evt, data) {
        var dataTransfer = data.dataTransfer;
        var content = '';

        if (dataTransfer.getData('text/html')) {
          content = normalizeClipboardData(dataTransfer.getData('text/html'));
        } else if (dataTransfer.getData('text/plain')) {
          content = plainTextToHtml(dataTransfer.getData('text/plain'));
        }

        content = _this._htmlDataProcessor.toView(content);
        var eventInfo = new eventinfo_EventInfo(_this, 'inputTransformation');

        _this.fire(eventInfo, {
          content: content,
          dataTransfer: dataTransfer
        }); // If CKEditor handled the input, do not bubble the original event any further.
        // This helps external integrations recognize that fact and act accordingly.
        // https://github.com/ckeditor/ckeditor5-upload/issues/92


        if (eventInfo.stop.called) {
          evt.stop();
        }

        view.scrollToTheSelection();
      }, {
        priority: 'low'
      });
      this.listenTo(this, 'inputTransformation', function (evt, data) {
        if (!data.content.isEmpty) {
          var dataController = _this.editor.data;
          var model = _this.editor.model; // Convert the pasted content to a model document fragment.
          // Conversion is contextual, but in this case we need an "all allowed" context and for that
          // we use the $clipboardHolder item.

          var modelFragment = dataController.toModel(data.content, '$clipboardHolder');

          if (modelFragment.childCount == 0) {
            return;
          }

          model.insertContent(modelFragment);
          evt.stop();
        }
      }, {
        priority: 'low'
      }); // The clipboard copy/cut pipeline.

      function onCopyCut(evt, data) {
        var dataTransfer = data.dataTransfer;
        data.preventDefault();
        var content = editor.data.toView(editor.model.getSelectedContent(modelDocument.selection));
        viewDocument.fire('clipboardOutput', {
          dataTransfer: dataTransfer,
          content: content,
          method: evt.name
        });
      }

      this.listenTo(viewDocument, 'copy', onCopyCut, {
        priority: 'low'
      });
      this.listenTo(viewDocument, 'cut', function (evt, data) {
        // Cutting is disabled when editor is read-only.
        // See: https://github.com/ckeditor/ckeditor5-clipboard/issues/26.
        if (editor.isReadOnly) {
          data.preventDefault();
        } else {
          onCopyCut(evt, data);
        }
      }, {
        priority: 'low'
      });
      this.listenTo(viewDocument, 'clipboardOutput', function (evt, data) {
        if (!data.content.isEmpty) {
          data.dataTransfer.setData('text/html', _this._htmlDataProcessor.toData(data.content));
          data.dataTransfer.setData('text/plain', viewToPlainText(data.content));
        }

        if (data.method == 'cut') {
          editor.model.deleteContent(modelDocument.selection);
        }
      }, {
        priority: 'low'
      });
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'Clipboard';
    }
  }]);

  return Clipboard;
}(plugin_Plugin);
/**
 * Fired with a `content` and `dataTransfer` objects. The `content` which comes from the clipboard (was pasted or dropped)
 * should be processed in order to be inserted into the editor. The `dataTransfer` object is available
 * in case the transformation functions needs access to a raw clipboard data.
 *
 * It is a part of the {@glink framework/guides/deep-dive/clipboard#input-pipeline "clipboard input pipeline"}.
 *
 * @see module:clipboard/clipboardobserver~ClipboardObserver
 * @see module:clipboard/clipboard~Clipboard
 * @event module:clipboard/clipboard~Clipboard#event:inputTransformation
 * @param {Object} data Event data.
 * @param {module:engine/view/documentfragment~DocumentFragment} data.content Event data. Content to be inserted into the editor.
 * It can be modified by the event listeners. Read more about the clipboard pipelines in
 * {@glink framework/guides/deep-dive/clipboard "Clipboard" deep dive}.
 * @param {module:clipboard/datatransfer~DataTransfer} data.dataTransfer Data transfer instance.
 */

/**
 * Fired on {@link module:engine/view/document~Document#event:copy} and {@link module:engine/view/document~Document#event:cut}
 * with a copy of selected content. The content can be processed before it ends up in the clipboard.
 *
 * It is a part of the {@glink framework/guides/deep-dive/clipboard#output-pipeline "clipboard output pipeline"}.
 *
 * @see module:clipboard/clipboardobserver~ClipboardObserver
 * @see module:clipboard/clipboard~Clipboard
 * @event module:engine/view/document~Document#event:clipboardOutput
 * @param {module:clipboard/clipboard~ClipboardOutputEventData} data Event data.
 */

/**
 * The value of the {@link module:engine/view/document~Document#event:clipboardOutput} event.
 *
 * @class module:clipboard/clipboard~ClipboardOutputEventData
 */

/**
 * Data transfer instance.
 *
 * @readonly
 * @member {module:clipboard/datatransfer~DataTransfer} module:clipboard/clipboard~ClipboardOutputEventData#dataTransfer
 */

/**
 * Content to be put into the clipboard. It can be modified by the event listeners.
 * Read more about the clipboard pipelines in {@glink framework/guides/deep-dive/clipboard "Clipboard" deep dive}.
 *
 * @member {module:engine/view/documentfragment~DocumentFragment} module:clipboard/clipboard~ClipboardOutputEventData#content
 */

/**
 * Whether the event was triggered by copy or cut operation.
 *
 * @member {'copy'|'cut'} module:clipboard/clipboard~ClipboardOutputEventData#method
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-core/src/command.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module core/command
 */


/**
 * The base class for CKEditor commands.
 *
 * Commands are the main way to manipulate editor contents and state. They are mostly used by UI elements (or by other
 * commands) to make changes in the model. Commands are available in every part of code that has access to
 * the {@link module:core/editor/editor~Editor editor} instance.
 *
 * Instances of registered commands can be retrieved from {@link module:core/editor/editor~Editor#commands `editor.commands`}.
 * The easiest way to execute a command is through {@link module:core/editor/editor~Editor#execute `editor.execute()`}.
 *
 * By default commands are disabled when the editor is in {@link module:core/editor/editor~Editor#isReadOnly read-only} mode.
 *
 * @mixes module:utils/observablemixin~ObservableMixin
 */

var command_Command = /*#__PURE__*/function () {
  /**
   * Creates a new `Command` instance.
   *
   * @param {module:core/editor/editor~Editor} editor Editor on which this command will be used.
   */
  function Command(editor) {
    var _this = this;

    Object(classCallCheck["a" /* default */])(this, Command);

    /**
     * The editor on which this command will be used.
     *
     * @readonly
     * @member {module:core/editor/editor~Editor}
     */
    this.editor = editor;
    /**
     * The value of the command. A concrete command class should define what it represents for it.
     *
     * For example, the `'bold'` command's value indicates whether the selection starts in a bolded text.
     * And the value of the `'link'` command may be an object with links details.
     *
     * It is possible for a command to have no value (e.g. for stateless actions such as `'imageUpload'`).
     *
     * A concrete command class should control this value by overriding the {@link #refresh `refresh()`} method.
     *
     * @observable
     * @readonly
     * @member #value
     */

    this.set('value', undefined);
    /**
     * Flag indicating whether a command is enabled or disabled.
     * A disabled command will do nothing when executed.
     *
     * A concrete command class should control this value by overriding the {@link #refresh `refresh()`} method.
     *
     * It is possible to disable a command from "outside". For instance, in your integration you may want to disable
     * a certain set of commands for the time being. To do that, you can use the fact that `isEnabled` is observable
     * and it fires the `set:isEnabled` event every time anyone tries to modify its value:
     *
     *		function disableCommand( cmd ) {
     *			cmd.on( 'set:isEnabled', forceDisable, { priority: 'highest' } );
     *
     *			cmd.isEnabled = false;
     *
     *			// Make it possible to enable the command again.
     *			return () => {
     *				cmd.off( 'set:isEnabled', forceDisable );
     *				cmd.refresh();
     *			};
     *
     *			function forceDisable( evt ) {
     *				evt.return = false;
     *				evt.stop();
     *			}
     *		}
     *
     *		// Usage:
     *
     *		// Disabling the command.
     *		const enableBold = disableCommand( editor.commands.get( 'bold' ) );
     *
     *		// Enabling the command again.
     *		enableBold();
     *
     * @observable
     * @readonly
     * @member {Boolean} #isEnabled
     */

    this.set('isEnabled', false);
    /**
     * Holds identifiers for {@link #forceDisabled} mechanism.
     *
     * @type {Set.<String>}
     * @private
     */

    this._disableStack = new Set();
    this.decorate('execute'); // By default every command is refreshed when changes are applied to the model.

    this.listenTo(this.editor.model.document, 'change', function () {
      _this.refresh();
    });
    this.on('execute', function (evt) {
      if (!_this.isEnabled) {
        evt.stop();
      }
    }, {
      priority: 'high'
    }); // By default commands are disabled when the editor is in read-only mode.

    this.listenTo(editor, 'change:isReadOnly', function (evt, name, value) {
      if (value) {
        _this.forceDisabled('readOnlyMode');
      } else {
        _this.clearForceDisabled('readOnlyMode');
      }
    });
  }
  /**
   * Refreshes the command. The command should update its {@link #isEnabled} and {@link #value} properties
   * in this method.
   *
   * This method is automatically called when
   * {@link module:engine/model/document~Document#event:change any changes are applied to the document}.
   */


  Object(createClass["a" /* default */])(Command, [{
    key: "refresh",
    value: function refresh() {
      this.isEnabled = true;
    }
    /**
     * Disables the command.
     *
     * Command may be disabled by multiple features or algorithms (at once). When disabling a command, unique id should be passed
     * (e.g. feature name). The same identifier should be used when {@link #clearForceDisabled enabling back} the command.
     * The command becomes enabled only after all features {@link #clearForceDisabled enabled it back}.
     *
     * Disabling and enabling a command:
     *
     *		command.isEnabled; // -> true
     *		command.forceDisabled( 'MyFeature' );
     *		command.isEnabled; // -> false
     *		command.clearForceDisabled( 'MyFeature' );
     *		command.isEnabled; // -> true
     *
     * Command disabled by multiple features:
     *
     *		command.forceDisabled( 'MyFeature' );
     *		command.forceDisabled( 'OtherFeature' );
     *		command.clearForceDisabled( 'MyFeature' );
     *		command.isEnabled; // -> false
     *		command.clearForceDisabled( 'OtherFeature' );
     *		command.isEnabled; // -> true
     *
     * Multiple disabling with the same identifier is redundant:
     *
     *		command.forceDisabled( 'MyFeature' );
     *		command.forceDisabled( 'MyFeature' );
     *		command.clearForceDisabled( 'MyFeature' );
     *		command.isEnabled; // -> true
     *
     * **Note:** some commands or algorithms may have more complex logic when it comes to enabling or disabling certain commands,
     * so the command might be still disabled after {@link #clearForceDisabled} was used.
     *
     * @param {String} id Unique identifier for disabling. Use the same id when {@link #clearForceDisabled enabling back} the command.
     */

  }, {
    key: "forceDisabled",
    value: function forceDisabled(id) {
      this._disableStack.add(id);

      if (this._disableStack.size == 1) {
        this.on('set:isEnabled', command_forceDisable, {
          priority: 'highest'
        });
        this.isEnabled = false;
      }
    }
    /**
     * Clears forced disable previously set through {@link #forceDisabled}. See {@link #forceDisabled}.
     *
     * @param {String} id Unique identifier, equal to the one passed in {@link #forceDisabled} call.
     */

  }, {
    key: "clearForceDisabled",
    value: function clearForceDisabled(id) {
      this._disableStack.delete(id);

      if (this._disableStack.size == 0) {
        this.off('set:isEnabled', command_forceDisable);
        this.refresh();
      }
    }
    /**
     * Executes the command.
     *
     * A command may accept parameters. They will be passed from {@link module:core/editor/editor~Editor#execute `editor.execute()`}
     * to the command.
     *
     * The `execute()` method will automatically abort when the command is disabled ({@link #isEnabled} is `false`).
     * This behavior is implemented by a high priority listener to the {@link #event:execute} event.
     *
     * In order to see how to disable a command from "outside" see the {@link #isEnabled} documentation.
     *
     * @fires execute
     */

  }, {
    key: "execute",
    value: function execute() {}
    /**
     * Destroys the command.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.stopListening();
    }
    /**
     * Event fired by the {@link #execute} method. The command action is a listener to this event so it's
     * possible to change/cancel the behavior of the command by listening to this event.
     *
     * See {@link module:utils/observablemixin~ObservableMixin#decorate} for more information and samples.
     *
     * **Note:** This event is fired even if command is disabled. However, it is automatically blocked
     * by a high priority listener in order to prevent command execution.
     *
     * @event execute
     */

  }]);

  return Command;
}();


mix(command_Command, observablemixin); // Helper function that forces command to be disabled.

function command_forceDisable(evt) {
  evt.return = false;
  evt.stop();
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-enter/src/utils.js



var utils_marked = /*#__PURE__*/regeneratorRuntime.mark(getCopyOnEnterAttributes);

/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module enter/utils
 */

/**
 * Returns attributes that should be preserved on the enter key.
 *
 * Filtering is realized based on `copyOnEnter` attribute property. Read more about attribute properties
 * {@link module:engine/model/schema~Schema#setAttributeProperties here}.
 *
 * @param {module:engine/model/schema~Schema} schema
 * @param {Iterable.<*>} allAttributes attributes to filter.
 * @returns {Iterable.<*>}
 */
function getCopyOnEnterAttributes(schema, allAttributes) {
  var _iterator, _step, attribute;

  return regeneratorRuntime.wrap(function getCopyOnEnterAttributes$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          _iterator = _createForOfIteratorHelper(allAttributes);
          _context.prev = 1;

          _iterator.s();

        case 3:
          if ((_step = _iterator.n()).done) {
            _context.next = 10;
            break;
          }

          attribute = _step.value;

          if (!(attribute && schema.getAttributeProperties(attribute[0]).copyOnEnter)) {
            _context.next = 8;
            break;
          }

          _context.next = 8;
          return attribute;

        case 8:
          _context.next = 3;
          break;

        case 10:
          _context.next = 15;
          break;

        case 12:
          _context.prev = 12;
          _context.t0 = _context["catch"](1);

          _iterator.e(_context.t0);

        case 15:
          _context.prev = 15;

          _iterator.f();

          return _context.finish(15);

        case 18:
        case "end":
          return _context.stop();
      }
    }
  }, utils_marked, null, [[1, 12, 15, 18]]);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-enter/src/entercommand.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module enter/entercommand
 */


/**
 * Enter command. It is used by the {@link module:enter/enter~Enter Enter feature} to handle the <kbd>Enter</kbd> key.
 *
 * @extends module:core/command~Command
 */

var entercommand_EnterCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(EnterCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(EnterCommand);

  function EnterCommand() {
    Object(classCallCheck["a" /* default */])(this, EnterCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(EnterCommand, [{
    key: "execute",

    /**
     * @inheritDoc
     */
    value: function execute() {
      var _this = this;

      var model = this.editor.model;
      var doc = model.document;
      model.change(function (writer) {
        enterBlock(_this.editor.model, writer, doc.selection, model.schema);

        _this.fire('afterExecute', {
          writer: writer
        });
      });
    }
  }]);

  return EnterCommand;
}(command_Command); // Creates a new block in the way that the <kbd>Enter</kbd> key is expected to work.
//
// @param {module:engine/model~Model} model
// @param {module:engine/model/writer~Writer} writer
// @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection
// Selection on which the action should be performed.
// @param {module:engine/model/schema~Schema} schema




function enterBlock(model, writer, selection, schema) {
  var isSelectionEmpty = selection.isCollapsed;
  var range = selection.getFirstRange();
  var startElement = range.start.parent;
  var endElement = range.end.parent; // Don't touch the roots and other limit elements.

  if (schema.isLimit(startElement) || schema.isLimit(endElement)) {
    // Delete the selected content but only if inside a single limit element.
    // Abort, when crossing limit elements boundary (e.g. <limit1>x[x</limit1>donttouchme<limit2>y]y</limit2>).
    // This is an edge case and it's hard to tell what should actually happen because such a selection
    // is not entirely valid.
    if (!isSelectionEmpty && startElement == endElement) {
      model.deleteContent(selection);
    }

    return;
  }

  if (isSelectionEmpty) {
    var attributesToCopy = getCopyOnEnterAttributes(writer.model.schema, selection.getAttributes());
    splitBlock(writer, range.start);
    writer.setSelectionAttribute(attributesToCopy);
  } else {
    var leaveUnmerged = !(range.start.isAtStart && range.end.isAtEnd);
    var isContainedWithinOneElement = startElement == endElement;
    model.deleteContent(selection, {
      leaveUnmerged: leaveUnmerged
    });

    if (leaveUnmerged) {
      // Partially selected elements.
      //
      // <h>x[xx]x</h>		-> <h>x^x</h>			-> <h>x</h><h>^x</h>
      if (isContainedWithinOneElement) {
        splitBlock(writer, selection.focus);
      } // Selection over multiple elements.
      //
      // <h>x[x</h><p>y]y<p>	-> <h>x^</h><p>y</p>	-> <h>x</h><p>^y</p>
      else {
          writer.setSelection(endElement, 0);
        }
    }
  }
}

function splitBlock(writer, splitPos) {
  writer.split(splitPos);
  writer.setSelection(splitPos.parent.nextSibling, 0);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-enter/src/enterobserver.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module enter/enterobserver
 */



/**
 * Enter observer introduces the {@link module:engine/view/document~Document#event:enter} event.
 *
 * @extends module:engine/view/observer/observer~Observer
 */

var enterobserver_EnterObserver = /*#__PURE__*/function (_Observer) {
  Object(inherits["a" /* default */])(EnterObserver, _Observer);

  var _super = Object(createSuper["a" /* default */])(EnterObserver);

  function EnterObserver(view) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, EnterObserver);

    _this = _super.call(this, view);
    var doc = _this.document;
    doc.on('keydown', function (evt, data) {
      if (_this.isEnabled && data.keyCode == keyCodes.enter) {
        // Save the event object to check later if it was stopped or not.
        var event;
        doc.once('enter', function (evt) {
          return event = evt;
        }, {
          priority: 'highest'
        });
        doc.fire('enter', new domeventdata_DomEventData(doc, data.domEvent, {
          isSoft: data.shiftKey
        })); // Stop `keydown` event if `enter` event was stopped.
        // https://github.com/ckeditor/ckeditor5/issues/753

        if (event && event.stop.called) {
          evt.stop();
        }
      }
    });
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(EnterObserver, [{
    key: "observe",
    value: function observe() {}
  }]);

  return EnterObserver;
}(observer_Observer);
/**
 * Event fired when the user presses the <kbd>Enter</kbd> key.
 *
 * Note: This event is fired by the {@link module:enter/enterobserver~EnterObserver observer}
 * (usually registered by the {@link module:enter/enter~Enter Enter feature} and
 * {@link module:enter/shiftenter~ShiftEnter ShiftEnter feature}).
 *
 * @event module:engine/view/document~Document#event:enter
 * @param {module:engine/view/observer/domeventdata~DomEventData} data
 * @param {Boolean} data.isSoft Whether it's a soft enter (<kbd>Shift</kbd>+<kbd>Enter</kbd>) or hard enter (<kbd>Enter</kbd>).
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-enter/src/enter.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module enter/enter
 */



/**
 * This plugin handles the <kbd>Enter</kbd> key (hard line break) in the editor.
 *
 * See also the {@link module:enter/shiftenter~ShiftEnter} plugin.
 *
 * For more information about this feature see the {@glink api/enter package page}.
 *
 * @extends module:core/plugin~Plugin
 */

var enter_Enter = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(Enter, _Plugin);

  var _super = Object(createSuper["a" /* default */])(Enter);

  function Enter() {
    Object(classCallCheck["a" /* default */])(this, Enter);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Enter, [{
    key: "init",
    value: function init() {
      var editor = this.editor;
      var view = editor.editing.view;
      var viewDocument = view.document;
      view.addObserver(enterobserver_EnterObserver);
      editor.commands.add('enter', new entercommand_EnterCommand(editor));
      this.listenTo(viewDocument, 'enter', function (evt, data) {
        data.preventDefault(); // The soft enter key is handled by the ShiftEnter plugin.

        if (data.isSoft) {
          return;
        }

        editor.execute('enter');
        view.scrollToTheSelection();
      }, {
        priority: 'low'
      });
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'Enter';
    }
  }]);

  return Enter;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-enter/src/shiftentercommand.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module enter/shiftentercommand
 */


/**
 * ShiftEnter command. It is used by the {@link module:enter/shiftenter~ShiftEnter ShiftEnter feature} to handle
 * the <kbd>Shift</kbd>+<kbd>Enter</kbd> keystroke.
 *
 * @extends module:core/command~Command
 */

var shiftentercommand_ShiftEnterCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(ShiftEnterCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(ShiftEnterCommand);

  function ShiftEnterCommand() {
    Object(classCallCheck["a" /* default */])(this, ShiftEnterCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ShiftEnterCommand, [{
    key: "execute",

    /**
     * @inheritDoc
     */
    value: function execute() {
      var _this = this;

      var model = this.editor.model;
      var doc = model.document;
      model.change(function (writer) {
        softBreakAction(model, writer, doc.selection);

        _this.fire('afterExecute', {
          writer: writer
        });
      });
    }
  }, {
    key: "refresh",
    value: function refresh() {
      var model = this.editor.model;
      var doc = model.document;
      this.isEnabled = isEnabled(model.schema, doc.selection);
    }
  }]);

  return ShiftEnterCommand;
}(command_Command); // Checks whether the ShiftEnter command should be enabled in the specified selection.
//
// @param {module:engine/model/schema~Schema} schema
// @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection




function isEnabled(schema, selection) {
  // At this moment it is okay to support single range selections only.
  // But in the future we may need to change that.
  if (selection.rangeCount > 1) {
    return false;
  }

  var anchorPos = selection.anchor; // Check whether the break element can be inserted in the current selection anchor.

  if (!anchorPos || !schema.checkChild(anchorPos, 'softBreak')) {
    return false;
  }

  var range = selection.getFirstRange();
  var startElement = range.start.parent;
  var endElement = range.end.parent; // Do not modify the content if selection is cross-limit elements.

  if ((isInsideLimitElement(startElement, schema) || isInsideLimitElement(endElement, schema)) && startElement !== endElement) {
    return false;
  }

  return true;
} // Creates a break in the way that the <kbd>Shift</kbd>+<kbd>Enter</kbd> keystroke is expected to work.
//
// @param {module:engine/model~Model} model
// @param {module:engine/model/writer~Writer} writer
// @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection
// Selection on which the action should be performed.


function softBreakAction(model, writer, selection) {
  var isSelectionEmpty = selection.isCollapsed;
  var range = selection.getFirstRange();
  var startElement = range.start.parent;
  var endElement = range.end.parent;
  var isContainedWithinOneElement = startElement == endElement;

  if (isSelectionEmpty) {
    var attributesToCopy = getCopyOnEnterAttributes(model.schema, selection.getAttributes());
    insertBreak(model, writer, range.end);
    writer.removeSelectionAttribute(selection.getAttributeKeys());
    writer.setSelectionAttribute(attributesToCopy);
  } else {
    var leaveUnmerged = !(range.start.isAtStart && range.end.isAtEnd);
    model.deleteContent(selection, {
      leaveUnmerged: leaveUnmerged
    }); // Selection within one element:
    //
    // <h>x[xx]x</h>		-> <h>x^x</h>			-> <h>x<br>^x</h>

    if (isContainedWithinOneElement) {
      insertBreak(model, writer, selection.focus);
    } // Selection over multiple elements.
    //
    // <h>x[x</h><p>y]y<p>	-> <h>x^</h><p>y</p>	-> <h>x</h><p>^y</p>
    //
    // We chose not to insert a line break in this case because:
    //
    // * it's not a very common scenario,
    // * it actually surprised me when I saw the "expected behavior" in real life.
    //
    // It's ok if the user will need to be more specific where they want the <br> to be inserted.
    else {
        // Move the selection to the 2nd element (last step of the example above).
        if (leaveUnmerged) {
          writer.setSelection(endElement, 0);
        }
      }
  }
}

function insertBreak(model, writer, position) {
  var breakLineElement = writer.createElement('softBreak');
  model.insertContent(breakLineElement, position);
  writer.setSelection(breakLineElement, 'after');
} // Checks whether the specified `element` is a child of the limit element.
//
// Checking whether the `<p>` element is inside a limit element:
//   - <$root><p>Text.</p></$root> => false
//   - <$root><limitElement><p>Text</p></limitElement></$root> => true
//
// @param {module:engine/model/element~Element} element
// @param {module:engine/schema~Schema} schema
// @returns {Boolean}


function isInsideLimitElement(element, schema) {
  // `$root` is a limit element but in this case is an invalid element.
  if (element.is('rootElement')) {
    return false;
  }

  return schema.isLimit(element) || isInsideLimitElement(element.parent, schema);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-enter/src/shiftenter.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module enter/shiftenter
 */



/**
 * This plugin handles the <kbd>Shift</kbd>+<kbd>Enter</kbd> keystroke (soft line break) in the editor.
 *
 * See also the {@link module:enter/enter~Enter} plugin.
 *
 * For more information about this feature see the {@glink api/enter package page}.
 *
 * @extends module:core/plugin~Plugin
 */

var shiftenter_ShiftEnter = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ShiftEnter, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ShiftEnter);

  function ShiftEnter() {
    Object(classCallCheck["a" /* default */])(this, ShiftEnter);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ShiftEnter, [{
    key: "init",
    value: function init() {
      var editor = this.editor;
      var schema = editor.model.schema;
      var conversion = editor.conversion;
      var view = editor.editing.view;
      var viewDocument = view.document; // Configure the schema.

      schema.register('softBreak', {
        allowWhere: '$text',
        isInline: true
      }); // Configure converters.

      conversion.for('upcast').elementToElement({
        model: 'softBreak',
        view: 'br'
      });
      conversion.for('downcast').elementToElement({
        model: 'softBreak',
        view: function view(modelElement, viewWriter) {
          return viewWriter.createEmptyElement('br');
        }
      });
      view.addObserver(enterobserver_EnterObserver);
      editor.commands.add('shiftEnter', new shiftentercommand_ShiftEnterCommand(editor));
      this.listenTo(viewDocument, 'enter', function (evt, data) {
        data.preventDefault(); // The hard enter key is handled by the Enter plugin.

        if (!data.isSoft) {
          return;
        }

        editor.execute('shiftEnter');
        view.scrollToTheSelection();
      }, {
        priority: 'low'
      });
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'ShiftEnter';
    }
  }]);

  return ShiftEnter;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-select-all/src/selectallcommand.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module select-all/selectallcommand
 */

/**
 * The select all command.
 *
 * It is used by the {@link module:select-all/selectallediting~SelectAllEditing select all editing feature} to handle
 * the <kbd>Ctrl/⌘</kbd>+<kbd>A</kbd> keystroke.
 *
 * Executing this command changes the {@glink framework/guides/architecture/editing-engine#model model}
 * selection so it contains the entire content of the editable root of the editor the selection is
 * {@link module:engine/model/selection~Selection#anchor anchored} in.
 *
 * If the selection was anchored in a {@glink framework/guides/tutorials/implementing-a-block-widget nested editable}
 * (e.g. a caption of an image), the new selection will contain its entire content. Successive executions of this command
 * will expand the selection to encompass more and more content up to the entire editable root of the editor.
 *
 * @extends module:core/command~Command
 */

var selectallcommand_SelectAllCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(SelectAllCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(SelectAllCommand);

  function SelectAllCommand() {
    Object(classCallCheck["a" /* default */])(this, SelectAllCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(SelectAllCommand, [{
    key: "execute",

    /**
     * @inheritDoc
     */
    value: function execute() {
      var model = this.editor.model;
      var selection = model.document.selection;
      var scopeElement = model.schema.getLimitElement(selection); // If an entire scope is selected, or the selection's ancestor is not a scope yet,
      // browse through ancestors to find the enclosing parent scope.

      if (selection.containsEntireContent(scopeElement) || !isSelectAllScope(model.schema, scopeElement)) {
        do {
          scopeElement = scopeElement.parent; // Do nothing, if the entire `root` is already selected.

          if (!scopeElement) {
            return;
          }
        } while (!isSelectAllScope(model.schema, scopeElement));
      }

      model.change(function (writer) {
        writer.setSelection(scopeElement, 'in');
      });
    }
  }]);

  return SelectAllCommand;
}(command_Command); // Checks whether the element is a valid select-all scope.
// Returns true, if the element is a {@link module:engine/model/schema~Schema#isLimit limit},
// and can contain any text or paragraph.
//
// @param {module:engine/model/schema~Schema} schema The schema to check against.
// @param {module:engine/model/element~Element} element
// @return {Boolean}




function isSelectAllScope(schema, element) {
  return schema.isLimit(element) && (schema.checkChild(element, '$text') || schema.checkChild(element, 'paragraph'));
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-select-all/src/selectallediting.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module select-all/selectallediting
 */



var SELECT_ALL_KEYSTROKE = parseKeystroke('Ctrl+A');
/**
 * The select all editing feature.
 *
 * It registers the `'selectAll'` {@link module:select-all/selectallcommand~SelectAllCommand command}
 * and the <kbd>Ctrl/⌘</kbd>+<kbd>A</kbd> keystroke listener which executes it.
 *
 * @extends module:core/plugin~Plugin
 */

var selectallediting_SelectAllEditing = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(SelectAllEditing, _Plugin);

  var _super = Object(createSuper["a" /* default */])(SelectAllEditing);

  function SelectAllEditing() {
    Object(classCallCheck["a" /* default */])(this, SelectAllEditing);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(SelectAllEditing, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var editor = this.editor;
      var view = editor.editing.view;
      var viewDocument = view.document;
      editor.commands.add('selectAll', new selectallcommand_SelectAllCommand(editor));
      this.listenTo(viewDocument, 'keydown', function (eventInfo, domEventData) {
        if (getCode(domEventData) === SELECT_ALL_KEYSTROKE) {
          editor.execute('selectAll');
          domEventData.preventDefault();
        }
      });
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'SelectAllEditing';
    }
  }]);

  return SelectAllEditing;
}(plugin_Plugin);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-select-all/theme/icons/select-all.svg
var select_all = __webpack_require__("fa71");
var select_all_default = /*#__PURE__*/__webpack_require__.n(select_all);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-select-all/src/selectallui.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module select-all/selectallui
 */



/**
 * The select all UI feature.
 *
 * It registers the `'selectAll'` UI button in the editor's
 * {@link module:ui/componentfactory~ComponentFactory component factory}. When clicked, the button
 * executes the {@link module:select-all/selectallcommand~SelectAllCommand select all command}.
 *
 * @extends module:core/plugin~Plugin
 */

var selectallui_SelectAllUI = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(SelectAllUI, _Plugin);

  var _super = Object(createSuper["a" /* default */])(SelectAllUI);

  function SelectAllUI() {
    Object(classCallCheck["a" /* default */])(this, SelectAllUI);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(SelectAllUI, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this = this;

      var editor = this.editor;
      editor.ui.componentFactory.add('selectAll', function (locale) {
        var command = editor.commands.get('selectAll');
        var view = new buttonview_ButtonView(locale);
        var t = locale.t;
        view.set({
          label: t('Select all'),
          icon: select_all_default.a,
          keystroke: 'Ctrl+A',
          tooltip: true
        });
        view.bind('isOn', 'isEnabled').to(command, 'value', 'isEnabled'); // Execute the command.

        _this.listenTo(view, 'execute', function () {
          editor.execute('selectAll');
          editor.editing.view.focus();
        });

        return view;
      });
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'SelectAllUI';
    }
  }]);

  return SelectAllUI;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-select-all/src/selectall.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module select-all/selectall
 */



/**
 * The select all feature.
 *
 * This is a "glue" plugin which loads the {@link module:select-all/selectallediting~SelectAllEditing select all editing feature}
 * and the {@link module:select-all/selectallui~SelectAllUI select all UI feature}.
 *
 * Please refer to the documentation of individual features to learn more.
 *
 * @extends module:core/plugin~Plugin
 */

var selectall_SelectAll = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(SelectAll, _Plugin);

  var _super = Object(createSuper["a" /* default */])(SelectAll);

  function SelectAll() {
    Object(classCallCheck["a" /* default */])(this, SelectAll);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(SelectAll, null, [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [selectallediting_SelectAllEditing, selectallui_SelectAllUI];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'SelectAll';
    }
  }]);

  return SelectAll;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-typing/src/utils/changebuffer.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module typing/utils/changebuffer
 */

/**
 * Change buffer allows to group atomic changes (like characters that have been typed) into
 * {@link module:engine/model/batch~Batch batches}.
 *
 * Batches represent single undo steps, hence changes added to one single batch are undone together.
 *
 * The buffer has a configurable limit of atomic changes that it can accommodate. After the limit was
 * exceeded (see {@link ~ChangeBuffer#input}), a new batch is created in {@link ~ChangeBuffer#batch}.
 *
 * To use the change buffer you need to let it know about the number of changes that were added to the batch:
 *
 *		const buffer = new ChangeBuffer( model, LIMIT );
 *
 *		// Later on in your feature:
 *		buffer.batch.insert( pos, insertedCharacters );
 *		buffer.input( insertedCharacters.length );
 *
 */
var changebuffer_ChangeBuffer = /*#__PURE__*/function () {
  /**
   * Creates a new instance of the change buffer.
   *
   * @param {module:engine/model/model~Model} model
   * @param {Number} [limit=20] The maximum number of atomic changes which can be contained in one batch.
   */
  function ChangeBuffer(model) {
    var _this = this;

    var limit = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 20;

    Object(classCallCheck["a" /* default */])(this, ChangeBuffer);

    /**
     * The model instance.
     *
     * @readonly
     * @member {module:engine/model/model~Model} #model
     */
    this.model = model;
    /**
     * The number of atomic changes in the buffer. Once it exceeds the {@link #limit},
     * the {@link #batch batch} is set to a new one.
     *
     * @readonly
     * @member {Number} #size
     */

    this.size = 0;
    /**
     * The maximum number of atomic changes which can be contained in one batch.
     *
     * @readonly
     * @member {Number} #limit
     */

    this.limit = limit;
    /**
     * Whether the buffer is locked. A locked buffer cannot be reset unless it gets unlocked.
     *
     * @readonly
     * @member {Boolean} #isLocked
     */

    this.isLocked = false; // The function to be called in order to notify the buffer about batches which appeared in the document.
    // The callback will check whether it is a new batch and in that case the buffer will be flushed.
    //
    // The reason why the buffer needs to be flushed whenever a new batch appears is that the changes added afterwards
    // should be added to a new batch. For instance, when the  user types, then inserts an image, and then types again,
    // the characters typed after inserting the image should be added to a different batch than the characters typed before.

    this._changeCallback = function (evt, batch) {
      if (batch.type != 'transparent' && batch !== _this._batch) {
        _this._reset(true);
      }
    };

    this._selectionChangeCallback = function () {
      _this._reset();
    };

    this.model.document.on('change', this._changeCallback);
    this.model.document.selection.on('change:range', this._selectionChangeCallback);
    this.model.document.selection.on('change:attribute', this._selectionChangeCallback);
    /**
     * The current batch instance.
     *
     * @private
     * @member #_batch
     */

    /**
     * The callback to document the change event which later needs to be removed.
     *
     * @private
     * @member #_changeCallback
     */

    /**
     * The callback to document selection `change:attribute` and `change:range` events which resets the buffer.
     *
     * @private
     * @member #_selectionChangeCallback
     */
  }
  /**
   * The current batch to which a feature should add its operations. Once the {@link #size}
   * is reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
   *
   * @type {module:engine/model/batch~Batch}
   */


  Object(createClass["a" /* default */])(ChangeBuffer, [{
    key: "input",

    /**
     * The input number of changes into the buffer. Once the {@link #size} is
     * reached or exceeds the {@link #limit}, the batch is set to a new instance and the size is reset.
     *
     * @param {Number} changeCount The number of atomic changes to input.
     */
    value: function input(changeCount) {
      this.size += changeCount;

      if (this.size >= this.limit) {
        this._reset(true);
      }
    }
    /**
     * Locks the buffer.
     */

  }, {
    key: "lock",
    value: function lock() {
      this.isLocked = true;
    }
    /**
     * Unlocks the buffer.
     */

  }, {
    key: "unlock",
    value: function unlock() {
      this.isLocked = false;
    }
    /**
     * Destroys the buffer.
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.model.document.off('change', this._changeCallback);
      this.model.document.selection.off('change:range', this._selectionChangeCallback);
      this.model.document.selection.off('change:attribute', this._selectionChangeCallback);
    }
    /**
     * Resets the change buffer.
     *
     * @private
     * @param {Boolean} [ignoreLock] Whether internal lock {@link #isLocked} should be ignored.
     */

  }, {
    key: "_reset",
    value: function _reset(ignoreLock) {
      if (!this.isLocked || ignoreLock) {
        this._batch = null;
        this.size = 0;
      }
    }
  }, {
    key: "batch",
    get: function get() {
      if (!this._batch) {
        this._batch = this.model.createBatch();
      }

      return this._batch;
    }
  }]);

  return ChangeBuffer;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-typing/src/inputcommand.js












/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module typing/inputcommand
 */


/**
 * The input command. Used by the {@link module:typing/input~Input input feature} to handle typing.
 *
 * @extends module:core/command~Command
 */

var inputcommand_InputCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(InputCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(InputCommand);

  /**
   * Creates an instance of the command.
   *
   * @param {module:core/editor/editor~Editor} editor
   * @param {Number} undoStepSize The maximum number of atomic changes
   * which can be contained in one batch in the command buffer.
   */
  function InputCommand(editor, undoStepSize) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, InputCommand);

    _this = _super.call(this, editor);
    /**
     * Typing's change buffer used to group subsequent changes into batches.
     *
     * @readonly
     * @private
     * @member {module:typing/utils/changebuffer~ChangeBuffer} #_buffer
     */

    _this._buffer = new changebuffer_ChangeBuffer(editor.model, undoStepSize);
    /**
     * Stores batches created by the input command. The batches are used to differentiate input batches from other batches using
     * {@link module:typing/input~Input#isInput} method.
     *
     * @type {WeakSet<module:engine/model/batch~Batch>}
     * @protected
     */

    _this._batches = new WeakSet();
    return _this;
  }
  /**
   * The current change buffer.
   *
   * @type {module:typing/utils/changebuffer~ChangeBuffer}
   */


  Object(createClass["a" /* default */])(InputCommand, [{
    key: "destroy",

    /**
     * @inheritDoc
     */
    value: function destroy() {
      get_get(Object(getPrototypeOf["a" /* default */])(InputCommand.prototype), "destroy", this).call(this);

      this._buffer.destroy();
    }
    /**
     * Executes the input command. It replaces the content within the given range with the given text.
     * Replacing is a two step process, first the content within the range is removed and then the new text is inserted
     * at the beginning of the range (which after the removal is a collapsed range).
     *
     * @fires execute
     * @param {Object} [options] The command options.
     * @param {String} [options.text=''] The text to be inserted.
     * @param {module:engine/model/range~Range} [options.range] The range in which the text is inserted. Defaults
     * to the first range in the current selection.
     * @param {module:engine/model/range~Range} [options.resultRange] The range where the selection
     * should be placed after the insertion. If not specified, the selection will be placed right after
     * the inserted text.
     */

  }, {
    key: "execute",
    value: function execute() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var model = this.editor.model;
      var doc = model.document;
      var text = options.text || '';
      var textInsertions = text.length;
      var selection = options.range ? model.createSelection(options.range) : doc.selection;
      var resultRange = options.resultRange;
      model.enqueueChange(this._buffer.batch, function (writer) {
        _this2._buffer.lock();

        model.deleteContent(selection);

        if (text) {
          model.insertContent(writer.createText(text, doc.selection.getAttributes()), selection);
        }

        if (resultRange) {
          writer.setSelection(resultRange);
        } else if (!selection.is('documentSelection')) {
          writer.setSelection(selection);
        }

        _this2._buffer.unlock();

        _this2._buffer.input(textInsertions); // Store the batch as an 'input' batch for the Input.isInput( batch ) check.


        _this2._batches.add(_this2._buffer.batch);
      });
    }
  }, {
    key: "buffer",
    get: function get() {
      return this._buffer;
    }
  }]);

  return InputCommand;
}(command_Command);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-typing/src/utils/injectunsafekeystrokeshandling.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module typing/utils/injectunsafekeystrokeshandling
 */


/**
 * Handles keystrokes which are unsafe for typing. This handler's logic is explained
 * in https://github.com/ckeditor/ckeditor5-typing/issues/83#issuecomment-398690251.
 *
 * @param {module:core/editor/editor~Editor} editor The editor instance.
 */

function injectUnsafeKeystrokesHandling(editor) {
  var latestCompositionSelection = null;
  var model = editor.model;
  var view = editor.editing.view;
  var inputCommand = editor.commands.get('input'); // For Android, we want to handle keystrokes on `beforeinput` to be sure that code in `DeleteObserver` already had a chance to be fired.

  if (src_env.isAndroid) {
    view.document.on('beforeinput', function (evt, evtData) {
      return handleUnsafeKeystroke(evtData);
    }, {
      priority: 'lowest'
    });
  } else {
    view.document.on('keydown', function (evt, evtData) {
      return handleUnsafeKeystroke(evtData);
    }, {
      priority: 'lowest'
    });
  }

  view.document.on('compositionstart', handleCompositionStart, {
    priority: 'lowest'
  });
  view.document.on('compositionend', function () {
    latestCompositionSelection = model.createSelection(model.document.selection);
  }, {
    priority: 'lowest'
  }); // Handles the keydown event. We need to guess whether such keystroke is going to result
  // in typing. If so, then before character insertion happens, any selected content needs
  // to be deleted. Otherwise the default browser deletion mechanism would be
  // triggered, resulting in:
  //
  // * Hundreds of mutations which could not be handled.
  // * But most importantly, loss of control over how the content is being deleted.
  //
  // The method is used in a low-priority listener, hence allowing other listeners (e.g. delete or enter features)
  // to handle the event.
  //
  // @param {module:engine/view/observer/keyobserver~KeyEventData} evtData

  function handleUnsafeKeystroke(evtData) {
    var doc = model.document;
    var isComposing = view.document.isComposing;
    var isSelectionUnchanged = latestCompositionSelection && latestCompositionSelection.isEqual(doc.selection); // Reset stored composition selection.

    latestCompositionSelection = null; // By relying on the state of the input command we allow disabling the entire input easily
    // by just disabling the input command. We could’ve used here the delete command but that
    // would mean requiring the delete feature which would block loading one without the other.
    // We could also check the editor.isReadOnly property, but that wouldn't allow to block
    // the input without blocking other features.

    if (!inputCommand.isEnabled) {
      return;
    }

    if (isNonTypingKeystroke(evtData) || doc.selection.isCollapsed) {
      return;
    } // If during composition, deletion should be prevented as it may remove composed sequence (#83).


    if (isComposing && evtData.keyCode === 229) {
      return;
    } // If there is a `keydown` event fired with '229' keycode it might be related
    // to recent composition. Check if selection is the same as upon ending recent composition,
    // if so do not remove selected content as it will remove composed sequence (#83).


    if (!isComposing && evtData.keyCode === 229 && isSelectionUnchanged) {
      return;
    }

    deleteSelectionContent();
  } // Handles the `compositionstart` event. It is used only in special cases to remove the contents
  // of a non-collapsed selection so composition itself does not result in complex mutations.
  //
  // The special case mentioned above is a situation in which the `keydown` event is fired after
  // `compositionstart` event. In such cases {@link #handleKeydown} cannot clear current selection
  // contents (because it is too late and will break the composition) so the composition handler takes care of it.


  function handleCompositionStart() {
    var doc = model.document;
    var isFlatSelection = doc.selection.rangeCount === 1 ? doc.selection.getFirstRange().isFlat : true; // If on `compositionstart` there is a non-collapsed selection which start and end have different parents
    // it means the `handleKeydown()` method did not remove its contents. It happens usually because
    // of different order of events (`compositionstart` before `keydown` - in Safari). In such cases
    // we need to remove selection contents on composition start (#83).

    if (doc.selection.isCollapsed || isFlatSelection) {
      return;
    }

    deleteSelectionContent();
  }

  function deleteSelectionContent() {
    var buffer = inputCommand.buffer;
    buffer.lock();
    model.enqueueChange(buffer.batch, function () {
      model.deleteContent(model.document.selection);
    });
    buffer.unlock();
  }
}
var safeKeycodes = [getCode('arrowUp'), getCode('arrowRight'), getCode('arrowDown'), getCode('arrowLeft'), 9, // Tab
16, // Shift
17, // Ctrl
18, // Alt
19, // Pause
20, // CapsLock
27, // Escape
33, // PageUp
34, // PageDown
35, // Home
36, // End,
45, // Insert,
91, // Windows,
93, // Menu key,
144, // NumLock
145, // ScrollLock,
173, // Mute/Unmute
174, // Volume up
175, // Volume down,
176, // Next song,
177, // Previous song,
178, // Stop,
179, // Play/Pause,
255 // Display brightness (increase and decrease)
]; // Function keys.

for (var code = 112; code <= 135; code++) {
  safeKeycodes.push(code);
}
/**
 * Returns `true` if a keystroke will **not** result in "typing".
 *
 * For instance, keystrokes that result in typing are letters "a-zA-Z", numbers "0-9", delete, backspace, etc.
 *
 * Keystrokes that do not cause typing are, for instance, Fn keys (F5, F8, etc.), arrow keys (←, →, ↑, ↓),
 * Tab (↹), "Windows logo key" (⊞ Win), etc.
 *
 * Note: This implementation is very simple and will need to be refined with time.
 *
 * @param {module:engine/view/observer/keyobserver~KeyEventData} keyData
 * @returns {Boolean}
 */


function isNonTypingKeystroke(keyData) {
  // Keystrokes which contain Ctrl don't represent typing.
  if (keyData.ctrlKey) {
    return true;
  }

  return safeKeycodes.includes(keyData.keyCode);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/difftochanges.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/difftochanges
 */

/**
 * Creates a set of changes which need to be applied to the input in order to transform
 * it into the output. This function can be used with strings or arrays.
 *
 *		const input = Array.from( 'abc' );
 *		const output = Array.from( 'xaby' );
 *		const changes = diffToChanges( diff( input, output ), output );
 *
 *		changes.forEach( change => {
 *			if ( change.type == 'insert' ) {
 *				input.splice( change.index, 0, ...change.values );
 *			} else if ( change.type == 'delete' ) {
 *				input.splice( change.index, change.howMany );
 *			}
 *		} );
 *
 *		input.join( '' ) == output.join( '' ); // -> true
 *
 * @param {Array.<'equal'|'insert'|'delete'>} diff Result of {@link module:utils/diff~diff}.
 * @param {String|Array} output The string or array which was passed as diff's output.
 * @returns {Array.<Object>} Set of changes (insert or delete) which need to be applied to the input
 * in order to transform it into the output.
 */
function diffToChanges(diff, output) {
  var changes = [];
  var index = 0;
  var lastOperation;
  diff.forEach(function (change) {
    if (change == 'equal') {
      pushLast();
      index++;
    } else if (change == 'insert') {
      if (isContinuationOf('insert')) {
        lastOperation.values.push(output[index]);
      } else {
        pushLast();
        lastOperation = {
          type: 'insert',
          index: index,
          values: [output[index]]
        };
      }

      index++;
    } else
      /* if ( change == 'delete' ) */
      {
        if (isContinuationOf('delete')) {
          lastOperation.howMany++;
        } else {
          pushLast();
          lastOperation = {
            type: 'delete',
            index: index,
            howMany: 1
          };
        }
      }
  });
  pushLast();
  return changes;

  function pushLast() {
    if (lastOperation) {
      changes.push(lastOperation);
      lastOperation = null;
    }
  }

  function isContinuationOf(expected) {
    return lastOperation && lastOperation.type == expected;
  }
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-typing/src/utils/utils.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module typing/utils/utils
 */


/**
 * Returns true if container children have mutated or more than a single text node was changed.
 *
 * @private
 * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|
 * module:engine/view/observer/mutationobserver~MutatedChildren>} mutations
 * @returns {Boolean}
 */

function containerChildrenMutated(mutations) {
  if (mutations.length == 0) {
    return false;
  } // Check if there is any mutation of `children` type or any mutation that changes more than one text node.


  var _iterator = _createForOfIteratorHelper(mutations),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var mutation = _step.value;

      if (mutation.type === 'children' && !getSingleTextNodeChange(mutation)) {
        return true;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return false;
}
/**
 * Returns change made to a single text node.
 *
 * @private
 * @param {module:engine/view/observer/mutationobserver~MutatedText|
 * module:engine/view/observer/mutationobserver~MutatedChildren} mutation
 * @returns {Object|undefined} Change object (see {@link module:utils/difftochanges~diffToChanges} output)
 * or undefined if more than a single text node was changed.
 */

function getSingleTextNodeChange(mutation) {
  // One new node.
  if (mutation.newChildren.length - mutation.oldChildren.length != 1) {
    return;
  } // Which is text.


  var diffResult = diff_diff(mutation.oldChildren, mutation.newChildren, compareChildNodes);
  var changes = diffToChanges(diffResult, mutation.newChildren); // In case of [ delete, insert, insert ] the previous check will not exit.

  if (changes.length > 1) {
    return;
  }

  var change = changes[0]; // Which is text.

  if (!(!!change.values[0] && change.values[0].is('text'))) {
    return;
  }

  return change;
}
/**
 * Checks whether two view nodes are identical, which means they are the same object
 * or contain exactly same data (in case of text nodes).
 *
 * @private
 * @param {module:engine/view/node~Node} oldChild
 * @param {module:engine/view/node~Node} newChild
 * @returns {Boolean}
 */

function compareChildNodes(oldChild, newChild) {
  if (!!oldChild && oldChild.is('text') && !!newChild && newChild.is('text')) {
    return oldChild.data === newChild.data;
  } else {
    return oldChild === newChild;
  }
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-typing/src/utils/injecttypingmutationshandling.js
















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module typing/utils/injecttypingmutationshandling
 */



/**
 * Handles mutations caused by normal typing.
 *
 * @param {module:core/editor/editor~Editor} editor The editor instance.
 */

function injectTypingMutationsHandling(editor) {
  editor.editing.view.document.on('mutations', function (evt, mutations, viewSelection) {
    new injecttypingmutationshandling_MutationHandler(editor).handle(mutations, viewSelection);
  });
}
/**
 * Helper class for translating DOM mutations into model changes.
 *
 * @private
 */

var injecttypingmutationshandling_MutationHandler = /*#__PURE__*/function () {
  /**
   * Creates an instance of the mutation handler.
   *
   * @param {module:core/editor/editor~Editor} editor
   */
  function MutationHandler(editor) {
    Object(classCallCheck["a" /* default */])(this, MutationHandler);

    /**
     * Editor instance for which mutations are handled.
     *
     * @readonly
     * @member {module:core/editor/editor~Editor} #editor
     */
    this.editor = editor;
    /**
     * The editing controller.
     *
     * @readonly
     * @member {module:engine/controller/editingcontroller~EditingController} #editing
     */

    this.editing = this.editor.editing;
  }
  /**
   * Handles given mutations.
   *
   * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|
   * module:engine/view/observer/mutationobserver~MutatedChildren>} mutations
   * @param {module:engine/view/selection~Selection|null} viewSelection
   */


  Object(createClass["a" /* default */])(MutationHandler, [{
    key: "handle",
    value: function handle(mutations, viewSelection) {
      if (containerChildrenMutated(mutations)) {
        this._handleContainerChildrenMutations(mutations, viewSelection);
      } else {
        var _iterator = _createForOfIteratorHelper(mutations),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var mutation = _step.value;

            // Fortunately it will never be both.
            this._handleTextMutation(mutation, viewSelection);

            this._handleTextNodeInsertion(mutation);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }
    /**
     * Handles situations when container's children mutated during input. This can happen when
     * the browser is trying to "fix" DOM in certain situations. For example, when the user starts to type
     * in `<p><a href=""><i>Link{}</i></a></p>`, the browser might change the order of elements
     * to `<p><i><a href="">Link</a>x{}</i></p>`. A similar situation happens when the spell checker
     * replaces a word wrapped with `<strong>` with a word wrapped with a `<b>` element.
     *
     * To handle such situations, the common DOM ancestor of all mutations is converted to the model representation
     * and then compared with the current model to calculate the proper text change.
     *
     * Note: Single text node insertion is handled in {@link #_handleTextNodeInsertion} and text node mutation is handled
     * in {@link #_handleTextMutation}).
     *
     * @private
     * @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|
     * module:engine/view/observer/mutationobserver~MutatedChildren>} mutations
     * @param {module:engine/view/selection~Selection|null} viewSelection
     */

  }, {
    key: "_handleContainerChildrenMutations",
    value: function _handleContainerChildrenMutations(mutations, viewSelection) {
      // Get common ancestor of all mutations.
      var mutationsCommonAncestor = getMutationsContainer(mutations); // Quit if there is no common ancestor.

      if (!mutationsCommonAncestor) {
        return;
      }

      var domConverter = this.editor.editing.view.domConverter; // Get common ancestor in DOM.

      var domMutationCommonAncestor = domConverter.mapViewToDom(mutationsCommonAncestor); // Create fresh DomConverter so it will not use existing mapping and convert current DOM to model.
      // This wouldn't be needed if DomConverter would allow to create fresh view without checking any mappings.

      var freshDomConverter = new domconverter_DomConverter(this.editor.editing.view.document);
      var modelFromCurrentDom = this.editor.data.toModel(freshDomConverter.domToView(domMutationCommonAncestor)).getChild(0); // Current model.

      var currentModel = this.editor.editing.mapper.toModelElement(mutationsCommonAncestor); // If common ancestor is not mapped, do not do anything. It probably is a parent of another view element.
      // That means that we would need to diff model elements (see `if` below). Better return early instead of
      // trying to get a reasonable model ancestor. It will fell into the `if` below anyway.
      // This situation happens for example for lists. If `<ul>` is a common ancestor, `currentModel` is `undefined`
      // because `<ul>` is not mapped (`<li>`s are).
      // See https://github.com/ckeditor/ckeditor5/issues/718.

      if (!currentModel) {
        return;
      } // Get children from both ancestors.


      var modelFromDomChildren = Array.from(modelFromCurrentDom.getChildren());
      var currentModelChildren = Array.from(currentModel.getChildren()); // Remove the last `<softBreak>` from the end of `modelFromDomChildren` if there is no `<softBreak>` in current model.
      // If the described scenario happened, it means that this is a bogus `<br />` added by a browser.

      var lastDomChild = modelFromDomChildren[modelFromDomChildren.length - 1];
      var lastCurrentChild = currentModelChildren[currentModelChildren.length - 1];

      if (lastDomChild && lastDomChild.is('softBreak') && lastCurrentChild && !lastCurrentChild.is('softBreak')) {
        modelFromDomChildren.pop();
      }

      var schema = this.editor.model.schema; // Skip situations when common ancestor has any container elements.

      if (!isSafeForTextMutation(modelFromDomChildren, schema) || !isSafeForTextMutation(currentModelChildren, schema)) {
        return;
      } // Replace &nbsp; inserted by the browser with normal space. See comment in `_handleTextMutation`.
      // Replace non-texts with any character. This is potentially dangerous but passes in manual tests. The thing is
      // that we need to take care of proper indexes so we cannot simply remove non-text elements from the content.
      // By inserting a character we keep all the real texts on their indexes.


      var newText = modelFromDomChildren.map(function (item) {
        return item.is('text') ? item.data : '@';
      }).join('').replace(/\u00A0/g, ' ');
      var oldText = currentModelChildren.map(function (item) {
        return item.is('text') ? item.data : '@';
      }).join('').replace(/\u00A0/g, ' '); // Do nothing if mutations created same text.

      if (oldText === newText) {
        return;
      }

      var diffResult = diff_diff(oldText, newText);

      var _calculateChanges = calculateChanges(diffResult),
          firstChangeAt = _calculateChanges.firstChangeAt,
          insertions = _calculateChanges.insertions,
          deletions = _calculateChanges.deletions; // Try setting new model selection according to passed view selection.


      var modelSelectionRange = null;

      if (viewSelection) {
        modelSelectionRange = this.editing.mapper.toModelRange(viewSelection.getFirstRange());
      }

      var insertText = newText.substr(firstChangeAt, insertions);
      var removeRange = this.editor.model.createRange(this.editor.model.createPositionAt(currentModel, firstChangeAt), this.editor.model.createPositionAt(currentModel, firstChangeAt + deletions));
      this.editor.execute('input', {
        text: insertText,
        range: removeRange,
        resultRange: modelSelectionRange
      });
    }
    /**
     * @private
     */

  }, {
    key: "_handleTextMutation",
    value: function _handleTextMutation(mutation, viewSelection) {
      if (mutation.type != 'text') {
        return;
      } // Replace &nbsp; inserted by the browser with normal space.
      // We want only normal spaces in the model and in the view. Renderer and DOM Converter will be then responsible
      // for rendering consecutive spaces using &nbsp;, but the model and the view has to be clear.
      // Other feature may introduce inserting non-breakable space on specific key stroke (for example shift + space).
      // However then it will be handled outside of mutations, like enter key is.
      // The replacing is here because it has to be done before `diff` and `diffToChanges` functions, as they
      // take `newText` and compare it to (cleaned up) view.
      // It could also be done in mutation observer too, however if any outside plugin would like to
      // introduce additional events for mutations, they would get already cleaned up version (this may be good or not).


      var newText = mutation.newText.replace(/\u00A0/g, ' '); // To have correct `diffResult`, we also compare view node text data with &nbsp; replaced by space.

      var oldText = mutation.oldText.replace(/\u00A0/g, ' '); // Do nothing if mutations created same text.

      if (oldText === newText) {
        return;
      }

      var diffResult = diff_diff(oldText, newText);

      var _calculateChanges2 = calculateChanges(diffResult),
          firstChangeAt = _calculateChanges2.firstChangeAt,
          insertions = _calculateChanges2.insertions,
          deletions = _calculateChanges2.deletions; // Try setting new model selection according to passed view selection.


      var modelSelectionRange = null;

      if (viewSelection) {
        modelSelectionRange = this.editing.mapper.toModelRange(viewSelection.getFirstRange());
      } // Get the position in view and model where the changes will happen.


      var viewPos = this.editing.view.createPositionAt(mutation.node, firstChangeAt);
      var modelPos = this.editing.mapper.toModelPosition(viewPos);
      var removeRange = this.editor.model.createRange(modelPos, modelPos.getShiftedBy(deletions));
      var insertText = newText.substr(firstChangeAt, insertions);
      this.editor.execute('input', {
        text: insertText,
        range: removeRange,
        resultRange: modelSelectionRange
      });
    }
    /**
     * @private
     */

  }, {
    key: "_handleTextNodeInsertion",
    value: function _handleTextNodeInsertion(mutation) {
      if (mutation.type != 'children') {
        return;
      }

      var change = getSingleTextNodeChange(mutation);
      var viewPos = this.editing.view.createPositionAt(mutation.node, change.index);
      var modelPos = this.editing.mapper.toModelPosition(viewPos);
      var insertedText = change.values[0].data;
      this.editor.execute('input', {
        // Replace &nbsp; inserted by the browser with normal space.
        // See comment in `_handleTextMutation`.
        // In this case we don't need to do this before `diff` because we diff whole nodes.
        // Just change &nbsp; in case there are some.
        text: insertedText.replace(/\u00A0/g, ' '),
        range: this.editor.model.createRange(modelPos)
      });
    }
  }]);

  return MutationHandler;
}(); // Returns first common ancestor of all mutations that is either {@link module:engine/view/containerelement~ContainerElement}
// or {@link module:engine/view/rootelement~RootElement}.
//
// @private
// @param {Array.<module:engine/view/observer/mutationobserver~MutatedText|
// module:engine/view/observer/mutationobserver~MutatedChildren>} mutations
// @returns {module:engine/view/containerelement~ContainerElement|engine/view/rootelement~RootElement|undefined}


function getMutationsContainer(mutations) {
  var lca = mutations.map(function (mutation) {
    return mutation.node;
  }).reduce(function (commonAncestor, node) {
    return commonAncestor.getCommonAncestor(node, {
      includeSelf: true
    });
  });

  if (!lca) {
    return;
  } // We need to look for container and root elements only, so check all LCA's
  // ancestors (starting from itself).


  return lca.getAncestors({
    includeSelf: true,
    parentFirst: true
  }).find(function (element) {
    return element.is('containerElement') || element.is('rootElement');
  });
} // Returns true if provided array contains content that won't be problematic during diffing and text mutation handling.
//
// @param {Array.<module:engine/model/node~Node>} children
// @param {module:engine/model/schema~Schema} schema
// @returns {Boolean}


function isSafeForTextMutation(children, schema) {
  return children.every(function (child) {
    return schema.isInline(child);
  });
} // Calculates first change index and number of characters that should be inserted and deleted starting from that index.
//
// @private
// @param diffResult
// @returns {{insertions: number, deletions: number, firstChangeAt: *}}


function calculateChanges(diffResult) {
  // Index where the first change happens. Used to set the position from which nodes will be removed and where will be inserted.
  var firstChangeAt = null; // Index where the last change happens. Used to properly count how many characters have to be removed and inserted.

  var lastChangeAt = null; // Get `firstChangeAt` and `lastChangeAt`.

  for (var i = 0; i < diffResult.length; i++) {
    var change = diffResult[i];

    if (change != 'equal') {
      firstChangeAt = firstChangeAt === null ? i : firstChangeAt;
      lastChangeAt = i;
    }
  } // How many characters, starting from `firstChangeAt`, should be removed.


  var deletions = 0; // How many characters, starting from `firstChangeAt`, should be inserted.

  var insertions = 0;

  for (var _i = firstChangeAt; _i <= lastChangeAt; _i++) {
    // If there is no change (equal) or delete, the character is existing in `oldText`. We count it for removing.
    if (diffResult[_i] != 'insert') {
      deletions++;
    } // If there is no change (equal) or insert, the character is existing in `newText`. We count it for inserting.


    if (diffResult[_i] != 'delete') {
      insertions++;
    }
  }

  return {
    insertions: insertions,
    deletions: deletions,
    firstChangeAt: firstChangeAt
  };
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-typing/src/input.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module typing/input
 */




/**
 * Handles text input coming from the keyboard or other input methods.
 *
 * @extends module:core/plugin~Plugin
 */

var input_Input = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(Input, _Plugin);

  var _super = Object(createSuper["a" /* default */])(Input);

  function Input() {
    Object(classCallCheck["a" /* default */])(this, Input);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Input, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var editor = this.editor; // TODO The above default configuration value should be defined using editor.config.define() once it's fixed.

      var inputCommand = new inputcommand_InputCommand(editor, editor.config.get('typing.undoStep') || 20);
      editor.commands.add('input', inputCommand);
      injectUnsafeKeystrokesHandling(editor);
      injectTypingMutationsHandling(editor);
    }
    /**
     * Checks batch if it is a result of user input - e.g. typing.
     *
     *		const input = editor.plugins.get( 'Input' );
     *
     *		editor.model.document.on( 'change:data', ( evt, batch ) => {
     *			if ( input.isTyping( batch ) ) {
     *				console.log( 'The user typed something...' );
     *			}
     *		} );
     *
     * **Note:** This method checks if the batch was created using {@link module:typing/inputcommand~InputCommand 'input'}
     * command as typing changes coming from user input are inserted to the document using that command.
     *
     * @param {module:engine/model/batch~Batch} batch A batch to check.
     * @returns {Boolean}
     */

  }, {
    key: "isInput",
    value: function isInput(batch) {
      var inputCommand = this.editor.commands.get('input');
      return inputCommand._batches.has(batch);
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'Input';
    }
  }]);

  return Input;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-typing/src/deletecommand.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module typing/deletecommand
 */



/**
 * The delete command. Used by the {@link module:typing/delete~Delete delete feature} to handle the <kbd>Delete</kbd> and
 * <kbd>Backspace</kbd> keys.
 *
 * @extends module:core/command~Command
 */

var deletecommand_DeleteCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(DeleteCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(DeleteCommand);

  /**
   * Creates an instance of the command.
   *
   * @param {module:core/editor/editor~Editor} editor
   * @param {'forward'|'backward'} direction The directionality of the delete describing in what direction it
   * should consume the content when the selection is collapsed.
   */
  function DeleteCommand(editor, direction) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, DeleteCommand);

    _this = _super.call(this, editor);
    /**
     * The directionality of the delete describing in what direction it should
     * consume the content when the selection is collapsed.
     *
     * @readonly
     * @member {'forward'|'backward'} #direction
     */

    _this.direction = direction;
    /**
     * Delete's change buffer used to group subsequent changes into batches.
     *
     * @readonly
     * @private
     * @member {typing.ChangeBuffer} #buffer
     */

    _this._buffer = new changebuffer_ChangeBuffer(editor.model, editor.config.get('typing.undoStep'));
    return _this;
  }
  /**
   * The current change buffer.
   *
   * @type {module:typing/utils/changebuffer~ChangeBuffer}
   */


  Object(createClass["a" /* default */])(DeleteCommand, [{
    key: "execute",

    /**
     * Executes the delete command. Depending on whether the selection is collapsed or not, deletes its content
     * or a piece of content in the {@link #direction defined direction}.
     *
     * @fires execute
     * @param {Object} [options] The command options.
     * @param {'character'} [options.unit='character'] See {@link module:engine/model/utils/modifyselection~modifySelection}'s options.
     * @param {Number} [options.sequence=1] A number describing which subsequent delete event it is without the key being released.
     * See the {@link module:engine/view/document~Document#event:delete} event data.
     * @param {module:engine/model/selection~Selection} [options.selection] Selection to remove. If not set, current model selection
     * will be used.
     */
    value: function execute() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var model = this.editor.model;
      var doc = model.document;
      model.enqueueChange(this._buffer.batch, function (writer) {
        _this2._buffer.lock();

        var selection = writer.createSelection(options.selection || doc.selection); // Do not replace the whole selected content if selection was collapsed.
        // This prevents such situation:
        //
        // <h1></h1><p>[]</p>	-->  <h1>[</h1><p>]</p> 		-->  <p></p>
        // starting content		-->   after `modifySelection`	-->  after `deleteContent`.

        var doNotResetEntireContent = selection.isCollapsed; // Try to extend the selection in the specified direction.

        if (selection.isCollapsed) {
          model.modifySelection(selection, {
            direction: _this2.direction,
            unit: options.unit
          });
        } // Check if deleting in an empty editor. See #61.


        if (_this2._shouldEntireContentBeReplacedWithParagraph(options.sequence || 1)) {
          _this2._replaceEntireContentWithParagraph(writer);

          return;
        } // If selection is still collapsed, then there's nothing to delete.


        if (selection.isCollapsed) {
          return;
        }

        var changeCount = 0;
        selection.getFirstRange().getMinimalFlatRanges().forEach(function (range) {
          changeCount += count_count(range.getWalker({
            singleCharacters: true,
            ignoreElementEnd: true,
            shallow: true
          }));
        });
        model.deleteContent(selection, {
          doNotResetEntireContent: doNotResetEntireContent,
          direction: _this2.direction
        });

        _this2._buffer.input(changeCount);

        writer.setSelection(selection);

        _this2._buffer.unlock();
      });
    }
    /**
     * If the user keeps <kbd>Backspace</kbd> or <kbd>Delete</kbd> key pressed, the content of the current
     * editable will be cleared. However, this will not yet lead to resetting the remaining block to a paragraph
     * (which happens e.g. when the user does <kbd>Ctrl</kbd> + <kbd>A</kbd>, <kbd>Backspace</kbd>).
     *
     * But, if the user pressed the key in an empty editable for the first time,
     * we want to replace the entire content with a paragraph if:
     *
     * * the current limit element is empty,
     * * the paragraph is allowed in the limit element,
     * * the limit doesn't already have a paragraph inside.
     *
     * See https://github.com/ckeditor/ckeditor5-typing/issues/61.
     *
     * @private
     * @param {Number} sequence A number describing which subsequent delete event it is without the key being released.
     * @returns {Boolean}
     */

  }, {
    key: "_shouldEntireContentBeReplacedWithParagraph",
    value: function _shouldEntireContentBeReplacedWithParagraph(sequence) {
      // Does nothing if user pressed and held the "Backspace" or "Delete" key.
      if (sequence > 1) {
        return false;
      }

      var model = this.editor.model;
      var doc = model.document;
      var selection = doc.selection;
      var limitElement = model.schema.getLimitElement(selection); // If a collapsed selection contains the whole content it means that the content is empty
      // (from the user perspective).

      var limitElementIsEmpty = selection.isCollapsed && selection.containsEntireContent(limitElement);

      if (!limitElementIsEmpty) {
        return false;
      }

      if (!model.schema.checkChild(limitElement, 'paragraph')) {
        return false;
      }

      var limitElementFirstChild = limitElement.getChild(0); // Does nothing if the limit element already contains only a paragraph.
      // We ignore the case when paragraph might have some inline elements (<p><inlineWidget>[]</inlineWidget></p>)
      // because we don't support such cases yet and it's unclear whether inlineWidget shouldn't be a limit itself.

      if (limitElementFirstChild && limitElementFirstChild.name === 'paragraph') {
        return false;
      }

      return true;
    }
    /**
     * The entire content is replaced with the paragraph. Selection is moved inside the paragraph.
     *
     * @private
     */

  }, {
    key: "_replaceEntireContentWithParagraph",
    value: function _replaceEntireContentWithParagraph(writer) {
      var model = this.editor.model;
      var doc = model.document;
      var selection = doc.selection;
      var limitElement = model.schema.getLimitElement(selection);
      var paragraph = writer.createElement('paragraph');
      writer.remove(writer.createRangeIn(limitElement));
      writer.insert(paragraph, limitElement);
      writer.setSelection(paragraph, 0);
    }
  }, {
    key: "buffer",
    get: function get() {
      return this._buffer;
    }
  }]);

  return DeleteCommand;
}(command_Command);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-typing/src/deleteobserver.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module typing/deleteobserver
 */




/**
 * Delete observer introduces the {@link module:engine/view/document~Document#event:delete} event.
 *
 * @extends module:engine/view/observer/observer~Observer
 */

var deleteobserver_DeleteObserver = /*#__PURE__*/function (_Observer) {
  Object(inherits["a" /* default */])(DeleteObserver, _Observer);

  var _super = Object(createSuper["a" /* default */])(DeleteObserver);

  function DeleteObserver(view) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, DeleteObserver);

    _this = _super.call(this, view);
    var document = view.document;
    var sequence = 0;
    document.on('keyup', function (evt, data) {
      if (data.keyCode == keyCodes.delete || data.keyCode == keyCodes.backspace) {
        sequence = 0;
      }
    });
    document.on('keydown', function (evt, data) {
      var deleteData = {};

      if (data.keyCode == keyCodes.delete) {
        deleteData.direction = 'forward';
        deleteData.unit = 'character';
      } else if (data.keyCode == keyCodes.backspace) {
        deleteData.direction = 'backward';
        deleteData.unit = 'codePoint';
      } else {
        return;
      }

      var hasWordModifier = src_env.isMac ? data.altKey : data.ctrlKey;
      deleteData.unit = hasWordModifier ? 'word' : deleteData.unit;
      deleteData.sequence = ++sequence;
      fireViewDeleteEvent(evt, data.domEvent, deleteData);
    }); // `beforeinput` is handled only for Android devices. Desktop Chrome and iOS are skipped because they are working fine now.

    if (src_env.isAndroid) {
      document.on('beforeinput', function (evt, data) {
        // If event type is other than `deleteContentBackward` then this is not deleting.
        if (data.domEvent.inputType != 'deleteContentBackward') {
          return;
        }

        var deleteData = {
          unit: 'codepoint',
          direction: 'backward',
          sequence: 1
        }; // Android IMEs may change the DOM selection on `beforeinput` event so that the selection contains all the text
        // that the IME wants to remove. We will pass this information to `delete` event so proper part of the content is removed.
        //
        // Sometimes it is only expanding by a one character (in case of collapsed selection). In this case we don't need to
        // set a different selection to remove, it will work just fine.

        var domSelection = data.domTarget.ownerDocument.defaultView.getSelection();

        if (domSelection.anchorNode == domSelection.focusNode && domSelection.anchorOffset + 1 != domSelection.focusOffset) {
          deleteData.selectionToRemove = view.domConverter.domSelectionToView(domSelection);
        }

        fireViewDeleteEvent(evt, data.domEvent, deleteData);
      });
    }

    function fireViewDeleteEvent(originalEvent, domEvent, deleteData) {
      // Save the event object to check later if it was stopped or not.
      var event;
      document.once('delete', function (evt) {
        return event = evt;
      }, {
        priority: Number.POSITIVE_INFINITY
      });
      document.fire('delete', new domeventdata_DomEventData(document, domEvent, deleteData)); // Stop the original event if `delete` event was stopped.
      // https://github.com/ckeditor/ckeditor5/issues/753

      if (event && event.stop.called) {
        originalEvent.stop();
      }
    }

    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(DeleteObserver, [{
    key: "observe",
    value: function observe() {}
  }]);

  return DeleteObserver;
}(observer_Observer);
/**
 * Event fired when the user tries to delete content (e.g. presses <kbd>Delete</kbd> or <kbd>Backspace</kbd>).
 *
 * Note: This event is fired by the {@link module:typing/deleteobserver~DeleteObserver observer}
 * (usually registered by the {@link module:typing/delete~Delete delete feature}).
 *
 * @event module:engine/view/document~Document#event:delete
 * @param {module:engine/view/observer/domeventdata~DomEventData} data
 * @param {'forward'|'delete'} data.direction The direction in which the deletion should happen.
 * @param {'character'|'word'} data.unit The "amount" of content that should be deleted.
 * @param {Number} data.sequence A number describing which subsequent delete event it is without the key being released.
 * If it's 2 or more it means that the key was pressed and hold.
 * @param {module:engine/view/selection~Selection} [data.selectionToRemove] View selection which content should be removed. If not set,
 * current selection should be used.
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-typing/src/delete.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module typing/delete
 */




/**
 * The delete and backspace feature. Handles the <kbd>Delete</kbd> and <kbd>Backspace</kbd> keys in the editor.
 *
 * @extends module:core/plugin~Plugin
 */

var delete_Delete = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(Delete, _Plugin);

  var _super = Object(createSuper["a" /* default */])(Delete);

  function Delete() {
    Object(classCallCheck["a" /* default */])(this, Delete);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Delete, [{
    key: "init",
    value: function init() {
      var editor = this.editor;
      var view = editor.editing.view;
      var viewDocument = view.document;
      view.addObserver(deleteobserver_DeleteObserver);
      editor.commands.add('forwardDelete', new deletecommand_DeleteCommand(editor, 'forward'));
      editor.commands.add('delete', new deletecommand_DeleteCommand(editor, 'backward'));
      this.listenTo(viewDocument, 'delete', function (evt, data) {
        var deleteCommandParams = {
          unit: data.unit,
          sequence: data.sequence
        }; // If a specific (view) selection to remove was set, convert it to a model selection and set as a parameter for `DeleteCommand`.

        if (data.selectionToRemove) {
          var modelSelection = editor.model.createSelection();
          var ranges = [];

          var _iterator = _createForOfIteratorHelper(data.selectionToRemove.getRanges()),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var viewRange = _step.value;
              ranges.push(editor.editing.mapper.toModelRange(viewRange));
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          modelSelection.setTo(ranges);
          deleteCommandParams.selection = modelSelection;
        }

        editor.execute(data.direction == 'forward' ? 'forwardDelete' : 'delete', deleteCommandParams);
        data.preventDefault();
        view.scrollToTheSelection();
      }); // Android IMEs have a quirk - they change DOM selection after the input changes were performed by the browser.
      // This happens on `keyup` event. Android doesn't know anything about our deletion and selection handling. Even if the selection
      // was changed during input events, IME remembers the position where the selection "should" be placed and moves it there.
      //
      // To prevent incorrect selection, we save the selection after deleting here and then re-set it on `keyup`. This has to be done
      // on DOM selection level, because on `keyup` the model selection is still the same as it was just after deletion, so it
      // wouldn't be changed and the fix would do nothing.
      //

      if (src_env.isAndroid) {
        var domSelectionAfterDeletion = null;
        this.listenTo(viewDocument, 'delete', function (evt, data) {
          var domSelection = data.domTarget.ownerDocument.defaultView.getSelection();
          domSelectionAfterDeletion = {
            anchorNode: domSelection.anchorNode,
            anchorOffset: domSelection.anchorOffset,
            focusNode: domSelection.focusNode,
            focusOffset: domSelection.focusOffset
          };
        }, {
          priority: 'lowest'
        });
        this.listenTo(viewDocument, 'keyup', function (evt, data) {
          if (domSelectionAfterDeletion) {
            var domSelection = data.domTarget.ownerDocument.defaultView.getSelection();
            domSelection.collapse(domSelectionAfterDeletion.anchorNode, domSelectionAfterDeletion.anchorOffset);
            domSelection.extend(domSelectionAfterDeletion.focusNode, domSelectionAfterDeletion.focusOffset);
            domSelectionAfterDeletion = null;
          }
        });
      }
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'Delete';
    }
  }]);

  return Delete;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-typing/src/typing.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module typing/typing
 */



/**
 * The typing feature. It handles typing.
 *
 * This is a "glue" plugin which loads the {@link module:typing/input~Input} and {@link module:typing/delete~Delete}
 * plugins.
 *
 * @extends module:core/plugin~Plugin
 */

var typing_Typing = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(Typing, _Plugin);

  var _super = Object(createSuper["a" /* default */])(Typing);

  function Typing() {
    Object(classCallCheck["a" /* default */])(this, Typing);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Typing, null, [{
    key: "requires",
    get: function get() {
      return [input_Input, delete_Delete];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'Typing';
    }
  }]);

  return Typing;
}(plugin_Plugin);
/**
 * The configuration of the typing features. Used by the features from the `@ckeditor/ckeditor5-typing` package.
 *
 * Read more in {@link module:typing/typing~TypingConfig}.
 *
 * @member {module:typing/typing~TypingConfig} module:core/editor/editorconfig~EditorConfig#typing
 */

/**
 * The configuration of the typing features. Used by the typing features in `@ckeditor/ckeditor5-typing` package.
 *
 *		ClassicEditor
 *			.create( editorElement, {
 * 				typing: ... // Typing feature options.
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * See {@link module:core/editor/editorconfig~EditorConfig all editor options}.
 *
 * @interface TypingConfig
 */

/**
 * The granularity of undo/redo for typing and deleting. The value `20` means (more or less) that a new undo step
 * is created every 20 characters are inserted or deleted.
 *
 * @member {Number} [module:typing/typing~TypingConfig#undoStep=20]
 */



// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.find-index.js
var es_array_find_index = __webpack_require__("c740");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/model/operation/transform.js
















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */












var transformations = new Map();
/**
 * @module engine/model/operation/transform
 */

/**
 * Sets a transformation function to be be used to transform instances of class `OperationA` by instances of class `OperationB`.
 *
 * The `transformationFunction` is passed three parameters:
 *
 * * `a` - operation to be transformed, an instance of `OperationA`,
 * * `b` - operation to be transformed by, an instance of `OperationB`,
 * * {@link module:engine/model/operation/transform~TransformationContext `context`} - object with additional information about
 * transformation context.
 *
 * The `transformationFunction` should return transformation result, which is an array with one or multiple
 * {@link module:engine/model/operation/operation~Operation operation} instances.
 *
 * @protected
 * @param {Function} OperationA
 * @param {Function} OperationB
 * @param {Function} transformationFunction Function to use for transforming.
 */

function setTransformation(OperationA, OperationB, transformationFunction) {
  var aGroup = transformations.get(OperationA);

  if (!aGroup) {
    aGroup = new Map();
    transformations.set(OperationA, aGroup);
  }

  aGroup.set(OperationB, transformationFunction);
}
/**
 * Returns a previously set transformation function for transforming an instance of `OperationA` by an instance of `OperationB`.
 *
 * If no transformation was set for given pair of operations, {@link module:engine/model/operation/transform~noUpdateTransformation}
 * is returned. This means that if no transformation was set, the `OperationA` instance will not change when transformed
 * by the `OperationB` instance.
 *
 * @private
 * @param {Function} OperationA
 * @param {Function} OperationB
 * @returns {Function} Function set to transform an instance of `OperationA` by an instance of `OperationB`.
 */


function getTransformation(OperationA, OperationB) {
  var aGroup = transformations.get(OperationA);

  if (aGroup && aGroup.has(OperationB)) {
    return aGroup.get(OperationB);
  }

  return noUpdateTransformation;
}
/**
 * A transformation function that only clones operation to transform, without changing it.
 *
 * @private
 * @param {module:engine/model/operation/operation~Operation} a Operation to transform.
 * @returns {Array.<module:engine/model/operation/operation~Operation>}
 */


function noUpdateTransformation(a) {
  return [a];
}
/**
 * Transforms operation `a` by operation `b`.
 *
 * @param {module:engine/model/operation/operation~Operation} a Operation to be transformed.
 * @param {module:engine/model/operation/operation~Operation} b Operation to transform by.
 * @param {module:engine/model/operation/transform~TransformationContext} context Transformation context for this transformation.
 * @returns {Array.<module:engine/model/operation/operation~Operation>} Transformation result.
 */


function transform_transform(a, b) {
  var context = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var transformationFunction = getTransformation(a.constructor, b.constructor);
  /* eslint-disable no-useless-catch */

  try {
    a = a.clone();
    return transformationFunction(a, b, context);
  } catch (e) {
    // @if CK_DEBUG // console.warn( 'Error during operation transformation!', e.message );
    // @if CK_DEBUG // console.warn( 'Transformed operation', a );
    // @if CK_DEBUG // console.warn( 'Operation transformed by', b );
    // @if CK_DEBUG // console.warn( 'context.aIsStrong', context.aIsStrong );
    // @if CK_DEBUG // console.warn( 'context.aWasUndone', context.aWasUndone );
    // @if CK_DEBUG // console.warn( 'context.bWasUndone', context.bWasUndone );
    // @if CK_DEBUG // console.warn( 'context.abRelation', context.abRelation );
    // @if CK_DEBUG // console.warn( 'context.baRelation', context.baRelation );
    throw e;
  }
  /* eslint-enable no-useless-catch */

}
/**
 * Performs a transformation of two sets of operations - `operationsA` and `operationsB`. The transformation is two-way -
 * both transformed `operationsA` and transformed `operationsB` are returned.
 *
 * Note, that the first operation in each set should base on the same document state (
 * {@link module:engine/model/document~Document#version document version}).
 *
 * It is assumed that `operationsA` are "more important" during conflict resolution between two operations.
 *
 * New copies of both passed arrays and operations inside them are returned. Passed arguments are not altered.
 *
 * Base versions of the transformed operations sets are updated accordingly. For example, assume that base versions are `4`
 * and there are `3` operations in `operationsA` and `5` operations in `operationsB`. Then:
 *
 * * transformed `operationsA` will start from base version `9` (`4` base version + `5` operations B),
 * * transformed `operationsB` will start from base version `7` (`4` base version + `3` operations A).
 *
 * If no operation was broken into two during transformation, then both sets will end up with an operation that bases on version `11`:
 *
 * * transformed `operationsA` start from `9` and there are `3` of them, so the last will have `baseVersion` equal to `11`,
 * * transformed `operationsB` start from `7` and there are `5` of them, so the last will have `baseVersion` equal to `11`.
 *
 * @param {Array.<module:engine/model/operation/operation~Operation>} operationsA
 * @param {Array.<module:engine/model/operation/operation~Operation>} operationsB
 * @param {Object} options Additional transformation options.
 * @param {module:engine/model/document~Document|null} options.document Document which the operations change.
 * @param {Boolean} [options.useRelations=false] Whether during transformation relations should be used (used during undo for
 * better conflict resolution).
 * @param {Boolean} [options.padWithNoOps=false] Whether additional {@link module:engine/model/operation/nooperation~NoOperation}s
 * should be added to the transformation results to force the same last base version for both transformed sets (in case
 * if some operations got broken into multiple operations during transformation).
 * @returns {Object} Transformation result.
 * @returns {Array.<module:engine/model/operation/operation~Operation>} return.operationsA Transformed `operationsA`.
 * @returns {Array.<module:engine/model/operation/operation~Operation>} return.operationsB Transformed `operationsB`.
 * @returns {Map} return.originalOperations A map that links transformed operations to original operations. The keys are the transformed
 * operations and the values are the original operations from the input (`operationsA` and `operationsB`).
 */

function transformSets(operationsA, operationsB, options) {
  // Create new arrays so the originally passed arguments are not changed.
  // No need to clone operations, they are cloned as they are transformed.
  operationsA = operationsA.slice();
  operationsB = operationsB.slice();
  var contextFactory = new transform_ContextFactory(options.document, options.useRelations, options.forceWeakRemove);
  contextFactory.setOriginalOperations(operationsA);
  contextFactory.setOriginalOperations(operationsB);
  var originalOperations = contextFactory.originalOperations; // If one of sets is empty there is simply nothing to transform, so return sets as they are.

  if (operationsA.length == 0 || operationsB.length == 0) {
    return {
      operationsA: operationsA,
      operationsB: operationsB,
      originalOperations: originalOperations
    };
  } //
  // Following is a description of transformation process:
  //
  // There are `operationsA` and `operationsB` to be transformed, both by both.
  //
  // So, suppose we have sets of two operations each: `operationsA` = `[ a1, a2 ]`, `operationsB` = `[ b1, b2 ]`.
  //
  // Remember, that we can only transform operations that base on the same context. We assert that `a1` and `b1` base on
  // the same context and we transform them. Then, we get `a1'` and `b1'`. `a2` bases on a context with `a1` -- `a2`
  // is an operation that followed `a1`. Similarly, `b2` bases on a context with `b1`.
  //
  // However, since `a1'` is a result of transformation by `b1`, `a1'` now also has a context with `b1`. This means that
  // we can safely transform `a1'` by `b2`. As we finish transforming `a1`, we also transformed all `operationsB`.
  // All `operationsB` also have context including `a1`. Now, we can properly transform `a2` by those operations.
  //
  // The transformation process can be visualized on a transformation diagram ("diamond diagram"):
  //
  //          [the initial state]
  //         [common for a1 and b1]
  //
  //                   *
  //                  / \
  //                 /   \
  //               b1     a1
  //               /       \
  //              /         \
  //             *           *
  //            / \         / \
  //           /   \       /   \
  //         b2    a1'   b1'    a2
  //         /       \   /       \
  //        /         \ /         \
  //       *           *           *
  //        \         / \         /
  //         \       /   \       /
  //        a1''   b2'   a2'   b1''
  //           \   /       \   /
  //            \ /         \ /
  //             *           *
  //              \         /
  //               \       /
  //              a2''   b2''
  //                 \   /
  //                  \ /
  //                   *
  //
  //           [the final state]
  //
  // The final state can be reached from the initial state by applying `a1`, `a2`, `b1''` and `b2''`, as well as by
  // applying `b1`, `b2`, `a1''`, `a2''`. Note how the operations get to a proper common state before each pair is
  // transformed.
  //
  // Another thing to consider is that an operation during transformation can be broken into multiple operations.
  // Suppose that `a1` * `b1` = `[ a11', a12' ]` (instead of `a1'` that we considered previously).
  //
  // In that case, we leave `a12'` for later and we continue transforming `a11'` until it is transformed by all `operationsB`
  // (in our case it is just `b2`). At this point, `b1` is transformed by "whole" `a1`, while `b2` is only transformed
  // by `a11'`. Similarly, `a12'` is only transformed by `b1`. This leads to a conclusion that we need to start transforming `a12'`
  // from the moment just after it was broken. So, `a12'` is transformed by `b2`. Now, "the whole" `a1` is transformed
  // by `operationsB`, while all `operationsB` are transformed by "the whole" `a1`. This means that we can continue with
  // following `operationsA` (in our case it is just `a2`).
  //
  // Of course, also `operationsB` can be broken. However, since we focus on transforming operation `a` to the end,
  // the only thing to do is to store both pieces of operation `b`, so that the next transformed operation `a` will
  // be transformed by both of them.
  //
  //                       *
  //                      / \
  //                     /   \
  //                    /     \
  //                  b1       a1
  //                  /         \
  //                 /           \
  //                /             \
  //               *               *
  //              / \             / \
  //             /  a11'         /   \
  //            /     \         /     \
  //          b2       *      b1'      a2
  //          /       / \     /         \
  //         /       /  a12' /           \
  //        /       /     \ /             \
  //       *       b2'     *               *
  //        \     /       / \             /
  //       a11'' /     b21'' \           /
  //          \ /       /     \         /
  //           *       *      a2'     b1''
  //            \     / \       \     /
  //          a12'' b22''\       \   /
  //              \ /     \       \ /
  //               *      a2''     *
  //                \       \     /
  //                 \       \  b21'''
  //                  \       \ /
  //                a2'''      *
  //                    \     /
  //                     \  b22'''
  //                      \ /
  //                       *
  //
  // Note, how `a1` is broken and transformed into `a11'` and `a12'`, while `b2'` got broken and transformed into `b21''` and `b22''`.
  //
  // Having all that on mind, here is an outline for the transformation process algorithm:
  //
  // 1. We have `operationsA` and `operationsB` array, which we dynamically update as the transformation process goes.
  //
  // 2. We take next (or first) operation from `operationsA` and check from which operation `b` we need to start transforming it.
  // All original `operationsA` are set to be transformed starting from the first operation `b`.
  //
  // 3. We take operations from `operationsB`, one by one, starting from the correct one, and transform operation `a`
  // by operation `b` (and vice versa). We update `operationsA` and `operationsB` by replacing the original operations
  // with the transformation results.
  //
  // 4. If operation is broken into multiple operations, we save all the new operations in the place of the
  // original operation.
  //
  // 5. Additionally, if operation `a` was broken, for the "new" operation, we remember from which operation `b` it should
  // be transformed by.
  //
  // 6. We continue transforming "current" operation `a` until it is transformed by all `operationsB`. Then, go to 2.
  // unless the last operation `a` was transformed.
  //
  // The actual implementation of the above algorithm is slightly different, as only one loop (while) is used.
  // The difference is that we have "current" `a` operation to transform and we store the index of the next `b` operation
  // to transform by. Each loop operates on two indexes then: index pointing to currently processed `a` operation and
  // index pointing to next `b` operation. Each loop is just one `a * b` + `b * a` transformation. After each loop
  // operation `b` index is updated. If all `b` operations were visited for the current `a` operation, we change
  // current `a` operation index to the next one.
  //
  // For each operation `a`, keeps information what is the index in `operationsB` from which the transformation should start.


  var nextTransformIndex = new WeakMap(); // For all the original `operationsA`, set that they should be transformed starting from the first of `operationsB`.

  var _iterator = _createForOfIteratorHelper(operationsA),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var op = _step.value;
      nextTransformIndex.set(op, 0);
    } // Additional data that is used for some postprocessing after the main transformation process is done.

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  var data = {
    nextBaseVersionA: operationsA[operationsA.length - 1].baseVersion + 1,
    nextBaseVersionB: operationsB[operationsB.length - 1].baseVersion + 1,
    originalOperationsACount: operationsA.length,
    originalOperationsBCount: operationsB.length
  }; // Index of currently transformed operation `a`.

  var i = 0; // While not all `operationsA` are transformed...

  while (i < operationsA.length) {
    var _operationsA, _operationsB;

    // Get "current" operation `a`.
    var opA = operationsA[i]; // For the "current" operation `a`, get the index of the next operation `b` to transform by.

    var indexB = nextTransformIndex.get(opA); // If operation `a` was already transformed by every operation `b`, change "current" operation `a` to the next one.

    if (indexB == operationsB.length) {
      i++;
      continue;
    }

    var opB = operationsB[indexB]; // Transform `a` by `b` and `b` by `a`.

    var newOpsA = transform_transform(opA, opB, contextFactory.getContext(opA, opB, true));
    var newOpsB = transform_transform(opB, opA, contextFactory.getContext(opB, opA, false)); // As a result we get one or more `newOpsA` and one or more `newOpsB` operations.
    // Update contextual information about operations.

    contextFactory.updateRelation(opA, opB);
    contextFactory.setOriginalOperations(newOpsA, opA);
    contextFactory.setOriginalOperations(newOpsB, opB); // For new `a` operations, update their index of the next operation `b` to transform them by.
    //
    // This is needed even if there was only one result (`a` was not broken) because that information is used
    // at the beginning of this loop every time.

    var _iterator2 = _createForOfIteratorHelper(newOpsA),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var newOpA = _step2.value;
        // Acknowledge, that operation `b` also might be broken into multiple operations.
        //
        // This is why we raise `indexB` not just by 1. If `newOpsB` are multiple operations, they will be
        // spliced in the place of `opB`. So we need to change `transformBy` accordingly, so that an operation won't
        // be transformed by the same operation (part of it) again.
        nextTransformIndex.set(newOpA, indexB + newOpsB.length);
      } // Update `operationsA` and `operationsB` with the transformed versions.

    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    (_operationsA = operationsA).splice.apply(_operationsA, [i, 1].concat(_toConsumableArray(newOpsA)));

    (_operationsB = operationsB).splice.apply(_operationsB, [indexB, 1].concat(_toConsumableArray(newOpsB)));
  }

  if (options.padWithNoOps) {
    // If no-operations padding is enabled, count how many extra `a` and `b` operations were generated.
    var brokenOperationsACount = operationsA.length - data.originalOperationsACount;
    var brokenOperationsBCount = operationsB.length - data.originalOperationsBCount; // Then, if that number is not the same, pad `operationsA` or `operationsB` with correct number of no-ops so
    // that the base versions are equalled.
    //
    // Note that only one array will be updated, as only one of those subtractions can be greater than zero.

    padWithNoOps(operationsA, brokenOperationsBCount - brokenOperationsACount);
    padWithNoOps(operationsB, brokenOperationsACount - brokenOperationsBCount);
  } // Finally, update base versions of transformed operations.


  updateBaseVersions(operationsA, data.nextBaseVersionB);
  updateBaseVersions(operationsB, data.nextBaseVersionA);
  return {
    operationsA: operationsA,
    operationsB: operationsB,
    originalOperations: originalOperations
  };
} // Gathers additional data about operations processed during transformation. Can be used to obtain contextual information
// about two operations that are about to be transformed. This contextual information can be used for better conflict resolution.

var transform_ContextFactory = /*#__PURE__*/function () {
  // Creates `ContextFactory` instance.
  //
  // @param {module:engine/model/document~Document} document Document which the operations change.
  // @param {Boolean} useRelations Whether during transformation relations should be used (used during undo for
  // better conflict resolution).
  // @param {Boolean} [forceWeakRemove=false] If set to `false`, remove operation will be always stronger than move operation,
  // so the removed nodes won't end up back in the document root. When set to `true`, context data will be used.
  function ContextFactory(document, useRelations) {
    var forceWeakRemove = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    Object(classCallCheck["a" /* default */])(this, ContextFactory);

    // For each operation that is created during transformation process, we keep a reference to the original operation
    // which it comes from. The original operation works as a kind of "identifier". Every contextual information
    // gathered during transformation that we want to save for given operation, is actually saved for the original operation.
    // This way no matter if operation `a` is cloned, then transformed, even breaks, we still have access to the previously
    // gathered data through original operation reference.
    this.originalOperations = new Map(); // `model.History` instance which information about undone operations will be taken from.

    this._history = document.history; // Whether additional context should be used.

    this._useRelations = useRelations;
    this._forceWeakRemove = !!forceWeakRemove; // Relations is a double-map structure (maps in map) where for two operations we store how those operations were related
    // to each other. Those relations are evaluated during transformation process. For every transformated pair of operations
    // we keep relations between them.

    this._relations = new Map();
  } // Sets "original operation" for given operations.
  //
  // During transformation process, operations are cloned, then changed, then processed again, sometimes broken into two
  // or multiple operations. When gathering additional data it is important that all operations can be somehow linked
  // so a cloned and transformed "version" still kept track of the data assigned earlier to it.
  //
  // The original operation object will be used as such an universal linking id. Throughout the transformation process
  // all cloned operations will refer to "the original operation" when storing and reading additional data.
  //
  // If `takeFrom` is not set, each operation from `operations` array will be assigned itself as "the original operation".
  // This should be used as an initialization step.
  //
  // If `takeFrom` is set, each operation from `operations` will be assigned the same original operation as assigned
  // for `takeFrom` operation. This should be used to update original operations. It should be used in a way that
  // `operations` are the result of `takeFrom` transformation to ensure proper "original operation propagation".
  //
  // @param {Array.<module:engine/model/operation/operation~Operation>} operations
  // @param {module:engine/model/operation/operation~Operation|null} [takeFrom=null]


  Object(createClass["a" /* default */])(ContextFactory, [{
    key: "setOriginalOperations",
    value: function setOriginalOperations(operations) {
      var takeFrom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var originalOperation = takeFrom ? this.originalOperations.get(takeFrom) : null;

      var _iterator3 = _createForOfIteratorHelper(operations),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var operation = _step3.value;
          this.originalOperations.set(operation, originalOperation || operation);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    } // Saves a relation between operations `opA` and `opB`.
    //
    // Relations are then later used to help solve conflicts when operations are transformed.
    //
    // @param {module:engine/model/operation/operation~Operation} opA
    // @param {module:engine/model/operation/operation~Operation} opB

  }, {
    key: "updateRelation",
    value: function updateRelation(opA, opB) {
      // The use of relations is described in a bigger detail in transformation functions.
      //
      // In brief, this function, for specified pairs of operation types, checks how positions defined in those operations relate.
      // Then those relations are saved. For example, for two move operations, it is saved if one of those operations target
      // position is before the other operation source position. This kind of information gives contextual information when
      // transformation is used during undo. Similar checks are done for other pairs of operations.
      //
      switch (opA.constructor) {
        case moveoperation_MoveOperation:
          {
            switch (opB.constructor) {
              case mergeoperation_MergeOperation:
                {
                  if (opA.targetPosition.isEqual(opB.sourcePosition) || opB.movedRange.containsPosition(opA.targetPosition)) {
                    this._setRelation(opA, opB, 'insertAtSource');
                  } else if (opA.targetPosition.isEqual(opB.deletionPosition)) {
                    this._setRelation(opA, opB, 'insertBetween');
                  } else if (opA.targetPosition.isAfter(opB.sourcePosition)) {
                    this._setRelation(opA, opB, 'moveTargetAfter');
                  }

                  break;
                }

              case moveoperation_MoveOperation:
                {
                  if (opA.targetPosition.isEqual(opB.sourcePosition) || opA.targetPosition.isBefore(opB.sourcePosition)) {
                    this._setRelation(opA, opB, 'insertBefore');
                  } else {
                    this._setRelation(opA, opB, 'insertAfter');
                  }

                  break;
                }
            }

            break;
          }

        case splitoperation_SplitOperation:
          {
            switch (opB.constructor) {
              case mergeoperation_MergeOperation:
                {
                  if (opA.splitPosition.isBefore(opB.sourcePosition)) {
                    this._setRelation(opA, opB, 'splitBefore');
                  }

                  break;
                }

              case moveoperation_MoveOperation:
                {
                  if (opA.splitPosition.isEqual(opB.sourcePosition) || opA.splitPosition.isBefore(opB.sourcePosition)) {
                    this._setRelation(opA, opB, 'splitBefore');
                  }

                  break;
                }
            }

            break;
          }

        case mergeoperation_MergeOperation:
          {
            switch (opB.constructor) {
              case mergeoperation_MergeOperation:
                {
                  if (!opA.targetPosition.isEqual(opB.sourcePosition)) {
                    this._setRelation(opA, opB, 'mergeTargetNotMoved');
                  }

                  if (opA.sourcePosition.isEqual(opB.targetPosition)) {
                    this._setRelation(opA, opB, 'mergeSourceNotMoved');
                  }

                  if (opA.sourcePosition.isEqual(opB.sourcePosition)) {
                    this._setRelation(opA, opB, 'mergeSameElement');
                  }

                  break;
                }

              case splitoperation_SplitOperation:
                {
                  if (opA.sourcePosition.isEqual(opB.splitPosition)) {
                    this._setRelation(opA, opB, 'splitAtSource');
                  }
                }
            }

            break;
          }

        case markeroperation_MarkerOperation:
          {
            var markerRange = opA.newRange;

            if (!markerRange) {
              return;
            }

            switch (opB.constructor) {
              case moveoperation_MoveOperation:
                {
                  var movedRange = model_range_Range._createFromPositionAndShift(opB.sourcePosition, opB.howMany);

                  var affectedLeft = movedRange.containsPosition(markerRange.start) || movedRange.start.isEqual(markerRange.start);
                  var affectedRight = movedRange.containsPosition(markerRange.end) || movedRange.end.isEqual(markerRange.end);

                  if ((affectedLeft || affectedRight) && !movedRange.containsRange(markerRange)) {
                    this._setRelation(opA, opB, {
                      side: affectedLeft ? 'left' : 'right',
                      path: affectedLeft ? markerRange.start.path.slice() : markerRange.end.path.slice()
                    });
                  }

                  break;
                }

              case mergeoperation_MergeOperation:
                {
                  var wasInLeftElement = markerRange.start.isEqual(opB.targetPosition);
                  var wasStartBeforeMergedElement = markerRange.start.isEqual(opB.deletionPosition);
                  var wasEndBeforeMergedElement = markerRange.end.isEqual(opB.deletionPosition);
                  var wasInRightElement = markerRange.end.isEqual(opB.sourcePosition);

                  if (wasInLeftElement || wasStartBeforeMergedElement || wasEndBeforeMergedElement || wasInRightElement) {
                    this._setRelation(opA, opB, {
                      wasInLeftElement: wasInLeftElement,
                      wasStartBeforeMergedElement: wasStartBeforeMergedElement,
                      wasEndBeforeMergedElement: wasEndBeforeMergedElement,
                      wasInRightElement: wasInRightElement
                    });
                  }

                  break;
                }
            }

            break;
          }
      }
    } // Evaluates and returns contextual information about two given operations `opA` and `opB` which are about to be transformed.
    //
    // @param {module:engine/model/operation/operation~Operation} opA
    // @param {module:engine/model/operation/operation~Operation} opB
    // @returns {module:engine/model/operation/transform~TransformationContext}

  }, {
    key: "getContext",
    value: function getContext(opA, opB, aIsStrong) {
      return {
        aIsStrong: aIsStrong,
        aWasUndone: this._wasUndone(opA),
        bWasUndone: this._wasUndone(opB),
        abRelation: this._useRelations ? this._getRelation(opA, opB) : null,
        baRelation: this._useRelations ? this._getRelation(opB, opA) : null,
        forceWeakRemove: this._forceWeakRemove
      };
    } // Returns whether given operation `op` has already been undone.
    //
    // Information whether an operation was undone gives more context when making a decision when two operations are in conflict.
    //
    // @param {module:engine/model/operation/operation~Operation} op
    // @returns {Boolean}

  }, {
    key: "_wasUndone",
    value: function _wasUndone(op) {
      // For `op`, get its original operation. After all, if `op` is a clone (or even transformed clone) of another
      // operation, literally `op` couldn't be undone. It was just generated. If anything, it was the operation it origins
      // from which was undone. So get that original operation.
      var originalOp = this.originalOperations.get(op); // And check with the document if the original operation was undone.

      return originalOp.wasUndone || this._history.isUndoneOperation(originalOp);
    } // Returns a relation between `opA` and an operation which is undone by `opB`. This can be `String` value if a relation
    // was set earlier or `null` if there was no relation between those operations.
    //
    // This is a little tricky to understand, so let's compare it to `ContextFactory#_wasUndone`.
    //
    // When `wasUndone( opB )` is used, we check if the `opB` has already been undone. It is obvious, that the
    // undoing operation must happen after the undone operation. So, essentially, we have `opB`, we take document history,
    // we look forward in the future and ask if in that future `opB` was undone.
    //
    // Relations is a backward process to `wasUndone()`.
    //
    // Long story short - using relations is asking what happened in the past. Looking back. This time we have an undoing
    // operation `opB` which has undone some other operation. When there is a transformation `opA` x `opB` and there is
    // a conflict to solve and `opB` is an undoing operation, we can look back in the history and see what was a relation
    // between `opA` and the operation which `opB` undone. Basing on that relation from the past, we can now make
    // a better decision when resolving a conflict between two operations, because we know more about the context of
    // those two operations.
    //
    // This is why this function does not return a relation directly between `opA` and `opB` because we need to look
    // back to search for a meaningful contextual information.
    //
    // @param {module:engine/model/operation/operation~Operation} opA
    // @param {module:engine/model/operation/operation~Operation} opB
    // @returns {String|null}

  }, {
    key: "_getRelation",
    value: function _getRelation(opA, opB) {
      // Get the original operation. Similarly as in `wasUndone()` it is used as an universal identifier for stored data.
      var origB = this.originalOperations.get(opB);

      var undoneB = this._history.getUndoneOperation(origB); // If `opB` is not undoing any operation, there is no relation.


      if (!undoneB) {
        return null;
      }

      var origA = this.originalOperations.get(opA);

      var relationsA = this._relations.get(origA); // Get all relations for `opA`, and check if there is a relation with `opB`-undone-counterpart. If so, return it.


      if (relationsA) {
        return relationsA.get(undoneB) || null;
      }

      return null;
    } // Helper function for `ContextFactory#updateRelations`.
    //
    // @private
    // @param {module:engine/model/operation/operation~Operation} opA
    // @param {module:engine/model/operation/operation~Operation} opB
    // @param {String} relation

  }, {
    key: "_setRelation",
    value: function _setRelation(opA, opB, relation) {
      // As always, setting is for original operations, not the clones/transformed operations.
      var origA = this.originalOperations.get(opA);
      var origB = this.originalOperations.get(opB);

      var relationsA = this._relations.get(origA);

      if (!relationsA) {
        relationsA = new Map();

        this._relations.set(origA, relationsA);
      }

      relationsA.set(origB, relation);
    }
  }]);

  return ContextFactory;
}();
/**
 * Holds additional contextual information about a transformed pair of operations (`a` and `b`). Those information
 * can be used for better conflict resolving.
 *
 * @typedef {Object} module:engine/model/operation/transform~TransformationContext
 *
 * @property {Boolean} aIsStrong Whether `a` is strong operation in this transformation, or weak.
 * @property {Boolean} aWasUndone Whether `a` operation was undone.
 * @property {Boolean} bWasUndone Whether `b` operation was undone.
 * @property {String|null} abRelation The relation between `a` operation and an operation undone by `b` operation.
 * @property {String|null} baRelation The relation between `b` operation and an operation undone by `a` operation.
 */

/**
 * An utility function that updates {@link module:engine/model/operation/operation~Operation#baseVersion base versions}
 * of passed operations.
 *
 * The function simply sets `baseVersion` as a base version of the first passed operation and then increments it for
 * each following operation in `operations`.
 *
 * @private
 * @param {Array.<module:engine/model/operation/operation~Operation>} operations Operations to update.
 * @param {Number} baseVersion Base version to set for the first operation in `operations`.
 */


function updateBaseVersions(operations, baseVersion) {
  var _iterator4 = _createForOfIteratorHelper(operations),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var operation = _step4.value;
      operation.baseVersion = baseVersion++;
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
}
/**
 * Adds `howMany` instances of {@link module:engine/model/operation/nooperation~NoOperation} to `operations` set.
 *
 * @private
 * @param {Array.<module:engine/model/operation/operation~Operation>} operations
 * @param {Number} howMany
 */


function padWithNoOps(operations, howMany) {
  for (var i = 0; i < howMany; i++) {
    operations.push(new nooperation_NoOperation(0));
  }
} // -----------------------


setTransformation(attributeoperation_AttributeOperation, attributeoperation_AttributeOperation, function (a, b, context) {
  // If operations in conflict, check if their ranges intersect and manage them properly.
  //
  // Operations can be in conflict only if:
  //
  // * their key is the same (they change the same attribute), and
  // * they are in the same parent (operations for ranges [ 1 ] - [ 3 ] and [ 2, 0 ] - [ 2, 5 ] change different
  // elements and can't be in conflict).
  if (a.key === b.key && a.range.start.hasSameParentAs(b.range.start)) {
    // First, we want to apply change to the part of a range that has not been changed by the other operation.
    var operations = a.range.getDifference(b.range).map(function (range) {
      return new attributeoperation_AttributeOperation(range, a.key, a.oldValue, a.newValue, 0);
    }); // Then we take care of the common part of ranges.

    var common = a.range.getIntersection(b.range);

    if (common) {
      // If this operation is more important, we also want to apply change to the part of the
      // original range that has already been changed by the other operation. Since that range
      // got changed we also have to update `oldValue`.
      if (context.aIsStrong) {
        operations.push(new attributeoperation_AttributeOperation(common, b.key, b.newValue, a.newValue, 0));
      }
    }

    if (operations.length == 0) {
      return [new nooperation_NoOperation(0)];
    }

    return operations;
  } else {
    // If operations don't conflict, simply return an array containing just a clone of this operation.
    return [a];
  }
});
setTransformation(attributeoperation_AttributeOperation, insertoperation_InsertOperation, function (a, b) {
  // Case 1:
  //
  // The attribute operation range includes the position where nodes were inserted.
  // There are two possible scenarios: the inserted nodes were text and they should receive attributes or
  // the inserted nodes were elements and they should not receive attributes.
  //
  if (a.range.start.hasSameParentAs(b.position) && a.range.containsPosition(b.position)) {
    // If new nodes should not receive attributes, two separated ranges will be returned.
    // Otherwise, one expanded range will be returned.
    var range = a.range._getTransformedByInsertion(b.position, b.howMany, !b.shouldReceiveAttributes);

    var result = range.map(function (r) {
      return new attributeoperation_AttributeOperation(r, a.key, a.oldValue, a.newValue, a.baseVersion);
    });

    if (b.shouldReceiveAttributes) {
      // `AttributeOperation#range` includes some newly inserted text.
      // The operation should also change the attribute of that text. An example:
      //
      // Bold should be applied on the following range:
      // <p>Fo[zb]ar</p>
      //
      // In meantime, new text is typed:
      // <p>Fozxxbar</p>
      //
      // Bold should be applied also on the new text:
      // <p>Fo[zxxb]ar</p>
      // <p>Fo<$text bold="true">zxxb</$text>ar</p>
      //
      // There is a special case to consider here to consider.
      //
      // Consider setting an attribute with multiple possible values, for example `highlight`. The inserted text might
      // have already an attribute value applied and the `oldValue` property of the attribute operation might be wrong:
      //
      // Attribute `highlight="yellow"` should be applied on the following range:
      // <p>Fo[zb]ar<p>
      //
      // In meantime, character `x` with `highlight="red"` is typed:
      // <p>Fo[z<$text highlight="red">x</$text>b]ar</p>
      //
      // In this case we cannot simply apply operation changing the attribute value from `null` to `"yellow"` for the whole range
      // because that would lead to an exception (`oldValue` is incorrect for `x`).
      //
      // We also cannot break the original range as this would mess up a scenario when there are multiple following
      // insert operations, because then only the first inserted character is included in those ranges:
      // <p>Fo[z][x][b]ar</p>   -->   <p>Fo[z][x]x[b]ar</p>   -->   <p>Fo[z][x]xx[b]ar</p>
      //
      // So, the attribute range needs be expanded, no matter what attributes are set on the inserted nodes:
      //
      // <p>Fo[z<$text highlight="red">x</$text>b]ar</p>      <--- Change from `null` to `yellow`, throwing an exception.
      //
      // But before that operation would be applied, we will add an additional attribute operation that will change
      // attributes on the inserted nodes in a way which would make the original operation correct:
      //
      // <p>Fo[z{<$text highlight="red">}x</$text>b]ar</p>    <--- Change range `{}` from `red` to `null`.
      // <p>Fo[zxb]ar</p>                                     <--- Now change from `null` to `yellow` is completely fine.
      //
      // Generate complementary attribute operation. Be sure to add it before the original operation.
      var op = _getComplementaryAttributeOperations(b, a.key, a.oldValue);

      if (op) {
        result.unshift(op);
      }
    } // If nodes should not receive new attribute, we are done here.


    return result;
  } // If insert operation is not expanding the attribute operation range, simply transform the range.


  a.range = a.range._getTransformedByInsertion(b.position, b.howMany, false)[0];
  return [a];
});
/**
 * Helper function for `AttributeOperation` x `InsertOperation` (and reverse) transformation.
 *
 * For given `insertOperation` it checks the inserted node if it has an attribute `key` set to a value different
 * than `newValue`. If so, it generates an `AttributeOperation` which changes the value of `key` attribute to `newValue`.
 *
 * @private
 * @param {module:engine/model/operation/insertoperation~InsertOperation} insertOperation
 * @param {String} key
 * @param {*} newValue
 * @returns {module:engine/model/operation/attributeoperation~AttributeOperation|null}
 */

function _getComplementaryAttributeOperations(insertOperation, key, newValue) {
  var nodes = insertOperation.nodes; // At the beginning we store the attribute value from the first node.

  var insertValue = nodes.getNode(0).getAttribute(key);

  if (insertValue == newValue) {
    return null;
  }

  var range = new model_range_Range(insertOperation.position, insertOperation.position.getShiftedBy(insertOperation.howMany));
  return new attributeoperation_AttributeOperation(range, key, insertValue, newValue, 0);
}

setTransformation(attributeoperation_AttributeOperation, mergeoperation_MergeOperation, function (a, b) {
  var ranges = []; // Case 1:
  //
  // Attribute change on the merged element. In this case, the merged element was moved to the graveyard.
  // An additional attribute operation that will change the (re)moved element needs to be generated.
  //

  if (a.range.start.hasSameParentAs(b.deletionPosition)) {
    if (a.range.containsPosition(b.deletionPosition) || a.range.start.isEqual(b.deletionPosition)) {
      ranges.push(model_range_Range._createFromPositionAndShift(b.graveyardPosition, 1));
    }
  }

  var range = a.range._getTransformedByMergeOperation(b); // Do not add empty (collapsed) ranges to the result. `range` may be collapsed if it contained only the merged element.


  if (!range.isCollapsed) {
    ranges.push(range);
  } // Create `AttributeOperation`s out of the ranges.


  return ranges.map(function (range) {
    return new attributeoperation_AttributeOperation(range, a.key, a.oldValue, a.newValue, a.baseVersion);
  });
});
setTransformation(attributeoperation_AttributeOperation, moveoperation_MoveOperation, function (a, b) {
  var ranges = _breakRangeByMoveOperation(a.range, b); // Create `AttributeOperation`s out of the ranges.


  return ranges.map(function (range) {
    return new attributeoperation_AttributeOperation(range, a.key, a.oldValue, a.newValue, a.baseVersion);
  });
}); // Helper function for `AttributeOperation` x `MoveOperation` transformation.
//
// Takes the passed `range` and transforms it by move operation `moveOp` in a specific way. Only top-level nodes of `range`
// are considered to be in the range. If move operation moves nodes deep from inside of the range, those nodes won't
// be included in the result. In other words, top-level nodes of the ranges from the result are exactly the same as
// top-level nodes of the original `range`.
//
// This is important for `AttributeOperation` because, for its range, it changes only the top-level nodes. So we need to
// track only how those nodes have been affected by `MoveOperation`.
//
// @private
// @param {module:engine/model/range~Range} range
// @param {module:engine/model/operation/moveoperation~MoveOperation} moveOp
// @returns {Array.<module:engine/model/range~Range>}

function _breakRangeByMoveOperation(range, moveOp) {
  var moveRange = model_range_Range._createFromPositionAndShift(moveOp.sourcePosition, moveOp.howMany); // We are transforming `range` (original range) by `moveRange` (range moved by move operation). As usual when it comes to
  // transforming a ranges, we may have a common part of the ranges and we may have a difference part (zero to two ranges).


  var common = null;
  var difference = []; // Let's compare the ranges.

  if (moveRange.containsRange(range, true)) {
    // If the whole original range is moved, treat it whole as a common part. There's also no difference part.
    common = range;
  } else if (range.start.hasSameParentAs(moveRange.start)) {
    // If the ranges are "on the same level" (in the same parent) then move operation may move exactly those nodes
    // that are changed by the attribute operation. In this case we get common part and difference part in the usual way.
    difference = range.getDifference(moveRange);
    common = range.getIntersection(moveRange);
  } else {
    // In any other situation we assume that original range is different than move range, that is that move operation
    // moves other nodes that attribute operation change. Even if the moved range is deep inside in the original range.
    //
    // Note that this is different than in `.getIntersection` (we would get a common part in that case) and different
    // than `.getDifference` (we would get two ranges).
    difference = [range];
  }

  var result = []; // The default behaviour of `_getTransformedByMove` might get wrong results for difference part, though, so
  // we do it by hand.

  var _iterator5 = _createForOfIteratorHelper(difference),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var diff = _step5.value;
      // First, transform the range by removing moved nodes. Since this is a difference, this is safe, `null` won't be returned
      // as the range is different than the moved range.
      diff = diff._getTransformedByDeletion(moveOp.sourcePosition, moveOp.howMany); // Transform also `targetPosition`.

      var targetPosition = moveOp.getMovedRangeStart(); // Spread the range only if moved nodes are inserted only between the top-level nodes of the `diff` range.

      var spread = diff.start.hasSameParentAs(targetPosition); // Transform by insertion of moved nodes.

      diff = diff._getTransformedByInsertion(targetPosition, moveOp.howMany, spread);
      result.push.apply(result, _toConsumableArray(diff));
    } // Common part can be simply transformed by the move operation. This is because move operation will not target to
    // that common part (the operation would have to target inside its own moved range).

  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  if (common) {
    result.push(common._getTransformedByMove(moveOp.sourcePosition, moveOp.targetPosition, moveOp.howMany, false)[0]);
  }

  return result;
}

setTransformation(attributeoperation_AttributeOperation, splitoperation_SplitOperation, function (a, b) {
  // Case 1:
  //
  // Split node is the last node in `AttributeOperation#range`.
  // `AttributeOperation#range` needs to be expanded to include the new (split) node.
  //
  // Attribute `type` to be changed to `numbered` but the `listItem` is split.
  // <listItem type="bulleted">foobar</listItem>
  //
  // After split:
  // <listItem type="bulleted">foo</listItem><listItem type="bulleted">bar</listItem>
  //
  // After attribute change:
  // <listItem type="numbered">foo</listItem><listItem type="numbered">foo</listItem>
  //
  if (a.range.end.isEqual(b.insertionPosition)) {
    if (!b.graveyardPosition) {
      a.range.end.offset++;
    }

    return [a];
  } // Case 2:
  //
  // Split position is inside `AttributeOperation#range`, at the same level, so the nodes to change are
  // not going to make a flat range.
  //
  // Content with range-to-change and split position:
  // <p>Fo[zb^a]r</p>
  //
  // After split:
  // <p>Fozb</p><p>ar</p>
  //
  // Make two separate ranges containing all nodes to change:
  // <p>Fo[zb]</p><p>[a]r</p>
  //


  if (a.range.start.hasSameParentAs(b.splitPosition) && a.range.containsPosition(b.splitPosition)) {
    var secondPart = a.clone();
    secondPart.range = new model_range_Range(b.moveTargetPosition.clone(), a.range.end._getCombined(b.splitPosition, b.moveTargetPosition));
    a.range.end = b.splitPosition.clone();
    a.range.end.stickiness = 'toPrevious';
    return [a, secondPart];
  } // The default case.
  //


  a.range = a.range._getTransformedBySplitOperation(b);
  return [a];
});
setTransformation(insertoperation_InsertOperation, attributeoperation_AttributeOperation, function (a, b) {
  var result = [a]; // Case 1:
  //
  // The attribute operation range includes the position where nodes were inserted.
  // There are two possible scenarios: the inserted nodes were text and they should receive attributes or
  // the inserted nodes were elements and they should not receive attributes.
  //
  // This is a mirror scenario to the one described in `AttributeOperation` x `InsertOperation` transformation,
  // although this case is a little less complicated. In this case we simply need to change attributes of the
  // inserted nodes and that's it.
  //

  if (a.shouldReceiveAttributes && a.position.hasSameParentAs(b.range.start) && b.range.containsPosition(a.position)) {
    var op = _getComplementaryAttributeOperations(a, b.key, b.newValue);

    if (op) {
      result.push(op);
    }
  } // The default case is: do nothing.
  // `AttributeOperation` does not change the model tree structure so `InsertOperation` does not need to be changed.
  //


  return result;
});
setTransformation(insertoperation_InsertOperation, insertoperation_InsertOperation, function (a, b, context) {
  // Case 1:
  //
  // Two insert operations insert nodes at the same position. Since they are the same, it needs to be decided
  // what will be the order of inserted nodes. However, there is no additional information to help in that
  // decision. Also, when `b` will be transformed by `a`, the same order must be maintained.
  //
  // To achieve that, we will check if the operation is strong.
  // If it is, it won't get transformed. If it is not, it will be moved.
  //
  if (a.position.isEqual(b.position) && context.aIsStrong) {
    return [a];
  } // The default case.
  //


  a.position = a.position._getTransformedByInsertOperation(b);
  return [a];
});
setTransformation(insertoperation_InsertOperation, moveoperation_MoveOperation, function (a, b) {
  // The default case.
  //
  a.position = a.position._getTransformedByMoveOperation(b);
  return [a];
});
setTransformation(insertoperation_InsertOperation, splitoperation_SplitOperation, function (a, b) {
  // The default case.
  //
  a.position = a.position._getTransformedBySplitOperation(b);
  return [a];
});
setTransformation(insertoperation_InsertOperation, mergeoperation_MergeOperation, function (a, b) {
  a.position = a.position._getTransformedByMergeOperation(b);
  return [a];
}); // -----------------------

setTransformation(markeroperation_MarkerOperation, insertoperation_InsertOperation, function (a, b) {
  if (a.oldRange) {
    a.oldRange = a.oldRange._getTransformedByInsertOperation(b)[0];
  }

  if (a.newRange) {
    a.newRange = a.newRange._getTransformedByInsertOperation(b)[0];
  }

  return [a];
});
setTransformation(markeroperation_MarkerOperation, markeroperation_MarkerOperation, function (a, b, context) {
  if (a.name == b.name) {
    if (context.aIsStrong) {
      a.oldRange = b.newRange ? b.newRange.clone() : null;
    } else {
      return [new nooperation_NoOperation(0)];
    }
  }

  return [a];
});
setTransformation(markeroperation_MarkerOperation, mergeoperation_MergeOperation, function (a, b) {
  if (a.oldRange) {
    a.oldRange = a.oldRange._getTransformedByMergeOperation(b);
  }

  if (a.newRange) {
    a.newRange = a.newRange._getTransformedByMergeOperation(b);
  }

  return [a];
});
setTransformation(markeroperation_MarkerOperation, moveoperation_MoveOperation, function (a, b, context) {
  if (a.oldRange) {
    a.oldRange = model_range_Range._createFromRanges(a.oldRange._getTransformedByMoveOperation(b));
  }

  if (a.newRange) {
    if (context.abRelation) {
      var aNewRange = model_range_Range._createFromRanges(a.newRange._getTransformedByMoveOperation(b));

      if (context.abRelation.side == 'left' && b.targetPosition.isEqual(a.newRange.start)) {
        a.newRange.start.path = context.abRelation.path;
        a.newRange.end = aNewRange.end;
        return [a];
      } else if (context.abRelation.side == 'right' && b.targetPosition.isEqual(a.newRange.end)) {
        a.newRange.start = aNewRange.start;
        a.newRange.end.path = context.abRelation.path;
        return [a];
      }
    }

    a.newRange = model_range_Range._createFromRanges(a.newRange._getTransformedByMoveOperation(b));
  }

  return [a];
});
setTransformation(markeroperation_MarkerOperation, splitoperation_SplitOperation, function (a, b, context) {
  if (a.oldRange) {
    a.oldRange = a.oldRange._getTransformedBySplitOperation(b);
  }

  if (a.newRange) {
    if (context.abRelation) {
      var aNewRange = a.newRange._getTransformedBySplitOperation(b);

      if (a.newRange.start.isEqual(b.splitPosition) && context.abRelation.wasStartBeforeMergedElement) {
        a.newRange.start = model_position_Position._createAt(b.insertionPosition);
      } else if (a.newRange.start.isEqual(b.splitPosition) && !context.abRelation.wasInLeftElement) {
        a.newRange.start = model_position_Position._createAt(b.moveTargetPosition);
      }

      if (a.newRange.end.isEqual(b.splitPosition) && context.abRelation.wasInRightElement) {
        a.newRange.end = model_position_Position._createAt(b.moveTargetPosition);
      } else if (a.newRange.end.isEqual(b.splitPosition) && context.abRelation.wasEndBeforeMergedElement) {
        a.newRange.end = model_position_Position._createAt(b.insertionPosition);
      } else {
        a.newRange.end = aNewRange.end;
      }

      return [a];
    }

    a.newRange = a.newRange._getTransformedBySplitOperation(b);
  }

  return [a];
}); // -----------------------

setTransformation(mergeoperation_MergeOperation, insertoperation_InsertOperation, function (a, b) {
  if (a.sourcePosition.hasSameParentAs(b.position)) {
    a.howMany += b.howMany;
  }

  a.sourcePosition = a.sourcePosition._getTransformedByInsertOperation(b);
  a.targetPosition = a.targetPosition._getTransformedByInsertOperation(b);
  return [a];
});
setTransformation(mergeoperation_MergeOperation, mergeoperation_MergeOperation, function (a, b, context) {
  // Case 1:
  //
  // Same merge operations.
  //
  // Both operations have same source and target positions. So the element already got merged and there is
  // theoretically nothing to do.
  //
  if (a.sourcePosition.isEqual(b.sourcePosition) && a.targetPosition.isEqual(b.targetPosition)) {
    // There are two ways that we can provide a do-nothing operation.
    //
    // First is simply a NoOperation instance. We will use it if `b` operation was not undone.
    //
    // Second is a merge operation that has the source operation in the merged element - in the graveyard -
    // same target position and `howMany` equal to `0`. So it is basically merging an empty element from graveyard
    // which is almost the same as NoOperation.
    //
    // This way the merge operation can be later transformed by split operation
    // to provide correct undo. This will be used if `b` operation was undone (only then it is correct).
    //
    if (!context.bWasUndone) {
      return [new nooperation_NoOperation(0)];
    } else {
      var path = b.graveyardPosition.path.slice();
      path.push(0);
      a.sourcePosition = new model_position_Position(b.graveyardPosition.root, path);
      a.howMany = 0;
      return [a];
    }
  } // Case 2:
  //
  // Same merge source position but different target position.
  //
  // This can happen during collaboration. For example, if one client merged a paragraph to the previous paragraph
  // and the other person removed that paragraph and merged the same paragraph to something before:
  //
  // Client A:
  // <p>Foo</p><p>Bar</p><p>[]Xyz</p>
  // <p>Foo</p><p>BarXyz</p>
  //
  // Client B:
  // <p>Foo</p>[<p>Bar</p>]<p>Xyz</p>
  // <p>Foo</p><p>[]Xyz</p>
  // <p>FooXyz</p>
  //
  // In this case we need to decide where finally "Xyz" will land:
  //
  // <p>FooXyz</p>               graveyard: <p>Bar</p>
  // <p>Foo</p>                  graveyard: <p>BarXyz</p>
  //
  // Let's move it in a way so that a merge operation that does not target to graveyard is more important so that
  // nodes does not end up in the graveyard. It makes sense. Both for Client A and for Client B "Xyz" finally did not
  // end up in the graveyard (see above).
  //
  // If neither or both operations point to graveyard, then let `aIsStrong` decide.
  //


  if (a.sourcePosition.isEqual(b.sourcePosition) && !a.targetPosition.isEqual(b.targetPosition) && !context.bWasUndone && context.abRelation != 'splitAtSource') {
    var aToGraveyard = a.targetPosition.root.rootName == '$graveyard';
    var bToGraveyard = b.targetPosition.root.rootName == '$graveyard'; // If `aIsWeak` it means that `a` points to graveyard while `b` doesn't. Don't move nodes then.

    var aIsWeak = aToGraveyard && !bToGraveyard; // If `bIsWeak` it means that `b` points to graveyard while `a` doesn't. Force moving nodes then.

    var bIsWeak = bToGraveyard && !aToGraveyard; // Force move if `b` is weak or neither operation is weak but `a` is stronger through `context.aIsStrong`.

    var forceMove = bIsWeak || !aIsWeak && context.aIsStrong;

    if (forceMove) {
      var sourcePosition = b.targetPosition._getTransformedByMergeOperation(b);

      var targetPosition = a.targetPosition._getTransformedByMergeOperation(b);

      return [new moveoperation_MoveOperation(sourcePosition, a.howMany, targetPosition, 0)];
    } else {
      return [new nooperation_NoOperation(0)];
    }
  } // The default case.
  //


  if (a.sourcePosition.hasSameParentAs(b.targetPosition)) {
    a.howMany += b.howMany;
  }

  a.sourcePosition = a.sourcePosition._getTransformedByMergeOperation(b);
  a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b); // Handle positions in graveyard.
  // If graveyard positions are same and `a` operation is strong - do not transform.

  if (!a.graveyardPosition.isEqual(b.graveyardPosition) || !context.aIsStrong) {
    a.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation(b);
  }

  return [a];
});
setTransformation(mergeoperation_MergeOperation, moveoperation_MoveOperation, function (a, b, context) {
  // Case 1:
  //
  // The element to merge got removed.
  //
  // Merge operation does support merging elements which are not siblings. So it would not be a problem
  // from technical point of view. However, if the element was removed, the intention of the user deleting it
  // was to have it all deleted, together with its children. From user experience point of view, moving back the
  // removed nodes might be unexpected. This means that in this scenario we will block the merging.
  //
  // The exception of this rule would be if the remove operation was later undone.
  //
  var removedRange = model_range_Range._createFromPositionAndShift(b.sourcePosition, b.howMany);

  if (b.type == 'remove' && !context.bWasUndone && !context.forceWeakRemove) {
    if (a.deletionPosition.hasSameParentAs(b.sourcePosition) && removedRange.containsPosition(a.sourcePosition)) {
      return [new nooperation_NoOperation(0)];
    }
  } // The default case.
  //


  if (a.sourcePosition.hasSameParentAs(b.targetPosition)) {
    a.howMany += b.howMany;
  }

  if (a.sourcePosition.hasSameParentAs(b.sourcePosition)) {
    a.howMany -= b.howMany;
  }

  a.sourcePosition = a.sourcePosition._getTransformedByMoveOperation(b);
  a.targetPosition = a.targetPosition._getTransformedByMoveOperation(b); // `MergeOperation` graveyard position is like `MoveOperation` target position. It is a position where element(s) will
  // be moved. Like in other similar cases, we need to consider the scenario when those positions are same.
  // Here, we will treat `MergeOperation` like it is always strong (see `InsertOperation` x `InsertOperation` for comparison).
  // This means that we won't transform graveyard position if it is equal to move operation target position.

  if (!a.graveyardPosition.isEqual(b.targetPosition)) {
    a.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation(b);
  }

  return [a];
});
setTransformation(mergeoperation_MergeOperation, splitoperation_SplitOperation, function (a, b, context) {
  if (b.graveyardPosition) {
    // If `b` operation defines graveyard position, a node from graveyard will be moved. This means that we need to
    // transform `a.graveyardPosition` accordingly.
    a.graveyardPosition = a.graveyardPosition._getTransformedByDeletion(b.graveyardPosition, 1); // This is a scenario foreseen in `MergeOperation` x `MergeOperation`, with two identical merge operations.
    //
    // So, there was `MergeOperation` x `MergeOperation` transformation earlier. Now, `a` is a merge operation which
    // source position is in graveyard. Interestingly, split operation wants to use the node to be merged by `a`. This
    // means that `b` is undoing that merge operation from earlier, which caused `a` to be in graveyard.
    //
    // If that's the case, at this point, we will only "fix" `a.howMany`. It was earlier set to `0` in
    // `MergeOperation` x `MergeOperation` transformation. Later transformations in this function will change other
    // properties.
    //

    if (a.deletionPosition.isEqual(b.graveyardPosition)) {
      a.howMany = b.howMany;
    }
  } // Case 1:
  //
  // Merge operation moves nodes to the place where split happens.
  // This is a classic situation when there are two paragraphs, and there is a split (enter) after the first
  // paragraph and there is a merge (delete) at the beginning of the second paragraph:
  //
  // <p>Foo{}</p><p>[]Bar</p>.
  //
  // Split is after `Foo`, while merge is from `Bar` to the end of `Foo`.
  //
  // State after split:
  // <p>Foo</p><p></p><p>Bar</p>
  //
  // Now, `Bar` should be merged to the new paragraph:
  // <p>Foo</p><p>Bar</p>
  //
  // Instead of merging it to the original paragraph:
  // <p>FooBar</p><p></p>
  //
  // This means that `targetPosition` needs to be transformed. This is the default case though.
  // For example, if the split would be after `F`, `targetPosition` should also be transformed.
  //
  // There are three exceptions, though, when we want to keep `targetPosition` as it was.
  //
  // First exception is when the merge target position is inside an element (not at the end, as usual). This
  // happens when the merge operation earlier was transformed by "the same" merge operation. If merge operation
  // targets inside the element we want to keep the original target position (and not transform it) because
  // we have additional context telling us that we want to merge to the original element. We can check if the
  // merge operation points inside element by checking what is `SplitOperation#howMany`. Since merge target position
  // is same as split position, if `howMany` is non-zero, it means that the merge target position is inside an element.
  //
  // Second exception is when the element to merge is in the graveyard and split operation uses it. In that case
  // if target position would be transformed, the merge operation would target at the source position:
  //
  // root: <p>Foo</p>				graveyard: <p></p>
  //
  // SplitOperation: root [ 0, 3 ] using graveyard [ 0 ] (howMany = 0)
  // MergeOperation: graveyard [ 0, 0 ] -> root [ 0, 3 ] (howMany = 0)
  //
  // Since split operation moves the graveyard node back to the root, the merge operation source position changes.
  // We would like to merge from the empty <p> to the "Foo" <p>:
  //
  // root: <p>Foo</p><p></p>			graveyard:
  //
  // MergeOperation#sourcePosition = root [ 1, 0 ]
  //
  // If `targetPosition` is transformed, it would become root [ 1, 0 ] as well. It has to be kept as it was.
  //
  // Third exception is connected with relations. If this happens during undo and we have explicit information
  // that target position has not been affected by the operation which is undone by this split then this split should
  // not move the target position either.
  //


  if (a.targetPosition.isEqual(b.splitPosition)) {
    var mergeInside = b.howMany != 0;
    var mergeSplittingElement = b.graveyardPosition && a.deletionPosition.isEqual(b.graveyardPosition);

    if (mergeInside || mergeSplittingElement || context.abRelation == 'mergeTargetNotMoved') {
      a.sourcePosition = a.sourcePosition._getTransformedBySplitOperation(b);
      return [a];
    }
  } // Case 2:
  //
  // Merge source is at the same position as split position. This sometimes happen, mostly during undo.
  // The decision here is mostly to choose whether merge source position should stay where it is (so it will be at the end of the
  // split element) or should be move to the beginning of the new element.
  //


  if (a.sourcePosition.isEqual(b.splitPosition)) {
    // Use context to check if `SplitOperation` is not undoing a merge operation, that didn't change the `a` operation.
    // This scenario happens the undone merge operation moved nodes at the source position of `a` operation.
    // In that case `a` operation source position should stay where it is.
    if (context.abRelation == 'mergeSourceNotMoved') {
      a.howMany = 0;
      a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);
      return [a];
    } // This merge operation might have been earlier transformed by a merge operation which both merged the same element.
    // See that case in `MergeOperation` x `MergeOperation` transformation. In that scenario, if the merge operation has been undone,
    // the special case is not applied.
    //
    // Now, the merge operation is transformed by the split which has undone that previous merge operation.
    // So now we are fixing situation which was skipped in `MergeOperation` x `MergeOperation` case.
    //


    if (context.abRelation == 'mergeSameElement' || a.sourcePosition.offset > 0) {
      a.sourcePosition = b.moveTargetPosition.clone();
      a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);
      return [a];
    }
  } // The default case.
  //


  if (a.sourcePosition.hasSameParentAs(b.splitPosition)) {
    a.howMany = b.splitPosition.offset;
  }

  a.sourcePosition = a.sourcePosition._getTransformedBySplitOperation(b);
  a.targetPosition = a.targetPosition._getTransformedBySplitOperation(b);
  return [a];
}); // -----------------------

setTransformation(moveoperation_MoveOperation, insertoperation_InsertOperation, function (a, b) {
  var moveRange = model_range_Range._createFromPositionAndShift(a.sourcePosition, a.howMany);

  var transformed = moveRange._getTransformedByInsertOperation(b, false)[0];

  a.sourcePosition = transformed.start;
  a.howMany = transformed.end.offset - transformed.start.offset; // See `InsertOperation` x `MoveOperation` transformation for details on this case.
  //
  // In summary, both operations point to the same place, so the order of nodes needs to be decided.
  // `MoveOperation` is considered weaker, so it is always transformed, unless there was a certain relation
  // between operations.
  //

  if (!a.targetPosition.isEqual(b.position)) {
    a.targetPosition = a.targetPosition._getTransformedByInsertOperation(b);
  }

  return [a];
});
setTransformation(moveoperation_MoveOperation, moveoperation_MoveOperation, function (a, b, context) {
  //
  // Setting and evaluating some variables that will be used in special cases and default algorithm.
  //
  // Create ranges from `MoveOperations` properties.
  var rangeA = model_range_Range._createFromPositionAndShift(a.sourcePosition, a.howMany);

  var rangeB = model_range_Range._createFromPositionAndShift(b.sourcePosition, b.howMany); // Assign `context.aIsStrong` to a different variable, because the value may change during execution of
  // this algorithm and we do not want to override original `context.aIsStrong` that will be used in later transformations.


  var aIsStrong = context.aIsStrong; // This will be used to decide the order of nodes if both operations target at the same position.
  // By default, use strong/weak operation mechanism.

  var insertBefore = !context.aIsStrong; // If the relation is set, then use it to decide nodes order.

  if (context.abRelation == 'insertBefore' || context.baRelation == 'insertAfter') {
    insertBefore = true;
  } else if (context.abRelation == 'insertAfter' || context.baRelation == 'insertBefore') {
    insertBefore = false;
  } // `a.targetPosition` could be affected by the `b` operation. We will transform it.


  var newTargetPosition;

  if (a.targetPosition.isEqual(b.targetPosition) && insertBefore) {
    newTargetPosition = a.targetPosition._getTransformedByDeletion(b.sourcePosition, b.howMany);
  } else {
    newTargetPosition = a.targetPosition._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
  } //
  // Special case #1 + mirror.
  //
  // Special case when both move operations' target positions are inside nodes that are
  // being moved by the other move operation. So in other words, we move ranges into inside of each other.
  // This case can't be solved reasonably (on the other hand, it should not happen often).


  if (_moveTargetIntoMovedRange(a, b) && _moveTargetIntoMovedRange(b, a)) {
    // Instead of transforming operation, we return a reverse of the operation that we transform by.
    // So when the results of this "transformation" will be applied, `b` MoveOperation will get reversed.
    return [b.getReversed()];
  } //
  // End of special case #1.
  //
  //
  // Special case #2.
  //
  // Check if `b` operation targets inside `rangeA`.


  var bTargetsToA = rangeA.containsPosition(b.targetPosition); // If `b` targets to `rangeA` and `rangeA` contains `rangeB`, `b` operation has no influence on `a` operation.
  // You might say that operation `b` is captured inside operation `a`.

  if (bTargetsToA && rangeA.containsRange(rangeB, true)) {
    // There is a mini-special case here, where `rangeB` is on other level than `rangeA`. That's why
    // we need to transform `a` operation anyway.
    rangeA.start = rangeA.start._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
    rangeA.end = rangeA.end._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
    return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);
  } //
  // Special case #2 mirror.
  //


  var aTargetsToB = rangeB.containsPosition(a.targetPosition);

  if (aTargetsToB && rangeB.containsRange(rangeA, true)) {
    // `a` operation is "moved together" with `b` operation.
    // Here, just move `rangeA` "inside" `rangeB`.
    rangeA.start = rangeA.start._getCombined(b.sourcePosition, b.getMovedRangeStart());
    rangeA.end = rangeA.end._getCombined(b.sourcePosition, b.getMovedRangeStart());
    return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);
  } //
  // End of special case #2.
  //
  //
  // Special case #3 + mirror.
  //
  // `rangeA` has a node which is an ancestor of `rangeB`. In other words, `rangeB` is inside `rangeA`
  // but not on the same tree level. In such case ranges have common part but we have to treat it
  // differently, because in such case those ranges are not really conflicting and should be treated like
  // two separate ranges. Also we have to discard two difference parts.


  var aCompB = compareArrays(a.sourcePosition.getParentPath(), b.sourcePosition.getParentPath());

  if (aCompB == 'prefix' || aCompB == 'extension') {
    // Transform `rangeA` by `b` operation and make operation out of it, and that's all.
    // Note that this is a simplified version of default case, but here we treat the common part (whole `rangeA`)
    // like a one difference part.
    rangeA.start = rangeA.start._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
    rangeA.end = rangeA.end._getTransformedByMove(b.sourcePosition, b.targetPosition, b.howMany);
    return _makeMoveOperationsFromRanges([rangeA], newTargetPosition);
  } //
  // End of special case #3.
  //
  //
  // Default case - ranges are on the same level or are not connected with each other.
  //
  // Modifier for default case.
  // Modifies `aIsStrong` flag in certain conditions.
  //
  // If only one of operations is a remove operation, we force remove operation to be the "stronger" one
  // to provide more expected results.


  if (a.type == 'remove' && b.type != 'remove' && !context.aWasUndone && !context.forceWeakRemove) {
    aIsStrong = true;
  } else if (a.type != 'remove' && b.type == 'remove' && !context.bWasUndone && !context.forceWeakRemove) {
    aIsStrong = false;
  } // Handle operation's source ranges - check how `rangeA` is affected by `b` operation.
  // This will aggregate transformed ranges.


  var ranges = []; // Get the "difference part" of `a` operation source range.
  // This is an array with one or two ranges. Two ranges if `rangeB` is inside `rangeA`.

  var difference = rangeA.getDifference(rangeB);

  var _iterator6 = _createForOfIteratorHelper(difference),
      _step6;

  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var range = _step6.value;
      // Transform those ranges by `b` operation. For example if `b` moved range from before those ranges, fix those ranges.
      range.start = range.start._getTransformedByDeletion(b.sourcePosition, b.howMany);
      range.end = range.end._getTransformedByDeletion(b.sourcePosition, b.howMany); // If `b` operation targets into `rangeA` on the same level, spread `rangeA` into two ranges.

      var shouldSpread = compareArrays(range.start.getParentPath(), b.getMovedRangeStart().getParentPath()) == 'same';

      var newRanges = range._getTransformedByInsertion(b.getMovedRangeStart(), b.howMany, shouldSpread);

      ranges.push.apply(ranges, _toConsumableArray(newRanges));
    } // Then, we have to manage the "common part" of both move ranges.

  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  var common = rangeA.getIntersection(rangeB);

  if (common !== null && aIsStrong) {
    // Calculate the new position of that part of original range.
    common.start = common.start._getCombined(b.sourcePosition, b.getMovedRangeStart());
    common.end = common.end._getCombined(b.sourcePosition, b.getMovedRangeStart()); // Take care of proper range order.
    //
    // Put `common` at appropriate place. Keep in mind that we are interested in original order.
    // Basically there are only three cases: there is zero, one or two difference ranges.
    //
    // If there is zero difference ranges, just push `common` in the array.

    if (ranges.length === 0) {
      ranges.push(common);
    } // If there is one difference range, we need to check whether common part was before it or after it.
    else if (ranges.length == 1) {
        if (rangeB.start.isBefore(rangeA.start) || rangeB.start.isEqual(rangeA.start)) {
          ranges.unshift(common);
        } else {
          ranges.push(common);
        }
      } // If there are more ranges (which means two), put common part between them. This is the only scenario
      // where there could be two difference ranges so we don't have to make any comparisons.
      else {
          ranges.splice(1, 0, common);
        }
  }

  if (ranges.length === 0) {
    // If there are no "source ranges", nothing should be changed.
    // Note that this can happen only if `aIsStrong == false` and `rangeA.isEqual( rangeB )`.
    return [new nooperation_NoOperation(a.baseVersion)];
  }

  return _makeMoveOperationsFromRanges(ranges, newTargetPosition);
});
setTransformation(moveoperation_MoveOperation, splitoperation_SplitOperation, function (a, b, context) {
  var newTargetPosition = a.targetPosition.clone(); // Do not transform if target position is same as split insertion position and this split comes from undo.
  // This should be done on relations but it is too much work for now as it would require relations working in collaboration.
  // We need to make a decision how we will resolve such conflict and this is less harmful way.

  if (!a.targetPosition.isEqual(b.insertionPosition) || !b.graveyardPosition || context.abRelation == 'moveTargetAfter') {
    newTargetPosition = a.targetPosition._getTransformedBySplitOperation(b);
  } // Case 1:
  //
  // Last element in the moved range got split.
  //
  // In this case the default range transformation will not work correctly as the element created by
  // split operation would be outside the range. The range to move needs to be fixed manually.
  //


  var moveRange = model_range_Range._createFromPositionAndShift(a.sourcePosition, a.howMany);

  if (moveRange.end.isEqual(b.insertionPosition)) {
    // Do it only if this is a "natural" split, not a one that comes from undo.
    // If this is undo split, only `targetPosition` needs to be changed (if the move is a remove).
    if (!b.graveyardPosition) {
      a.howMany++;
    }

    a.targetPosition = newTargetPosition;
    return [a];
  } // Case 2:
  //
  // Split happened between the moved nodes. In this case two ranges to move need to be generated.
  //
  // Characters `ozba` are moved to the end of paragraph `Xyz` but split happened.
  // <p>F[oz|ba]r</p><p>Xyz</p>
  //
  // After split:
  // <p>F[oz</p><p>ba]r</p><p>Xyz</p>
  //
  // Correct ranges:
  // <p>F[oz]</p><p>[ba]r</p><p>Xyz</p>
  //
  // After move:
  // <p>F</p><p>r</p><p>Xyzozba</p>
  //


  if (moveRange.start.hasSameParentAs(b.splitPosition) && moveRange.containsPosition(b.splitPosition)) {
    var rightRange = new model_range_Range(b.splitPosition, moveRange.end);
    rightRange = rightRange._getTransformedBySplitOperation(b);
    var _ranges = [new model_range_Range(moveRange.start, b.splitPosition), rightRange];
    return _makeMoveOperationsFromRanges(_ranges, newTargetPosition);
  } // Case 3:
  //
  // Move operation targets at the split position. We need to decide if the nodes should be inserted
  // at the end of the split element or at the beginning of the new element.
  //


  if (a.targetPosition.isEqual(b.splitPosition) && context.abRelation == 'insertAtSource') {
    newTargetPosition = b.moveTargetPosition;
  } // Case 4:
  //
  // Move operation targets just after the split element. We need to decide if the nodes should be inserted
  // between two parts of split element, or after the new element.
  //
  // Split at `|`, while move operation moves `<p>Xyz</p>` and targets at `^`:
  // <p>Foo|bar</p>^<p>baz</p>
  // <p>Foo</p>^<p>bar</p><p>baz</p> or <p>Foo</p><p>bar</p>^<p>baz</p>?
  //
  // If there is no contextual information between operations (for example, they come from collaborative
  // editing), we don't want to put some unrelated content (move) between parts of related content (split parts).
  // However, if the split is from undo, in the past, the moved content might be targeting between the
  // split parts, meaning that was exactly user's intention:
  //
  // <p>Foo</p>^<p>bar</p>		<--- original situation, in "past".
  // <p>Foobar</p>^				<--- after merge target position is transformed.
  // <p>Foo|bar</p>^				<--- then the merge is undone, and split happens, which leads us to current situation.
  //
  // In this case it is pretty clear that the intention was to put new paragraph between those nodes,
  // so we need to transform accordingly. We can detect this scenario thanks to relations.
  //


  if (a.targetPosition.isEqual(b.insertionPosition) && context.abRelation == 'insertBetween') {
    newTargetPosition = a.targetPosition;
  } // The default case.
  //


  var transformed = moveRange._getTransformedBySplitOperation(b);

  var ranges = [transformed]; // Case 5:
  //
  // Moved range contains graveyard element used by split operation. Add extra move operation to the result.
  //

  if (b.graveyardPosition) {
    var movesGraveyardElement = moveRange.start.isEqual(b.graveyardPosition) || moveRange.containsPosition(b.graveyardPosition);

    if (a.howMany > 1 && movesGraveyardElement && !context.aWasUndone) {
      ranges.push(model_range_Range._createFromPositionAndShift(b.insertionPosition, 1));
    }
  }

  return _makeMoveOperationsFromRanges(ranges, newTargetPosition);
});
setTransformation(moveoperation_MoveOperation, mergeoperation_MergeOperation, function (a, b, context) {
  var movedRange = model_range_Range._createFromPositionAndShift(a.sourcePosition, a.howMany);

  if (b.deletionPosition.hasSameParentAs(a.sourcePosition) && movedRange.containsPosition(b.sourcePosition)) {
    if (a.type == 'remove' && !context.forceWeakRemove) {
      // Case 1:
      //
      // The element to remove got merged.
      //
      // Merge operation does support merging elements which are not siblings. So it would not be a problem
      // from technical point of view. However, if the element was removed, the intention of the user
      // deleting it was to have it all deleted. From user experience point of view, moving back the
      // removed nodes might be unexpected. This means that in this scenario we will reverse merging and remove the element.
      //
      if (!context.aWasUndone) {
        var results = [];
        var gyMoveSource = b.graveyardPosition.clone();

        var splitNodesMoveSource = b.targetPosition._getTransformedByMergeOperation(b);

        if (a.howMany > 1) {
          results.push(new moveoperation_MoveOperation(a.sourcePosition, a.howMany - 1, a.targetPosition, 0));
          gyMoveSource = gyMoveSource._getTransformedByMove(a.sourcePosition, a.targetPosition, a.howMany - 1);
          splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(a.sourcePosition, a.targetPosition, a.howMany - 1);
        }

        var gyMoveTarget = b.deletionPosition._getCombined(a.sourcePosition, a.targetPosition);

        var gyMove = new moveoperation_MoveOperation(gyMoveSource, 1, gyMoveTarget, 0);
        var splitNodesMoveTargetPath = gyMove.getMovedRangeStart().path.slice();
        splitNodesMoveTargetPath.push(0);
        var splitNodesMoveTarget = new model_position_Position(gyMove.targetPosition.root, splitNodesMoveTargetPath);
        splitNodesMoveSource = splitNodesMoveSource._getTransformedByMove(gyMoveSource, gyMoveTarget, 1);
        var splitNodesMove = new moveoperation_MoveOperation(splitNodesMoveSource, b.howMany, splitNodesMoveTarget, 0);
        results.push(gyMove);
        results.push(splitNodesMove);
        return results;
      }
    } else {
      // Case 2:
      //
      // The element to move got merged and it was the only element to move.
      // In this case just don't do anything, leave the node in the graveyard. Without special case
      // it would be a move operation that moves 0 nodes, so maybe it is better just to return no-op.
      //
      if (a.howMany == 1) {
        if (!context.bWasUndone) {
          return [new nooperation_NoOperation(0)];
        } else {
          a.sourcePosition = b.graveyardPosition.clone();
          a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);
          return [a];
        }
      }
    }
  } // The default case.
  //


  var moveRange = model_range_Range._createFromPositionAndShift(a.sourcePosition, a.howMany);

  var transformed = moveRange._getTransformedByMergeOperation(b);

  a.sourcePosition = transformed.start;
  a.howMany = transformed.end.offset - transformed.start.offset;
  a.targetPosition = a.targetPosition._getTransformedByMergeOperation(b);
  return [a];
}); // -----------------------

setTransformation(renameoperation_RenameOperation, insertoperation_InsertOperation, function (a, b) {
  a.position = a.position._getTransformedByInsertOperation(b);
  return [a];
});
setTransformation(renameoperation_RenameOperation, mergeoperation_MergeOperation, function (a, b) {
  // Case 1:
  //
  // Element to rename got merged, so it was moved to `b.graveyardPosition`.
  //
  if (a.position.isEqual(b.deletionPosition)) {
    a.position = b.graveyardPosition.clone();
    a.position.stickiness = 'toNext';
    return [a];
  }

  a.position = a.position._getTransformedByMergeOperation(b);
  return [a];
});
setTransformation(renameoperation_RenameOperation, moveoperation_MoveOperation, function (a, b) {
  a.position = a.position._getTransformedByMoveOperation(b);
  return [a];
});
setTransformation(renameoperation_RenameOperation, renameoperation_RenameOperation, function (a, b, context) {
  if (a.position.isEqual(b.position)) {
    if (context.aIsStrong) {
      a.oldName = b.newName;
    } else {
      return [new nooperation_NoOperation(0)];
    }
  }

  return [a];
});
setTransformation(renameoperation_RenameOperation, splitoperation_SplitOperation, function (a, b) {
  // Case 1:
  //
  // The element to rename has been split. In this case, the new element should be also renamed.
  //
  // User decides to change the paragraph to a list item:
  // <paragraph>Foobar</paragraph>
  //
  // However, in meantime, split happens:
  // <paragraph>Foo</paragraph><paragraph>bar</paragraph>
  //
  // As a result, rename both elements:
  // <listItem>Foo</listItem><listItem>bar</listItem>
  //
  var renamePath = a.position.path;
  var splitPath = b.splitPosition.getParentPath();

  if (compareArrays(renamePath, splitPath) == 'same' && !b.graveyardPosition) {
    var extraRename = new renameoperation_RenameOperation(a.position.getShiftedBy(1), a.oldName, a.newName, 0);
    return [a, extraRename];
  } // The default case.
  //


  a.position = a.position._getTransformedBySplitOperation(b);
  return [a];
}); // -----------------------

setTransformation(rootattributeoperation_RootAttributeOperation, rootattributeoperation_RootAttributeOperation, function (a, b, context) {
  if (a.root === b.root && a.key === b.key) {
    if (!context.aIsStrong || a.newValue === b.newValue) {
      return [new nooperation_NoOperation(0)];
    } else {
      a.oldValue = b.newValue;
    }
  }

  return [a];
}); // -----------------------

setTransformation(splitoperation_SplitOperation, insertoperation_InsertOperation, function (a, b) {
  // The default case.
  //
  if (a.splitPosition.hasSameParentAs(b.position) && a.splitPosition.offset < b.position.offset) {
    a.howMany += b.howMany;
  }

  a.splitPosition = a.splitPosition._getTransformedByInsertOperation(b);
  a.insertionPosition = splitoperation_SplitOperation.getInsertionPosition(a.splitPosition);
  return [a];
});
setTransformation(splitoperation_SplitOperation, mergeoperation_MergeOperation, function (a, b, context) {
  // Case 1:
  //
  // Split element got merged. If two different elements were merged, clients will have different content.
  //
  // Example. Merge at `{}`, split at `[]`:
  // <heading>Foo</heading>{}<paragraph>B[]ar</paragraph>
  //
  // On merge side it will look like this:
  // <heading>FooB[]ar</heading>
  // <heading>FooB</heading><heading>ar</heading>
  //
  // On split side it will look like this:
  // <heading>Foo</heading>{}<paragraph>B</paragraph><paragraph>ar</paragraph>
  // <heading>FooB</heading><paragraph>ar</paragraph>
  //
  // Clearly, the second element is different for both clients.
  //
  // We could use the removed merge element from graveyard as a split element but then clients would have a different
  // model state (in graveyard), because the split side client would still have an element in graveyard (removed by merge).
  //
  // To overcome this, in `SplitOperation` x `MergeOperation` transformation we will add additional `SplitOperation`
  // in the graveyard, which will actually clone the merged-and-deleted element. Then, that cloned element will be
  // used for splitting. Example below.
  //
  // Original state:
  // <heading>Foo</heading>{}<paragraph>B[]ar</paragraph>
  //
  // Merge side client:
  //
  // After merge:
  // <heading>FooB[]ar</heading>                                 graveyard: <paragraph></paragraph>
  //
  // Extra split:
  // <heading>FooB[]ar</heading>                                 graveyard: <paragraph></paragraph><paragraph></paragraph>
  //
  // Use the "cloned" element from graveyard:
  // <heading>FooB</heading><paragraph>ar</paragraph>            graveyard: <paragraph></paragraph>
  //
  // Split side client:
  //
  // After split:
  // <heading>Foo</heading>{}<paragraph>B</paragraph><paragraph>ar</paragraph>
  //
  // After merge:
  // <heading>FooB</heading><paragraph>ar</paragraph>            graveyard: <paragraph></paragraph>
  //
  // This special case scenario only applies if the original split operation clones the split element.
  // If the original split operation has `graveyardPosition` set, it all doesn't have sense because split operation
  // knows exactly which element it should use. So there would be no original problem with different contents.
  //
  // Additionally, the special case applies only if the merge wasn't already undone.
  //
  if (!a.graveyardPosition && !context.bWasUndone && a.splitPosition.hasSameParentAs(b.sourcePosition)) {
    var splitPath = b.graveyardPosition.path.slice();
    splitPath.push(0);
    var splitPosition = new model_position_Position(b.graveyardPosition.root, splitPath);
    var insertionPosition = splitoperation_SplitOperation.getInsertionPosition(new model_position_Position(b.graveyardPosition.root, splitPath));
    var additionalSplit = new splitoperation_SplitOperation(splitPosition, 0, null, 0);
    additionalSplit.insertionPosition = insertionPosition;
    a.splitPosition = a.splitPosition._getTransformedByMergeOperation(b);
    a.insertionPosition = splitoperation_SplitOperation.getInsertionPosition(a.splitPosition);
    a.graveyardPosition = additionalSplit.insertionPosition.clone();
    a.graveyardPosition.stickiness = 'toNext';
    return [additionalSplit, a];
  } // The default case.
  //


  if (a.splitPosition.hasSameParentAs(b.deletionPosition) && !a.splitPosition.isAfter(b.deletionPosition)) {
    a.howMany--;
  }

  if (a.splitPosition.hasSameParentAs(b.targetPosition)) {
    a.howMany += b.howMany;
  }

  a.splitPosition = a.splitPosition._getTransformedByMergeOperation(b);
  a.insertionPosition = splitoperation_SplitOperation.getInsertionPosition(a.splitPosition);

  if (a.graveyardPosition) {
    a.graveyardPosition = a.graveyardPosition._getTransformedByMergeOperation(b);
  }

  return [a];
});
setTransformation(splitoperation_SplitOperation, moveoperation_MoveOperation, function (a, b, context) {
  var rangeToMove = model_range_Range._createFromPositionAndShift(b.sourcePosition, b.howMany);

  if (a.graveyardPosition) {
    // Case 1:
    //
    // Split operation graveyard node was moved. In this case move operation is stronger. Since graveyard element
    // is already moved to the correct position, we need to only move the nodes after the split position.
    // This will be done by `MoveOperation` instead of `SplitOperation`.
    //
    var gyElementMoved = rangeToMove.start.isEqual(a.graveyardPosition) || rangeToMove.containsPosition(a.graveyardPosition);

    if (!context.bWasUndone && gyElementMoved) {
      var sourcePosition = a.splitPosition._getTransformedByMoveOperation(b);

      var newParentPosition = a.graveyardPosition._getTransformedByMoveOperation(b);

      var newTargetPath = newParentPosition.path.slice();
      newTargetPath.push(0);
      var newTargetPosition = new model_position_Position(newParentPosition.root, newTargetPath);
      var moveOp = new moveoperation_MoveOperation(sourcePosition, a.howMany, newTargetPosition, 0);
      return [moveOp];
    }

    a.graveyardPosition = a.graveyardPosition._getTransformedByMoveOperation(b);
  } // Case 2:
  //
  // If the split position is inside the moved range, we need to shift the split position to a proper place.
  // The position cannot be moved together with moved range because that would result in splitting of an incorrect element.
  //
  // Characters `bc` should be moved to the second paragraph while split position is between them:
  // <paragraph>A[b|c]d</paragraph><paragraph>Xyz</paragraph>
  //
  // After move, new split position is incorrect:
  // <paragraph>Ad</paragraph><paragraph>Xb|cyz</paragraph>
  //
  // Correct split position:
  // <paragraph>A|d</paragraph><paragraph>Xbcyz</paragraph>
  //
  // After split:
  // <paragraph>A</paragraph><paragraph>d</paragraph><paragraph>Xbcyz</paragraph>
  //


  if (a.splitPosition.hasSameParentAs(b.sourcePosition) && rangeToMove.containsPosition(a.splitPosition)) {
    var howManyRemoved = b.howMany - (a.splitPosition.offset - b.sourcePosition.offset);
    a.howMany -= howManyRemoved;

    if (a.splitPosition.hasSameParentAs(b.targetPosition) && a.splitPosition.offset < b.targetPosition.offset) {
      a.howMany += b.howMany;
    }

    a.splitPosition = b.sourcePosition.clone();
    a.insertionPosition = splitoperation_SplitOperation.getInsertionPosition(a.splitPosition);
    return [a];
  } // Case 3:
  //
  // Split is at a position where nodes were moved.
  //
  // This is a scenario described in `MoveOperation` x `SplitOperation` transformation but from the
  // "split operation point of view".
  //


  var splitAtTarget = a.splitPosition.isEqual(b.targetPosition);

  if (splitAtTarget && (context.baRelation == 'insertAtSource' || context.abRelation == 'splitBefore')) {
    a.howMany += b.howMany;
    a.splitPosition = a.splitPosition._getTransformedByDeletion(b.sourcePosition, b.howMany);
    a.insertionPosition = splitoperation_SplitOperation.getInsertionPosition(a.splitPosition);
    return [a];
  } // The default case.
  // Don't change `howMany` if move operation does not really move anything.
  //


  if (!b.sourcePosition.isEqual(b.targetPosition)) {
    if (a.splitPosition.hasSameParentAs(b.sourcePosition) && a.splitPosition.offset <= b.sourcePosition.offset) {
      a.howMany -= b.howMany;
    }

    if (a.splitPosition.hasSameParentAs(b.targetPosition) && a.splitPosition.offset < b.targetPosition.offset) {
      a.howMany += b.howMany;
    }
  } // Change position stickiness to force a correct transformation.


  a.splitPosition.stickiness = 'toNone';
  a.splitPosition = a.splitPosition._getTransformedByMoveOperation(b);
  a.splitPosition.stickiness = 'toNext';

  if (a.graveyardPosition) {
    a.insertionPosition = a.insertionPosition._getTransformedByMoveOperation(b);
  } else {
    a.insertionPosition = splitoperation_SplitOperation.getInsertionPosition(a.splitPosition);
  }

  return [a];
});
setTransformation(splitoperation_SplitOperation, splitoperation_SplitOperation, function (a, b, context) {
  // Case 1:
  //
  // Split at the same position.
  //
  // If there already was a split at the same position as in `a` operation, it means that the intention
  // conveyed by `a` operation has already been fulfilled and `a` should not do anything (to avoid double split).
  //
  // However, there is a difference if these are new splits or splits created by undo. These have different
  // intentions. Also splits moving back different elements from graveyard have different intentions. They
  // are just different operations.
  //
  // So we cancel split operation only if it was really identical.
  //
  // Also, there is additional case, where split operations aren't identical and should not be cancelled, however the
  // default transformation is incorrect too.
  //
  if (a.splitPosition.isEqual(b.splitPosition)) {
    if (!a.graveyardPosition && !b.graveyardPosition) {
      return [new nooperation_NoOperation(0)];
    }

    if (a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual(b.graveyardPosition)) {
      return [new nooperation_NoOperation(0)];
    } // Use context to know that the `a.splitPosition` should stay where it is.
    // This happens during undo when first a merge operation moved nodes to `a.splitPosition` and now `b` operation undoes that merge.


    if (context.abRelation == 'splitBefore') {
      // Since split is at the same position, there are no nodes left to split.
      a.howMany = 0; // Note: there was `if ( a.graveyardPosition )` here but it was uncovered in tests and I couldn't find any scenarios for now.
      // That would have to be a `SplitOperation` that didn't come from undo but is transformed by operations that were undone.
      // It could happen if `context` is enabled in collaboration.

      a.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation(b);
      return [a];
    }
  } // Case 2:
  //
  // Same node is using to split different elements. This happens in undo when previously same element was merged to
  // two different elements. This is described in `MergeOperation` x `MergeOperation` transformation.
  //
  // In this case we will follow the same logic. We will assume that `insertionPosition` is same for both
  // split operations. This might not always be true but in the real cases that were experienced it was. After all,
  // if these splits are reverses of merge operations that were merging the same element, then the `insertionPosition`
  // should be same for both of those splits.
  //
  // Again, we will decide which operation is stronger by checking if split happens in graveyard or in non-graveyard root.
  //


  if (a.graveyardPosition && b.graveyardPosition && a.graveyardPosition.isEqual(b.graveyardPosition)) {
    var aInGraveyard = a.splitPosition.root.rootName == '$graveyard';
    var bInGraveyard = b.splitPosition.root.rootName == '$graveyard'; // If `aIsWeak` it means that `a` points to graveyard while `b` doesn't. Don't move nodes then.

    var aIsWeak = aInGraveyard && !bInGraveyard; // If `bIsWeak` it means that `b` points to graveyard while `a` doesn't. Force moving nodes then.

    var bIsWeak = bInGraveyard && !aInGraveyard; // Force move if `b` is weak or neither operation is weak but `a` is stronger through `context.aIsStrong`.

    var forceMove = bIsWeak || !aIsWeak && context.aIsStrong;

    if (forceMove) {
      var result = []; // First we need to move any nodes split by `b` back to where they were.
      // Do it only if `b` actually moved something.

      if (b.howMany) {
        result.push(new moveoperation_MoveOperation(b.moveTargetPosition, b.howMany, b.splitPosition, 0));
      } // Then we need to move nodes from `a` split position to their new element.
      // Do it only if `a` actually should move something.


      if (a.howMany) {
        result.push(new moveoperation_MoveOperation(a.splitPosition, a.howMany, a.moveTargetPosition, 0));
      }

      return result;
    } else {
      return [new nooperation_NoOperation(0)];
    }
  }

  if (a.graveyardPosition) {
    a.graveyardPosition = a.graveyardPosition._getTransformedBySplitOperation(b);
  } // Case 3:
  //
  // Position where operation `b` inserted a new node after split is the same as the operation `a` split position.
  // As in similar cases, there is ambiguity if the split should be before the new node (created by `b`) or after.
  //


  if (a.splitPosition.isEqual(b.insertionPosition) && context.abRelation == 'splitBefore') {
    a.howMany++;
    return [a];
  } // Case 4:
  //
  // This is a mirror to the case 2. above.
  //


  if (b.splitPosition.isEqual(a.insertionPosition) && context.baRelation == 'splitBefore') {
    var newPositionPath = b.insertionPosition.path.slice();
    newPositionPath.push(0);
    var newPosition = new model_position_Position(b.insertionPosition.root, newPositionPath);
    var moveOp = new moveoperation_MoveOperation(a.insertionPosition, 1, newPosition, 0);
    return [a, moveOp];
  } // The default case.
  //


  if (a.splitPosition.hasSameParentAs(b.splitPosition) && a.splitPosition.offset < b.splitPosition.offset) {
    a.howMany -= b.howMany;
  }

  a.splitPosition = a.splitPosition._getTransformedBySplitOperation(b);
  a.insertionPosition = splitoperation_SplitOperation.getInsertionPosition(a.splitPosition);
  return [a];
}); // Checks whether `MoveOperation` `targetPosition` is inside a node from the moved range of the other `MoveOperation`.
//
// @private
// @param {module:engine/model/operation/moveoperation~MoveOperation} a
// @param {module:engine/model/operation/moveoperation~MoveOperation} b
// @returns {Boolean}

function _moveTargetIntoMovedRange(a, b) {
  return a.targetPosition._getTransformedByDeletion(b.sourcePosition, b.howMany) === null;
} // Helper function for `MoveOperation` x `MoveOperation` transformation. Converts given ranges and target position to
// move operations and returns them.
//
// Ranges and target position will be transformed on-the-fly when generating operations.
//
// Given `ranges` should be in the order of how they were in the original transformed operation.
//
// Given `targetPosition` is the target position of the first range from `ranges`.
//
// @private
// @param {Array.<module:engine/model/range~Range>} ranges
// @param {module:engine/model/position~Position} targetPosition
// @returns {Array.<module:engine/model/operation/moveoperation~MoveOperation>}


function _makeMoveOperationsFromRanges(ranges, targetPosition) {
  // At this moment we have some ranges and a target position, to which those ranges should be moved.
  // Order in `ranges` array is the go-to order of after transformation.
  //
  // We are almost done. We have `ranges` and `targetPosition` to make operations from.
  // Unfortunately, those operations may affect each other. Precisely, first operation after move
  // may affect source range and target position of second and third operation. Same with second
  // operation affecting third.
  //
  // We need to fix those source ranges and target positions once again, before converting `ranges` to operations.
  var operations = []; // Keep in mind that nothing will be transformed if there is just one range in `ranges`.

  for (var i = 0; i < ranges.length; i++) {
    // Create new operation out of a range and target position.
    var range = ranges[i];
    var op = new moveoperation_MoveOperation(range.start, range.end.offset - range.start.offset, targetPosition, 0);
    operations.push(op); // Transform other ranges by the generated operation.

    for (var j = i + 1; j < ranges.length; j++) {
      // All ranges in `ranges` array should be:
      //
      // * non-intersecting (these are part of original operation source range), and
      // * `targetPosition` does not target into them (opposite would mean that transformed operation targets "inside itself").
      //
      // This means that the transformation will be "clean" and always return one result.
      ranges[j] = ranges[j]._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany)[0];
    }

    targetPosition = targetPosition._getTransformedByMove(op.sourcePosition, op.targetPosition, op.howMany);
  }

  return operations;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-undo/src/basecommand.js
















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module undo/basecommand
 */


/**
 * Base class for undo feature commands: {@link module:undo/undocommand~UndoCommand} and {@link module:undo/redocommand~RedoCommand}.
 *
 * @protected
 * @extends module:core/command~Command
 */

var basecommand_BaseCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(BaseCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(BaseCommand);

  function BaseCommand(editor) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, BaseCommand);

    _this = _super.call(this, editor);
    /**
     * Stack of items stored by the command. These are pairs of:
     *
     * * {@link module:engine/model/batch~Batch batch} saved by the command,
     * * {@link module:engine/model/selection~Selection selection} state at the moment of saving the batch.
     *
     * @protected
     * @member {Array} #_stack
     */

    _this._stack = [];
    /**
     * Stores all batches that were created by this command.
     *
     * @protected
     * @member {WeakSet.<module:engine/model/batch~Batch>} #_createdBatches
     */

    _this._createdBatches = new WeakSet(); // Refresh state, so the command is inactive right after initialization.

    _this.refresh();

    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(BaseCommand, [{
    key: "refresh",
    value: function refresh() {
      this.isEnabled = this._stack.length > 0;
    }
    /**
     * Stores a batch in the command, together with the selection state of the {@link module:engine/model/document~Document document}
     * created by the editor which this command is registered to.
     *
     * @param {module:engine/model/batch~Batch} batch The batch to add.
     */

  }, {
    key: "addBatch",
    value: function addBatch(batch) {
      var docSelection = this.editor.model.document.selection;
      var selection = {
        ranges: docSelection.hasOwnRange ? Array.from(docSelection.getRanges()) : [],
        isBackward: docSelection.isBackward
      };

      this._stack.push({
        batch: batch,
        selection: selection
      });

      this.refresh();
    }
    /**
     * Removes all items from the stack.
     */

  }, {
    key: "clearStack",
    value: function clearStack() {
      this._stack = [];
      this.refresh();
    }
    /**
     * Restores the {@link module:engine/model/document~Document#selection document selection} state after a batch was undone.
     *
     * @protected
     * @param {Array.<module:engine/model/range~Range>} ranges Ranges to be restored.
     * @param {Boolean} isBackward A flag describing whether the restored range was selected forward or backward.
     * @param {Array.<module:engine/model/operation/operation~Operation>} operations Operations which has been applied
     * since selection has been stored.
     */

  }, {
    key: "_restoreSelection",
    value: function _restoreSelection(ranges, isBackward, operations) {
      var model = this.editor.model;
      var document = model.document; // This will keep the transformed selection ranges.

      var selectionRanges = []; // Transform all ranges from the restored selection.

      var _iterator = _createForOfIteratorHelper(ranges),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var range = _step.value;
          var transformed = transformSelectionRange(range, operations); // For each `range` from `ranges`, we take only one transformed range.
          // This is because we want to prevent situation where single-range selection
          // got transformed to multi-range selection. We will take the first range that
          // is not in the graveyard.

          var newRange = transformed.find(function (range) {
            return range.start.root != document.graveyard;
          }); // `transformedRange` might be `undefined` if transformed range ended up in graveyard.

          if (newRange) {
            selectionRanges.push(newRange);
          }
        } // `selectionRanges` may be empty if all ranges ended up in graveyard. If that is the case, do not restore selection.

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      if (selectionRanges.length) {
        model.change(function (writer) {
          writer.setSelection(selectionRanges, {
            backward: isBackward
          });
        });
      }
    }
    /**
     * Undoes a batch by reversing that batch, transforming reversed batch and finally applying it.
     * This is a helper method for {@link #execute}.
     *
     * @protected
     * @param {module:engine/model/batch~Batch} batchToUndo The batch to be undone.
     * @param {module:engine/model/batch~Batch} undoingBatch The batch that will contain undoing changes.
     */

  }, {
    key: "_undo",
    value: function _undo(batchToUndo, undoingBatch) {
      var model = this.editor.model;
      var document = model.document; // All changes done by the command execution will be saved as one batch.

      this._createdBatches.add(undoingBatch);

      var operationsToUndo = batchToUndo.operations.slice().filter(function (operation) {
        return operation.isDocumentOperation;
      });
      operationsToUndo.reverse(); // We will process each operation from `batchToUndo`, in reverse order. If there were operations A, B and C in undone batch,
      // we need to revert them in reverse order, so first C' (reversed C), then B', then A'.

      var _iterator2 = _createForOfIteratorHelper(operationsToUndo),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var operationToUndo = _step2.value;
          var nextBaseVersion = operationToUndo.baseVersion + 1;
          var historyOperations = Array.from(document.history.getOperations(nextBaseVersion));
          var transformedSets = transformSets([operationToUndo.getReversed()], historyOperations, {
            useRelations: true,
            document: this.editor.model.document,
            padWithNoOps: false,
            forceWeakRemove: true
          });
          var reversedOperations = transformedSets.operationsA; // After reversed operation has been transformed by all history operations, apply it.

          var _iterator3 = _createForOfIteratorHelper(reversedOperations),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var operation = _step3.value;
              // Before applying, add the operation to the `undoingBatch`.
              undoingBatch.addOperation(operation);
              model.applyOperation(operation);
              document.history.setOperationAsUndone(operationToUndo, operation);
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
  }]);

  return BaseCommand;
}(command_Command); // Transforms given range `range` by given `operations`.
// Returns an array containing one or more ranges, which are result of the transformation.




function transformSelectionRange(range, operations) {
  var transformed = range.getTransformedByOperations(operations); // After `range` got transformed, we have an array of ranges. Some of those
  // ranges may be "touching" -- they can be next to each other and could be merged.
  // First, we have to sort those ranges to assure that they are in order.

  transformed.sort(function (a, b) {
    return a.start.isBefore(b.start) ? -1 : 1;
  }); // Then, we check if two consecutive ranges are touching.

  for (var i = 1; i < transformed.length; i++) {
    var a = transformed[i - 1];
    var b = transformed[i];

    if (a.end.isTouching(b.start)) {
      // And join them together if they are.
      a.end = b.end;
      transformed.splice(i, 1);
      i--;
    }
  }

  return transformed;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-undo/src/undocommand.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module undo/undocommand
 */

/**
 * The undo command stores {@link module:engine/model/batch~Batch batches} applied to the
 * {@link module:engine/model/document~Document document} and is able to undo a batch by reversing it and transforming by
 * batches from {@link module:engine/model/document~Document#history history} that happened after the reversed batch.
 *
 * The undo command also takes care of restoring the {@link module:engine/model/document~Document#selection document selection}.
 *
 * @extends module:undo/basecommand~BaseCommand
 */

var undocommand_UndoCommand = /*#__PURE__*/function (_BaseCommand) {
  Object(inherits["a" /* default */])(UndoCommand, _BaseCommand);

  var _super = Object(createSuper["a" /* default */])(UndoCommand);

  function UndoCommand() {
    Object(classCallCheck["a" /* default */])(this, UndoCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(UndoCommand, [{
    key: "execute",

    /**
     * Executes the command. This method reverts a {@link module:engine/model/batch~Batch batch} added to the command's stack, transforms
     * and applies the reverted version on the {@link module:engine/model/document~Document document} and removes the batch from the stack.
     * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
     *
     * @fires execute
     * @fires revert
     * @param {module:engine/model/batch~Batch} [batch] A batch that should be undone. If not set, the last added batch will be undone.
     */
    value: function execute() {
      var _this = this;

      var batch = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;
      // If batch is not given, set `batchIndex` to the last index in command stack.
      var batchIndex = batch ? this._stack.findIndex(function (a) {
        return a.batch == batch;
      }) : this._stack.length - 1;

      var item = this._stack.splice(batchIndex, 1)[0];

      var undoingBatch = this.editor.model.createBatch('transparent'); // All changes has to be done in one `enqueueChange` callback so other listeners will not
      // step between consecutive operations, or won't do changes to the document before selection is properly restored.

      this.editor.model.enqueueChange(undoingBatch, function () {
        _this._undo(item.batch, undoingBatch);

        var operations = _this.editor.model.document.history.getOperations(item.batch.baseVersion);

        _this._restoreSelection(item.selection.ranges, item.selection.isBackward, operations);

        _this.fire('revert', item.batch, undoingBatch);
      });
      this.refresh();
    }
  }]);

  return UndoCommand;
}(basecommand_BaseCommand);
/**
 * Fired when execution of the command reverts some batch.
 *
 * @event revert
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-undo/src/redocommand.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module undo/redocommand
 */

/**
 * The redo command stores {@link module:engine/model/batch~Batch batches} that were used to undo a batch by
 * {@link module:undo/undocommand~UndoCommand}. It is able to redo a previously undone batch by reversing the undoing
 * batches created by `UndoCommand`. The reversed batch is transformed by all the batches from
 * {@link module:engine/model/document~Document#history history} that happened after the reversed undo batch.
 *
 * The redo command also takes care of restoring the {@link module:engine/model/document~Document#selection document selection}.
 *
 * @extends module:undo/basecommand~BaseCommand
 */

var redocommand_RedoCommand = /*#__PURE__*/function (_BaseCommand) {
  Object(inherits["a" /* default */])(RedoCommand, _BaseCommand);

  var _super = Object(createSuper["a" /* default */])(RedoCommand);

  function RedoCommand() {
    Object(classCallCheck["a" /* default */])(this, RedoCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(RedoCommand, [{
    key: "execute",

    /**
     * Executes the command. This method reverts the last {@link module:engine/model/batch~Batch batch} added to
     * the command's stack, applies the reverted and transformed version on the
     * {@link module:engine/model/document~Document document} and removes the batch from the stack.
     * Then, it restores the {@link module:engine/model/document~Document#selection document selection}.
     *
     * @fires execute
     */
    value: function execute() {
      var _this = this;

      var item = this._stack.pop();

      var redoingBatch = this.editor.model.createBatch('transparent'); // All changes have to be done in one `enqueueChange` callback so other listeners will not step between consecutive
      // operations, or won't do changes to the document before selection is properly restored.

      this.editor.model.enqueueChange(redoingBatch, function () {
        var lastOperation = item.batch.operations[item.batch.operations.length - 1];
        var nextBaseVersion = lastOperation.baseVersion + 1;

        var operations = _this.editor.model.document.history.getOperations(nextBaseVersion);

        _this._restoreSelection(item.selection.ranges, item.selection.isBackward, operations);

        _this._undo(item.batch, redoingBatch);
      });
      this.refresh();
    }
  }]);

  return RedoCommand;
}(basecommand_BaseCommand);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-undo/src/undoediting.js










/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module undo/undoediting
 */



/**
 * The undo engine feature.
 *
 * It introduces the `'undo'` and `'redo'` commands to the editor.
 *
 * @extends module:core/plugin~Plugin
 */

var undoediting_UndoEditing = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(UndoEditing, _Plugin);

  var _super = Object(createSuper["a" /* default */])(UndoEditing);

  Object(createClass["a" /* default */])(UndoEditing, null, [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'UndoEditing';
    }
    /**
     * @inheritDoc
     */

  }]);

  function UndoEditing(editor) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, UndoEditing);

    _this = _super.call(this, editor);
    /**
     * The command that manages undo {@link module:engine/model/batch~Batch batches} stack (history).
     * Created and registered during the {@link #init feature initialization}.
     *
     * @private
     * @member {module:undo/undocommand~UndoCommand} #_undoCommand
     */

    /**
     * The command that manages redo {@link module:engine/model/batch~Batch batches} stack (history).
     * Created and registered during the {@link #init feature initialization}.
     *
     * @private
     * @member {module:undo/undocommand~UndoCommand} #_redoCommand
     */

    /**
     * Keeps track of which batches were registered in undo.
     *
     * @private
     * @member {WeakSet.<module:engine/model/batch~Batch>}
     */

    _this._batchRegistry = new WeakSet();
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(UndoEditing, [{
    key: "init",
    value: function init() {
      var _this2 = this;

      var editor = this.editor; // Create commands.

      this._undoCommand = new undocommand_UndoCommand(editor);
      this._redoCommand = new redocommand_RedoCommand(editor); // Register command to the editor.

      editor.commands.add('undo', this._undoCommand);
      editor.commands.add('redo', this._redoCommand);
      this.listenTo(editor.model, 'applyOperation', function (evt, args) {
        var operation = args[0]; // Do not register batch if the operation is not a document operation.
        // This prevents from creating empty undo steps, where all operations where non-document operations.
        // Non-document operations creates and alters content in detached tree fragments (for example, document fragments).
        // Most of time this is preparing data before it is inserted into actual tree (for example during copy & paste).
        // Such operations should not be reversed.

        if (!operation.isDocumentOperation) {
          return;
        }

        var batch = operation.batch;

        var isRedoBatch = _this2._redoCommand._createdBatches.has(batch);

        var isUndoBatch = _this2._undoCommand._createdBatches.has(batch);

        var isRegisteredBatch = _this2._batchRegistry.has(batch); // If changes are not a part of a batch or this is not a new batch, omit those changes.


        if (isRegisteredBatch || batch.type == 'transparent' && !isRedoBatch && !isUndoBatch) {
          return;
        } else {
          if (isRedoBatch) {
            // If this batch comes from `redoCommand`, add it to `undoCommand` stack.
            _this2._undoCommand.addBatch(batch);
          } else if (!isUndoBatch) {
            // A default batch - these are new changes in the document, not introduced by undo feature.
            // Add them to `undoCommand` stack and clear `redoCommand` stack.
            _this2._undoCommand.addBatch(batch);

            _this2._redoCommand.clearStack();
          }
        } // Add the batch to the registry so it will not be processed again.


        _this2._batchRegistry.add(batch);
      }, {
        priority: 'highest'
      });
      this.listenTo(this._undoCommand, 'revert', function (evt, undoneBatch, undoingBatch) {
        _this2._redoCommand.addBatch(undoingBatch);
      });
      editor.keystrokes.set('CTRL+Z', 'undo');
      editor.keystrokes.set('CTRL+Y', 'redo');
      editor.keystrokes.set('CTRL+SHIFT+Z', 'redo');
    }
  }]);

  return UndoEditing;
}(plugin_Plugin);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-undo/theme/icons/undo.svg
var undo = __webpack_require__("f945");
var undo_default = /*#__PURE__*/__webpack_require__.n(undo);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-undo/theme/icons/redo.svg
var redo = __webpack_require__("332d");
var redo_default = /*#__PURE__*/__webpack_require__.n(redo);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-undo/src/undoui.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module undo/undoui
 */




/**
 * The undo UI feature. It introduces the `'undo'` and `'redo'` buttons to the editor.
 *
 * @extends module:core/plugin~Plugin
 */

var undoui_UndoUI = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(UndoUI, _Plugin);

  var _super = Object(createSuper["a" /* default */])(UndoUI);

  function UndoUI() {
    Object(classCallCheck["a" /* default */])(this, UndoUI);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(UndoUI, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var editor = this.editor;
      var locale = editor.locale;
      var t = editor.t;
      var localizedUndoIcon = locale.uiLanguageDirection == 'ltr' ? undo_default.a : redo_default.a;
      var localizedRedoIcon = locale.uiLanguageDirection == 'ltr' ? redo_default.a : undo_default.a;

      this._addButton('undo', t('Undo'), 'CTRL+Z', localizedUndoIcon);

      this._addButton('redo', t('Redo'), 'CTRL+Y', localizedRedoIcon);
    }
    /**
     * Creates a button for the specified command.
     *
     * @private
     * @param {String} name Command name.
     * @param {String} label Button label.
     * @param {String} keystroke Command keystroke.
     * @param {String} Icon Source of the icon.
     */

  }, {
    key: "_addButton",
    value: function _addButton(name, label, keystroke, Icon) {
      var _this = this;

      var editor = this.editor;
      editor.ui.componentFactory.add(name, function (locale) {
        var command = editor.commands.get(name);
        var view = new buttonview_ButtonView(locale);
        view.set({
          label: label,
          icon: Icon,
          keystroke: keystroke,
          tooltip: true
        });
        view.bind('isEnabled').to(command, 'isEnabled');

        _this.listenTo(view, 'execute', function () {
          editor.execute(name);
          editor.editing.view.focus();
        });

        return view;
      });
    }
  }]);

  return UndoUI;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-undo/src/undo.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module undo/undo
 */



/**
 * The undo feature.
 *
 * This is a "glue" plugin which loads the {@link module:undo/undoediting~UndoEditing undo editing feature}
 * and {@link module:undo/undoui~UndoUI undo UI feature}.
 *
 * Below is the explanation of the undo mechanism working together with {@link module:engine/model/history~History History}:
 *
 * Whenever a {@link module:engine/model/operation/operation~Operation operation} is applied to the
 * {@link module:engine/model/document~Document document}, it is saved to `History` as is.
 * The {@link module:engine/model/batch~Batch batch} that owns that operation is also saved, in
 * {@link module:undo/undocommand~UndoCommand}, together with the selection that was present in the document before the
 * operation was applied. A batch is saved instead of the operation because changes are undone batch-by-batch, not operation-by-operation
 * and a batch is seen as one undo step.
 *
 * After some changes happen to the document, the `History` and `UndoCommand` stack can be represented as follows:
 *
 *		    History                            Undo stack
 *		==============             ==================================
 *		[operation A1]                         [batch A]
 *		[operation B1]                         [batch B]
 *		[operation B2]                         [batch C]
 *		[operation C1]
 *		[operation C2]
 *		[operation B3]
 *		[operation C3]
 *
 * Where operations starting with the same letter are from same batch.
 *
 * Undoing a batch means that a set of operations which will reverse the effects of that batch needs to be generated.
 * For example, if a batch added several letters, undoing the batch should remove them. It is important to apply undoing
 * operations in the reversed order, so if a batch has operation `X`, `Y`, `Z`, reversed operations `Zr`, `Yr` and `Xr`
 * need to be applied. Otherwise reversed operation `Xr` would operate on a wrong document state, because operation `X`
 * does not know that operations `Y` and `Z` happened.
 *
 * After operations from an undone batch got {@link module:engine/model/operation/operation~Operation#getReversed reversed},
 * one needs to make sure if they are ready to be applied. In the scenario above, operation `C3` is the last operation and `C3r`
 * bases on up-to-date document state, so it can be applied to the document.
 *
 *		     History                             Undo stack
 *		=================             ==================================
 *		[ operation A1  ]                      [  batch A  ]
 *		[ operation B1  ]                      [  batch B  ]
 *		[ operation B2  ]             [   processing undoing batch C   ]
 *		[ operation C1  ]
 *		[ operation C2  ]
 *		[ operation B3  ]
 *		[ operation C3  ]
 *		[ operation C3r ]
 *
 * Next is operation `C2`, reversed to `C2r`. `C2r` bases on `C2`, so it bases on the wrong document state. It needs to be
 * transformed by operations from history that happened after it, so it "knows" about them. Let us assume that `C2' = C2r * B3 * C3 * C3r`,
 * where `*` means "transformed by". Rest of operations from that batch are processed in the same fashion.
 *
 *		     History                             Undo stack                                      Redo stack
 *		=================             ==================================             ==================================
 *		[ operation A1  ]                      [  batch A  ]                                    [ batch Cr ]
 *		[ operation B1  ]                      [  batch B  ]
 *		[ operation B2  ]
 *		[ operation C1  ]
 *		[ operation C2  ]
 *		[ operation B3  ]
 *		[ operation C3  ]
 *		[ operation C3r ]
 *		[ operation C2' ]
 *		[ operation C1' ]
 *
 * Selective undo works on the same basis, however, instead of undoing the last batch in the undo stack, any batch can be undone.
 * The same algorithm applies: operations from a batch (i.e. `A1`) are reversed and then transformed by operations stored in history.
 *
 * Redo also is very similar to undo. It has its own stack that is filled with undoing (reversed batches). Operations from
 * batch that is re-done are reversed-back, transformed in proper order and applied to the document.
 *
 *		     History                             Undo stack                                      Redo stack
 *		=================             ==================================             ==================================
 *		[ operation A1  ]                      [  batch A  ]
 *		[ operation B1  ]                      [  batch B  ]
 *		[ operation B2  ]                      [ batch Crr ]
 *		[ operation C1  ]
 *		[ operation C2  ]
 *		[ operation B3  ]
 *		[ operation C3  ]
 *		[ operation C3r ]
 *		[ operation C2' ]
 *		[ operation C1' ]
 *		[ operation C1'r]
 *		[ operation C2'r]
 *		[ operation C3rr]
 *
 * @extends module:core/plugin~Plugin
 */

var undo_Undo = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(Undo, _Plugin);

  var _super = Object(createSuper["a" /* default */])(Undo);

  function Undo() {
    Object(classCallCheck["a" /* default */])(this, Undo);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Undo, null, [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [undoediting_UndoEditing, undoui_UndoUI];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'Undo';
    }
  }]);

  return Undo;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-essentials/src/essentials.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module essentials/essentials
 */







/**
 * A plugin including all essential editing features. It represents a set of features that enables similar functionalities
 * to a `<textarea>` element.
 *
 * It includes:
 *
 * * {@link module:clipboard/clipboard~Clipboard},
 * * {@link module:enter/enter~Enter},
 * * {@link module:select-all/selectall~SelectAll},
 * * {@link module:enter/shiftenter~ShiftEnter},
 * * {@link module:typing/typing~Typing},
 * * {@link module:undo/undo~Undo}.
 *
 * This plugin set does not define any block-level containers (such as {@link module:paragraph/paragraph~Paragraph}).
 * If your editor is supposed to handle block content, make sure to include it.
 *
 * @extends module:core/plugin~Plugin
 */

var essentials_Essentials = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(Essentials, _Plugin);

  var _super = Object(createSuper["a" /* default */])(Essentials);

  function Essentials() {
    Object(classCallCheck["a" /* default */])(this, Essentials);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Essentials, null, [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [clipboard_Clipboard, enter_Enter, selectall_SelectAll, shiftenter_ShiftEnter, typing_Typing, undo_Undo];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'Essentials';
    }
  }]);

  return Essentials;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-core/src/contextplugin.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module core/contextplugin
 */


/**
 * The base class for {@link module:core/context~Context} plugin classes.
 *
 * A context plugin can either be initialized for an {@link module:core/editor/editor~Editor editor} or for
 * a {@link module:core/context~Context context}. In other words, it can either
 * work within one editor instance or with one or more editor instances that use a single context.
 * It is the context plugin's role to implement handling for both modes.
 *
 * There are a few rules for interaction between the editor plugins and context plugins:
 *
 * * A context plugin can require another context plugin.
 * * An {@link module:core/plugin~Plugin editor plugin} can require a context plugin.
 * * A context plugin MUST NOT require an {@link module:core/plugin~Plugin editor plugin}.
 *
 * @implements module:core/plugin~PluginInterface
 * @mixes module:utils/observablemixin~ObservableMixin
 */

var contextplugin_ContextPlugin = /*#__PURE__*/function () {
  /**
   * Creates a new plugin instance.
   *
   * @param {module:core/context~Context|module:core/editor/editor~Editor} context
   */
  function ContextPlugin(context) {
    Object(classCallCheck["a" /* default */])(this, ContextPlugin);

    /**
     * The context instance.
     *
     * @readonly
     * @type {module:core/context~Context|module:core/editor/editor~Editor}
     */
    this.context = context;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(ContextPlugin, [{
    key: "destroy",
    value: function destroy() {
      this.stopListening();
    }
    /**
     * @inheritDoc
     */

  }], [{
    key: "isContextPlugin",
    get: function get() {
      return true;
    }
  }]);

  return ContextPlugin;
}();


mix(contextplugin_ContextPlugin, observablemixin);
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-core/src/pendingactions.js












/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module core/pendingactions
 */




/**
 * The list of pending editor actions.
 *
 * This plugin should be used to synchronise plugins that execute long-lasting actions
 * (e.g. file upload) with the editor integration. It gives the developer who integrates the editor
 * an easy way to check if there are any actions pending whenever such information is needed.
 * All plugins that register a pending action also provide a message about the action that is ongoing
 * which can be displayed to the user. This lets them decide if they want to interrupt the action or wait.
 *
 * Adding and updating a pending action:
 *
 * 		const pendingActions = editor.plugins.get( 'PendingActions' );
 * 		const action = pendingActions.add( 'Upload in progress: 0%.' );
 *
 *		// You can update the message:
 * 		action.message = 'Upload in progress: 10%.';
 *
 * Removing a pending action:
 *
 * 		const pendingActions = editor.plugins.get( 'PendingActions' );
 * 		const action = pendingActions.add( 'Unsaved changes.' );
 *
 * 		pendingActions.remove( action );
 *
 * Getting pending actions:
 *
 * 		const pendingActions = editor.plugins.get( 'PendingActions' );
 *
 * 		const action1 = pendingActions.add( 'Action 1' );
 * 		const action2 = pendingActions.add( 'Action 2' );
 *
 * 		pendingActions.first; // Returns action1
 * 		Array.from( pendingActions ); // Returns [ action1, action2 ]
 *
 * This plugin is used by features like {@link module:upload/filerepository~FileRepository} to register their ongoing actions
 * and by features like {@link module:autosave/autosave~Autosave} to detect whether there are any ongoing actions.
 * Read more about saving the data in the {@glink builds/guides/integration/saving-data Saving and getting data} guide.
 *
 * @extends module:core/contextplugin~ContextPlugin
 */

var pendingactions_PendingActions = /*#__PURE__*/function (_ContextPlugin) {
  Object(inherits["a" /* default */])(PendingActions, _ContextPlugin);

  var _super = Object(createSuper["a" /* default */])(PendingActions);

  function PendingActions() {
    Object(classCallCheck["a" /* default */])(this, PendingActions);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(PendingActions, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      /**
       * Defines whether there is any registered pending action.
       *
       * @readonly
       * @observable
       * @member {Boolean} #hasAny
       */
      this.set('hasAny', false);
      /**
       * A list of pending actions.
       *
       * @private
       * @type {module:utils/collection~Collection}
       */

      this._actions = new collection_Collection({
        idProperty: '_id'
      });

      this._actions.delegate('add', 'remove').to(this);
    }
    /**
     * Adds an action to the list of pending actions.
     *
     * This method returns an action object with an observable message property.
     * The action object can be later used in the {@link #remove} method. It also allows you to change the message.
     *
     * @param {String} message The action message.
     * @returns {Object} An observable object that represents a pending action.
     */

  }, {
    key: "add",
    value: function add(message) {
      if (typeof message !== 'string') {
        /**
         * The message must be a string.
         *
         * @error pendingactions-add-invalid-message
         */
        throw new ckeditorerror["b" /* default */]('pendingactions-add-invalid-message: The message must be a string.', this);
      }

      var action = Object.create(observablemixin);
      action.set('message', message);

      this._actions.add(action);

      this.hasAny = true;
      return action;
    }
    /**
     * Removes an action from the list of pending actions.
     *
     * @param {Object} action An action object.
     */

  }, {
    key: "remove",
    value: function remove(action) {
      this._actions.remove(action);

      this.hasAny = !!this._actions.length;
    }
    /**
     * Returns the first action from the list or null when list is empty
     *
     * returns {Object|null} The pending action object.
     */

  }, {
    key: Symbol.iterator,

    /**
     * Iterable interface.
     *
     * @returns {Iterable.<*>}
     */
    value: function value() {
      return this._actions[Symbol.iterator]();
    }
    /**
     * Fired when an action is added to the list.
     *
     * @event add
     * @param {Object} action The added action.
     */

    /**
     * Fired when an action is removed from the list.
     *
     * @event remove
     * @param {Object} action The removed action.
     */

  }, {
    key: "first",
    get: function get() {
      return this._actions.get(0);
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'PendingActions';
    }
  }]);

  return PendingActions;
}(contextplugin_ContextPlugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-upload/src/filereader.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module upload/filereader
 */

/* globals window */


/**
 * Wrapper over the native `FileReader`.
 */

var filereader_FileReader = /*#__PURE__*/function () {
  /**
   * Creates an instance of the FileReader.
   */
  function FileReader() {
    var _this = this;

    Object(classCallCheck["a" /* default */])(this, FileReader);

    var reader = new window.FileReader();
    /**
     * Instance of native FileReader.
     *
     * @private
     * @member {FileReader} #_reader
     */

    this._reader = reader;
    this._data = undefined;
    /**
     * Number of bytes loaded.
     *
     * @readonly
     * @observable
     * @member {Number} #loaded
     */

    this.set('loaded', 0);

    reader.onprogress = function (evt) {
      _this.loaded = evt.loaded;
    };
  }
  /**
   * Returns error that occurred during file reading.
   *
   * @returns {Error}
   */


  Object(createClass["a" /* default */])(FileReader, [{
    key: "read",

    /**
     * Reads the provided file.
     *
     * @param {File} file Native File object.
     * @returns {Promise.<String>} Returns a promise that will be resolved with file's content.
     * The promise will be rejected in case of an error or when the reading process is aborted.
     */
    value: function read(file) {
      var _this2 = this;

      var reader = this._reader;
      this.total = file.size;
      return new Promise(function (resolve, reject) {
        reader.onload = function () {
          var result = reader.result;
          _this2._data = result;
          resolve(result);
        };

        reader.onerror = function () {
          reject('error');
        };

        reader.onabort = function () {
          reject('aborted');
        };

        _this2._reader.readAsDataURL(file);
      });
    }
    /**
     * Aborts file reader.
     */

  }, {
    key: "abort",
    value: function abort() {
      this._reader.abort();
    }
  }, {
    key: "error",
    get: function get() {
      return this._reader.error;
    }
    /**
     * Holds the data of an already loaded file. The file must be first loaded
     * by using {@link module:upload/filereader~FileReader#read `read()`}.
     *
     * @type {File|undefined}
     */

  }, {
    key: "data",
    get: function get() {
      return this._data;
    }
  }]);

  return FileReader;
}();


mix(filereader_FileReader, observablemixin);
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-upload/src/filerepository.js















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module upload/filerepository
 */

/* globals console */








/**
 * File repository plugin. A central point for managing file upload.
 *
 * To use it, first you need an upload adapter. Upload adapter's job is to handle communication with the server
 * (sending the file and handling server's response). You can use one of the existing plugins introducing upload adapters
 * (e.g. {@link module:easy-image/cloudservicesuploadadapter~CloudServicesUploadAdapter} or
 * {@link module:adapter-ckfinder/uploadadapter~CKFinderUploadAdapter}) or write your own one – see
 * the {@glink framework/guides/deep-dive/upload-adapter "Custom image upload adapter" deep dive guide}.
 *
 * Then, you can use {@link module:upload/filerepository~FileRepository#createLoader `createLoader()`} and the returned
 * {@link module:upload/filerepository~FileLoader} instance to load and upload files.
 *
 * @extends module:core/plugin~Plugin
 */

var filerepository_FileRepository = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(FileRepository, _Plugin);

  var _super = Object(createSuper["a" /* default */])(FileRepository);

  function FileRepository() {
    Object(classCallCheck["a" /* default */])(this, FileRepository);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(FileRepository, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this = this;

      /**
       * Collection of loaders associated with this repository.
       *
       * @member {module:utils/collection~Collection} #loaders
       */
      this.loaders = new collection_Collection(); // Keeps upload in a sync with pending actions.

      this.loaders.on('add', function () {
        return _this._updatePendingAction();
      });
      this.loaders.on('remove', function () {
        return _this._updatePendingAction();
      });
      /**
       * Loaders mappings used to retrieve loaders references.
       *
       * @private
       * @member {Map<File|Promise, FileLoader>} #_loadersMap
       */

      this._loadersMap = new Map();
      /**
       * Reference to a pending action registered in a {@link module:core/pendingactions~PendingActions} plugin
       * while upload is in progress. When there is no upload then value is `null`.
       *
       * @private
       * @member {Object} #_pendingAction
       */

      this._pendingAction = null;
      /**
       * A factory function which should be defined before using `FileRepository`.
       *
       * It should return a new instance of {@link module:upload/filerepository~UploadAdapter} that will be used to upload files.
       * {@link module:upload/filerepository~FileLoader} instance associated with the adapter
       * will be passed to that function.
       *
       * For more information and example see {@link module:upload/filerepository~UploadAdapter}.
       *
       * @member {Function} #createUploadAdapter
       */

      /**
       * Number of bytes uploaded.
       *
       * @readonly
       * @observable
       * @member {Number} #uploaded
       */

      this.set('uploaded', 0);
      /**
       * Number of total bytes to upload.
       *
       * It might be different than the file size because of headers and additional data.
       * It contains `null` if value is not available yet, so it's better to use {@link #uploadedPercent} to monitor
       * the progress.
       *
       * @readonly
       * @observable
       * @member {Number|null} #uploadTotal
       */

      this.set('uploadTotal', null);
      /**
       * Upload progress in percents.
       *
       * @readonly
       * @observable
       * @member {Number} #uploadedPercent
       */

      this.bind('uploadedPercent').to(this, 'uploaded', this, 'uploadTotal', function (uploaded, total) {
        return total ? uploaded / total * 100 : 0;
      });
    }
    /**
     * Returns the loader associated with specified file or promise.
     *
     * To get loader by id use `fileRepository.loaders.get( id )`.
     *
     * @param {File|Promise.<File>} fileOrPromise Native file or promise handle.
     * @returns {module:upload/filerepository~FileLoader|null}
     */

  }, {
    key: "getLoader",
    value: function getLoader(fileOrPromise) {
      return this._loadersMap.get(fileOrPromise) || null;
    }
    /**
     * Creates a loader instance for the given file.
     *
     * Requires {@link #createUploadAdapter} factory to be defined.
     *
     * @param {File|Promise.<File>} fileOrPromise Native File object or native Promise object which resolves to a File.
     * @returns {module:upload/filerepository~FileLoader|null}
     */

  }, {
    key: "createLoader",
    value: function createLoader(fileOrPromise) {
      var _this2 = this;

      if (!this.createUploadAdapter) {
        /**
         * You need to enable an upload adapter in order to be able to upload files.
         *
         * This warning shows up when {@link module:upload/filerepository~FileRepository} is being used
         * without {@link #createUploadAdapter definining an upload adapter}.
         *
         * **If you see this warning when using one of the {@glink builds/index CKEditor 5 Builds}**
         * it means that you did not configure any of the upload adapters available by default in those builds.
         *
         * See the {@glink features/image-upload/image-upload comprehensive "Image upload overview"} to learn which upload
         * adapters are available in the builds and how to configure them.
         *
         * **If you see this warning when using a custom build** there is a chance that you enabled
         * a feature like {@link module:image/imageupload~ImageUpload},
         * or {@link module:image/imageupload/imageuploadui~ImageUploadUI} but you did not enable any upload adapter.
         * You can choose one of the existing upload adapters listed in the
         * {@glink features/image-upload/image-upload "Image upload overview"}.
         *
         * You can also implement your {@glink framework/guides/deep-dive/upload-adapter own image upload adapter}.
         *
         * @error filerepository-no-upload-adapter
         */
        console.warn(Object(ckeditorerror["a" /* attachLinkToDocumentation */])('filerepository-no-upload-adapter: Upload adapter is not defined.'));
        return null;
      }

      var loader = new filerepository_FileLoader(Promise.resolve(fileOrPromise), this.createUploadAdapter);
      this.loaders.add(loader);

      this._loadersMap.set(fileOrPromise, loader); // Store also file => loader mapping so loader can be retrieved by file instance returned upon Promise resolution.


      if (fileOrPromise instanceof Promise) {
        loader.file.then(function (file) {
          _this2._loadersMap.set(file, loader);
        }) // Every then() must have a catch().
        // File loader state (and rejections) are handled in read() and upload().
        // Also, see the "does not swallow the file promise rejection" test.
        .catch(function () {});
      }

      loader.on('change:uploaded', function () {
        var aggregatedUploaded = 0;

        var _iterator = _createForOfIteratorHelper(_this2.loaders),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _loader = _step.value;
            aggregatedUploaded += _loader.uploaded;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        _this2.uploaded = aggregatedUploaded;
      });
      loader.on('change:uploadTotal', function () {
        var aggregatedTotal = 0;

        var _iterator2 = _createForOfIteratorHelper(_this2.loaders),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _loader2 = _step2.value;

            if (_loader2.uploadTotal) {
              aggregatedTotal += _loader2.uploadTotal;
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        _this2.uploadTotal = aggregatedTotal;
      });
      return loader;
    }
    /**
     * Destroys the given loader.
     *
     * @param {File|Promise|module:upload/filerepository~FileLoader} fileOrPromiseOrLoader File or Promise associated
     * with that loader or loader itself.
     */

  }, {
    key: "destroyLoader",
    value: function destroyLoader(fileOrPromiseOrLoader) {
      var _this3 = this;

      var loader = fileOrPromiseOrLoader instanceof filerepository_FileLoader ? fileOrPromiseOrLoader : this.getLoader(fileOrPromiseOrLoader);

      loader._destroy();

      this.loaders.remove(loader);

      this._loadersMap.forEach(function (value, key) {
        if (value === loader) {
          _this3._loadersMap.delete(key);
        }
      });
    }
    /**
     * Registers or deregisters pending action bound with upload progress.
     *
     * @private
     */

  }, {
    key: "_updatePendingAction",
    value: function _updatePendingAction() {
      var pendingActions = this.editor.plugins.get(pendingactions_PendingActions);

      if (this.loaders.length) {
        if (!this._pendingAction) {
          var t = this.editor.t;

          var getMessage = function getMessage(value) {
            return "".concat(t('Upload in progress'), " ").concat(parseInt(value), "%.");
          };

          this._pendingAction = pendingActions.add(getMessage(this.uploadedPercent));

          this._pendingAction.bind('message').to(this, 'uploadedPercent', getMessage);
        }
      } else {
        pendingActions.remove(this._pendingAction);
        this._pendingAction = null;
      }
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'FileRepository';
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "requires",
    get: function get() {
      return [pendingactions_PendingActions];
    }
  }]);

  return FileRepository;
}(plugin_Plugin);


mix(filerepository_FileRepository, observablemixin);
/**
 * File loader class.
 *
 * It is used to control the process of reading the file and uploading it using the specified upload adapter.
 */

var filerepository_FileLoader = /*#__PURE__*/function () {
  /**
   * Creates a new instance of `FileLoader`.
   *
   * @param {Promise.<File>} filePromise A promise which resolves to a file instance.
   * @param {Function} uploadAdapterCreator The function which returns {@link module:upload/filerepository~UploadAdapter} instance.
   */
  function FileLoader(filePromise, uploadAdapterCreator) {
    Object(classCallCheck["a" /* default */])(this, FileLoader);

    /**
     * Unique id of FileLoader instance.
     *
     * @readonly
     * @member {Number}
     */
    this.id = uid_uid();
    /**
     * Additional wrapper over the initial file promise passed to this loader.
     *
     * @protected
     * @member {module:upload/filerepository~FilePromiseWrapper}
     */

    this._filePromiseWrapper = this._createFilePromiseWrapper(filePromise);
    /**
     * Adapter instance associated with this file loader.
     *
     * @private
     * @member {module:upload/filerepository~UploadAdapter}
     */

    this._adapter = uploadAdapterCreator(this);
    /**
     * FileReader used by FileLoader.
     *
     * @protected
     * @member {module:upload/filereader~FileReader}
     */

    this._reader = new filereader_FileReader();
    /**
     * Current status of FileLoader. It can be one of the following:
     *
     * * 'idle',
     * * 'reading',
     * * 'uploading',
     * * 'aborted',
     * * 'error'.
     *
     * When reading status can change in a following way:
     *
     * `idle` -> `reading` -> `idle`
     * `idle` -> `reading -> `aborted`
     * `idle` -> `reading -> `error`
     *
     * When uploading status can change in a following way:
     *
     * `idle` -> `uploading` -> `idle`
     * `idle` -> `uploading` -> `aborted`
     * `idle` -> `uploading` -> `error`
     *
     * @readonly
     * @observable
     * @member {String} #status
     */

    this.set('status', 'idle');
    /**
     * Number of bytes uploaded.
     *
     * @readonly
     * @observable
     * @member {Number} #uploaded
     */

    this.set('uploaded', 0);
    /**
     * Number of total bytes to upload.
     *
     * @readonly
     * @observable
     * @member {Number|null} #uploadTotal
     */

    this.set('uploadTotal', null);
    /**
     * Upload progress in percents.
     *
     * @readonly
     * @observable
     * @member {Number} #uploadedPercent
     */

    this.bind('uploadedPercent').to(this, 'uploaded', this, 'uploadTotal', function (uploaded, total) {
      return total ? uploaded / total * 100 : 0;
    });
    /**
     * Response of the upload.
     *
     * @readonly
     * @observable
     * @member {Object|null} #uploadResponse
     */

    this.set('uploadResponse', null);
  }
  /**
   * A `Promise` which resolves to a `File` instance associated with this file loader.
   *
   * @type {Promise.<File|null>}
   */


  Object(createClass["a" /* default */])(FileLoader, [{
    key: "read",

    /**
     * Reads file using {@link module:upload/filereader~FileReader}.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-read-wrong-status` when status
     * is different than `idle`.
     *
     * Example usage:
     *
     *	fileLoader.read()
     *		.then( data => { ... } )
     *		.catch( err => {
     *			if ( err === 'aborted' ) {
     *				console.log( 'Reading aborted.' );
     *			} else {
     *				console.log( 'Reading error.', err );
     *			}
     *		} );
     *
     * @returns {Promise.<String>} Returns promise that will be resolved with read data. Promise will be rejected if error
     * occurs or if read process is aborted.
     */
    value: function read() {
      var _this4 = this;

      if (this.status != 'idle') {
        throw new ckeditorerror["b" /* default */]('filerepository-read-wrong-status: You cannot call read if the status is different than idle.', this);
      }

      this.status = 'reading';
      return this.file.then(function (file) {
        return _this4._reader.read(file);
      }).then(function (data) {
        // Edge case: reader was aborted after file was read - double check for proper status.
        // It can happen when image was deleted during its upload.
        if (_this4.status !== 'reading') {
          throw _this4.status;
        }

        _this4.status = 'idle';
        return data;
      }).catch(function (err) {
        if (err === 'aborted') {
          _this4.status = 'aborted';
          throw 'aborted';
        }

        _this4.status = 'error';
        throw _this4._reader.error ? _this4._reader.error : err;
      });
    }
    /**
     * Reads file using the provided {@link module:upload/filerepository~UploadAdapter}.
     *
     * Throws {@link module:utils/ckeditorerror~CKEditorError CKEditorError} `filerepository-upload-wrong-status` when status
     * is different than `idle`.
     * Example usage:
     *
     *	fileLoader.upload()
     *		.then( data => { ... } )
     *		.catch( e => {
     *			if ( e === 'aborted' ) {
     *				console.log( 'Uploading aborted.' );
     *			} else {
     *				console.log( 'Uploading error.', e );
     *			}
     *		} );
     *
     * @returns {Promise.<Object>} Returns promise that will be resolved with response data. Promise will be rejected if error
     * occurs or if read process is aborted.
     */

  }, {
    key: "upload",
    value: function upload() {
      var _this5 = this;

      if (this.status != 'idle') {
        throw new ckeditorerror["b" /* default */]('filerepository-upload-wrong-status: You cannot call upload if the status is different than idle.', this);
      }

      this.status = 'uploading';
      return this.file.then(function () {
        return _this5._adapter.upload();
      }).then(function (data) {
        _this5.uploadResponse = data;
        _this5.status = 'idle';
        return data;
      }).catch(function (err) {
        if (_this5.status === 'aborted') {
          throw 'aborted';
        }

        _this5.status = 'error';
        throw err;
      });
    }
    /**
     * Aborts loading process.
     */

  }, {
    key: "abort",
    value: function abort() {
      var status = this.status;
      this.status = 'aborted';

      if (!this._filePromiseWrapper.isFulfilled) {
        // Edge case: file loader is aborted before read() is called
        // so it might happen that no one handled the rejection of this promise.
        // See https://github.com/ckeditor/ckeditor5-upload/pull/100
        this._filePromiseWrapper.promise.catch(function () {});

        this._filePromiseWrapper.rejecter('aborted');
      } else if (status == 'reading') {
        this._reader.abort();
      } else if (status == 'uploading' && this._adapter.abort) {
        this._adapter.abort();
      }

      this._destroy();
    }
    /**
     * Performs cleanup.
     *
     * @private
     */

  }, {
    key: "_destroy",
    value: function _destroy() {
      this._filePromiseWrapper = undefined;
      this._reader = undefined;
      this._adapter = undefined;
      this.uploadResponse = undefined;
    }
    /**
     * Wraps a given file promise into another promise giving additional
     * control (resolving, rejecting, checking if fulfilled) over it.
     *
     * @private
     * @param filePromise The initial file promise to be wrapped.
     * @returns {module:upload/filerepository~FilePromiseWrapper}
     */

  }, {
    key: "_createFilePromiseWrapper",
    value: function _createFilePromiseWrapper(filePromise) {
      var wrapper = {};
      wrapper.promise = new Promise(function (resolve, reject) {
        wrapper.rejecter = reject;
        wrapper.isFulfilled = false;
        filePromise.then(function (file) {
          wrapper.isFulfilled = true;
          resolve(file);
        }).catch(function (err) {
          wrapper.isFulfilled = true;
          reject(err);
        });
      });
      return wrapper;
    }
  }, {
    key: "file",
    get: function get() {
      var _this6 = this;

      if (!this._filePromiseWrapper) {
        // Loader was destroyed, return promise which resolves to null.
        return Promise.resolve(null);
      } else {
        // The `this._filePromiseWrapper.promise` is chained and not simply returned to handle a case when:
        //
        //		* The `loader.file.then( ... )` is called by external code (returned promise is pending).
        //		* Then `loader._destroy()` is called (call is synchronous) which destroys the `loader`.
        //		* Promise returned by the first `loader.file.then( ... )` call is resolved.
        //
        // Returning `this._filePromiseWrapper.promise` will still resolve to a `File` instance so there
        // is an additional check needed in the chain to see if `loader` was destroyed in the meantime.
        return this._filePromiseWrapper.promise.then(function (file) {
          return _this6._filePromiseWrapper ? file : null;
        });
      }
    }
    /**
     * Returns the file data. To read its data, you need for first load the file
     * by using the {@link module:upload/filerepository~FileLoader#read `read()`} method.
     *
     * @type {File|undefined}
     */

  }, {
    key: "data",
    get: function get() {
      return this._reader.data;
    }
  }]);

  return FileLoader;
}();

mix(filerepository_FileLoader, observablemixin);
/**
 * Upload adapter interface used by the {@link module:upload/filerepository~FileRepository file repository}
 * to handle file upload. An upload adapter is a bridge between the editor and server that handles file uploads.
 * It should contain a logic necessary to initiate an upload process and monitor its progress.
 *
 * Learn how to develop your own upload adapter for CKEditor 5 in the
 * {@glink framework/guides/deep-dive/upload-adapter "Custom upload adapter" guide}.
 *
 * @interface UploadAdapter
 */

/**
 * Executes the upload process.
 * This method should return a promise that will resolve when data will be uploaded to server. Promise should be
 * resolved with an object containing information about uploaded file:
 *
 *		{
 *			default: 'http://server/default-size.image.png'
 *		}
 *
 * Additionally, other image sizes can be provided:
 *
 *		{
 *			default: 'http://server/default-size.image.png',
 *			'160': 'http://server/size-160.image.png',
 *			'500': 'http://server/size-500.image.png',
 *			'1000': 'http://server/size-1000.image.png',
 *			'1052': 'http://server/default-size.image.png'
 *		}
 *
 * NOTE: When returning multiple images, the widest returned one should equal the default one. It is essential to
 * correctly set `width` attribute of the image. See this discussion:
 * https://github.com/ckeditor/ckeditor5-easy-image/issues/4 for more information.
 *
 * Take a look at {@link module:upload/filerepository~UploadAdapter example Adapter implementation} and
 * {@link module:upload/filerepository~FileRepository#createUploadAdapter createUploadAdapter method}.
 *
 * @method module:upload/filerepository~UploadAdapter#upload
 * @returns {Promise.<Object>} Promise that should be resolved when data is uploaded.
 */

/**
 * Aborts the upload process.
 * After aborting it should reject promise returned from {@link #upload upload()}.
 *
 * Take a look at {@link module:upload/filerepository~UploadAdapter example Adapter implementation} and
 * {@link module:upload/filerepository~FileRepository#createUploadAdapter createUploadAdapter method}.
 *
 * @method module:upload/filerepository~UploadAdapter#abort
 */

/**
 * Object returned by {@link module:upload/filerepository~FileLoader#_createFilePromiseWrapper} method
 * to add more control over the initial file promise passed to {@link module:upload/filerepository~FileLoader}.
 *
 * @protected
 * @typedef {Object} module:upload/filerepository~FilePromiseWrapper
 * @property {Promise.<File>} promise Wrapper promise which can be chained for further processing.
 * @property {Function} rejecter Rejects the promise when called.
 * @property {Boolean} isFulfilled Whether original promise is already fulfilled.
 */
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.uint8-array.js
var es_typed_array_uint8_array = __webpack_require__("5cc6");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.copy-within.js
var es_typed_array_copy_within = __webpack_require__("9a8c");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.every.js
var es_typed_array_every = __webpack_require__("a975");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.fill.js
var es_typed_array_fill = __webpack_require__("735e");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.filter.js
var es_typed_array_filter = __webpack_require__("c1ac");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.find.js
var es_typed_array_find = __webpack_require__("d139");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.find-index.js
var es_typed_array_find_index = __webpack_require__("3a7b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.for-each.js
var es_typed_array_for_each = __webpack_require__("d5d6");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.includes.js
var es_typed_array_includes = __webpack_require__("82f8");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.index-of.js
var es_typed_array_index_of = __webpack_require__("e91f");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.iterator.js
var es_typed_array_iterator = __webpack_require__("60bd");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.join.js
var es_typed_array_join = __webpack_require__("5f96");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.last-index-of.js
var es_typed_array_last_index_of = __webpack_require__("3280");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.map.js
var es_typed_array_map = __webpack_require__("3fcc");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reduce.js
var es_typed_array_reduce = __webpack_require__("ca91");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reduce-right.js
var es_typed_array_reduce_right = __webpack_require__("25a1");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.reverse.js
var es_typed_array_reverse = __webpack_require__("cd26");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.set.js
var es_typed_array_set = __webpack_require__("3c5d");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.slice.js
var es_typed_array_slice = __webpack_require__("2954");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.some.js
var es_typed_array_some = __webpack_require__("649e");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.sort.js
var es_typed_array_sort = __webpack_require__("219c");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.subarray.js
var es_typed_array_subarray = __webpack_require__("170b");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.to-locale-string.js
var es_typed_array_to_locale_string = __webpack_require__("b39a");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.typed-array.to-string.js
var es_typed_array_to_string = __webpack_require__("72f7");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-adapter-ckfinder/src/utils.js































/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* globals window, document */

/**
 * @module adapter-ckfinder/utils
 */
var TOKEN_COOKIE_NAME = 'ckCsrfToken';
var TOKEN_LENGTH = 40;
var tokenCharset = 'abcdefghijklmnopqrstuvwxyz0123456789';
/**
 * Returns the CSRF token value. The value is a hash stored in `document.cookie`
 * under the `ckCsrfToken` key. The CSRF token can be used to secure the communication
 * between the web browser and the CKFinder server.
 *
 * @returns {String}
 */

function getCsrfToken() {
  var token = getCookie(TOKEN_COOKIE_NAME);

  if (!token || token.length != TOKEN_LENGTH) {
    token = generateToken(TOKEN_LENGTH);
    setCookie(TOKEN_COOKIE_NAME, token);
  }

  return token;
}
/**
 * Returns the value of the cookie with a given name or `null` if the cookie is not found.
 *
 * @param {String} name
 * @returns {String|null}
 */

function getCookie(name) {
  name = name.toLowerCase();
  var parts = document.cookie.split(';');

  var _iterator = _createForOfIteratorHelper(parts),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var part = _step.value;
      var pair = part.split('=');
      var key = decodeURIComponent(pair[0].trim().toLowerCase());

      if (key === name) {
        return decodeURIComponent(pair[1]);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return null;
}
/**
 * Sets the value of the cookie with a given name.
 *
 * @param {String} name
 * @param {String} value
 */

function setCookie(name, value) {
  document.cookie = encodeURIComponent(name) + '=' + encodeURIComponent(value) + ';path=/';
} // Generates the CSRF token with the given length.
//
// @private
// @param {Number} length
// @returns {string}

function generateToken(length) {
  var result = '';
  var randValues = new Uint8Array(length);
  window.crypto.getRandomValues(randValues);

  for (var j = 0; j < randValues.length; j++) {
    var character = tokenCharset.charAt(randValues[j] % tokenCharset.length);
    result += Math.random() > 0.5 ? character.toUpperCase() : character;
  }

  return result;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-adapter-ckfinder/src/uploadadapter.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* globals XMLHttpRequest, FormData */

/**
 * @module adapter-ckfinder/uploadadapter
 */



/**
 * A plugin that enables file uploads in CKEditor 5 using the CKFinder server–side connector.
 *
 * See the {@glink features/image-upload/ckfinder "CKFinder file manager integration" guide} to learn how to configure
 * and use this feature as well as find out more about the full integration with the file manager
 * provided by the {@link module:ckfinder/ckfinder~CKFinder} plugin.
 *
 * Check out the {@glink features/image-upload/image-upload comprehensive "Image upload overview"} to learn about
 * other ways to upload images into CKEditor 5.
 *
 * @extends module:core/plugin~Plugin
 */

var uploadadapter_CKFinderUploadAdapter = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(CKFinderUploadAdapter, _Plugin);

  var _super = Object(createSuper["a" /* default */])(CKFinderUploadAdapter);

  function CKFinderUploadAdapter() {
    Object(classCallCheck["a" /* default */])(this, CKFinderUploadAdapter);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(CKFinderUploadAdapter, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this = this;

      var url = this.editor.config.get('ckfinder.uploadUrl');

      if (!url) {
        return;
      } // Register CKFinderAdapter


      this.editor.plugins.get(filerepository_FileRepository).createUploadAdapter = function (loader) {
        return new uploadadapter_UploadAdapter(loader, url, _this.editor.t);
      };
    }
  }], [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [filerepository_FileRepository];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'CKFinderUploadAdapter';
    }
  }]);

  return CKFinderUploadAdapter;
}(plugin_Plugin);
/**
 * Upload adapter for CKFinder.
 *
 * @private
 * @implements module:upload/filerepository~UploadAdapter
 */




var uploadadapter_UploadAdapter = /*#__PURE__*/function () {
  /**
   * Creates a new adapter instance.
   *
   * @param {module:upload/filerepository~FileLoader} loader
   * @param {String} url
   * @param {module:utils/locale~Locale#t} t
   */
  function UploadAdapter(loader, url, t) {
    Object(classCallCheck["a" /* default */])(this, UploadAdapter);

    /**
     * FileLoader instance to use during the upload.
     *
     * @member {module:upload/filerepository~FileLoader} #loader
     */
    this.loader = loader;
    /**
     * Upload URL.
     *
     * @member {String} #url
     */

    this.url = url;
    /**
     * Locale translation method.
     *
     * @member {module:utils/locale~Locale#t} #t
     */

    this.t = t;
  }
  /**
   * Starts the upload process.
   *
   * @see module:upload/filerepository~UploadAdapter#upload
   * @returns {Promise.<Object>}
   */


  Object(createClass["a" /* default */])(UploadAdapter, [{
    key: "upload",
    value: function upload() {
      var _this2 = this;

      return this.loader.file.then(function (file) {
        return new Promise(function (resolve, reject) {
          _this2._initRequest();

          _this2._initListeners(resolve, reject, file);

          _this2._sendRequest(file);
        });
      });
    }
    /**
     * Aborts the upload process.
     *
     * @see module:upload/filerepository~UploadAdapter#abort
     */

  }, {
    key: "abort",
    value: function abort() {
      if (this.xhr) {
        this.xhr.abort();
      }
    }
    /**
     * Initializes the XMLHttpRequest object.
     *
     * @private
     */

  }, {
    key: "_initRequest",
    value: function _initRequest() {
      var xhr = this.xhr = new XMLHttpRequest();
      xhr.open('POST', this.url, true);
      xhr.responseType = 'json';
    }
    /**
     * Initializes XMLHttpRequest listeners.
     *
     * @private
     * @param {Function} resolve Callback function to be called when the request is successful.
     * @param {Function} reject Callback function to be called when the request cannot be completed.
     * @param {File} file File instance to be uploaded.
     */

  }, {
    key: "_initListeners",
    value: function _initListeners(resolve, reject, file) {
      var xhr = this.xhr;
      var loader = this.loader;
      var t = this.t;
      var genericError = t('Cannot upload file:') + " ".concat(file.name, ".");
      xhr.addEventListener('error', function () {
        return reject(genericError);
      });
      xhr.addEventListener('abort', function () {
        return reject();
      });
      xhr.addEventListener('load', function () {
        var response = xhr.response;

        if (!response || !response.uploaded) {
          return reject(response && response.error && response.error.message ? response.error.message : genericError);
        }

        resolve({
          default: response.url
        });
      }); // Upload progress when it's supported.

      /* istanbul ignore else */

      if (xhr.upload) {
        xhr.upload.addEventListener('progress', function (evt) {
          if (evt.lengthComputable) {
            loader.uploadTotal = evt.total;
            loader.uploaded = evt.loaded;
          }
        });
      }
    }
    /**
     * Prepares the data and sends the request.
     *
     * @private
     * @param {File} file File instance to be uploaded.
     */

  }, {
    key: "_sendRequest",
    value: function _sendRequest(file) {
      // Prepare form data.
      var data = new FormData();
      data.append('upload', file);
      data.append('ckCsrfToken', getCsrfToken()); // Send request.

      this.xhr.send(data);
    }
  }]);

  return UploadAdapter;
}();
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-autoformat/src/blockautoformatediting.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * The block autoformatting engine. It allows to format various block patterns. For example,
 * it can be configured to turn a paragraph starting with `*` and followed by a space into a list item.
 *
 * The autoformatting operation is integrated with the undo manager,
 * so the autoformatting step can be undone if the user's intention was not to format the text.
 *
 * See the {@link module:autoformat/blockautoformatediting~blockAutoformatEditing `blockAutoformatEditing`} documentation
 * to learn how to create custom block autoformatters. You can also use
 * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters
 * (lists, headings, bold and italic).
 *
 * @module autoformat/blockautoformatediting
 */

/**
 * Creates a listener triggered on {@link module:engine/model/document~Document#event:change:data `change:data`} event in the document.
 * Calls the callback when inserted text matches the regular expression or the command name
 * if provided instead of the callback.
 *
 * Examples of usage:
 *
 * To convert a paragraph to heading 1 when `- ` is typed, using just the command name:
 *
 *		blockAutoformatEditing( editor, plugin, /^\- $/, 'heading1' );
 *
 * To convert a paragraph to heading 1 when `- ` is typed, using just the callback:
 *
 *		blockAutoformatEditing( editor, plugin, /^\- $/, ( context ) => {
 *			const { match } = context;
 *			const headingLevel = match[ 1 ].length;
 *
 *			editor.execute( 'heading', {
 *				formatId: `heading${ headingLevel }`
 *			} );
 * 		} );
 *
 * @param {module:core/editor/editor~Editor} editor The editor instance.
 * @param {module:autoformat/autoformat~Autoformat} plugin The autoformat plugin instance.
 * @param {RegExp} pattern The regular expression to execute on just inserted text.
 * @param {Function|String} callbackOrCommand The callback to execute or the command to run when the text is matched.
 * In case of providing the callback, it receives the following parameter:
 * * {Object} match RegExp.exec() result of matching the pattern to inserted text.
 */

function blockAutoformatEditing(editor, plugin, pattern, callbackOrCommand) {
  var callback;
  var command = null;

  if (typeof callbackOrCommand == 'function') {
    callback = callbackOrCommand;
  } else {
    // We assume that the actual command name was provided.
    command = editor.commands.get(callbackOrCommand);

    callback = function callback() {
      editor.execute(callbackOrCommand);
    };
  }

  editor.model.document.on('change:data', function (evt, batch) {
    if (command && !command.isEnabled || !plugin.isEnabled) {
      return;
    }

    if (batch.type == 'transparent') {
      return;
    }

    var changes = Array.from(editor.model.document.differ.getChanges());
    var entry = changes[0]; // Typing is represented by only a single change.

    if (changes.length != 1 || entry.type !== 'insert' || entry.name != '$text' || entry.length != 1) {
      return;
    }

    var blockToFormat = entry.position.parent; // Block formatting should trigger only if the entire content of a paragraph is a single text node... (see ckeditor5#5671).

    if (!blockToFormat.is('paragraph') || blockToFormat.childCount !== 1) {
      return;
    }

    var match = pattern.exec(blockToFormat.getChild(0).data); // ...and this text node's data match the pattern.

    if (!match) {
      return;
    } // Use enqueueChange to create new batch to separate typing batch from the auto-format changes.


    editor.model.enqueueChange(function (writer) {
      // Matched range.
      var start = writer.createPositionAt(blockToFormat, 0);
      var end = writer.createPositionAt(blockToFormat, match[0].length);
      var range = new liverange_LiveRange(start, end);
      var wasChanged = callback({
        match: match
      }); // Remove matched text.

      if (wasChanged !== false) {
        writer.remove(range);
      }

      range.detach();
    });
  });
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-autoformat/src/inlineautoformatediting.js











/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * The inline autoformatting engine. It allows to format various inline patterns. For example,
 * it can be configured to make "foo" bold when typed `**foo**` (the `**` markers will be removed).
 *
 * The autoformatting operation is integrated with the undo manager,
 * so the autoformatting step can be undone if the user's intention was not to format the text.
 *
 * See the {@link module:autoformat/inlineautoformatediting~inlineAutoformatEditing `inlineAutoformatEditing`} documentation
 * to learn how to create custom inline autoformatters. You can also use
 * the {@link module:autoformat/autoformat~Autoformat} feature which enables a set of default autoformatters
 * (lists, headings, bold and italic).
 *
 * @module autoformat/inlineautoformatediting
 */

/**
 * Enables autoformatting mechanism for a given {@link module:core/editor/editor~Editor}.
 *
 * It formats the matched text by applying the given model attribute or by running the provided formatting callback.
 * On every {@link module:engine/model/document~Document#event:change:data data change} in the model document
 * the autoformatting engine checks the text on the left of the selection
 * and executes the provided action if the text matches given criteria (regular expression or callback).
 *
 * @param {module:core/editor/editor~Editor} editor The editor instance.
 * @param {module:autoformat/autoformat~Autoformat} plugin The autoformat plugin instance.
 * @param {Function|RegExp} testRegexpOrCallback The regular expression or callback to execute on text.
 * Provided regular expression *must* have three capture groups. The first and the third capture group
 * should match opening and closing delimiters. The second capture group should match the text to format.
 *
 *		// Matches the `**bold text**` pattern.
 *		// There are three capturing groups:
 *		// - The first to match the starting `**` delimiter.
 *		// - The second to match the text to format.
 *		// - The third to match the ending `**` delimiter.
 *		inlineAutoformatEditing( editor, plugin, /(\*\*)([^\*]+?)(\*\*)$/g, formatCallback );
 *
 * When a function is provided instead of the regular expression, it will be executed with the text to match as a parameter.
 * The function should return proper "ranges" to delete and format.
 *
 *		{
 *			remove: [
 *				[ 0, 1 ],	// Remove the first letter from the given text.
 *				[ 5, 6 ]	// Remove the 6th letter from the given text.
 *			],
 *			format: [
 *				[ 1, 5 ]	// Format all letters from 2nd to 5th.
 *			]
 *		}
 *
 * @param {Function} formatCallback A callback to apply actual formatting.
 * It should return `false` if changes should not be applied (e.g. if a command is disabled).
 *
 *		inlineAutoformatEditing( editor, plugin, /(\*\*)([^\*]+?)(\*\*)$/g, ( writer, rangesToFormat ) => {
 *			const command = editor.commands.get( 'bold' );
 *
 *			if ( !command.isEnabled ) {
 *				return false;
 *			}
 *
 *			const validRanges = editor.model.schema.getValidRanges( rangesToFormat, 'bold' );
 *
 *			for ( let range of validRanges ) {
 *				writer.setAttribute( 'bold', true, range );
 *			}
 *		} );
 */
function inlineAutoformatEditing(editor, plugin, testRegexpOrCallback, formatCallback) {
  var regExp;
  var testCallback;

  if (testRegexpOrCallback instanceof RegExp) {
    regExp = testRegexpOrCallback;
  } else {
    testCallback = testRegexpOrCallback;
  } // A test callback run on changed text.


  testCallback = testCallback || function (text) {
    var result;
    var remove = [];
    var format = [];

    while ((result = regExp.exec(text)) !== null) {
      // There should be full match and 3 capture groups.
      if (result && result.length < 4) {
        break;
      }

      var _result = result,
          index = _result.index,
          leftDel = _result['1'],
          content = _result['2'],
          rightDel = _result['3']; // Real matched string - there might be some non-capturing groups so we need to recalculate starting index.

      var found = leftDel + content + rightDel;
      index += result[0].length - found.length; // Start and End offsets of delimiters to remove.

      var delStart = [index, index + leftDel.length];
      var delEnd = [index + leftDel.length + content.length, index + leftDel.length + content.length + rightDel.length];
      remove.push(delStart);
      remove.push(delEnd);
      format.push([index + leftDel.length, index + leftDel.length + content.length]);
    }

    return {
      remove: remove,
      format: format
    };
  };

  editor.model.document.on('change:data', function (evt, batch) {
    if (batch.type == 'transparent' || !plugin.isEnabled) {
      return;
    }

    var model = editor.model;
    var selection = model.document.selection; // Do nothing if selection is not collapsed.

    if (!selection.isCollapsed) {
      return;
    }

    var changes = Array.from(model.document.differ.getChanges());
    var entry = changes[0]; // Typing is represented by only a single change.

    if (changes.length != 1 || entry.type !== 'insert' || entry.name != '$text' || entry.length != 1) {
      return;
    }

    var focus = selection.focus;
    var block = focus.parent;

    var _getTextAfterCode = getTextAfterCode(model.createRange(model.createPositionAt(block, 0), focus), model),
        text = _getTextAfterCode.text,
        range = _getTextAfterCode.range;

    var testOutput = testCallback(text);
    var rangesToFormat = testOutputToRanges(range.start, testOutput.format, model);
    var rangesToRemove = testOutputToRanges(range.start, testOutput.remove, model);

    if (!(rangesToFormat.length && rangesToRemove.length)) {
      return;
    } // Use enqueueChange to create new batch to separate typing batch from the auto-format changes.


    model.enqueueChange(function (writer) {
      // Apply format.
      var hasChanged = formatCallback(writer, rangesToFormat); // Strict check on `false` to have backward compatibility (when callbacks were returning `undefined`).

      if (hasChanged === false) {
        return;
      } // Remove delimiters - use reversed order to not mix the offsets while removing.


      var _iterator = _createForOfIteratorHelper(rangesToRemove.reverse()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _range = _step.value;
          writer.remove(_range);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    });
  });
} // Converts output of the test function provided to the inlineAutoformatEditing and converts it to the model ranges
// inside provided block.
//
// @private
// @param {module:engine/model/position~Position} start
// @param {Array.<Array>} arrays
// @param {module:engine/model/model~Model} model

function testOutputToRanges(start, arrays, model) {
  return arrays.filter(function (array) {
    return array[0] !== undefined && array[1] !== undefined;
  }).map(function (array) {
    return model.createRange(start.getShiftedBy(array[0]), start.getShiftedBy(array[1]));
  });
} // Returns the last text line after the last code element from the given range.
// It is similar to {@link module:typing/utils/getlasttextline.getLastTextLine `getLastTextLine()`},
// but it ignores any text before the last `code`.
//
// @param {module:engine/model/range~Range} range
// @param {module:engine/model/model~Model} model
// @returns {module:typing/utils/getlasttextline~LastTextLineData}


function getTextAfterCode(range, model) {
  var start = range.start;
  var text = Array.from(range.getItems()).reduce(function (rangeText, node) {
    // Trim text to a last occurrence of an inline element and update range start.
    if (!(node.is('text') || node.is('textProxy')) || node.getAttribute('code')) {
      start = model.createPositionAfter(node);
      return '';
    }

    return rangeText + node.data;
  }, '');
  return {
    text: text,
    range: model.createRange(start, range.end)
  };
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-autoformat/src/autoformat.js













/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module autoformat/autoformat
 */



/**
 * Enables a set of predefined autoformatting actions.
 *
 * For a detailed overview, check the {@glink features/autoformat Autoformatting feature documentation}
 * and the {@glink api/autoformat package page}.
 *
 * @extends module:core/plugin~Plugin
 */

var autoformat_Autoformat = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(Autoformat, _Plugin);

  var _super = Object(createSuper["a" /* default */])(Autoformat);

  function Autoformat() {
    Object(classCallCheck["a" /* default */])(this, Autoformat);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Autoformat, [{
    key: "afterInit",

    /**
     * @inheritDoc
     */
    value: function afterInit() {
      this._addListAutoformats();

      this._addBasicStylesAutoformats();

      this._addHeadingAutoformats();

      this._addBlockQuoteAutoformats();

      this._addCodeBlockAutoformats();
    }
    /**
     * Adds autoformatting related to the {@link module:list/list~List}.
     *
     * When typed:
     * - `* ` or `- ` &ndash; A paragraph will be changed to a bulleted list.
     * - `1. ` or `1) ` &ndash; A paragraph will be changed to a numbered list ("1" can be any digit or a list of digits).
     *
     * @private
     */

  }, {
    key: "_addListAutoformats",
    value: function _addListAutoformats() {
      var commands = this.editor.commands;

      if (commands.get('bulletedList')) {
        blockAutoformatEditing(this.editor, this, /^[*-]\s$/, 'bulletedList');
      }

      if (commands.get('numberedList')) {
        blockAutoformatEditing(this.editor, this, /^1[.|)]\s$/, 'numberedList');
      }
    }
    /**
     * Adds autoformatting related to the {@link module:basic-styles/bold~Bold},
     * {@link module:basic-styles/italic~Italic}, {@link module:basic-styles/code~Code}
     * and {@link module:basic-styles/strikethrough~Strikethrough}
     *
     * When typed:
     * - `**foobar**` &ndash; `**` characters are removed and `foobar` is set to bold,
     * - `__foobar__` &ndash; `__` characters are removed and `foobar` is set to bold,
     * - `*foobar*` &ndash; `*` characters are removed and `foobar` is set to italic,
     * - `_foobar_` &ndash; `_` characters are removed and `foobar` is set to italic,
     * - ``` `foobar` &ndash; ``` ` ``` characters are removed and `foobar` is set to code,
     * - `~~foobar~~` &ndash; `~~` characters are removed and `foobar` is set to strikethrough.
     *
     * @private
     */

  }, {
    key: "_addBasicStylesAutoformats",
    value: function _addBasicStylesAutoformats() {
      var commands = this.editor.commands;

      if (commands.get('bold')) {
        var boldCallback = getCallbackFunctionForInlineAutoformat(this.editor, 'bold');
        inlineAutoformatEditing(this.editor, this, /(\*\*)([^*]+)(\*\*)$/g, boldCallback);
        inlineAutoformatEditing(this.editor, this, /(__)([^_]+)(__)$/g, boldCallback);
      }

      if (commands.get('italic')) {
        var italicCallback = getCallbackFunctionForInlineAutoformat(this.editor, 'italic'); // The italic autoformatter cannot be triggered by the bold markers, so we need to check the
        // text before the pattern (e.g. `(?:^|[^\*])`).

        inlineAutoformatEditing(this.editor, this, /(?:^|[^*])(\*)([^*_]+)(\*)$/g, italicCallback);
        inlineAutoformatEditing(this.editor, this, /(?:^|[^_])(_)([^_]+)(_)$/g, italicCallback);
      }

      if (commands.get('code')) {
        var codeCallback = getCallbackFunctionForInlineAutoformat(this.editor, 'code');
        inlineAutoformatEditing(this.editor, this, /(`)([^`]+)(`)$/g, codeCallback);
      }

      if (commands.get('strikethrough')) {
        var strikethroughCallback = getCallbackFunctionForInlineAutoformat(this.editor, 'strikethrough');
        inlineAutoformatEditing(this.editor, this, /(~~)([^~]+)(~~)$/g, strikethroughCallback);
      }
    }
    /**
     * Adds autoformatting related to {@link module:heading/heading~Heading}.
     *
     * It is using a number at the end of the command name to associate it with the proper trigger:
     *
     * * `heading` with value `heading1` will be executed when typing `#`,
     * * `heading` with value `heading2` will be executed when typing `##`,
     * * ... up to `heading6` and `######`.
     *
     * @private
     */

  }, {
    key: "_addHeadingAutoformats",
    value: function _addHeadingAutoformats() {
      var _this = this;

      var command = this.editor.commands.get('heading');

      if (command) {
        command.modelElements.filter(function (name) {
          return name.match(/^heading[1-6]$/);
        }).forEach(function (commandValue) {
          var level = commandValue[7];
          var pattern = new RegExp("^(#{".concat(level, "})\\s$"));
          blockAutoformatEditing(_this.editor, _this, pattern, function () {
            if (!command.isEnabled) {
              return false;
            }

            _this.editor.execute('heading', {
              value: commandValue
            });
          });
        });
      }
    }
    /**
     * Adds autoformatting related to {@link module:block-quote/blockquote~BlockQuote}.
     *
     * When typed:
     * * `> ` &ndash; A paragraph will be changed to a block quote.
     *
     * @private
     */

  }, {
    key: "_addBlockQuoteAutoformats",
    value: function _addBlockQuoteAutoformats() {
      if (this.editor.commands.get('blockQuote')) {
        blockAutoformatEditing(this.editor, this, /^>\s$/, 'blockQuote');
      }
    }
    /**
     * Adds autoformatting related to {@link module:code-block/codeblock~CodeBlock}.
     *
     * When typed:
     * - `` ``` `` &ndash; A paragraph will be changed to a code block.
     *
     * @private
     */

  }, {
    key: "_addCodeBlockAutoformats",
    value: function _addCodeBlockAutoformats() {
      if (this.editor.commands.get('codeBlock')) {
        blockAutoformatEditing(this.editor, this, /^```$/, 'codeBlock');
      }
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'Autoformat';
    }
  }]);

  return Autoformat;
}(plugin_Plugin); // Helper function for getting `inlineAutoformatEditing` callbacks that checks if command is enabled.
//
// @param {module:core/editor/editor~Editor} editor
// @param {String} attributeKey
// @returns {Function}




function getCallbackFunctionForInlineAutoformat(editor, attributeKey) {
  return function (writer, rangesToFormat) {
    var command = editor.commands.get(attributeKey);

    if (!command.isEnabled) {
      return false;
    }

    var validRanges = editor.model.schema.getValidRanges(rangesToFormat, attributeKey);

    var _iterator = _createForOfIteratorHelper(validRanges),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var range = _step.value;
        writer.setAttribute(attributeKey, true, range);
      } // After applying attribute to the text, remove given attribute from the selection.
      // This way user is able to type a text without attribute used by auto formatter.

    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    writer.removeSelectionAttribute(attributeKey);
  };
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-basic-styles/src/attributecommand.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module basic-styles/attributecommand
 */

/**
 * An extension of the base {@link module:core/command~Command} class, which provides utilities for a command
 * that toggles a single attribute on a text or an element.
 *
 * `AttributeCommand` uses {@link module:engine/model/document~Document#selection}
 * to decide which nodes (if any) should be changed, and applies or removes the attribute from them.
 *
 * The command checks the {@link module:engine/model/model~Model#schema} to decide if it can be enabled
 * for the current selection and to which nodes the attribute can be applied.
 *
 * @extends module:core/command~Command
 */

var attributecommand_AttributeCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(AttributeCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(AttributeCommand);

  /**
   * @param {module:core/editor/editor~Editor} editor
   * @param {String} attributeKey Attribute that will be set by the command.
   */
  function AttributeCommand(editor, attributeKey) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, AttributeCommand);

    _this = _super.call(this, editor);
    /**
     * The attribute that will be set by the command.
     *
     * @readonly
     * @member {String}
     */

    _this.attributeKey = attributeKey;
    /**
     * Flag indicating whether the command is active. The command is active when the
     * {@link module:engine/model/selection~Selection#hasAttribute selection has the attribute} which means that:
     *
     * * If the selection is not empty &ndash; That the attribute is set on the first node in the selection that allows this attribute.
     * * If the selection is empty &ndash; That the selection has the attribute itself (which means that newly typed
     * text will have this attribute, too).
     *
     * @observable
     * @readonly
     * @member {Boolean} #value
     */

    return _this;
  }
  /**
   * Updates the command's {@link #value} and {@link #isEnabled} based on the current selection.
   */


  Object(createClass["a" /* default */])(AttributeCommand, [{
    key: "refresh",
    value: function refresh() {
      var model = this.editor.model;
      var doc = model.document;
      this.value = this._getValueFromFirstAllowedNode();
      this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, this.attributeKey);
    }
    /**
     * Executes the command &mdash; applies the attribute to the selection or removes it from the selection.
     *
     * If the command is active (`value == true`), it will remove attributes. Otherwise, it will set attributes.
     *
     * The execution result differs, depending on the {@link module:engine/model/document~Document#selection}:
     *
     * * If the selection is on a range, the command applies the attribute to all nodes in that range
     * (if they are allowed to have this attribute by the {@link module:engine/model/schema~Schema schema}).
     * * If the selection is collapsed in a non-empty node, the command applies the attribute to the
     * {@link module:engine/model/document~Document#selection} itself (note that typed characters copy attributes from the selection).
     * * If the selection is collapsed in an empty node, the command applies the attribute to the parent node of the selection (note
     * that the selection inherits all attributes from a node if it is in an empty node).
     *
     * @fires execute
     * @param {Object} [options] Command options.
     * @param {Boolean} [options.forceValue] If set, it will force the command behavior. If `true`, the command will apply the attribute,
     * otherwise the command will remove the attribute.
     * If not set, the command will look for its current value to decide what it should do.
     */

  }, {
    key: "execute",
    value: function execute() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var model = this.editor.model;
      var doc = model.document;
      var selection = doc.selection;
      var value = options.forceValue === undefined ? !this.value : options.forceValue;
      model.change(function (writer) {
        if (selection.isCollapsed) {
          if (value) {
            writer.setSelectionAttribute(_this2.attributeKey, true);
          } else {
            writer.removeSelectionAttribute(_this2.attributeKey);
          }
        } else {
          var ranges = model.schema.getValidRanges(selection.getRanges(), _this2.attributeKey);

          var _iterator = _createForOfIteratorHelper(ranges),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var range = _step.value;

              if (value) {
                writer.setAttribute(_this2.attributeKey, value, range);
              } else {
                writer.removeAttribute(_this2.attributeKey, range);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      });
    }
    /**
     * Checks the attribute value of the first node in the selection that allows the attribute.
     * For the collapsed selection returns the selection attribute.
     *
     * @private
     * @returns {Boolean} The attribute value.
     */

  }, {
    key: "_getValueFromFirstAllowedNode",
    value: function _getValueFromFirstAllowedNode() {
      var model = this.editor.model;
      var schema = model.schema;
      var selection = model.document.selection;

      if (selection.isCollapsed) {
        return selection.hasAttribute(this.attributeKey);
      }

      var _iterator2 = _createForOfIteratorHelper(selection.getRanges()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var range = _step2.value;

          var _iterator3 = _createForOfIteratorHelper(range.getItems()),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var item = _step3.value;

              if (schema.checkAttribute(item, this.attributeKey)) {
                return item.hasAttribute(this.attributeKey);
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return false;
    }
  }]);

  return AttributeCommand;
}(command_Command);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-basic-styles/src/bold/boldediting.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module basic-styles/bold/boldediting
 */


var BOLD = 'bold';
/**
 * The bold editing feature.
 *
 * It registers the `'bold'` command and introduces the `bold` attribute in the model which renders to the view
 * as a `<strong>` element.
 *
 * @extends module:core/plugin~Plugin
 */

var boldediting_BoldEditing = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(BoldEditing, _Plugin);

  var _super = Object(createSuper["a" /* default */])(BoldEditing);

  function BoldEditing() {
    Object(classCallCheck["a" /* default */])(this, BoldEditing);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(BoldEditing, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var editor = this.editor; // Allow bold attribute on text nodes.

      editor.model.schema.extend('$text', {
        allowAttributes: BOLD
      });
      editor.model.schema.setAttributeProperties(BOLD, {
        isFormatting: true,
        copyOnEnter: true
      }); // Build converter from model to view for data and editing pipelines.

      editor.conversion.attributeToElement({
        model: BOLD,
        view: 'strong',
        upcastAlso: ['b', function (viewElement) {
          var fontWeight = viewElement.getStyle('font-weight');

          if (!fontWeight) {
            return null;
          } // Value of the `font-weight` attribute can be defined as a string or a number.


          if (fontWeight == 'bold' || Number(fontWeight) >= 600) {
            return {
              name: true,
              styles: ['font-weight']
            };
          }
        }]
      }); // Create bold command.

      editor.commands.add(BOLD, new attributecommand_AttributeCommand(editor, BOLD)); // Set the Ctrl+B keystroke.

      editor.keystrokes.set('CTRL+B', BOLD);
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'BoldEditing';
    }
  }]);

  return BoldEditing;
}(plugin_Plugin);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-basic-styles/theme/icons/bold.svg
var bold = __webpack_require__("8708");
var bold_default = /*#__PURE__*/__webpack_require__.n(bold);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-basic-styles/src/bold/boldui.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module basic-styles/bold/boldui
 */



var boldui_BOLD = 'bold';
/**
 * The bold UI feature. It introduces the Bold button.
 *
 * @extends module:core/plugin~Plugin
 */

var boldui_BoldUI = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(BoldUI, _Plugin);

  var _super = Object(createSuper["a" /* default */])(BoldUI);

  function BoldUI() {
    Object(classCallCheck["a" /* default */])(this, BoldUI);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(BoldUI, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this = this;

      var editor = this.editor;
      var t = editor.t; // Add bold button to feature components.

      editor.ui.componentFactory.add(boldui_BOLD, function (locale) {
        var command = editor.commands.get(boldui_BOLD);
        var view = new buttonview_ButtonView(locale);
        view.set({
          label: t('Bold'),
          icon: bold_default.a,
          keystroke: 'CTRL+B',
          tooltip: true,
          isToggleable: true
        });
        view.bind('isOn', 'isEnabled').to(command, 'value', 'isEnabled'); // Execute command.

        _this.listenTo(view, 'execute', function () {
          editor.execute(boldui_BOLD);
          editor.editing.view.focus();
        });

        return view;
      });
    }
  }]);

  return BoldUI;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-basic-styles/src/bold.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module basic-styles/bold
 */



/**
 * The bold feature.
 *
 * For a detailed overview check the {@glink features/basic-styles Basic styles feature documentation}
 * and the {@glink api/basic-styles package page}.
 *
 * This is a "glue" plugin which loads the {@link module:basic-styles/bold/boldediting~BoldEditing bold editing feature}
 * and {@link module:basic-styles/bold/boldui~BoldUI bold UI feature}.
 *
 * @extends module:core/plugin~Plugin
 */

var bold_Bold = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(Bold, _Plugin);

  var _super = Object(createSuper["a" /* default */])(Bold);

  function Bold() {
    Object(classCallCheck["a" /* default */])(this, Bold);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Bold, null, [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [boldediting_BoldEditing, boldui_BoldUI];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'Bold';
    }
  }]);

  return Bold;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-basic-styles/src/italic/italicediting.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module basic-styles/italic/italicediting
 */


var ITALIC = 'italic';
/**
 * The italic editing feature.
 *
 * It registers the `'italic'` command, the <kbd>Ctrl+I</kbd> keystroke and introduces the `italic` attribute in the model
 * which renders to the view as an `<i>` element.
 *
 * @extends module:core/plugin~Plugin
 */

var italicediting_ItalicEditing = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ItalicEditing, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ItalicEditing);

  function ItalicEditing() {
    Object(classCallCheck["a" /* default */])(this, ItalicEditing);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ItalicEditing, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var editor = this.editor; // Allow italic attribute on text nodes.

      editor.model.schema.extend('$text', {
        allowAttributes: ITALIC
      });
      editor.model.schema.setAttributeProperties(ITALIC, {
        isFormatting: true,
        copyOnEnter: true
      });
      editor.conversion.attributeToElement({
        model: ITALIC,
        view: 'i',
        upcastAlso: ['em', {
          styles: {
            'font-style': 'italic'
          }
        }]
      }); // Create italic command.

      editor.commands.add(ITALIC, new attributecommand_AttributeCommand(editor, ITALIC)); // Set the Ctrl+I keystroke.

      editor.keystrokes.set('CTRL+I', ITALIC);
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'ItalicEditing';
    }
  }]);

  return ItalicEditing;
}(plugin_Plugin);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-basic-styles/theme/icons/italic.svg
var italic = __webpack_require__("1033");
var italic_default = /*#__PURE__*/__webpack_require__.n(italic);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-basic-styles/src/italic/italicui.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module basic-styles/italic/italicui
 */



var italicui_ITALIC = 'italic';
/**
 * The italic UI feature. It introduces the Italic button.
 *
 * @extends module:core/plugin~Plugin
 */

var italicui_ItalicUI = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ItalicUI, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ItalicUI);

  function ItalicUI() {
    Object(classCallCheck["a" /* default */])(this, ItalicUI);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ItalicUI, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this = this;

      var editor = this.editor;
      var t = editor.t; // Add bold button to feature components.

      editor.ui.componentFactory.add(italicui_ITALIC, function (locale) {
        var command = editor.commands.get(italicui_ITALIC);
        var view = new buttonview_ButtonView(locale);
        view.set({
          label: t('Italic'),
          icon: italic_default.a,
          keystroke: 'CTRL+I',
          tooltip: true,
          isToggleable: true
        });
        view.bind('isOn', 'isEnabled').to(command, 'value', 'isEnabled'); // Execute command.

        _this.listenTo(view, 'execute', function () {
          editor.execute(italicui_ITALIC);
          editor.editing.view.focus();
        });

        return view;
      });
    }
  }]);

  return ItalicUI;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-basic-styles/src/italic.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module basic-styles/italic
 */



/**
 * The italic feature.
 *
 * For a detailed overview check the {@glink features/basic-styles Basic styles feature documentation}
 * and the {@glink api/basic-styles package page}.
 *
 * This is a "glue" plugin which loads the {@link module:basic-styles/italic/italicediting~ItalicEditing} and
 * {@link module:basic-styles/italic/italicui~ItalicUI} plugins.
 *
 * @extends module:core/plugin~Plugin
 */

var italic_Italic = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(Italic, _Plugin);

  var _super = Object(createSuper["a" /* default */])(Italic);

  function Italic() {
    Object(classCallCheck["a" /* default */])(this, Italic);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Italic, null, [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [italicediting_ItalicEditing, italicui_ItalicUI];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'Italic';
    }
  }]);

  return Italic;
}(plugin_Plugin);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ckfinder/theme/icons/browse-files.svg
var browse_files = __webpack_require__("2074");
var browse_files_default = /*#__PURE__*/__webpack_require__.n(browse_files);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ckfinder/src/ckfinderui.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ckfinder/ckfinderui
 */



/**
 * The CKFinder UI plugin. It introduces the `'ckfinder'` toolbar button.
 *
 * @extends module:core/plugin~Plugin
 */

var ckfinderui_CKFinderUI = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(CKFinderUI, _Plugin);

  var _super = Object(createSuper["a" /* default */])(CKFinderUI);

  function CKFinderUI() {
    Object(classCallCheck["a" /* default */])(this, CKFinderUI);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(CKFinderUI, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var editor = this.editor;
      var componentFactory = editor.ui.componentFactory;
      var t = editor.t;
      componentFactory.add('ckfinder', function (locale) {
        var command = editor.commands.get('ckfinder');
        var button = new buttonview_ButtonView(locale);
        button.set({
          label: t('Insert image or file'),
          icon: browse_files_default.a,
          tooltip: true
        });
        button.bind('isEnabled').to(command);
        button.on('execute', function () {
          editor.execute('ckfinder');
          editor.editing.view.focus();
        });
        return button;
      });
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'CKFinderUI';
    }
  }]);

  return CKFinderUI;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/image/imageloadobserver.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/image/imageloadobserver
 */

/**
 * Observes all new images added to the {@link module:engine/view/document~Document},
 * fires {@link module:engine/view/document~Document#event:imageLoaded} and
 * {@link module:engine/view/document~Document#event:layoutChanged} event every time when the new image
 * has been loaded.
 *
 * **Note:** This event is not fired for images that has been added to the document and rendered as `complete` (already loaded).
 *
 * @extends module:engine/view/observer/observer~Observer
 */

var imageloadobserver_ImageLoadObserver = /*#__PURE__*/function (_Observer) {
  Object(inherits["a" /* default */])(ImageLoadObserver, _Observer);

  var _super = Object(createSuper["a" /* default */])(ImageLoadObserver);

  function ImageLoadObserver() {
    Object(classCallCheck["a" /* default */])(this, ImageLoadObserver);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ImageLoadObserver, [{
    key: "observe",

    /**
     * @inheritDoc
     */
    value: function observe(domRoot) {
      var _this = this;

      this.listenTo(domRoot, 'load', function (event, domEvent) {
        var domElement = domEvent.target;

        if (domElement.tagName == 'IMG') {
          _this._fireEvents(domEvent);
        } // Use capture phase for better performance (#4504).

      }, {
        useCapture: true
      });
    }
    /**
     * Fires {@link module:engine/view/document~Document#event:layoutChanged} and
     * {@link module:engine/view/document~Document#event:imageLoaded}
     * if observer {@link #isEnabled is enabled}.
     *
     * @protected
     * @param {Event} domEvent The DOM event.
     */

  }, {
    key: "_fireEvents",
    value: function _fireEvents(domEvent) {
      if (this.isEnabled) {
        this.document.fire('layoutChanged');
        this.document.fire('imageLoaded', domEvent);
      }
    }
  }]);

  return ImageLoadObserver;
}(observer_Observer);
/**
 * Fired when an <img/> DOM element has been loaded in the DOM root.
 *
 * Introduced by {@link module:image/image/imageloadobserver~ImageLoadObserver}.
 *
 * @see module:image/image/imageloadobserver~ImageLoadObserver
 * @event module:engine/view/document~Document#event:imageLoaded
 * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-utils/src/first.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module utils/first
 */

/**
 * Returns first item of the given `iterable`.
 *
 * @param {Iterable.<*>} iterable
 * @returns {*}
 */
function first_first(iterable) {
  var iteratorItem = iterable.next();

  if (iteratorItem.done) {
    return null;
  }

  return iteratorItem.value;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-widget/src/highlightstack.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module widget/highlightstack
 */


/**
 * Class used to handle correct order of highlights on elements.
 *
 * When different highlights are applied to same element correct order should be preserved:
 *
 * * highlight with highest priority should be applied,
 * * if two highlights have same priority - sort by CSS class provided in
 * {@link module:engine/conversion/downcasthelpers~HighlightDescriptor}.
 *
 * This way, highlight will be applied with the same rules it is applied on texts.
 */

var highlightstack_HighlightStack = /*#__PURE__*/function () {
  /**
   * Creates class instance.
   */
  function HighlightStack() {
    Object(classCallCheck["a" /* default */])(this, HighlightStack);

    this._stack = [];
  }
  /**
   * Adds highlight descriptor to the stack.
   *
   * @fires change:top
   * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor
   * @param {module:engine/view/downcastwriter~DowncastWriter} writer
   */


  Object(createClass["a" /* default */])(HighlightStack, [{
    key: "add",
    value: function add(descriptor, writer) {
      var stack = this._stack; // Save top descriptor and insert new one. If top is changed - fire event.

      var oldTop = stack[0];

      this._insertDescriptor(descriptor);

      var newTop = stack[0]; // When new object is at the top and stores different information.

      if (oldTop !== newTop && !compareDescriptors(oldTop, newTop)) {
        this.fire('change:top', {
          oldDescriptor: oldTop,
          newDescriptor: newTop,
          writer: writer
        });
      }
    }
    /**
     * Removes highlight descriptor from the stack.
     *
     * @fires change:top
     * @param {String} id Id of the descriptor to remove.
     * @param {module:engine/view/downcastwriter~DowncastWriter} writer
     */

  }, {
    key: "remove",
    value: function remove(id, writer) {
      var stack = this._stack;
      var oldTop = stack[0];

      this._removeDescriptor(id);

      var newTop = stack[0]; // When new object is at the top and stores different information.

      if (oldTop !== newTop && !compareDescriptors(oldTop, newTop)) {
        this.fire('change:top', {
          oldDescriptor: oldTop,
          newDescriptor: newTop,
          writer: writer
        });
      }
    }
    /**
     * Inserts given descriptor in correct place in the stack. It also takes care about updating information when
     * descriptor with same id is already present.
     *
     * @private
     * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} descriptor
     */

  }, {
    key: "_insertDescriptor",
    value: function _insertDescriptor(descriptor) {
      var stack = this._stack;
      var index = stack.findIndex(function (item) {
        return item.id === descriptor.id;
      }); // Inserting exact same descriptor - do nothing.

      if (compareDescriptors(descriptor, stack[index])) {
        return;
      } // If descriptor with same id but with different information is on the stack - remove it.


      if (index > -1) {
        stack.splice(index, 1);
      } // Find correct place to insert descriptor in the stack.
      // It have different information (for example priority) so it must be re-inserted in correct place.


      var i = 0;

      while (stack[i] && shouldABeBeforeB(stack[i], descriptor)) {
        i++;
      }

      stack.splice(i, 0, descriptor);
    }
    /**
     * Removes descriptor with given id from the stack.
     *
     * @private
     * @param {String} id Descriptor's id.
     */

  }, {
    key: "_removeDescriptor",
    value: function _removeDescriptor(id) {
      var stack = this._stack;
      var index = stack.findIndex(function (item) {
        return item.id === id;
      }); // If descriptor with same id is on the list - remove it.

      if (index > -1) {
        stack.splice(index, 1);
      }
    }
  }]);

  return HighlightStack;
}();


mix(highlightstack_HighlightStack, emittermixin); // Compares two descriptors by checking their priority and class list.
//
// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} a
// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} b
// @returns {Boolean} Returns true if both descriptors are defined and have same priority and classes.

function compareDescriptors(a, b) {
  return a && b && a.priority == b.priority && classesToString(a.classes) == classesToString(b.classes);
} // Checks whenever first descriptor should be placed in the stack before second one.
//
// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} a
// @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} b
// @returns {Boolean}


function shouldABeBeforeB(a, b) {
  if (a.priority > b.priority) {
    return true;
  } else if (a.priority < b.priority) {
    return false;
  } // When priorities are equal and names are different - use classes to compare.


  return classesToString(a.classes) > classesToString(b.classes);
} // Converts CSS classes passed with {@link module:engine/conversion/downcasthelpers~HighlightDescriptor} to
// sorted string.
//
// @param {String|Array<String>} descriptor
// @returns {String}


function classesToString(classes) {
  return Array.isArray(classes) ? classes.sort().join(',') : classes;
}
/**
 * Fired when top element on {@link module:widget/highlightstack~HighlightStack} has been changed
 *
 * @event change:top
 * @param {Object} data Additional information about the change.
 * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} [data.newDescriptor] New highlight
 * descriptor. It will be `undefined` when last descriptor is removed from the stack.
 * @param {module:engine/conversion/downcasthelpers~HighlightDescriptor} [data.oldDescriptor] Old highlight
 * descriptor. It will be `undefined` when first descriptor is added to the stack.
 * @param {module:engine/view/downcastwriter~DowncastWriter} writer View writer that can be used to modify element.
 */
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonpanel.css
var balloonpanel = __webpack_require__("1af3");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/panel/balloon/balloonpanelview.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module ui/panel/balloon/balloonpanelview
 */







var balloonpanelview_toPx = toUnit('px');
var defaultLimiterElement = global.document.body;
/**
 * The balloon panel view class.
 *
 * A floating container which can
 * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#pin pin} to any
 * {@link module:utils/dom/position~Options#target target} in the DOM and remain in that position
 * e.g. when the web page is scrolled.
 *
 * The balloon panel can be used to display contextual, non-blocking UI like forms, toolbars and
 * the like in its {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#content} view
 * collection.
 *
 * There is a number of {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}
 * that the balloon can use, automatically switching from one to another when the viewport space becomes
 * scarce to keep the balloon visible to the user as long as it is possible. The balloon will also
 * accept any custom position set provided by the user compatible with the
 * {@link module:utils/dom/position~Options options}.
 *
 *		const panel = new BalloonPanelView( locale );
 *		const childView = new ChildView();
 *		const positions = BalloonPanelView.defaultPositions;
 *
 *		panel.render();
 *
 *		// Add a child view to the panel's content collection.
 *		panel.content.add( childView );
 *
 *		// Start pinning the panel to an element with the "target" id DOM.
 *		// The balloon will remain pinned until unpin() is called.
 *		panel.pin( {
 *			target: document.querySelector( '#target' ),
 *			positions: [
 *				positions.northArrowSouth,
 *				positions.southArrowNorth
 *			]
 *		} );
 *
 * @extends module:ui/view~View
 */

var balloonpanelview_BalloonPanelView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(BalloonPanelView, _View);

  var _super = Object(createSuper["a" /* default */])(BalloonPanelView);

  /**
   * @inheritDoc
   */
  function BalloonPanelView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, BalloonPanelView);

    _this = _super.call(this, locale);
    var bind = _this.bindTemplate;
    /**
     * The absolute top position of the balloon panel in pixels.
     *
     * @observable
     * @default 0
     * @member {Number} #top
     */

    _this.set('top', 0);
    /**
     * The absolute left position of the balloon panel in pixels.
     *
     * @observable
     * @default 0
     * @member {Number} #left
     */


    _this.set('left', 0);
    /**
     * The balloon panel's current position. The position name is reflected in the CSS class set
     * to the balloon, i.e. `.ck-balloon-panel_arrow_nw` for the "arrow_nw" position. The class
     * controls the minor aspects of the balloon's visual appearance like the placement
     * of an {@link #withArrow arrow}. To support a new position, an additional CSS must be created.
     *
     * Default position names correspond with
     * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
     *
     * See the {@link #attachTo} and {@link #pin} methods to learn about custom balloon positions.
     *
     * @observable
     * @default 'arrow_nw'
     * @member {'arrow_nw'|'arrow_ne'|'arrow_sw'|'arrow_se'} #position
     */


    _this.set('position', 'arrow_nw');
    /**
     * Controls whether the balloon panel is visible or not.
     *
     * @observable
     * @default false
     * @member {Boolean} #isVisible
     */


    _this.set('isVisible', false);
    /**
     * Controls whether the balloon panel has an arrow. The presence of the arrow
     * is reflected in the `ck-balloon-panel_with-arrow` CSS class.
     *
     * @observable
     * @default true
     * @member {Boolean} #withArrow
     */


    _this.set('withArrow', true);
    /**
     * An additional CSS class added to the {@link #element}.
     *
     * @observable
     * @member {String} #class
     */


    _this.set('class');
    /**
     * A callback that starts pinning the panel when {@link #isVisible} gets
     * `true`. Used by {@link #pin}.
     *
     * @private
     * @member {Function} #_pinWhenIsVisibleCallback
     */

    /**
     * A collection of the child views that creates the balloon panel contents.
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */


    _this.content = _this.createCollection();

    _this.setTemplate({
      tag: 'div',
      attributes: {
        class: ['ck', 'ck-balloon-panel', bind.to('position', function (value) {
          return "ck-balloon-panel_".concat(value);
        }), bind.if('isVisible', 'ck-balloon-panel_visible'), bind.if('withArrow', 'ck-balloon-panel_with-arrow'), bind.to('class')],
        style: {
          top: bind.to('top', balloonpanelview_toPx),
          left: bind.to('left', balloonpanelview_toPx)
        }
      },
      children: _this.content
    });

    return _this;
  }
  /**
   * Shows the panel.
   *
   * See {@link #isVisible}.
   */


  Object(createClass["a" /* default */])(BalloonPanelView, [{
    key: "show",
    value: function show() {
      this.isVisible = true;
    }
    /**
     * Hides the panel.
     *
     * See {@link #isVisible}.
     */

  }, {
    key: "hide",
    value: function hide() {
      this.isVisible = false;
    }
    /**
     * Attaches the panel to a specified {@link module:utils/dom/position~Options#target} with a
     * smart positioning heuristics that chooses from available positions to make sure the panel
     * is visible to the user i.e. within the limits of the viewport.
     *
     * This method accepts configuration {@link module:utils/dom/position~Options options}
     * to set the `target`, optional `limiter` and `positions` the balloon should choose from.
     *
     *		const panel = new BalloonPanelView( locale );
     *		const positions = BalloonPanelView.defaultPositions;
     *
     *		panel.render();
     *
     *		// Attach the panel to an element with the "target" id DOM.
     *		panel.attachTo( {
     *			target: document.querySelector( '#target' ),
     *			positions: [
     *				positions.northArrowSouth,
     *				positions.southArrowNorth
     *			]
     *		} );
     *
     * **Note**: Attaching the panel will also automatically {@link #show} it.
     *
     * **Note**: An attached panel will not follow its target when the window is scrolled or resized.
     * See the {@link #pin} method for a more permanent positioning strategy.
     *
     * @param {module:utils/dom/position~Options} options Positioning options compatible with
     * {@link module:utils/dom/position~getOptimalPosition}. Default `positions` array is
     * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
     */

  }, {
    key: "attachTo",
    value: function attachTo(options) {
      this.show();
      var defaultPositions = BalloonPanelView.defaultPositions;
      var positionOptions = Object.assign({}, {
        element: this.element,
        positions: [defaultPositions.southArrowNorth, defaultPositions.southArrowNorthMiddleWest, defaultPositions.southArrowNorthMiddleEast, defaultPositions.southArrowNorthWest, defaultPositions.southArrowNorthEast, defaultPositions.northArrowSouth, defaultPositions.northArrowSouthMiddleWest, defaultPositions.northArrowSouthMiddleEast, defaultPositions.northArrowSouthWest, defaultPositions.northArrowSouthEast],
        limiter: defaultLimiterElement,
        fitInViewport: true
      }, options);

      var optimalPosition = BalloonPanelView._getOptimalPosition(positionOptions); // Usually browsers make some problems with super accurate values like 104.345px
      // so it is better to use int values.


      var left = parseInt(optimalPosition.left);
      var top = parseInt(optimalPosition.top);
      var position = optimalPosition.name;
      Object.assign(this, {
        top: top,
        left: left,
        position: position
      });
    }
    /**
     * Works the same way as the {@link #attachTo} method except that the position of the panel is
     * continuously updated when:
     *
     * * any ancestor of the {@link module:utils/dom/position~Options#target}
     * or {@link module:utils/dom/position~Options#limiter} is scrolled,
     * * the browser window gets resized or scrolled.
     *
     * Thanks to that, the panel always sticks to the {@link module:utils/dom/position~Options#target}
     * and is immune to the changing environment.
     *
     *		const panel = new BalloonPanelView( locale );
     *		const positions = BalloonPanelView.defaultPositions;
     *
     *		panel.render();
     *
     *		// Pin the panel to an element with the "target" id DOM.
     *		panel.pin( {
     *			target: document.querySelector( '#target' ),
     *			positions: [
     *				positions.northArrowSouth,
     *				positions.southArrowNorth
     *			]
     *		} );
     *
     * To leave the pinned state, use the {@link #unpin} method.
     *
     * **Note**: Pinning the panel will also automatically {@link #show} it.
     *
     * @param {module:utils/dom/position~Options} options Positioning options compatible with
     * {@link module:utils/dom/position~getOptimalPosition}. Default `positions` array is
     * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions}.
     */

  }, {
    key: "pin",
    value: function pin(options) {
      var _this2 = this;

      this.unpin();

      this._pinWhenIsVisibleCallback = function () {
        if (_this2.isVisible) {
          _this2._startPinning(options);
        } else {
          _this2._stopPinning();
        }
      };

      this._startPinning(options); // Control the state of the listeners depending on whether the panel is visible
      // or not.
      // TODO: Use on() (https://github.com/ckeditor/ckeditor5-utils/issues/144).


      this.listenTo(this, 'change:isVisible', this._pinWhenIsVisibleCallback);
    }
    /**
     * Stops pinning the panel, as set up by {@link #pin}.
     */

  }, {
    key: "unpin",
    value: function unpin() {
      if (this._pinWhenIsVisibleCallback) {
        // Deactivate listeners attached by pin().
        this._stopPinning(); // Deactivate the panel pin() control logic.
        // TODO: Use off() (https://github.com/ckeditor/ckeditor5-utils/issues/144).


        this.stopListening(this, 'change:isVisible', this._pinWhenIsVisibleCallback);
        this._pinWhenIsVisibleCallback = null;
        this.hide();
      }
    }
    /**
     * Starts managing the pinned state of the panel. See {@link #pin}.
     *
     * @private
     * @param {module:utils/dom/position~Options} options Positioning options compatible with
     * {@link module:utils/dom/position~getOptimalPosition}.
     */

  }, {
    key: "_startPinning",
    value: function _startPinning(options) {
      var _this3 = this;

      this.attachTo(options);
      var targetElement = getDomElement(options.target);
      var limiterElement = options.limiter ? getDomElement(options.limiter) : defaultLimiterElement; // Then we need to listen on scroll event of eny element in the document.

      this.listenTo(global.document, 'scroll', function (evt, domEvt) {
        var scrollTarget = domEvt.target; // The position needs to be updated if the positioning target is within the scrolled element.

        var isWithinScrollTarget = targetElement && scrollTarget.contains(targetElement); // The position needs to be updated if the positioning limiter is within the scrolled element.

        var isLimiterWithinScrollTarget = limiterElement && scrollTarget.contains(limiterElement); // The positioning target and/or limiter can be a Rect, object etc..
        // There's no way to optimize the listener then.

        if (isWithinScrollTarget || isLimiterWithinScrollTarget || !targetElement || !limiterElement) {
          _this3.attachTo(options);
        }
      }, {
        useCapture: true
      }); // We need to listen on window resize event and update position.

      this.listenTo(global.window, 'resize', function () {
        _this3.attachTo(options);
      });
    }
    /**
     * Stops managing the pinned state of the panel. See {@link #pin}.
     *
     * @private
     */

  }, {
    key: "_stopPinning",
    value: function _stopPinning() {
      this.stopListening(global.document, 'scroll');
      this.stopListening(global.window, 'resize');
    }
  }]);

  return BalloonPanelView;
}(src_view_View); // Returns the DOM element for given object or null, if there is none,
// e.g. when the passed object is a Rect instance or so.
//
// @private
// @param {*} object
// @returns {HTMLElement|null}




function getDomElement(object) {
  if (lodash_es_isElement(object)) {
    return object;
  }

  if (isRange(object)) {
    return object.commonAncestorContainer;
  }

  if (typeof object == 'function') {
    return getDomElement(object());
  }

  return null;
}
/**
 * A horizontal offset of the arrow tip from the edge of the balloon. Controlled by CSS.
 *
 *		 +-----|---------...
 *		 |     |
 *		 |     |
 *		 |     |
 *		 |     |
 *		 +--+  |  +------...
 *		     \ | /
 *		      \|/
 *	    >|-----|<---------------- horizontal offset
 *
 * @default 30
 * @member {Number} module:ui/panel/balloon/balloonpanelview~BalloonPanelView.arrowHorizontalOffset
 */


balloonpanelview_BalloonPanelView.arrowHorizontalOffset = 25;
/**
 * A vertical offset of the arrow from the edge of the balloon. Controlled by CSS.
 *
 *		 +-------------...
 *		 |
 *		 |
 *		 |                      /-- vertical offset
 *		 |                     V
 *		 +--+    +-----...    ---------
 *		     \  /              |
 *		      \/               |
 *		-------------------------------
 *		                       ^
 *
 * @default 15
 * @member {Number} module:ui/panel/balloon/balloonpanelview~BalloonPanelView.arrowVerticalOffset
 */

balloonpanelview_BalloonPanelView.arrowVerticalOffset = 10;
/**
 * Function used to calculate the optimal position for the balloon.
 *
 * @protected
 * @member {Function} module:ui/panel/balloon/balloonpanelview~BalloonPanelView._getOptimalPosition
 */

balloonpanelview_BalloonPanelView._getOptimalPosition = getOptimalPosition;
/**
 * A default set of positioning functions used by the balloon panel view
 * when attaching using the {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#attachTo} method.
 *
 * The available positioning functions are as follows:
 *
 *
 *
 * **North west**
 *
 * * `northWestArrowSouthWest`
 *
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *		 V
 *		 [ Target ]
 *
 * * `northWestArrowSouthMiddleWest`
 *
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *		    V
 *		    [ Target ]
 *
 * * `northWestArrowSouth`
 *
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *		         V
 *		         [ Target ]
 *
 * * `northWestArrowSouthMiddleEast`
 *
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *		             V
 *		             [ Target ]
 *
 * * `northWestArrowSouthEast`
 *
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *		                 V
 *		                 [ Target ]
 *
 *
 *
 * **North**
 *
 * * `northArrowSouthWest`
 *
 *		    +-----------------+
 *		    |     Balloon     |
 *		    +-----------------+
 *		     V
 *		[ Target ]
 *
 * * `northArrowSouthMiddleWest`
 *
 *		 +-----------------+
 *		 |     Balloon     |
 *		 +-----------------+
 *		     V
 *		[ Target ]
 *
 * * `northArrowSouth`
 *
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *		         V
 *		    [ Target ]
 *
 * * `northArrowSouthMiddleEast`
 *
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *		             V
 *		        [ Target ]
 *
 * * `northArrowSouthEast`
 *
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *		                V
 *		           [ Target ]
 *
 * **North east**
 *
 * * `northEastArrowSouthWest`
 *
 *		        +-----------------+
 *		        |     Balloon     |
 *		        +-----------------+
 *		         V
 *		[ Target ]
 *
 *
 * * `northEastArrowSouthMiddleWest`
 *
 *		     +-----------------+
 *		     |     Balloon     |
 *		     +-----------------+
 *		         V
 *		[ Target ]
 *
 * * `northEastArrowSouth`
 *
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *		         V
 *		[ Target ]
 *
 * * `northEastArrowSouthMiddleEast`
 *
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *		             V
 *		    [ Target ]
 *
 * * `northEastArrowSouthEast`
 *
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *		                 V
 *		        [ Target ]
 *
 *
 *
 * **South**
 *
 *
 * * `southArrowNorthWest`
 *
 *		[ Target ]
 *		     ^
 *		    +-----------------+
 *		    |     Balloon     |
 *		    +-----------------+
 *
 * * `southArrowNorthMiddleWest`
 *
 *		   [ Target ]
 *		        ^
 *		    +-----------------+
 *		    |     Balloon     |
 *		    +-----------------+
 *
 * * `southArrowNorth`
 *
 *		    [ Target ]
 *		         ^
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *
 * * `southArrowNorthMiddleEast`
 *
 *		            [ Target ]
 *		                 ^
 *		   +-----------------+
 *		   |     Balloon     |
 *		   +-----------------+
 *
 * * `southArrowNorthEast`
 *
 *		            [ Target ]
 *		                 ^
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *
 *
 *
 * **South west**
 *
 * * `southWestArrowNorthWest`
 *
 *		 [ Target ]
 *		 ^
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *
 * * `southWestArrowNorthMiddleWest`
 *
 *		     [ Target ]
 *		     ^
 *		 +-----------------+
 *		 |     Balloon     |
 *		 +-----------------+
 *
 * * `southWestArrowNorth`
 *
 *		         [ Target ]
 *		         ^
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *
 * * `southWestArrowNorthMiddleEast`
 *
 *		              [ Target ]
 *		              ^
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *
 * * `southWestArrowNorthEast`
 *
 *		                 [ Target ]
 *		                 ^
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *
 *
 *
 * **South east**
 *
 * * `southEastArrowNorthWest`
 *
 *		[ Target ]
 *		         ^
 *		        +-----------------+
 *		        |     Balloon     |
 *		        +-----------------+
* * `southEastArrowNorthMiddleWest`
 *
 *		   [ Target ]
 *		            ^
 *		        +-----------------+
 *		        |     Balloon     |
 *		        +-----------------+
 *
 * * `southEastArrowNorth`
 *
 *		[ Target ]
 *		         ^
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *
 * * `southEastArrowNorthMiddleEast`
 *
 *		     [ Target ]
 *		              ^
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *
 * * `southEastArrowNorthEast`
 *
 *		        [ Target ]
 *		                 ^
 *		+-----------------+
 *		|     Balloon     |
 *		+-----------------+
 *
 *
 * See {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView#attachTo}.
 *
 * Positioning functions must be compatible with {@link module:utils/dom/position~Position}.
 *
 * The name that the position function returns will be reflected in the balloon panel's class that
 * controls the placement of the "arrow". See {@link #position} to learn more.
 *
 * @member {Object} module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions
 */

balloonpanelview_BalloonPanelView.defaultPositions = {
  // ------- North west
  northWestArrowSouthWest: function northWestArrowSouthWest(targetRect, balloonRect) {
    return {
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_sw'
    };
  },
  northWestArrowSouthMiddleWest: function northWestArrowSouthMiddleWest(targetRect, balloonRect) {
    return {
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width * .25 - balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_smw'
    };
  },
  northWestArrowSouth: function northWestArrowSouth(targetRect, balloonRect) {
    return {
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width / 2,
      name: 'arrow_s'
    };
  },
  northWestArrowSouthMiddleEast: function northWestArrowSouthMiddleEast(targetRect, balloonRect) {
    return {
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width * .75 + balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_sme'
    };
  },
  northWestArrowSouthEast: function northWestArrowSouthEast(targetRect, balloonRect) {
    return {
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width + balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_se'
    };
  },
  // ------- North
  northArrowSouthWest: function northArrowSouthWest(targetRect, balloonRect) {
    return {
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_sw'
    };
  },
  northArrowSouthMiddleWest: function northArrowSouthMiddleWest(targetRect, balloonRect) {
    return {
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width * .25 - balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_smw'
    };
  },
  northArrowSouth: function northArrowSouth(targetRect, balloonRect) {
    return {
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
      name: 'arrow_s'
    };
  },
  northArrowSouthMiddleEast: function northArrowSouthMiddleEast(targetRect, balloonRect) {
    return {
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width * .75 + balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_sme'
    };
  },
  northArrowSouthEast: function northArrowSouthEast(targetRect, balloonRect) {
    return {
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width + balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_se'
    };
  },
  // ------- North east
  northEastArrowSouthWest: function northEastArrowSouthWest(targetRect, balloonRect) {
    return {
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_sw'
    };
  },
  northEastArrowSouthMiddleWest: function northEastArrowSouthMiddleWest(targetRect, balloonRect) {
    return {
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width * .25 - balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_smw'
    };
  },
  northEastArrowSouth: function northEastArrowSouth(targetRect, balloonRect) {
    return {
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width / 2,
      name: 'arrow_s'
    };
  },
  northEastArrowSouthMiddleEast: function northEastArrowSouthMiddleEast(targetRect, balloonRect) {
    return {
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width * .75 + balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_sme'
    };
  },
  northEastArrowSouthEast: function northEastArrowSouthEast(targetRect, balloonRect) {
    return {
      top: getNorthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width + balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_se'
    };
  },
  // ------- South west
  southWestArrowNorthWest: function southWestArrowNorthWest(targetRect, balloonRect) {
    return {
      top: getSouthTop(targetRect, balloonRect),
      left: targetRect.left - balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_nw'
    };
  },
  southWestArrowNorthMiddleWest: function southWestArrowNorthMiddleWest(targetRect, balloonRect) {
    return {
      top: getSouthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width * .25 - balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_nmw'
    };
  },
  southWestArrowNorth: function southWestArrowNorth(targetRect, balloonRect) {
    return {
      top: getSouthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width / 2,
      name: 'arrow_n'
    };
  },
  southWestArrowNorthMiddleEast: function southWestArrowNorthMiddleEast(targetRect, balloonRect) {
    return {
      top: getSouthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width * .75 + balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_nme'
    };
  },
  southWestArrowNorthEast: function southWestArrowNorthEast(targetRect, balloonRect) {
    return {
      top: getSouthTop(targetRect, balloonRect),
      left: targetRect.left - balloonRect.width + balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_ne'
    };
  },
  // ------- South
  southArrowNorthWest: function southArrowNorthWest(targetRect, balloonRect) {
    return {
      top: getSouthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_nw'
    };
  },
  southArrowNorthMiddleWest: function southArrowNorthMiddleWest(targetRect, balloonRect) {
    return {
      top: getSouthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.25 - balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_nmw'
    };
  },
  southArrowNorth: function southArrowNorth(targetRect, balloonRect) {
    return {
      top: getSouthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width / 2,
      name: 'arrow_n'
    };
  },
  southArrowNorthMiddleEast: function southArrowNorthMiddleEast(targetRect, balloonRect) {
    return {
      top: getSouthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width * 0.75 + balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_nme'
    };
  },
  southArrowNorthEast: function southArrowNorthEast(targetRect, balloonRect) {
    return {
      top: getSouthTop(targetRect, balloonRect),
      left: targetRect.left + targetRect.width / 2 - balloonRect.width + balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_ne'
    };
  },
  // ------- South east
  southEastArrowNorthWest: function southEastArrowNorthWest(targetRect, balloonRect) {
    return {
      top: getSouthTop(targetRect, balloonRect),
      left: targetRect.right - balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_nw'
    };
  },
  southEastArrowNorthMiddleWest: function southEastArrowNorthMiddleWest(targetRect, balloonRect) {
    return {
      top: getSouthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width * .25 - balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_nmw'
    };
  },
  southEastArrowNorth: function southEastArrowNorth(targetRect, balloonRect) {
    return {
      top: getSouthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width / 2,
      name: 'arrow_n'
    };
  },
  southEastArrowNorthMiddleEast: function southEastArrowNorthMiddleEast(targetRect, balloonRect) {
    return {
      top: getSouthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width * .75 + balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_nme'
    };
  },
  southEastArrowNorthEast: function southEastArrowNorthEast(targetRect, balloonRect) {
    return {
      top: getSouthTop(targetRect, balloonRect),
      left: targetRect.right - balloonRect.width + balloonpanelview_BalloonPanelView.arrowHorizontalOffset,
      name: 'arrow_ne'
    };
  }
}; // Returns the top coordinate for positions starting with `north*`.
//
// @private
// @param {utils/dom/rect~Rect} targetRect A rect of the target.
// @param {utils/dom/rect~Rect} elementRect A rect of the balloon.
// @returns {Number}

function getNorthTop(targetRect, balloonRect) {
  return targetRect.top - balloonRect.height - balloonpanelview_BalloonPanelView.arrowVerticalOffset;
} // Returns the top coordinate for positions starting with `south*`.
//
// @private
// @param {utils/dom/rect~Rect} targetRect A rect of the target.
// @param {utils/dom/rect~Rect} elementRect A rect of the balloon.
// @returns {Number}


function getSouthTop(targetRect) {
  return targetRect.bottom + balloonpanelview_BalloonPanelView.arrowVerticalOffset;
}
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-widget/theme/icons/drag-handle.svg
var drag_handle = __webpack_require__("5dbf");
var drag_handle_default = /*#__PURE__*/__webpack_require__.n(drag_handle);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-widget/src/widgettypearound/utils.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module widget/widgettypearound/utils
 */

/**
 * The name of the type around model selection attribute responsible for
 * displaying a "fake caret" next to a selected widget.
 */

var TYPE_AROUND_SELECTION_ATTRIBUTE = 'widget-type-around';
/**
 * Checks if an element is a widget that qualifies to get the type around UI.
 *
 * @param {module:engine/view/element~Element} viewElement
 * @param {module:engine/model/element~Element} modelElement
 * @param {module:engine/model/schema~Schema} schema
 * @returns {Boolean}
 */

function isTypeAroundWidget(viewElement, modelElement, schema) {
  return viewElement && isWidget(viewElement) && !schema.isInline(modelElement);
}
/**
 * For the passed HTML element, this helper finds the closest type around button ancestor.
 *
 * @param {HTMLElement} domElement
 * @returns {HTMLElement|null}
 */

function getClosestTypeAroundDomButton(domElement) {
  return domElement.closest('.ck-widget__type-around__button');
}
/**
 * For the passed type around button element, this helper determines at which position
 * the paragraph would be inserted into the content if, for instance, the button was
 * clicked by the user.
 *
 * @param {HTMLElement} domElement
 * @returns {'before'|'after'} Position of the button.
 */

function getTypeAroundButtonPosition(domElement) {
  return domElement.classList.contains('ck-widget__type-around__button_before') ? 'before' : 'after';
}
/**
 * For the passed HTML element, this helper returns the closest view widget ancestor.
 *
 * @param {HTMLElement} domElement
 * @param {module:engine/view/domconverter~DomConverter} domConverter
 * @returns {module:engine/view/element~Element}
 */

function getClosestWidgetViewElement(domElement, domConverter) {
  var widgetDomElement = domElement.closest('.ck-widget');
  return domConverter.mapDomToView(widgetDomElement);
}
/**
 * For the passed selection instance, it returns the position of the "fake caret" displayed next to a widget.
 *
 * **Note**: If the "fake caret" is not currently displayed, `null` is returned.
 *
 * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection
 * @returns {'before'|'after'|null} Position of the fake caret or `null` when none is preset.
 */

function getTypeAroundFakeCaretPosition(selection) {
  return selection.getAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-widget/src/utils.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module widget/utils
 */







/**
 * CSS class added to each widget element.
 *
 * @const {String}
 */

var WIDGET_CLASS_NAME = 'ck-widget';
/**
 * CSS class added to currently selected widget element.
 *
 * @const {String}
 */

var WIDGET_SELECTED_CLASS_NAME = 'ck-widget_selected';
/**
 * Returns `true` if given {@link module:engine/view/node~Node} is an {@link module:engine/view/element~Element} and a widget.
 *
 * @param {module:engine/view/node~Node} node
 * @returns {Boolean}
 */

function isWidget(node) {
  if (!node.is('element')) {
    return false;
  }

  return !!node.getCustomProperty('widget');
}
/* eslint-disable max-len */

/**
 * Converts the given {@link module:engine/view/element~Element} to a widget in the following way:
 *
 * * sets the `contenteditable` attribute to `"true"`,
 * * adds the `ck-widget` CSS class,
 * * adds a custom {@link module:engine/view/element~Element#getFillerOffset `getFillerOffset()`} method returning `null`,
 * * adds a custom property allowing to recognize widget elements by using {@link ~isWidget `isWidget()`},
 * * implements the {@link ~setHighlightHandling view highlight on widgets}.
 *
 * This function needs to be used in conjunction with
 * {@link module:engine/conversion/downcasthelpers~DowncastHelpers downcast conversion helpers}
 * like {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.
 * Moreover, typically you will want to use `toWidget()` only for `editingDowncast`, while keeping the `dataDowncast` clean.
 *
 * For example, in order to convert a `<widget>` model element to `<div class="widget">` in the view, you can define
 * such converters:
 *
 *		editor.conversion.for( 'editingDowncast' )
 *			.elementToElement( {
 *				model: 'widget',
 *				view: ( modelItem, writer ) => {
 *					const div = writer.createContainerElement( 'div', { class: 'widget' } );
 *
 *					return toWidget( div, writer, { label: 'some widget' } );
 *				}
 *			} );
 *
 *		editor.conversion.for( 'dataDowncast' )
 *			.elementToElement( {
 *				model: 'widget',
 *				view: ( modelItem, writer ) => {
 *					return writer.createContainerElement( 'div', { class: 'widget' } );
 *				}
 *			} );
 *
 * See the full source code of the widget (with a nested editable) schema definition and converters in
 * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).
 *
 * @param {module:engine/view/element~Element} element
 * @param {module:engine/view/downcastwriter~DowncastWriter} writer
 * @param {Object} [options={}]
 * @param {String|Function} [options.label] Element's label provided to the {@link ~setLabel} function. It can be passed as
 * a plain string or a function returning a string. It represents the widget for assistive technologies (like screen readers).
 * @param {Boolean} [options.hasSelectionHandle=false] If `true`, the widget will have a selection handle added.
 * @returns {module:engine/view/element~Element} Returns the same element.
 */

/* eslint-enable max-len */

function toWidget(element, writer) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  writer.setAttribute('contenteditable', 'false', element);
  writer.addClass(WIDGET_CLASS_NAME, element);
  writer.setCustomProperty('widget', true, element);
  element.getFillerOffset = utils_getFillerOffset;

  if (options.label) {
    setLabel(element, options.label, writer);
  }

  if (options.hasSelectionHandle) {
    addSelectionHandle(element, writer);
  }

  setHighlightHandling(element, writer, function (element, descriptor, writer) {
    return writer.addClass(normalizeToArray(descriptor.classes), element);
  }, function (element, descriptor, writer) {
    return writer.removeClass(normalizeToArray(descriptor.classes), element);
  });
  return element; // Normalizes CSS class in descriptor that can be provided in form of an array or a string.

  function normalizeToArray(classes) {
    return Array.isArray(classes) ? classes : [classes];
  }
}
/**
 * Sets highlight handling methods. Uses {@link module:widget/highlightstack~HighlightStack} to
 * properly determine which highlight descriptor should be used at given time.
 *
 * @param {module:engine/view/element~Element} element
 * @param {module:engine/view/downcastwriter~DowncastWriter} writer
 * @param {Function} add
 * @param {Function} remove
 */

function setHighlightHandling(element, writer, add, remove) {
  var stack = new highlightstack_HighlightStack();
  stack.on('change:top', function (evt, data) {
    if (data.oldDescriptor) {
      remove(element, data.oldDescriptor, data.writer);
    }

    if (data.newDescriptor) {
      add(element, data.newDescriptor, data.writer);
    }
  });
  writer.setCustomProperty('addHighlight', function (element, descriptor, writer) {
    return stack.add(descriptor, writer);
  }, element);
  writer.setCustomProperty('removeHighlight', function (element, id, writer) {
    return stack.remove(id, writer);
  }, element);
}
/**
 * Sets label for given element.
 * It can be passed as a plain string or a function returning a string. Function will be called each time label is retrieved by
 * {@link ~getLabel `getLabel()`}.
 *
 * @param {module:engine/view/element~Element} element
 * @param {String|Function} labelOrCreator
 * @param {module:engine/view/downcastwriter~DowncastWriter} writer
 */

function setLabel(element, labelOrCreator, writer) {
  writer.setCustomProperty('widgetLabel', labelOrCreator, element);
}
/**
 * Returns the label of the provided element.
 *
 * @param {module:engine/view/element~Element} element
 * @returns {String}
 */

function getLabel(element) {
  var labelCreator = element.getCustomProperty('widgetLabel');

  if (!labelCreator) {
    return '';
  }

  return typeof labelCreator == 'function' ? labelCreator() : labelCreator;
}
/**
 * Adds functionality to the provided {@link module:engine/view/editableelement~EditableElement} to act as a widget's editable:
 *
 * * sets the `contenteditable` attribute to `true` when {@link module:engine/view/editableelement~EditableElement#isReadOnly} is `false`,
 * otherwise sets it to `false`,
 * * adds the `ck-editor__editable` and `ck-editor__nested-editable` CSS classes,
 * * adds the `ck-editor__nested-editable_focused` CSS class when the editable is focused and removes it when it is blurred.
 *
 * Similarly to {@link ~toWidget `toWidget()`} this function should be used in `dataDowncast` only and it is usually
 * used together with {@link module:engine/conversion/downcasthelpers~DowncastHelpers#elementToElement `elementToElement()`}.
 *
 * For example, in order to convert a `<nested>` model element to `<div class="nested">` in the view, you can define
 * such converters:
 *
 *		editor.conversion.for( 'editingDowncast' )
 *			.elementToElement( {
 *				model: 'nested',
 *				view: ( modelItem, writer ) => {
 *					const div = writer.createEditableElement( 'div', { class: 'nested' } );
 *
 *					return toWidgetEditable( nested, writer );
 *				}
 *			} );
 *
 *		editor.conversion.for( 'dataDowncast' )
 *			.elementToElement( {
 *				model: 'nested',
 *				view: ( modelItem, writer ) => {
 *					return writer.createContainerElement( 'div', { class: 'nested' } );
 *				}
 *			} );
 *
 * See the full source code of the widget (with nested editable) schema definition and converters in
 * [this sample](https://github.com/ckeditor/ckeditor5-widget/blob/master/tests/manual/widget-with-nestededitable.js).
 *
 * @param {module:engine/view/editableelement~EditableElement} editable
 * @param {module:engine/view/downcastwriter~DowncastWriter} writer
 * @returns {module:engine/view/editableelement~EditableElement} Returns the same element that was provided in the `editable` parameter
 */

function toWidgetEditable(editable, writer) {
  writer.addClass(['ck-editor__editable', 'ck-editor__nested-editable'], editable); // Set initial contenteditable value.

  writer.setAttribute('contenteditable', editable.isReadOnly ? 'false' : 'true', editable); // Bind the contenteditable property to element#isReadOnly.

  editable.on('change:isReadOnly', function (evt, property, is) {
    writer.setAttribute('contenteditable', is ? 'false' : 'true', editable);
  });
  editable.on('change:isFocused', function (evt, property, is) {
    if (is) {
      writer.addClass('ck-editor__nested-editable_focused', editable);
    } else {
      writer.removeClass('ck-editor__nested-editable_focused', editable);
    }
  });
  return editable;
}
/**
 * Returns a model position which is optimal (in terms of UX) for inserting a widget block.
 *
 * For instance, if a selection is in the middle of a paragraph, the position before this paragraph
 * will be returned so that it is not split. If the selection is at the end of a paragraph,
 * the position after this paragraph will be returned.
 *
 * Note: If the selection is placed in an empty block, that block will be returned. If that position
 * is then passed to {@link module:engine/model/model~Model#insertContent},
 * the block will be fully replaced by the image.
 *
 * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} selection
 * The selection based on which the insertion position should be calculated.
 * @param {module:engine/model/model~Model} model Model instance.
 * @returns {module:engine/model/position~Position} The optimal position.
 */

function findOptimalInsertionPosition(selection, model) {
  var selectedElement = selection.getSelectedElement();

  if (selectedElement) {
    var typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(selection); // If the WidgetTypeAround "fake caret" is displayed, use its position for the insertion
    // to provide the most predictable UX (https://github.com/ckeditor/ckeditor5/issues/7438).

    if (typeAroundFakeCaretPosition) {
      return model.createPositionAt(selectedElement, typeAroundFakeCaretPosition);
    }

    if (model.schema.isBlock(selectedElement)) {
      return model.createPositionAfter(selectedElement);
    }
  }

  var firstBlock = selection.getSelectedBlocks().next().value;

  if (firstBlock) {
    // If inserting into an empty block – return position in that block. It will get
    // replaced with the image by insertContent(). #42.
    if (firstBlock.isEmpty) {
      return model.createPositionAt(firstBlock, 0);
    }

    var positionAfter = model.createPositionAfter(firstBlock); // If selection is at the end of the block - return position after the block.

    if (selection.focus.isTouching(positionAfter)) {
      return positionAfter;
    } // Otherwise return position before the block.


    return model.createPositionBefore(firstBlock);
  }

  return selection.focus;
}
/**
 * A util to be used in order to map view positions to correct model positions when implementing a widget
 * which renders non-empty view element for an empty model element.
 *
 * For example:
 *
 *		// Model:
 *		<placeholder type="name"></placeholder>
 *
 *		// View:
 *		<span class="placeholder">name</span>
 *
 * In such case, view positions inside `<span>` cannot be correct mapped to the model (because the model element is empty).
 * To handle mapping positions inside `<span class="placeholder">` to the model use this util as follows:
 *
 *		editor.editing.mapper.on(
 *			'viewToModelPosition',
 *			viewToModelPositionOutsideModelElement( model, viewElement => viewElement.hasClass( 'placeholder' ) )
 *		);
 *
 * The callback will try to map the view offset of selection to an expected model position.
 *
 * 1. When the position is at the end (or in the middle) of the inline widget:
 *
 *		// View:
 *		<p>foo <span class="placeholder">name|</span> bar</p>
 *
 *		// Model:
 *		<paragraph>foo <placeholder type="name"></placeholder>| bar</paragraph>
 *
 * 2. When the position is at the beginning of the inline widget:
 *
 *		// View:
 *		<p>foo <span class="placeholder">|name</span> bar</p>
 *
 *		// Model:
 *		<paragraph>foo |<placeholder type="name"></placeholder> bar</paragraph>
 *
 * @param {module:engine/model/model~Model} model Model instance on which the callback operates.
 * @param {Function} viewElementMatcher Function that is passed a view element and should return `true` if the custom mapping
 * should be applied to the given view element.
 * @return {Function}
 */

function viewToModelPositionOutsideModelElement(model, viewElementMatcher) {
  return function (evt, data) {
    var mapper = data.mapper,
        viewPosition = data.viewPosition;
    var viewParent = mapper.findMappedViewAncestor(viewPosition);

    if (!viewElementMatcher(viewParent)) {
      return;
    }

    var modelParent = mapper.toModelElement(viewParent);
    data.modelPosition = model.createPositionAt(modelParent, viewPosition.isAtStart ? 'before' : 'after');
  };
}
/**
 * A positioning function passed to the {@link module:utils/dom/position~getOptimalPosition} helper as a last resort
 * when attaching {@link  module:ui/panel/balloon/balloonpanelview~BalloonPanelView balloon UI} to widgets.
 * It comes in handy when a widget is longer than the visual viewport of the web browser and/or upper/lower boundaries
 * of a widget are off screen because of the web page scroll.
 *
 *	                                       ┌─┄┄┄┄┄┄┄┄┄Widget┄┄┄┄┄┄┄┄┄┐
 *	                                       ┊                         ┊
 *	┌────────────Viewport───────────┐   ┌──╁─────────Viewport────────╁──┐
 *	│  ┏━━━━━━━━━━Widget━━━━━━━━━┓  │   │  ┃            ^            ┃  │
 *	│  ┃            ^            ┃  │   │  ┃   ╭───────/ \───────╮   ┃  │
 *	│  ┃   ╭───────/ \───────╮   ┃  │   │  ┃   │     Balloon     │   ┃  │
 *	│  ┃   │     Balloon     │   ┃  │   │  ┃   ╰─────────────────╯   ┃  │
 *	│  ┃   ╰─────────────────╯   ┃  │   │  ┃                         ┃  │
 *	│  ┃                         ┃  │   │  ┃                         ┃  │
 *	│  ┃                         ┃  │   │  ┃                         ┃  │
 *	│  ┃                         ┃  │   │  ┃                         ┃  │
 *	│  ┃                         ┃  │   │  ┃                         ┃  │
 *	│  ┃                         ┃  │   │  ┃                         ┃  │
 *	│  ┃                         ┃  │   │  ┃                         ┃  │
 *	└──╀─────────────────────────╀──┘   └──╀─────────────────────────╀──┘
 *	   ┊                         ┊         ┊                         ┊
 *	   ┊                         ┊         └┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┘
 *	   ┊                         ┊
 *	   └┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄┘
 *
 * **Note**: Works best if used together with
 * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView.defaultPositions default `BalloonPanelView` positions}
 * like `northArrowSouth` and `southArrowNorth`; the transition between these two and this position is smooth.
 *
 * @param {module:utils/dom/rect~Rect} widgetRect A rect of the widget.
 * @param {module:utils/dom/rect~Rect} balloonRect A rect of the balloon.
 * @returns {module:utils/dom/position~Position|null}
 */

function centeredBalloonPositionForLongWidgets(widgetRect, balloonRect) {
  var viewportRect = new rect_Rect(global.window);
  var viewportWidgetInsersectionRect = viewportRect.getIntersection(widgetRect);
  var balloonTotalHeight = balloonRect.height + balloonpanelview_BalloonPanelView.arrowVerticalOffset; // If there is enough space above or below the widget then this position should not be used.

  if (widgetRect.top - balloonTotalHeight > viewportRect.top || widgetRect.bottom + balloonTotalHeight < viewportRect.bottom) {
    return null;
  } // Because this is a last resort positioning, to keep things simple we're not playing with positions of the arrow
  // like, for instance, "south west" or whatever. Just try to keep the balloon in the middle of the visible area of
  // the widget for as long as it is possible. If the widgets becomes invisible (because cropped by the viewport),
  // just... place the balloon in the middle of it (because why not?).


  var targetRect = viewportWidgetInsersectionRect || widgetRect;
  var left = targetRect.left + targetRect.width / 2 - balloonRect.width / 2;
  return {
    top: Math.max(widgetRect.top, 0) + balloonpanelview_BalloonPanelView.arrowVerticalOffset,
    left: left,
    name: 'arrow_n'
  };
} // Default filler offset function applied to all widget elements.
//
// @returns {null}

function utils_getFillerOffset() {
  return null;
} // Adds a drag handle to the widget.
//
// @param {module:engine/view/containerelement~ContainerElement}
// @param {module:engine/view/downcastwriter~DowncastWriter} writer


function addSelectionHandle(widgetElement, writer) {
  var selectionHandle = writer.createUIElement('div', {
    class: 'ck ck-widget__selection-handle'
  }, function (domDocument) {
    var domElement = this.toDomElement(domDocument); // Use the IconView from the ui library.

    var icon = new iconview_IconView();
    icon.set('content', drag_handle_default.a); // Render the icon view right away to append its #element to the selectionHandle DOM element.

    icon.render();
    domElement.appendChild(icon.element);
    return domElement;
  }); // Append the selection handle into the widget wrapper.

  writer.insert(writer.createPositionAt(widgetElement, 0), selectionHandle);
  writer.addClass(['ck-widget_with-selection-handle'], widgetElement);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/image/utils.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/image/utils
 */

/**
 * Converts a given {@link module:engine/view/element~Element} to an image widget:
 * * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to recognize the image widget element.
 * * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.
 *
 * @param {module:engine/view/element~Element} viewElement
 * @param {module:engine/view/downcastwriter~DowncastWriter} writer An instance of the view writer.
 * @param {String} label The element's label. It will be concatenated with the image `alt` attribute if one is present.
 * @returns {module:engine/view/element~Element}
 */

function toImageWidget(viewElement, writer, label) {
  writer.setCustomProperty('image', true, viewElement);
  return toWidget(viewElement, writer, {
    label: labelCreator
  });

  function labelCreator() {
    var imgElement = getViewImgFromWidget(viewElement);
    var altText = imgElement.getAttribute('alt');
    return altText ? "".concat(altText, " ").concat(label) : label;
  }
}
/**
 * Checks if a given view element is an image widget.
 *
 * @param {module:engine/view/element~Element} viewElement
 * @returns {Boolean}
 */

function isImageWidget(viewElement) {
  return !!viewElement.getCustomProperty('image') && isWidget(viewElement);
}
/**
 * Returns an image widget editing view element if one is selected.
 *
 * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} selection
 * @returns {module:engine/view/element~Element|null}
 */

function getSelectedImageWidget(selection) {
  var viewElement = selection.getSelectedElement();

  if (viewElement && isImageWidget(viewElement)) {
    return viewElement;
  }

  return null;
}
/**
 * Checks if the provided model element is an `image`.
 *
 * @param {module:engine/model/element~Element} modelElement
 * @returns {Boolean}
 */

function isImage(modelElement) {
  return !!modelElement && modelElement.is('image');
}
/**
 * Handles inserting single file. This method unifies image insertion using {@link module:widget/utils~findOptimalInsertionPosition} method.
 *
 *		model.change( writer => {
 *			insertImage( writer, model, { src: 'path/to/image.jpg' } );
 *		} );
 *
 * @param {module:engine/model/writer~Writer} writer
 * @param {module:engine/model/model~Model} model
 * @param {Object} [attributes={}] Attributes of inserted image
 */

function insertImage(writer, model) {
  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var imageElement = writer.createElement('image', attributes);
  var insertAtSelection = findOptimalInsertionPosition(model.document.selection, model);
  model.insertContent(imageElement, insertAtSelection); // Inserting an image might've failed due to schema regulations.

  if (imageElement.parent) {
    writer.setSelection(imageElement, 'on');
  }
}
/**
 * Checks if image can be inserted at current model selection.
 *
 * @param {module:engine/model/model~Model} model
 * @returns {Boolean}
 */

function isImageAllowed(model) {
  var schema = model.schema;
  var selection = model.document.selection;
  return isImageAllowedInParent(selection, schema, model) && !checkSelectionOnObject(selection, schema) && isInOtherImage(selection);
}
/**
 * Get view `<img>` element from the view widget (`<figure>`).
 *
 * Assuming that image is always a first child of a widget (ie. `figureView.getChild( 0 )`) is unsafe as other features might
 * inject their own elements to the widget.
 *
 * The `<img>` can be wrapped to other elements, e.g. `<a>`. Nested check required.
 *
 * @param {module:engine/view/element~Element} figureView
 * @returns {module:engine/view/element~Element}
 */

function getViewImgFromWidget(figureView) {
  var figureChildren = [];

  var _iterator = _createForOfIteratorHelper(figureView.getChildren()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var figureChild = _step.value;
      figureChildren.push(figureChild);

      if (figureChild.is('element')) {
        figureChildren.push.apply(figureChildren, _toConsumableArray(figureChild.getChildren()));
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return figureChildren.find(function (viewChild) {
    return viewChild.is('img');
  });
} // Checks if image is allowed by schema in optimal insertion parent.
//
// @returns {Boolean}

function isImageAllowedInParent(selection, schema, model) {
  var parent = getInsertImageParent(selection, model);
  return schema.checkChild(parent, 'image');
} // Check if selection is on object.
//
// @returns {Boolean}


function checkSelectionOnObject(selection, schema) {
  var selectedElement = selection.getSelectedElement();
  return selectedElement && schema.isObject(selectedElement);
} // Checks if selection is placed in other image (ie. in caption).


function isInOtherImage(selection) {
  return _toConsumableArray(selection.focus.getAncestors()).every(function (ancestor) {
    return !ancestor.is('image');
  });
} // Returns a node that will be used to insert image with `model.insertContent` to check if image can be placed there.


function getInsertImageParent(selection, model) {
  var insertAt = findOptimalInsertionPosition(selection, model);
  var parent = insertAt.parent;

  if (parent.isEmpty && !parent.is('$root')) {
    return parent.parent;
  }

  return parent;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/image/converters.js


/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/image/converters
 */


/**
 * Returns a function that converts the image view representation:
 *
 *		<figure class="image"><img src="..." alt="..."></img></figure>
 *
 * to the model representation:
 *
 *		<image src="..." alt="..."></image>
 *
 * The entire content of the `<figure>` element except the first `<img>` is being converted as children
 * of the `<image>` model element.
 *
 * @returns {Function}
 */

function viewFigureToModel() {
  return function (dispatcher) {
    dispatcher.on('element:figure', converter);
  };

  function converter(evt, data, conversionApi) {
    // Do not convert if this is not an "image figure".
    if (!conversionApi.consumable.test(data.viewItem, {
      name: true,
      classes: 'image'
    })) {
      return;
    } // Find an image element inside the figure element.


    var viewImage = getViewImgFromWidget(data.viewItem); // Do not convert if image element is absent, is missing src attribute or was already converted.

    if (!viewImage || !viewImage.hasAttribute('src') || !conversionApi.consumable.test(viewImage, {
      name: true
    })) {
      return;
    } // Convert view image to model image.


    var conversionResult = conversionApi.convertItem(viewImage, data.modelCursor); // Get image element from conversion result.

    var modelImage = first_first(conversionResult.modelRange.getItems()); // When image wasn't successfully converted then finish conversion.

    if (!modelImage) {
      return;
    } // Convert rest of the figure element's children as an image children.


    conversionApi.convertChildren(data.viewItem, conversionApi.writer.createPositionAt(modelImage, 0)); // Set image range as conversion result.

    data.modelRange = conversionResult.modelRange; // Continue conversion where image conversion ends.

    data.modelCursor = conversionResult.modelCursor;
  }
}
/**
 * Converter used to convert the `srcset` model image attribute to the `srcset`, `sizes` and `width` attributes in the view.
 *
 * @returns {Function}
 */

function srcsetAttributeConverter() {
  return function (dispatcher) {
    dispatcher.on('attribute:srcset:image', converter);
  };

  function converter(evt, data, conversionApi) {
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }

    var writer = conversionApi.writer;
    var figure = conversionApi.mapper.toViewElement(data.item);
    var img = getViewImgFromWidget(figure);

    if (data.attributeNewValue === null) {
      var srcset = data.attributeOldValue;

      if (srcset.data) {
        writer.removeAttribute('srcset', img);
        writer.removeAttribute('sizes', img);

        if (srcset.width) {
          writer.removeAttribute('width', img);
        }
      }
    } else {
      var _srcset = data.attributeNewValue;

      if (_srcset.data) {
        writer.setAttribute('srcset', _srcset.data, img); // Always outputting `100vw`. See https://github.com/ckeditor/ckeditor5-image/issues/2.

        writer.setAttribute('sizes', '100vw', img);

        if (_srcset.width) {
          writer.setAttribute('width', _srcset.width, img);
        }
      }
    }
  }
}
function modelToViewAttributeConverter(attributeKey) {
  return function (dispatcher) {
    dispatcher.on("attribute:".concat(attributeKey, ":image"), converter);
  };

  function converter(evt, data, conversionApi) {
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    }

    var viewWriter = conversionApi.writer;
    var figure = conversionApi.mapper.toViewElement(data.item);
    var img = getViewImgFromWidget(figure);
    viewWriter.setAttribute(data.attributeKey, data.attributeNewValue || '', img);
  }
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/image/imageinsertcommand.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */


/**
 * @module image/image/imageinsertcommand
 */

/**
 * Insert image command.
 *
 * The command is registered by the {@link module:image/image/imageediting~ImageEditing} plugin as `'imageInsert'`.
 *
 * In order to insert an image at the current selection position
 * (according to the {@link module:widget/utils~findOptimalInsertionPosition} algorithm),
 * execute the command and specify the image source:
 *
 *		editor.execute( 'imageInsert', { source: 'http://url.to.the/image' } );
 *
 * It is also possible to insert multiple images at once:
 *
 *		editor.execute( 'imageInsert', {
 *			source:  [
 *				'path/to/image.jpg',
 *				'path/to/other-image.jpg'
 *			]
 *		} );
 *
 * @extends module:core/command~Command
 */

var imageinsertcommand_ImageInsertCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(ImageInsertCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(ImageInsertCommand);

  function ImageInsertCommand() {
    Object(classCallCheck["a" /* default */])(this, ImageInsertCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ImageInsertCommand, [{
    key: "refresh",

    /**
     * @inheritDoc
     */
    value: function refresh() {
      this.isEnabled = isImageAllowed(this.editor.model);
    }
    /**
     * Executes the command.
     *
     * @fires execute
     * @param {Object} options Options for the executed command.
     * @param {String|Array.<String>} options.source The image source or an array of image sources to insert.
     */

  }, {
    key: "execute",
    value: function execute(options) {
      var model = this.editor.model;
      model.change(function (writer) {
        var sources = Array.isArray(options.source) ? options.source : [options.source];

        var _iterator = _createForOfIteratorHelper(sources),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var src = _step.value;
            insertImage(writer, model, {
              src: src
            });
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
    }
  }]);

  return ImageInsertCommand;
}(command_Command);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/image/imageediting.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/image/imageediting
 */





/**
 * The image engine plugin.
 *
 * It registers:
 *
 * * `<image>` as a block element in the document schema, and allows `alt`, `src` and `srcset` attributes.
 * * converters for editing and data pipelines.
 * * `'imageInsert'` command.
 *
 * @extends module:core/plugin~Plugin
 */

var imageediting_ImageEditing = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ImageEditing, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ImageEditing);

  function ImageEditing() {
    Object(classCallCheck["a" /* default */])(this, ImageEditing);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ImageEditing, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var editor = this.editor;
      var schema = editor.model.schema;
      var t = editor.t;
      var conversion = editor.conversion; // See https://github.com/ckeditor/ckeditor5-image/issues/142.

      editor.editing.view.addObserver(imageloadobserver_ImageLoadObserver); // Configure schema.

      schema.register('image', {
        isObject: true,
        isBlock: true,
        allowWhere: '$block',
        allowAttributes: ['alt', 'src', 'srcset']
      });
      conversion.for('dataDowncast').elementToElement({
        model: 'image',
        view: function view(modelElement, viewWriter) {
          return createImageViewElement(viewWriter);
        }
      });
      conversion.for('editingDowncast').elementToElement({
        model: 'image',
        view: function view(modelElement, viewWriter) {
          return toImageWidget(createImageViewElement(viewWriter), viewWriter, t('image widget'));
        }
      });
      conversion.for('downcast').add(modelToViewAttributeConverter('src')).add(modelToViewAttributeConverter('alt')).add(srcsetAttributeConverter());
      conversion.for('upcast').elementToElement({
        view: {
          name: 'img',
          attributes: {
            src: true
          }
        },
        model: function model(viewImage, modelWriter) {
          return modelWriter.createElement('image', {
            src: viewImage.getAttribute('src')
          });
        }
      }).attributeToAttribute({
        view: {
          name: 'img',
          key: 'alt'
        },
        model: 'alt'
      }).attributeToAttribute({
        view: {
          name: 'img',
          key: 'srcset'
        },
        model: {
          key: 'srcset',
          value: function value(viewImage) {
            var value = {
              data: viewImage.getAttribute('srcset')
            };

            if (viewImage.hasAttribute('width')) {
              value.width = viewImage.getAttribute('width');
            }

            return value;
          }
        }
      }).add(viewFigureToModel()); // Register imageUpload command.

      editor.commands.add('imageInsert', new imageinsertcommand_ImageInsertCommand(editor));
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'ImageEditing';
    }
  }]);

  return ImageEditing;
}(plugin_Plugin); // Creates a view element representing the image.
//
//		<figure class="image"><img></img></figure>
//
// Note that `alt` and `src` attributes are converted separately, so they are not included.
//
// @private
// @param {module:engine/view/downcastwriter~DowncastWriter} writer
// @returns {module:engine/view/containerelement~ContainerElement}



function createImageViewElement(writer) {
  var emptyElement = writer.createEmptyElement('img');
  var figure = writer.createContainerElement('figure', {
    class: 'image'
  });
  writer.insert(writer.createPositionAt(figure, 0), emptyElement);
  return figure;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/observer/mouseobserver.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/observer/mouseobserver
 */

/**
 * Mouse events observer.
 *
 * Note that this observer is not available by default. To make it available it needs to be added to
 * {@link module:engine/view/view~View} by {@link module:engine/view/view~View#addObserver} method.
 *
 * @extends module:engine/view/observer/domeventobserver~DomEventObserver
 */

var mouseobserver_MouseObserver = /*#__PURE__*/function (_DomEventObserver) {
  Object(inherits["a" /* default */])(MouseObserver, _DomEventObserver);

  var _super = Object(createSuper["a" /* default */])(MouseObserver);

  function MouseObserver(view) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, MouseObserver);

    _this = _super.call(this, view);
    _this.domEventType = 'mousedown';
    return _this;
  }

  Object(createClass["a" /* default */])(MouseObserver, [{
    key: "onDomEvent",
    value: function onDomEvent(domEvent) {
      this.fire(domEvent.type, domEvent);
    }
  }]);

  return MouseObserver;
}(domeventobserver_DomEventObserver);
/**
 * Fired when mouse button is pressed down on one of the editables.
 *
 * Introduced by {@link module:engine/view/observer/mouseobserver~MouseObserver}.
 *
 * Note that this event is not available by default. To make it available {@link module:engine/view/observer/mouseobserver~MouseObserver}
 * needs to be added to {@link module:engine/view/view~View} by a {@link module:engine/view/view~View#addObserver} method.
 *
 * @see module:engine/view/observer/mouseobserver~MouseObserver
 * @event module:engine/view/document~Document#event:mousedown
 * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/utils/bindtwostepcarettoattribute.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/utils/bindtwostepcarettoattribute
 */


/**
 * This helper enables the two-step caret (phantom) movement behavior for the given {@link module:engine/model/model~Model}
 * attribute on arrow right (<kbd>→</kbd>) and left (<kbd>←</kbd>) key press.
 *
 * Thanks to this (phantom) caret movement the user is able to type before/after as well as at the
 * beginning/end of an attribute.
 *
 * **Note:** This helper support right–to–left (Arabic, Hebrew, etc.) content by mirroring its behavior
 * but for the sake of simplicity examples showcase only left–to–right use–cases.
 *
 * # Forward movement
 *
 * ## "Entering" an attribute:
 *
 * When this behavior is enabled for the `a` attribute and the selection is right before it
 * (at the attribute boundary), pressing the right arrow key will not move the selection but update its
 * attributes accordingly:
 *
 * * When enabled:
 *
 *   		foo{}<$text a="true">bar</$text>
 *
 *    <kbd>→</kbd>
 *
 *   		foo<$text a="true">{}bar</$text>
 *
 * * When disabled:
 *
 *   		foo{}<$text a="true">bar</$text>
 *
 *   <kbd>→</kbd>
 *
 *   		foo<$text a="true">b{}ar</$text>
 *
 *
 * ## "Leaving" an attribute:
 *
 * * When enabled:
 *
 *   		<$text a="true">bar{}</$text>baz
 *
 *    <kbd>→</kbd>
 *
 *   		<$text a="true">bar</$text>{}baz
 *
 * * When disabled:
 *
 *   		<$text a="true">bar{}</$text>baz
 *
 *   <kbd>→</kbd>
 *
 *   		<$text a="true">bar</$text>b{}az
 *
 * # Backward movement
 *
 * * When enabled:
 *
 *   		<$text a="true">bar</$text>{}baz
 *
 *    <kbd>←</kbd>
 *
 *   		<$text a="true">bar{}</$text>baz
 *
 * * When disabled:
 *
 *   		<$text a="true">bar</$text>{}baz
 *
 *   <kbd>←</kbd>
 *
 *   		<$text a="true">ba{}r</$text>b{}az
 *
 * @param {Object} options Helper options.
 * @param {module:engine/view/view~View} options.view View controller instance.
 * @param {module:engine/model/model~Model} options.model Data model instance.
 * @param {module:utils/dom/emittermixin~Emitter} options.emitter The emitter to which this behavior should be added
 * (e.g. a plugin instance).
 * @param {String} options.attribute Attribute for which this behavior will be added.
 * @param {module:utils/locale~Locale} options.locale The {@link module:core/editor/editor~Editor#locale} instance.
 */

function bindTwoStepCaretToAttribute(_ref) {
  var view = _ref.view,
      model = _ref.model,
      emitter = _ref.emitter,
      attribute = _ref.attribute,
      locale = _ref.locale;
  var twoStepCaretHandler = new bindtwostepcarettoattribute_TwoStepCaretHandler(model, emitter, attribute);
  var modelSelection = model.document.selection; // Listen to keyboard events and handle the caret movement according to the 2-step caret logic.
  //
  // Note: This listener has the "high+1" priority:
  // * "high" because of the filler logic implemented in the renderer which also engages on #keydown.
  // When the gravity is overridden the attributes of the (model) selection attributes are reset.
  // It may end up with the filler kicking in and breaking the selection.
  // * "+1" because we would like to avoid collisions with other features (like Widgets), which
  // take over the keydown events with the "high" priority. Two-step caret movement takes precedence
  // over Widgets in that matter.
  //
  // Find out more in https://github.com/ckeditor/ckeditor5-engine/issues/1301.

  emitter.listenTo(view.document, 'keydown', function (evt, data) {
    // This implementation works only for collapsed selection.
    if (!modelSelection.isCollapsed) {
      return;
    } // When user tries to expand the selection or jump over the whole word or to the beginning/end then
    // two-steps movement is not necessary.


    if (data.shiftKey || data.altKey || data.ctrlKey) {
      return;
    }

    var arrowRightPressed = data.keyCode == keyCodes.arrowright;
    var arrowLeftPressed = data.keyCode == keyCodes.arrowleft; // When neither left or right arrow has been pressed then do noting.

    if (!arrowRightPressed && !arrowLeftPressed) {
      return;
    }

    var position = modelSelection.getFirstPosition();
    var contentDirection = locale.contentLanguageDirection;
    var isMovementHandled;

    if (contentDirection === 'ltr' && arrowRightPressed || contentDirection === 'rtl' && arrowLeftPressed) {
      isMovementHandled = twoStepCaretHandler.handleForwardMovement(position, data);
    } else {
      isMovementHandled = twoStepCaretHandler.handleBackwardMovement(position, data);
    } // Stop the keydown event if the two-step caret movement handled it. Avoid collisions
    // with other features which may also take over the caret movement (e.g. Widget).


    if (isMovementHandled) {
      evt.stop();
    }
  }, {
    priority: src_priorities.get('high') + 1
  });
}
/**
 * This is a protected helper–class for {@link module:engine/utils/bindtwostepcarettoattribute}.
 * It handles the state of the 2-step caret movement for a single {@link module:engine/model/model~Model}
 * attribute upon the `keypress` in the {@link module:engine/view/view~View}.
 *
 * @protected
 */

var bindtwostepcarettoattribute_TwoStepCaretHandler = /*#__PURE__*/function () {
  /*
   * Creates two step handler instance.
   *
   * @param {module:engine/model/model~Model} model Data model instance.
   * @param {module:utils/dom/emittermixin~Emitter} emitter The emitter to which this behavior should be added
   * (e.g. a plugin instance).
   * @param {String} attribute Attribute for which the behavior will be added.
   */
  function TwoStepCaretHandler(model, emitter, attribute) {
    var _this = this;

    Object(classCallCheck["a" /* default */])(this, TwoStepCaretHandler);

    /**
     * The model instance this class instance operates on.
     *
     * @readonly
     * @member {module:engine/model/model~Model#schema}
     */
    this.model = model;
    /**
     * The Attribute this class instance operates on.
     *
     * @readonly
     * @member {String}
     */

    this.attribute = attribute;
    /**
     * A reference to the document selection.
     *
     * @private
     * @member {module:engine/model/selection~Selection}
     */

    this._modelSelection = model.document.selection;
    /**
     * The current UID of the overridden gravity, as returned by
     * {@link module:engine/model/writer~Writer#overrideSelectionGravity}.
     *
     * @private
     * @member {String}
     */

    this._overrideUid = null;
    /**
     * A flag indicating that the automatic gravity restoration for this attribute
     * should not happen upon the next
     * {@link module:engine/model/selection~Selection#event:change:range} event.
     *
     * @private
     * @member {String}
     */

    this._isNextGravityRestorationSkipped = false; // The automatic gravity restoration logic.

    emitter.listenTo(this._modelSelection, 'change:range', function (evt, data) {
      // Skipping the automatic restoration is needed if the selection should change
      // but the gravity must remain overridden afterwards. See the #handleBackwardMovement
      // to learn more.
      if (_this._isNextGravityRestorationSkipped) {
        _this._isNextGravityRestorationSkipped = false;
        return;
      } // Skip automatic restore when the gravity is not overridden — simply, there's nothing to restore
      // at this moment.


      if (!_this._isGravityOverridden) {
        return;
      } // Skip automatic restore when the change is indirect AND the selection is at the attribute boundary.
      // It means that e.g. if the change was external (collaboration) and the user had their
      // selection around the link, its gravity should remain intact in this change:range event.


      if (!data.directChange && isAtBoundary(_this._modelSelection.getFirstPosition(), attribute)) {
        return;
      }

      _this._restoreGravity();
    });
  }
  /**
   * Updates the document selection and the view according to the two–step caret movement state
   * when moving **forwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.
   *
   * @param {module:engine/model/position~Position} position The model position at the moment of the key press.
   * @param {module:engine/view/observer/domeventdata~DomEventData} data Data of the key press.
   * @returns {Boolean} `true` when the handler prevented caret movement
   */


  Object(createClass["a" /* default */])(TwoStepCaretHandler, [{
    key: "handleForwardMovement",
    value: function handleForwardMovement(position, data) {
      var attribute = this.attribute; // DON'T ENGAGE 2-SCM if gravity is already overridden. It means that we just entered
      //
      // 		<paragraph>foo<$text attribute>{}bar</$text>baz</paragraph>
      //
      // or left the attribute
      //
      // 		<paragraph>foo<$text attribute>bar</$text>{}baz</paragraph>
      //
      // and the gravity will be restored automatically.

      if (this._isGravityOverridden) {
        return;
      } // DON'T ENGAGE 2-SCM when the selection is at the beginning of the block AND already has the
      // attribute:
      // * when the selection was initially set there using the mouse,
      // * when the editor has just started
      //
      //		<paragraph><$text attribute>{}bar</$text>baz</paragraph>
      //


      if (position.isAtStart && this._hasSelectionAttribute) {
        return;
      } // ENGAGE 2-SCM when about to leave one attribute value and enter another:
      //
      // 		<paragraph><$text attribute="1">foo{}</$text><$text attribute="2">bar</$text></paragraph>
      //
      // but DON'T when already in between of them (no attribute selection):
      //
      // 		<paragraph><$text attribute="1">foo</$text>{}<$text attribute="2">bar</$text></paragraph>
      //


      if (isBetweenDifferentValues(position, attribute) && this._hasSelectionAttribute) {
        this._preventCaretMovement(data);

        this._removeSelectionAttribute();

        return true;
      } // ENGAGE 2-SCM when entering an attribute:
      //
      // 		<paragraph>foo{}<$text attribute>bar</$text>baz</paragraph>
      //


      if (isAtStartBoundary(position, attribute)) {
        this._preventCaretMovement(data);

        this._overrideGravity();

        return true;
      } // ENGAGE 2-SCM when leaving an attribute:
      //
      //		<paragraph>foo<$text attribute>bar{}</$text>baz</paragraph>
      //


      if (isAtEndBoundary(position, attribute) && this._hasSelectionAttribute) {
        this._preventCaretMovement(data);

        this._overrideGravity();

        return true;
      }
    }
    /**
     * Updates the document selection and the view according to the two–step caret movement state
     * when moving **backwards**. Executed upon `keypress` in the {@link module:engine/view/view~View}.
     *
     * @param {module:engine/model/position~Position} position The model position at the moment of the key press.
     * @param {module:engine/view/observer/domeventdata~DomEventData} data Data of the key press.
     * @returns {Boolean} `true` when the handler prevented caret movement
     */

  }, {
    key: "handleBackwardMovement",
    value: function handleBackwardMovement(position, data) {
      var attribute = this.attribute; // When the gravity is already overridden...

      if (this._isGravityOverridden) {
        // ENGAGE 2-SCM & REMOVE SELECTION ATTRIBUTE
        // when about to leave one attribute value and enter another:
        //
        // 		<paragraph><$text attribute="1">foo</$text><$text attribute="2">{}bar</$text></paragraph>
        //
        // but DON'T when already in between of them (no attribute selection):
        //
        // 		<paragraph><$text attribute="1">foo</$text>{}<$text attribute="2">bar</$text></paragraph>
        //
        if (isBetweenDifferentValues(position, attribute) && this._hasSelectionAttribute) {
          this._preventCaretMovement(data);

          this._restoreGravity();

          this._removeSelectionAttribute();

          return true;
        } // ENGAGE 2-SCM when at any boundary of the attribute:
        //
        // 		<paragraph>foo<$text attribute>bar</$text>{}baz</paragraph>
        // 		<paragraph>foo<$text attribute>{}bar</$text>baz</paragraph>
        //
        else {
            this._preventCaretMovement(data);

            this._restoreGravity(); // REMOVE SELECTION ATRIBUTE at the beginning of the block.
            // It's like restoring gravity but towards a non-existent content when
            // the gravity is overridden:
            //
            // 		<paragraph><$text attribute>{}bar</$text></paragraph>
            //
            // becomes:
            //
            // 		<paragraph>{}<$text attribute>bar</$text></paragraph>
            //


            if (position.isAtStart) {
              this._removeSelectionAttribute();
            }

            return true;
          }
      } else {
        // ENGAGE 2-SCM when between two different attribute values but selection has no attribute:
        //
        // 		<paragraph><$text attribute="1">foo</$text>{}<$text attribute="2">bar</$text></paragraph>
        //
        if (isBetweenDifferentValues(position, attribute) && !this._hasSelectionAttribute) {
          this._preventCaretMovement(data);

          this._setSelectionAttributeFromTheNodeBefore(position);

          return true;
        } // End of block boundary cases:
        //
        // 		<paragraph><$text attribute>bar{}</$text></paragraph>
        // 		<paragraph><$text attribute>bar</$text>{}</paragraph>
        //


        if (position.isAtEnd && isAtEndBoundary(position, attribute)) {
          // DON'T ENGAGE 2-SCM if the selection has the attribute already.
          // This is a common selection if set using the mouse.
          //
          // 		<paragraph><$text attribute>bar{}</$text></paragraph>
          //
          if (this._hasSelectionAttribute) {
            // DON'T ENGAGE 2-SCM if the attribute at the end of the block which has length == 1.
            // Make sure the selection will not the attribute after it moves backwards.
            //
            // 		<paragraph>foo<$text attribute>b{}</$text></paragraph>
            //
            if (isStepAfterTheAttributeBoundary(position, attribute)) {
              // Skip the automatic gravity restore upon the next selection#change:range event.
              // If not skipped, it would automatically restore the gravity, which should remain
              // overridden.
              this._skipNextAutomaticGravityRestoration();

              this._overrideGravity(); // Don't return "true" here because we didn't call _preventCaretMovement.
              // Returning here will destabilize the filler logic, which also listens to
              // keydown (and the event would be stopped).

            }

            return;
          } // ENGAGE 2-SCM if the selection has no attribute. This may happen when the user
          // left the attribute using a FORWARD 2-SCM.
          //
          // 		<paragraph><$text attribute>bar</$text>{}</paragraph>
          //
          else {
              this._preventCaretMovement(data);

              this._setSelectionAttributeFromTheNodeBefore(position);

              return true;
            }
        } // REMOVE SELECTION ATRIBUTE when restoring gravity towards a non-existent content at the
        // beginning of the block.
        //
        // 		<paragraph>{}<$text attribute>bar</$text></paragraph>
        //


        if (position.isAtStart) {
          if (this._hasSelectionAttribute) {
            this._removeSelectionAttribute();

            this._preventCaretMovement(data);

            return true;
          }

          return;
        } // DON'T ENGAGE 2-SCM when about to enter of leave an attribute.
        // We need to check if the caret is a one position before the attribute boundary:
        //
        // 		<paragraph>foo<$text attribute>b{}ar</$text>baz</paragraph>
        // 		<paragraph>foo<$text attribute>bar</$text>b{}az</paragraph>
        //


        if (isStepAfterTheAttributeBoundary(position, attribute)) {
          // Skip the automatic gravity restore upon the next selection#change:range event.
          // If not skipped, it would automatically restore the gravity, which should remain
          // overridden.
          this._skipNextAutomaticGravityRestoration();

          this._overrideGravity(); // Don't return "true" here because we didn't call _preventCaretMovement.
          // Returning here will destabilize the filler logic, which also listens to
          // keydown (and the event would be stopped).

        }
      }
    }
    /**
     * `true` when the gravity is overridden for the {@link #attribute}.
     *
     * @readonly
     * @private
     * @type {Boolean}
     */

  }, {
    key: "_overrideGravity",

    /**
     * Overrides the gravity using the {@link module:engine/model/writer~Writer model writer}
     * and stores the information about this fact in the {@link #_overrideUid}.
     *
     * A shorthand for {@link module:engine/model/writer~Writer#overrideSelectionGravity}.
     *
     * @private
     */
    value: function _overrideGravity() {
      this._overrideUid = this.model.change(function (writer) {
        return writer.overrideSelectionGravity();
      });
    }
    /**
     * Restores the gravity using the {@link module:engine/model/writer~Writer model writer}.
     *
     * A shorthand for {@link module:engine/model/writer~Writer#restoreSelectionGravity}.
     *
     * @private
     */

  }, {
    key: "_restoreGravity",
    value: function _restoreGravity() {
      var _this2 = this;

      this.model.change(function (writer) {
        writer.restoreSelectionGravity(_this2._overrideUid);
        _this2._overrideUid = null;
      });
    }
    /**
     * Prevents the caret movement in the view by calling `preventDefault` on the event data.
     *
     * @private
     */

  }, {
    key: "_preventCaretMovement",
    value: function _preventCaretMovement(data) {
      data.preventDefault();
    }
    /**
     * Removes the {@link #attribute} from the selection using using the
     * {@link module:engine/model/writer~Writer model writer}.
     *
     * @private
     */

  }, {
    key: "_removeSelectionAttribute",
    value: function _removeSelectionAttribute() {
      var _this3 = this;

      this.model.change(function (writer) {
        writer.removeSelectionAttribute(_this3.attribute);
      });
    }
    /**
     * Applies the {@link #attribute} to the current selection using using the
     * value from the node before the current position. Uses
     * the {@link module:engine/model/writer~Writer model writer}.
     *
     * @private
     * @param {module:engine/model/position~Position} position
     */

  }, {
    key: "_setSelectionAttributeFromTheNodeBefore",
    value: function _setSelectionAttributeFromTheNodeBefore(position) {
      var _this4 = this;

      var attribute = this.attribute;
      this.model.change(function (writer) {
        writer.setSelectionAttribute(_this4.attribute, position.nodeBefore.getAttribute(attribute));
      });
    }
    /**
     * Skips the next automatic selection gravity restoration upon the
     * {@link module:engine/model/selection~Selection#event:change:range} event.
     *
     * See {@link #_isNextGravityRestorationSkipped}.
     *
     * @private
     */

  }, {
    key: "_skipNextAutomaticGravityRestoration",
    value: function _skipNextAutomaticGravityRestoration() {
      this._isNextGravityRestorationSkipped = true;
    }
  }, {
    key: "_isGravityOverridden",
    get: function get() {
      return !!this._overrideUid;
    }
    /**
     * `true` when the {@link module:engine/model/selection~Selection} has the {@link #attribute}.
     *
     * @readonly
     * @private
     * @type {Boolean}
     */

  }, {
    key: "_hasSelectionAttribute",
    get: function get() {
      return this._modelSelection.hasAttribute(this.attribute);
    }
  }]);

  return TwoStepCaretHandler;
}(); // @param {module:engine/model/position~Position} position
// @param {String} attribute
// @returns {Boolean} `true` when position between the nodes sticks to the bound of text with given attribute.

function isAtBoundary(position, attribute) {
  return isAtStartBoundary(position, attribute) || isAtEndBoundary(position, attribute);
} // @param {module:engine/model/position~Position} position
// @param {String} attribute


function isAtStartBoundary(position, attribute) {
  var nodeBefore = position.nodeBefore,
      nodeAfter = position.nodeAfter;
  var isAttrBefore = nodeBefore ? nodeBefore.hasAttribute(attribute) : false;
  var isAttrAfter = nodeAfter ? nodeAfter.hasAttribute(attribute) : false;
  return isAttrAfter && (!isAttrBefore || nodeBefore.getAttribute(attribute) !== nodeAfter.getAttribute(attribute));
} // @param {module:engine/model/position~Position} position
// @param {String} attribute


function isAtEndBoundary(position, attribute) {
  var nodeBefore = position.nodeBefore,
      nodeAfter = position.nodeAfter;
  var isAttrBefore = nodeBefore ? nodeBefore.hasAttribute(attribute) : false;
  var isAttrAfter = nodeAfter ? nodeAfter.hasAttribute(attribute) : false;
  return isAttrBefore && (!isAttrAfter || nodeBefore.getAttribute(attribute) !== nodeAfter.getAttribute(attribute));
} // @param {module:engine/model/position~Position} position
// @param {String} attribute


function isBetweenDifferentValues(position, attribute) {
  var nodeBefore = position.nodeBefore,
      nodeAfter = position.nodeAfter;
  var isAttrBefore = nodeBefore ? nodeBefore.hasAttribute(attribute) : false;
  var isAttrAfter = nodeAfter ? nodeAfter.hasAttribute(attribute) : false;

  if (!isAttrAfter || !isAttrBefore) {
    return;
  }

  return nodeAfter.getAttribute(attribute) !== nodeBefore.getAttribute(attribute);
} // @param {module:engine/model/position~Position} position
// @param {String} attribute


function isStepAfterTheAttributeBoundary(position, attribute) {
  return isAtBoundary(position.getShiftedBy(-1), attribute);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-link/src/findlinkrange.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module link/findlinkrange
 */

/**
 * Returns a range containing the entire link in which the given `position` is placed.
 *
 * It can be used e.g. to get the entire range on which the `linkHref` attribute needs to be changed when having a
 * selection inside a link.
 *
 * @param {module:engine/model/position~Position} position The start position.
 * @param {String} value The `linkHref` attribute value.
 * @returns {module:engine/model/range~Range} The link range.
 */
function findLinkRange(position, value, model) {
  return model.createRange(_findBound(position, value, true, model), _findBound(position, value, false, model));
} // Walks forward or backward (depends on the `lookBack` flag), node by node, as long as they have the same `linkHref` attribute value
// and returns a position just before or after (depends on the `lookBack` flag) the last matched node.
//
// @param {module:engine/model/position~Position} position The start position.
// @param {String} value The `linkHref` attribute value.
// @param {Boolean} lookBack Whether the walk direction is forward (`false`) or backward (`true`).
// @returns {module:engine/model/position~Position} The position just before the last matched node.

function _findBound(position, value, lookBack, model) {
  // Get node before or after position (depends on `lookBack` flag).
  // When position is inside text node then start searching from text node.
  var node = position.textNode || (lookBack ? position.nodeBefore : position.nodeAfter);
  var lastNode = null;

  while (node && node.getAttribute('linkHref') == value) {
    lastNode = node;
    node = lookBack ? node.previousSibling : node.nextSibling;
  }

  return lastNode ? model.createPositionAt(lastNode, lookBack ? 'before' : 'after') : position;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-link/src/linkcommand.js










/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module link/linkcommand
 */





/**
 * The link command. It is used by the {@link module:link/link~Link link feature}.
 *
 * @extends module:core/command~Command
 */

var linkcommand_LinkCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(LinkCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(LinkCommand);

  /**
   * The value of the `'linkHref'` attribute if the start of the selection is located in a node with this attribute.
   *
   * @observable
   * @readonly
   * @member {Object|undefined} #value
   */
  function LinkCommand(editor) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, LinkCommand);

    _this = _super.call(this, editor);
    /**
     * A collection of {@link module:link/utils~ManualDecorator manual decorators}
     * corresponding to the {@link module:link/link~LinkConfig#decorators decorator configuration}.
     *
     * You can consider it a model with states of manual decorators added to the currently selected link.
     *
     * @readonly
     * @type {module:utils/collection~Collection}
     */

    _this.manualDecorators = new collection_Collection();
    return _this;
  }
  /**
   * Synchronizes the state of {@link #manualDecorators} with the currently present elements in the model.
   */


  Object(createClass["a" /* default */])(LinkCommand, [{
    key: "restoreManualDecoratorStates",
    value: function restoreManualDecoratorStates() {
      var _iterator = _createForOfIteratorHelper(this.manualDecorators),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var manualDecorator = _step.value;
          manualDecorator.value = this._getDecoratorStateFromModel(manualDecorator.id);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "refresh",
    value: function refresh() {
      var model = this.editor.model;
      var doc = model.document;
      var selectedElement = first_first(doc.selection.getSelectedBlocks()); // A check for the `LinkImage` plugin. If the selection contains an element, get values from the element.
      // Currently the selection reads attributes from text nodes only. See #7429 and #7465.

      if (selectedElement && selectedElement.is('image') && model.schema.checkAttribute('image', 'linkHref')) {
        this.value = selectedElement.getAttribute('linkHref');
        this.isEnabled = model.schema.checkAttribute(selectedElement, 'linkHref');
      } else {
        this.value = doc.selection.getAttribute('linkHref');
        this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, 'linkHref');
      }

      var _iterator2 = _createForOfIteratorHelper(this.manualDecorators),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var manualDecorator = _step2.value;
          manualDecorator.value = this._getDecoratorStateFromModel(manualDecorator.id);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    /**
     * Executes the command.
     *
     * When the selection is non-collapsed, the `linkHref` attribute will be applied to nodes inside the selection, but only to
     * those nodes where the `linkHref` attribute is allowed (disallowed nodes will be omitted).
     *
     * When the selection is collapsed and is not inside the text with the `linkHref` attribute, a
     * new {@link module:engine/model/text~Text text node} with the `linkHref` attribute will be inserted in place of the caret, but
     * only if such element is allowed in this place. The `_data` of the inserted text will equal the `href` parameter.
     * The selection will be updated to wrap the just inserted text node.
     *
     * When the selection is collapsed and inside the text with the `linkHref` attribute, the attribute value will be updated.
     *
     * # Decorators and model attribute management
     *
     * There is an optional argument to this command that applies or removes model
     * {@glink framework/guides/architecture/editing-engine#text-attributes text attributes} brought by
     * {@link module:link/utils~ManualDecorator manual link decorators}.
     *
     * Text attribute names in the model correspond to the entries in the {@link module:link/link~LinkConfig#decorators configuration}.
     * For every decorator configured, a model text attribute exists with the "link" prefix. For example, a `'linkMyDecorator'` attribute
     * corresponds to `'myDecorator'` in the configuration.
     *
     * To learn more about link decorators, check out the {@link module:link/link~LinkConfig#decorators `config.link.decorators`}
     * documentation.
     *
     * Here is how to manage decorator attributes with the link command:
     *
     *		const linkCommand = editor.commands.get( 'link' );
     *
     *		// Adding a new decorator attribute.
     *		linkCommand.execute( 'http://example.com', {
     *			linkIsExternal: true
     *		} );
     *
     *		// Removing a decorator attribute from the selection.
     *		linkCommand.execute( 'http://example.com', {
     *			linkIsExternal: false
     *		} );
     *
     *		// Adding multiple decorator attributes at the same time.
     *		linkCommand.execute( 'http://example.com', {
     *			linkIsExternal: true,
     *			linkIsDownloadable: true,
     *		} );
     *
     *		// Removing and adding decorator attributes at the same time.
     *		linkCommand.execute( 'http://example.com', {
     *			linkIsExternal: false,
     *			linkFoo: true,
     *			linkIsDownloadable: false,
     *		} );
     *
     * **Note**: If the decorator attribute name is not specified, its state remains untouched.
     *
     * **Note**: {@link module:link/unlinkcommand~UnlinkCommand#execute `UnlinkCommand#execute()`} removes all
     * decorator attributes.
     *
     * @fires execute
     * @param {String} href Link destination.
     * @param {Object} [manualDecoratorIds={}] The information about manual decorator attributes to be applied or removed upon execution.
     */

  }, {
    key: "execute",
    value: function execute(href) {
      var _this2 = this;

      var manualDecoratorIds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var model = this.editor.model;
      var selection = model.document.selection; // Stores information about manual decorators to turn them on/off when command is applied.

      var truthyManualDecorators = [];
      var falsyManualDecorators = [];

      for (var name in manualDecoratorIds) {
        if (manualDecoratorIds[name]) {
          truthyManualDecorators.push(name);
        } else {
          falsyManualDecorators.push(name);
        }
      }

      model.change(function (writer) {
        // If selection is collapsed then update selected link or insert new one at the place of caret.
        if (selection.isCollapsed) {
          var position = selection.getFirstPosition(); // When selection is inside text with `linkHref` attribute.

          if (selection.hasAttribute('linkHref')) {
            // Then update `linkHref` value.
            var linkRange = findLinkRange(position, selection.getAttribute('linkHref'), model);
            writer.setAttribute('linkHref', href, linkRange);
            truthyManualDecorators.forEach(function (item) {
              writer.setAttribute(item, true, linkRange);
            });
            falsyManualDecorators.forEach(function (item) {
              writer.removeAttribute(item, linkRange);
            }); // Put the selection at the end of the updated link.

            writer.setSelection(writer.createPositionAfter(linkRange.end.nodeBefore));
          } // If not then insert text node with `linkHref` attribute in place of caret.
          // However, since selection in collapsed, attribute value will be used as data for text node.
          // So, if `href` is empty, do not create text node.
          else if (href !== '') {
              var attributes = toMap(selection.getAttributes());
              attributes.set('linkHref', href);
              truthyManualDecorators.forEach(function (item) {
                attributes.set(item, true);
              });
              var node = writer.createText(href, attributes);
              model.insertContent(node, position); // Put the selection at the end of the inserted link.

              writer.setSelection(writer.createPositionAfter(node));
            } // Remove the `linkHref` attribute and all link decorators from the selection.
          // It stops adding a new content into the link element.


          ['linkHref'].concat(truthyManualDecorators, falsyManualDecorators).forEach(function (item) {
            writer.removeSelectionAttribute(item);
          });
        } else {
          // If selection has non-collapsed ranges, we change attribute on nodes inside those ranges
          // omitting nodes where the `linkHref` attribute is disallowed.
          var ranges = model.schema.getValidRanges(selection.getRanges(), 'linkHref'); // But for the first, check whether the `linkHref` attribute is allowed on selected blocks (e.g. the "image" element).

          var allowedRanges = [];

          var _iterator3 = _createForOfIteratorHelper(selection.getSelectedBlocks()),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var element = _step3.value;

              if (model.schema.checkAttribute(element, 'linkHref')) {
                allowedRanges.push(writer.createRangeOn(element));
              }
            } // Ranges that accept the `linkHref` attribute. Since we will iterate over `allowedRanges`, let's clone it.

          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          var rangesToUpdate = allowedRanges.slice(); // For all selection ranges we want to check whether given range is inside an element that accepts the `linkHref` attribute.
          // If so, we don't want to propagate applying the attribute to its children.

          var _iterator4 = _createForOfIteratorHelper(ranges),
              _step4;

          try {
            for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
              var range = _step4.value;

              if (_this2._isRangeToUpdate(range, allowedRanges)) {
                rangesToUpdate.push(range);
              }
            }
          } catch (err) {
            _iterator4.e(err);
          } finally {
            _iterator4.f();
          }

          var _iterator5 = _createForOfIteratorHelper(rangesToUpdate),
              _step5;

          try {
            var _loop = function _loop() {
              var range = _step5.value;
              writer.setAttribute('linkHref', href, range);
              truthyManualDecorators.forEach(function (item) {
                writer.setAttribute(item, true, range);
              });
              falsyManualDecorators.forEach(function (item) {
                writer.removeAttribute(item, range);
              });
            };

            for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
              _loop();
            }
          } catch (err) {
            _iterator5.e(err);
          } finally {
            _iterator5.f();
          }
        }
      });
    }
    /**
     * Provides information whether a decorator with a given name is present in the currently processed selection.
     *
     * @private
     * @param {String} decoratorName The name of the manual decorator used in the model
     * @returns {Boolean} The information whether a given decorator is currently present in the selection.
     */

  }, {
    key: "_getDecoratorStateFromModel",
    value: function _getDecoratorStateFromModel(decoratorName) {
      var doc = this.editor.model.document;
      return doc.selection.getAttribute(decoratorName);
    }
    /**
     * Checks whether specified `range` is inside an element that accepts the `linkHref` attribute.
     *
     * @private
     * @param {module:engine/view/range~Range} range A range to check.
     * @param {Array.<module:engine/view/range~Range>} allowedRanges An array of ranges created on elements where the attribute is accepted.
     * @returns {Boolean}
     */

  }, {
    key: "_isRangeToUpdate",
    value: function _isRangeToUpdate(range, allowedRanges) {
      var _iterator6 = _createForOfIteratorHelper(allowedRanges),
          _step6;

      try {
        for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
          var allowedRange = _step6.value;

          // A range is inside an element that will have the `linkHref` attribute. Do not modify its nodes.
          if (allowedRange.containsRange(range)) {
            return false;
          }
        }
      } catch (err) {
        _iterator6.e(err);
      } finally {
        _iterator6.f();
      }

      return true;
    }
  }]);

  return LinkCommand;
}(command_Command);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-link/src/unlinkcommand.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module link/unlinkcommand
 */



/**
 * The unlink command. It is used by the {@link module:link/link~Link link plugin}.
 *
 * @extends module:core/command~Command
 */

var unlinkcommand_UnlinkCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(UnlinkCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(UnlinkCommand);

  function UnlinkCommand() {
    Object(classCallCheck["a" /* default */])(this, UnlinkCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(UnlinkCommand, [{
    key: "refresh",

    /**
     * @inheritDoc
     */
    value: function refresh() {
      var model = this.editor.model;
      var doc = model.document;
      var selectedElement = first_first(doc.selection.getSelectedBlocks()); // A check for the `LinkImage` plugin. If the selection contains an image element, get values from the element.
      // Currently the selection reads attributes from text nodes only. See #7429 and #7465.

      if (selectedElement && selectedElement.is('image') && model.schema.checkAttribute('image', 'linkHref')) {
        this.isEnabled = model.schema.checkAttribute(selectedElement, 'linkHref');
      } else {
        this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, 'linkHref');
      }
    }
    /**
     * Executes the command.
     *
     * When the selection is collapsed, it removes the `linkHref` attribute from each node with the same `linkHref` attribute value.
     * When the selection is non-collapsed, it removes the `linkHref` attribute from each node in selected ranges.
     *
     * # Decorators
     *
     * If {@link module:link/link~LinkConfig#decorators `config.link.decorators`} is specified,
     * all configured decorators are removed together with the `linkHref` attribute.
     *
     * @fires execute
     */

  }, {
    key: "execute",
    value: function execute() {
      var editor = this.editor;
      var model = this.editor.model;
      var selection = model.document.selection;
      var linkCommand = editor.commands.get('link');
      model.change(function (writer) {
        // Get ranges to unlink.
        var rangesToUnlink = selection.isCollapsed ? [findLinkRange(selection.getFirstPosition(), selection.getAttribute('linkHref'), model)] : selection.getRanges(); // Remove `linkHref` attribute from specified ranges.

        var _iterator = _createForOfIteratorHelper(rangesToUnlink),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var range = _step.value;
            writer.removeAttribute('linkHref', range); // If there are registered custom attributes, then remove them during unlink.

            if (linkCommand) {
              var _iterator2 = _createForOfIteratorHelper(linkCommand.manualDecorators),
                  _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var manualDecorator = _step2.value;
                  writer.removeAttribute(manualDecorator.id, range);
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
    }
  }]);

  return UnlinkCommand;
}(command_Command);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-link/src/utils/automaticdecorators.js











/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md.
 */

/**
 * @module link/utils
 */

/**
 * Helper class that ties together all {@link module:link/link~LinkDecoratorAutomaticDefinition} and provides
 * a {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement downcast dispatcher} for them.
 */
var automaticdecorators_AutomaticDecorators = /*#__PURE__*/function () {
  function AutomaticDecorators() {
    Object(classCallCheck["a" /* default */])(this, AutomaticDecorators);

    /**
     * Stores the definition of {@link module:link/link~LinkDecoratorAutomaticDefinition automatic decorators}.
     * This data is used as a source for a downcast dispatcher to create a proper conversion to output data.
     *
     * @private
     * @type {Set}
     */
    this._definitions = new Set();
  }
  /**
   * Gives information about the number of decorators stored in the {@link module:link/utils~AutomaticDecorators} instance.
   *
   * @readonly
   * @protected
   * @type {Number}
   */


  Object(createClass["a" /* default */])(AutomaticDecorators, [{
    key: "add",

    /**
     * Adds automatic decorator objects or an array with them to be used during downcasting.
     *
     * @param {module:link/link~LinkDecoratorAutomaticDefinition|Array.<module:link/link~LinkDecoratorAutomaticDefinition>} item
     * A configuration object of automatic rules for decorating links. It might also be an array of such objects.
     */
    value: function add(item) {
      var _this = this;

      if (Array.isArray(item)) {
        item.forEach(function (item) {
          return _this._definitions.add(item);
        });
      } else {
        this._definitions.add(item);
      }
    }
    /**
     * Provides the conversion helper used in the {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add} method.
     *
     * @returns {Function} A dispatcher function used as conversion helper
     * in {@link module:engine/conversion/downcasthelpers~DowncastHelpers#add}.
     */

  }, {
    key: "getDispatcher",
    value: function getDispatcher() {
      var _this2 = this;

      return function (dispatcher) {
        dispatcher.on('attribute:linkHref', function (evt, data, conversionApi) {
          // There is only test as this behavior decorates links and
          // it is run before dispatcher which actually consumes this node.
          // This allows on writing own dispatcher with highest priority,
          // which blocks both native converter and this additional decoration.
          if (!conversionApi.consumable.test(data.item, 'attribute:linkHref')) {
            return;
          }

          var viewWriter = conversionApi.writer;
          var viewSelection = viewWriter.document.selection;

          var _iterator = _createForOfIteratorHelper(_this2._definitions),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var item = _step.value;
              var viewElement = viewWriter.createAttributeElement('a', item.attributes, {
                priority: 5
              });
              viewWriter.setCustomProperty('link', true, viewElement);

              if (item.callback(data.attributeNewValue)) {
                if (data.item.is('selection')) {
                  viewWriter.wrap(viewSelection.getFirstRange(), viewElement);
                } else {
                  viewWriter.wrap(conversionApi.mapper.toViewRange(data.range), viewElement);
                }
              } else {
                viewWriter.unwrap(conversionApi.mapper.toViewRange(data.range), viewElement);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }, {
          priority: 'high'
        });
      };
    }
  }, {
    key: "length",
    get: function get() {
      return this._definitions.size;
    }
  }]);

  return AutomaticDecorators;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-link/src/utils/manualdecorator.js


/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module link/utils
 */


/**
 * Helper class that stores manual decorators with observable {@link module:link/utils~ManualDecorator#value}
 * to support integration with the UI state. An instance of this class is a model with the state of individual manual decorators.
 * These decorators are kept as collections in {@link module:link/linkcommand~LinkCommand#manualDecorators}.
 *
 * @mixes module:utils/observablemixin~ObservableMixin
 */

var manualdecorator_ManualDecorator =
/**
 * Creates a new instance of {@link module:link/utils~ManualDecorator}.
 *
 * @param {Object} config
 * @param {String} config.id The name of the attribute used in the model that represents a given manual decorator.
 * For example: `'linkIsExternal'`.
 * @param {String} config.label The label used in the user interface to toggle the manual decorator.
 * @param {Object} config.attributes A set of attributes added to output data when the decorator is active for a specific link.
 * Attributes should keep the format of attributes defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
 * @param {Boolean} [config.defaultValue] Controls whether the decorator is "on" by default.
 */
function ManualDecorator(_ref) {
  var id = _ref.id,
      label = _ref.label,
      attributes = _ref.attributes,
      defaultValue = _ref.defaultValue;

  Object(classCallCheck["a" /* default */])(this, ManualDecorator);

  /**
   * An ID of a manual decorator which is the name of the attribute in the model, for example: 'linkManualDecorator0'.
   *
   * @type {String}
   */
  this.id = id;
  /**
   * The value of the current manual decorator. It reflects its state from the UI.
   *
   * @observable
   * @member {Boolean} module:link/utils~ManualDecorator#value
   */

  this.set('value');
  /**
   * The default value of manual decorator.
   *
   * @type {Boolean}
   */

  this.defaultValue = defaultValue;
  /**
   * The label used in the user interface to toggle the manual decorator.
   *
   * @type {String}
   */

  this.label = label;
  /**
   * A set of attributes added to downcasted data when the decorator is activated for a specific link.
   * Attributes should be added in a form of attributes defined in {@link module:engine/view/elementdefinition~ElementDefinition}.
   *
   * @type {Object}
   */

  this.attributes = attributes;
};


mix(manualdecorator_ManualDecorator, observablemixin);
// CONCATENATED MODULE: ./node_modules/lodash-es/_castSlice.js


/**
 * Casts `array` to a slice if it's needed.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {number} start The start position.
 * @param {number} [end=array.length] The end position.
 * @returns {Array} Returns the cast slice.
 */
function castSlice(array, start, end) {
  var length = array.length;
  end = end === undefined ? length : end;
  return (!start && end >= length) ? array : _baseSlice(array, start, end);
}

/* harmony default export */ var _castSlice = (castSlice);

// CONCATENATED MODULE: ./node_modules/lodash-es/_hasUnicode.js
/** Used to compose unicode character classes. */
var rsAstralRange = '\\ud800-\\udfff',
    rsComboMarksRange = '\\u0300-\\u036f',
    reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    rsComboSymbolsRange = '\\u20d0-\\u20ff',
    rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
    rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsZWJ = '\\u200d';

/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

/**
 * Checks if `string` contains Unicode symbols.
 *
 * @private
 * @param {string} string The string to inspect.
 * @returns {boolean} Returns `true` if a symbol is found, else `false`.
 */
function hasUnicode(string) {
  return reHasUnicode.test(string);
}

/* harmony default export */ var _hasUnicode = (hasUnicode);

// CONCATENATED MODULE: ./node_modules/lodash-es/_asciiToArray.js
/**
 * Converts an ASCII `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function asciiToArray(string) {
  return string.split('');
}

/* harmony default export */ var _asciiToArray = (asciiToArray);

// CONCATENATED MODULE: ./node_modules/lodash-es/_unicodeToArray.js
/** Used to compose unicode character classes. */
var _unicodeToArray_rsAstralRange = '\\ud800-\\udfff',
    _unicodeToArray_rsComboMarksRange = '\\u0300-\\u036f',
    _unicodeToArray_reComboHalfMarksRange = '\\ufe20-\\ufe2f',
    _unicodeToArray_rsComboSymbolsRange = '\\u20d0-\\u20ff',
    _unicodeToArray_rsComboRange = _unicodeToArray_rsComboMarksRange + _unicodeToArray_reComboHalfMarksRange + _unicodeToArray_rsComboSymbolsRange,
    _unicodeToArray_rsVarRange = '\\ufe0e\\ufe0f';

/** Used to compose unicode capture groups. */
var rsAstral = '[' + _unicodeToArray_rsAstralRange + ']',
    rsCombo = '[' + _unicodeToArray_rsComboRange + ']',
    rsFitz = '\\ud83c[\\udffb-\\udfff]',
    rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
    rsNonAstral = '[^' + _unicodeToArray_rsAstralRange + ']',
    rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
    rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
    _unicodeToArray_rsZWJ = '\\u200d';

/** Used to compose unicode regexes. */
var reOptMod = rsModifier + '?',
    rsOptVar = '[' + _unicodeToArray_rsVarRange + ']?',
    rsOptJoin = '(?:' + _unicodeToArray_rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
    rsSeq = rsOptVar + reOptMod + rsOptJoin,
    rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

/**
 * Converts a Unicode `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function unicodeToArray(string) {
  return string.match(reUnicode) || [];
}

/* harmony default export */ var _unicodeToArray = (unicodeToArray);

// CONCATENATED MODULE: ./node_modules/lodash-es/_stringToArray.js




/**
 * Converts `string` to an array.
 *
 * @private
 * @param {string} string The string to convert.
 * @returns {Array} Returns the converted array.
 */
function stringToArray(string) {
  return _hasUnicode(string)
    ? _unicodeToArray(string)
    : _asciiToArray(string);
}

/* harmony default export */ var _stringToArray = (stringToArray);

// CONCATENATED MODULE: ./node_modules/lodash-es/_createCaseFirst.js





/**
 * Creates a function like `_.lowerFirst`.
 *
 * @private
 * @param {string} methodName The name of the `String` case method to use.
 * @returns {Function} Returns the new case function.
 */
function createCaseFirst(methodName) {
  return function(string) {
    string = lodash_es_toString(string);

    var strSymbols = _hasUnicode(string)
      ? _stringToArray(string)
      : undefined;

    var chr = strSymbols
      ? strSymbols[0]
      : string.charAt(0);

    var trailing = strSymbols
      ? _castSlice(strSymbols, 1).join('')
      : string.slice(1);

    return chr[methodName]() + trailing;
  };
}

/* harmony default export */ var _createCaseFirst = (createCaseFirst);

// CONCATENATED MODULE: ./node_modules/lodash-es/upperFirst.js


/**
 * Converts the first character of `string` to upper case.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category String
 * @param {string} [string=''] The string to convert.
 * @returns {string} Returns the converted string.
 * @example
 *
 * _.upperFirst('fred');
 * // => 'Fred'
 *
 * _.upperFirst('FRED');
 * // => 'FRED'
 */
var upperFirst = _createCaseFirst('toUpperCase');

/* harmony default export */ var lodash_es_upperFirst = (upperFirst);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-link/src/utils.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module link/utils
 */

var ATTRIBUTE_WHITESPACES = /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205f\u3000]/g; // eslint-disable-line no-control-regex

var SAFE_URL = /^(?:(?:https?|ftps?|mailto):|[^a-z]|[a-z+.-]+(?:[^a-z+.:-]|$))/i;
/**
 * A keystroke used by the {@link module:link/linkui~LinkUI link UI feature}.
 */

var LINK_KEYSTROKE = 'Ctrl+K';
/**
 * Returns `true` if a given view node is the link element.
 *
 * @param {module:engine/view/node~Node} node
 * @returns {Boolean}
 */

function isLinkElement(node) {
  return node.is('attributeElement') && !!node.getCustomProperty('link');
}
/**
 * Creates link {@link module:engine/view/attributeelement~AttributeElement} with the provided `href` attribute.
 *
 * @param {String} href
 * @returns {module:engine/view/attributeelement~AttributeElement}
 */

function createLinkElement(href, writer) {
  // Priority 5 - https://github.com/ckeditor/ckeditor5-link/issues/121.
  var linkElement = writer.createAttributeElement('a', {
    href: href
  }, {
    priority: 5
  });
  writer.setCustomProperty('link', true, linkElement);
  return linkElement;
}
/**
 * Returns a safe URL based on a given value.
 *
 * A URL is considered safe if it is safe for the user (does not contain any malicious code).
 *
 * If a URL is considered unsafe, a simple `"#"` is returned.
 *
 * @protected
 * @param {*} url
 * @returns {String} Safe URL.
 */

function ensureSafeUrl(url) {
  url = String(url);
  return isSafeUrl(url) ? url : '#';
} // Checks whether the given URL is safe for the user (does not contain any malicious code).
//
// @param {String} url URL to check.

function isSafeUrl(url) {
  var normalizedUrl = url.replace(ATTRIBUTE_WHITESPACES, '');
  return normalizedUrl.match(SAFE_URL);
}
/**
 * Returns the {@link module:link/link~LinkConfig#decorators `config.link.decorators`} configuration processed
 * to respect the locale of the editor, i.e. to display the {@link module:link/link~LinkDecoratorManualDefinition label}
 * in the correct language.
 *
 * **Note**: Only the few most commonly used labels are translated automatically. Other labels should be manually
 * translated in the {@link module:link/link~LinkConfig#decorators `config.link.decorators`} configuration.
 *
 * @param {module:utils/locale~Locale#t} t shorthand for {@link module:utils/locale~Locale#t Locale#t}
 * @param {Array.<module:link/link~LinkDecoratorDefinition>} The decorator reference
 * where the label values should be localized.
 * @returns {Array.<module:link/link~LinkDecoratorDefinition>}
 */


function getLocalizedDecorators(t, decorators) {
  var localizedDecoratorsLabels = {
    'Open in a new tab': t('Open in a new tab'),
    'Downloadable': t('Downloadable')
  };
  decorators.forEach(function (decorator) {
    if (decorator.label && localizedDecoratorsLabels[decorator.label]) {
      decorator.label = localizedDecoratorsLabels[decorator.label];
    }

    return decorator;
  });
  return decorators;
}
/**
 * Converts an object with defined decorators to a normalized array of decorators. The `id` key is added for each decorator and
 * is used as the attribute's name in the model.
 *
 * @param {Object.<String, module:link/link~LinkDecoratorDefinition>} decorators
 * @returns {Array.<module:link/link~LinkDecoratorDefinition>}
 */

function normalizeDecorators(decorators) {
  var retArray = [];

  if (decorators) {
    for (var _i = 0, _Object$entries = Object.entries(decorators); _i < _Object$entries.length; _i++) {
      var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2),
          key = _Object$entries$_i[0],
          value = _Object$entries$_i[1];

      var decorator = Object.assign({}, value, {
        id: "link".concat(lodash_es_upperFirst(key))
      });
      retArray.push(decorator);
    }
  }

  return retArray;
}
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-link/theme/link.css
var theme_link = __webpack_require__("356b");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-link/src/linkediting.js

















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module link/linkediting
 */










var HIGHLIGHT_CLASS = 'ck-link_selected';
var DECORATOR_AUTOMATIC = 'automatic';
var DECORATOR_MANUAL = 'manual';
var EXTERNAL_LINKS_REGEXP = /^(https?:)?\/\//;
/**
 * The link engine feature.
 *
 * It introduces the `linkHref="url"` attribute in the model which renders to the view as a `<a href="url">` element
 * as well as `'link'` and `'unlink'` commands.
 *
 * @extends module:core/plugin~Plugin
 */

var linkediting_LinkEditing = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(LinkEditing, _Plugin);

  var _super = Object(createSuper["a" /* default */])(LinkEditing);

  Object(createClass["a" /* default */])(LinkEditing, null, [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'LinkEditing';
    }
    /**
     * @inheritDoc
     */

  }]);

  function LinkEditing(editor) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, LinkEditing);

    _this = _super.call(this, editor);
    editor.config.define('link', {
      addTargetToExternalLinks: false
    });
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(LinkEditing, [{
    key: "init",
    value: function init() {
      var editor = this.editor;
      var locale = editor.locale; // Allow link attribute on all inline nodes.

      editor.model.schema.extend('$text', {
        allowAttributes: 'linkHref'
      });
      editor.conversion.for('dataDowncast').attributeToElement({
        model: 'linkHref',
        view: createLinkElement
      });
      editor.conversion.for('editingDowncast').attributeToElement({
        model: 'linkHref',
        view: function view(href, writer) {
          return createLinkElement(ensureSafeUrl(href), writer);
        }
      });
      editor.conversion.for('upcast').elementToAttribute({
        view: {
          name: 'a',
          attributes: {
            href: true
          }
        },
        model: {
          key: 'linkHref',
          value: function value(viewElement) {
            return viewElement.getAttribute('href');
          }
        }
      }); // Create linking commands.

      editor.commands.add('link', new linkcommand_LinkCommand(editor));
      editor.commands.add('unlink', new unlinkcommand_UnlinkCommand(editor));
      var linkDecorators = getLocalizedDecorators(editor.t, normalizeDecorators(editor.config.get('link.decorators')));

      this._enableAutomaticDecorators(linkDecorators.filter(function (item) {
        return item.mode === DECORATOR_AUTOMATIC;
      }));

      this._enableManualDecorators(linkDecorators.filter(function (item) {
        return item.mode === DECORATOR_MANUAL;
      })); // Enable two-step caret movement for `linkHref` attribute.


      bindTwoStepCaretToAttribute({
        view: editor.editing.view,
        model: editor.model,
        emitter: this,
        attribute: 'linkHref',
        locale: locale
      }); // Setup highlight over selected link.

      this._setupLinkHighlight(); // Change the attributes of the selection in certain situations after the link was inserted into the document.


      this._enableInsertContentSelectionAttributesFixer(); // Handle a click at the beginning/end of a link element.


      this._enableClickingAfterLink();
    }
    /**
     * Processes an array of configured {@link module:link/link~LinkDecoratorAutomaticDefinition automatic decorators}
     * and registers a {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher downcast dispatcher}
     * for each one of them. Downcast dispatchers are obtained using the
     * {@link module:link/utils~AutomaticDecorators#getDispatcher} method.
     *
     * **Note**: This method also activates the automatic external link decorator if enabled with
     * {@link module:link/link~LinkConfig#addTargetToExternalLinks `config.link.addTargetToExternalLinks`}.
     *
     * @private
     * @param {Array.<module:link/link~LinkDecoratorAutomaticDefinition>} automaticDecoratorDefinitions
     */

  }, {
    key: "_enableAutomaticDecorators",
    value: function _enableAutomaticDecorators(automaticDecoratorDefinitions) {
      var editor = this.editor;
      var automaticDecorators = new automaticdecorators_AutomaticDecorators(); // Adds a default decorator for external links.

      if (editor.config.get('link.addTargetToExternalLinks')) {
        automaticDecorators.add({
          id: 'linkIsExternal',
          mode: DECORATOR_AUTOMATIC,
          callback: function callback(url) {
            return EXTERNAL_LINKS_REGEXP.test(url);
          },
          attributes: {
            target: '_blank',
            rel: 'noopener noreferrer'
          }
        });
      }

      automaticDecorators.add(automaticDecoratorDefinitions);

      if (automaticDecorators.length) {
        editor.conversion.for('downcast').add(automaticDecorators.getDispatcher());
      }
    }
    /**
     * Processes an array of configured {@link module:link/link~LinkDecoratorManualDefinition manual decorators},
     * transforms them into {@link module:link/utils~ManualDecorator} instances and stores them in the
     * {@link module:link/linkcommand~LinkCommand#manualDecorators} collection (a model for manual decorators state).
     *
     * Also registers an {@link module:engine/conversion/downcasthelpers~DowncastHelpers#attributeToElement attribute-to-element}
     * converter for each manual decorator and extends the {@link module:engine/model/schema~Schema model's schema}
     * with adequate model attributes.
     *
     * @private
     * @param {Array.<module:link/link~LinkDecoratorManualDefinition>} manualDecoratorDefinitions
     */

  }, {
    key: "_enableManualDecorators",
    value: function _enableManualDecorators(manualDecoratorDefinitions) {
      if (!manualDecoratorDefinitions.length) {
        return;
      }

      var editor = this.editor;
      var command = editor.commands.get('link');
      var manualDecorators = command.manualDecorators;
      manualDecoratorDefinitions.forEach(function (decorator) {
        editor.model.schema.extend('$text', {
          allowAttributes: decorator.id
        }); // Keeps reference to manual decorator to decode its name to attributes during downcast.

        manualDecorators.add(new manualdecorator_ManualDecorator(decorator));
        editor.conversion.for('downcast').attributeToElement({
          model: decorator.id,
          view: function view(manualDecoratorName, writer) {
            if (manualDecoratorName) {
              var attributes = manualDecorators.get(decorator.id).attributes;
              var element = writer.createAttributeElement('a', attributes, {
                priority: 5
              });
              writer.setCustomProperty('link', true, element);
              return element;
            }
          }
        });
        editor.conversion.for('upcast').elementToAttribute({
          view: {
            name: 'a',
            attributes: manualDecorators.get(decorator.id).attributes
          },
          model: {
            key: decorator.id
          }
        });
      });
    }
    /**
     * Adds a visual highlight style to a link in which the selection is anchored.
     * Together with two-step caret movement, they indicate that the user is typing inside the link.
     *
     * Highlight is turned on by adding the `.ck-link_selected` class to the link in the view:
     *
     * * The class is removed before the conversion has started, as callbacks added with the `'highest'` priority
     * to {@link module:engine/conversion/downcastdispatcher~DowncastDispatcher} events.
     * * The class is added in the view post fixer, after other changes in the model tree were converted to the view.
     *
     * This way, adding and removing the highlight does not interfere with conversion.
     *
     * @private
     */

  }, {
    key: "_setupLinkHighlight",
    value: function _setupLinkHighlight() {
      var editor = this.editor;
      var view = editor.editing.view;
      var highlightedLinks = new Set(); // Adding the class.

      view.document.registerPostFixer(function (writer) {
        var selection = editor.model.document.selection;
        var changed = false;

        if (selection.hasAttribute('linkHref')) {
          var modelRange = findLinkRange(selection.getFirstPosition(), selection.getAttribute('linkHref'), editor.model);
          var viewRange = editor.editing.mapper.toViewRange(modelRange); // There might be multiple `a` elements in the `viewRange`, for example, when the `a` element is
          // broken by a UIElement.

          var _iterator = _createForOfIteratorHelper(viewRange.getItems()),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var item = _step.value;

              if (item.is('a') && !item.hasClass(HIGHLIGHT_CLASS)) {
                writer.addClass(HIGHLIGHT_CLASS, item);
                highlightedLinks.add(item);
                changed = true;
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        return changed;
      }); // Removing the class.

      editor.conversion.for('editingDowncast').add(function (dispatcher) {
        // Make sure the highlight is removed on every possible event, before conversion is started.
        dispatcher.on('insert', removeHighlight, {
          priority: 'highest'
        });
        dispatcher.on('remove', removeHighlight, {
          priority: 'highest'
        });
        dispatcher.on('attribute', removeHighlight, {
          priority: 'highest'
        });
        dispatcher.on('selection', removeHighlight, {
          priority: 'highest'
        });

        function removeHighlight() {
          view.change(function (writer) {
            var _iterator2 = _createForOfIteratorHelper(highlightedLinks.values()),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var item = _step2.value;
                writer.removeClass(HIGHLIGHT_CLASS, item);
                highlightedLinks.delete(item);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          });
        }
      });
    }
    /**
     * Starts listening to {@link module:engine/model/model~Model#event:insertContent} and corrects the model
     * selection attributes if the selection is at the end of a link after inserting the content.
     *
     * The purpose of this action is to improve the overall UX because the user is no longer "trapped" by the
     * `linkHref` attribute of the selection and they can type a "clean" (`linkHref`–less) text right away.
     *
     * See https://github.com/ckeditor/ckeditor5/issues/6053.
     *
     * @private
     */

  }, {
    key: "_enableInsertContentSelectionAttributesFixer",
    value: function _enableInsertContentSelectionAttributesFixer() {
      var editor = this.editor;
      var model = editor.model;
      var selection = model.document.selection;
      model.on('insertContent', function () {
        var nodeBefore = selection.anchor.nodeBefore;
        var nodeAfter = selection.anchor.nodeAfter; // NOTE: ↰ and ↱ represent the gravity of the selection.
        // The only truly valid case is:
        //
        //		                                 ↰
        //		...<$text linkHref="foo">INSERTED[]</$text>
        //
        // If the selection is not "trapped" by the `linkHref` attribute after inserting, there's nothing
        // to fix there.

        if (!selection.hasAttribute('linkHref')) {
          return;
        } // Filter out the following case where a link with the same href (e.g. <a href="foo">INSERTED</a>) is inserted
        // in the middle of an existing link:
        //
        // Before insertion:
        //		                       ↰
        //		<$text linkHref="foo">l[]ink</$text>
        //
        // Expected after insertion:
        //		                               ↰
        //		<$text linkHref="foo">lINSERTED[]ink</$text>
        //


        if (!nodeBefore) {
          return;
        } // Filter out the following case where the selection has the "linkHref" attribute because the
        // gravity is overridden and some text with another attribute (e.g. <b>INSERTED</b>) is inserted:
        //
        // Before insertion:
        //
        //		                       ↱
        //		<$text linkHref="foo">[]link</$text>
        //
        // Expected after insertion:
        //
        //		                                                          ↱
        //		<$text bold="true">INSERTED</$text><$text linkHref="foo">[]link</$text>
        //


        if (!nodeBefore.hasAttribute('linkHref')) {
          return;
        } // Filter out the following case where a link is a inserted in the middle (or before) another link
        // (different URLs, so they will not merge). In this (let's say weird) case, we can leave the selection
        // attributes as they are because the user will end up writing in one link or another anyway.
        //
        // Before insertion:
        //
        //		                       ↰
        //		<$text linkHref="foo">l[]ink</$text>
        //
        // Expected after insertion:
        //
        //		                                                             ↰
        //		<$text linkHref="foo">l</$text><$text linkHref="bar">INSERTED[]</$text><$text linkHref="foo">ink</$text>
        //


        if (nodeAfter && nodeAfter.hasAttribute('linkHref')) {
          return;
        } // Make the selection free of link-related model attributes.
        // All link-related model attributes start with "link". That includes not only "linkHref"
        // but also all decorator attributes (they have dynamic names).


        model.change(function (writer) {
          _toConsumableArray(model.document.selection.getAttributeKeys()).filter(function (name) {
            return name.startsWith('link');
          }).forEach(function (name) {
            return writer.removeSelectionAttribute(name);
          });
        });
      }, {
        priority: 'low'
      });
    }
    /**
     * Starts listening to {@link module:engine/view/document~Document#event:mousedown} and
     * {@link module:engine/view/document~Document#event:selectionChange} and puts the selection before/after a link node
     * if clicked at the beginning/ending of the link.
     *
     * The purpose of this action is to allow typing around the link node directly after a click.
     *
     * See https://github.com/ckeditor/ckeditor5/issues/1016.
     *
     * @private
     */

  }, {
    key: "_enableClickingAfterLink",
    value: function _enableClickingAfterLink() {
      var editor = this.editor;
      editor.editing.view.addObserver(mouseobserver_MouseObserver);
      var clicked = false; // Detect the click.

      this.listenTo(editor.editing.view.document, 'mousedown', function () {
        clicked = true;
      }); // When the selection has changed...

      this.listenTo(editor.editing.view.document, 'selectionChange', function () {
        if (!clicked) {
          return;
        } // ...and it was caused by the click...


        clicked = false;
        var selection = editor.model.document.selection; // ...and no text is selected...

        if (!selection.isCollapsed) {
          return;
        } // ...and clicked text is the link...


        if (!selection.hasAttribute('linkHref')) {
          return;
        }

        var position = selection.getFirstPosition();
        var linkRange = findLinkRange(position, selection.getAttribute('linkHref'), editor.model); // ...check whether clicked start/end boundary of the link.
        // If so, remove the `linkHref` attribute.

        if (position.isTouching(linkRange.start) || position.isTouching(linkRange.end)) {
          editor.model.change(function (writer) {
            writer.removeSelectionAttribute('linkHref');

            var _iterator3 = _createForOfIteratorHelper(editor.commands.get('link').manualDecorators),
                _step3;

            try {
              for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                var manualDecorator = _step3.value;
                writer.removeSelectionAttribute(manualDecorator.id);
              }
            } catch (err) {
              _iterator3.e(err);
            } finally {
              _iterator3.f();
            }
          });
        }
      });
    }
  }]);

  return LinkEditing;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/notification/notification.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/notification/notification
 */

/* globals window */

/**
 * The Notification plugin.
 *
 * This plugin sends a few types of notifications: `success`, `info` and `warning`. The notifications need to be
 * handled and displayed by a plugin responsible for showing the UI of the notifications. Using this plugin for dispatching
 * notifications makes it possible to switch the notifications UI.
 *
 * Note that every unhandled and not stopped `warning` notification will be displayed as a system alert.
 * See {@link module:ui/notification/notification~Notification#showWarning}.
 *
 * @extends module:core/contextplugin~ContextPlugin
 */

var notification_Notification = /*#__PURE__*/function (_ContextPlugin) {
  Object(inherits["a" /* default */])(Notification, _ContextPlugin);

  var _super = Object(createSuper["a" /* default */])(Notification);

  function Notification() {
    Object(classCallCheck["a" /* default */])(this, Notification);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Notification, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      // Each unhandled and not stopped `show:warning` event is displayed as a system alert.
      this.on('show:warning', function (evt, data) {
        window.alert(data.message); // eslint-disable-line no-alert
      }, {
        priority: 'lowest'
      });
    }
    /**
     * Shows a success notification.
     *
     * By default, it fires the {@link #event:show:success `show:success` event} with the given `data`. The event namespace can be extended
     * using the `data.namespace` option. For example:
     *
     * 		showSuccess( 'Image is uploaded.', {
     * 			namespace: 'upload:image'
     * 		} );
     *
     * will fire the `show:success:upload:image` event.
     *
     * You can provide the title of the notification:
     *
     *		showSuccess( 'Image is uploaded.', {
     *			title: 'Image upload success'
     *		} );
     *
     * @param {String} message The content of the notification.
     * @param {Object} [data={}] Additional data.
     * @param {String} [data.namespace] Additional event namespace.
     * @param {String} [data.title] The title of the notification.
     */

  }, {
    key: "showSuccess",
    value: function showSuccess(message) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._showNotification({
        message: message,
        type: 'success',
        namespace: data.namespace,
        title: data.title
      });
    }
    /**
     * Shows an information notification.
     *
     * By default, it fires the {@link #event:show:info `show:info` event} with the given `data`. The event namespace can be extended
     * using the `data.namespace` option. For example:
     *
     * 		showInfo( 'Editor is offline.', {
     * 			namespace: 'editor:status'
     * 		} );
     *
     * will fire the `show:info:editor:status` event.
     *
     * You can provide the title of the notification:
     *
     *		showInfo( 'Editor is offline.', {
     *			title: 'Network information'
     *		} );
     *
     * @param {String} message The content of the notification.
     * @param {Object} [data={}] Additional data.
     * @param {String} [data.namespace] Additional event namespace.
     * @param {String} [data.title] The title of the notification.
     */

  }, {
    key: "showInfo",
    value: function showInfo(message) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._showNotification({
        message: message,
        type: 'info',
        namespace: data.namespace,
        title: data.title
      });
    }
    /**
     * Shows a warning notification.
     *
     * By default, it fires the {@link #event:show:warning `show:warning` event}
     * with the given `data`. The event namespace can be extended using the `data.namespace` option. For example:
     *
     * 		showWarning( 'Image upload error.', {
     * 			namespace: 'upload:image'
     * 		} );
     *
     * will fire the `show:warning:upload:image` event.
     *
     * You can provide the title of the notification:
     *
     *		showWarning( 'Image upload error.', {
     *			title: 'Upload failed'
     *		} );
     *
     * Note that each unhandled and not stopped `warning` notification will be displayed as a system alert.
     * The plugin responsible for displaying warnings should `stop()` the event to prevent displaying it as an alert:
     *
     * 		notifications.on( 'show:warning', ( evt, data ) => {
     * 			// Do something with the data.
     *
     * 			// Stop this event to prevent displaying it as an alert.
     * 			evt.stop();
     * 		} );
     *
     * You can attach many listeners to the same event and `stop()` this event in a listener with a low priority:
     *
     * 		notifications.on( 'show:warning', ( evt, data ) => {
     * 			// Show the warning in the UI, but do not stop it.
     * 		} );
     *
     * 		notifications.on( 'show:warning', ( evt, data ) => {
     * 			// Log the warning to some error tracker.
     *
     * 			// Stop this event to prevent displaying it as an alert.
     * 			evt.stop();
     * 		}, { priority: 'low' } );
     *
     * @param {String} message The content of the notification.
     * @param {Object} [data={}] Additional data.
     * @param {String} [data.namespace] Additional event namespace.
     * @param {String} [data.title] The title of the notification.
     */

  }, {
    key: "showWarning",
    value: function showWarning(message) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      this._showNotification({
        message: message,
        type: 'warning',
        namespace: data.namespace,
        title: data.title
      });
    }
    /**
     * Fires the `show` event with the specified type, namespace and message.
     *
     * @private
     * @param {Object} data The message data.
     * @param {String} data.message The content of the notification.
     * @param {'success'|'info'|'warning'} data.type The type of the message.
     * @param {String} [data.namespace] Additional event namespace.
     * @param {String} [data.title=''] The title of the notification.
     */

  }, {
    key: "_showNotification",
    value: function _showNotification(data) {
      var event = "show:".concat(data.type) + (data.namespace ? ":".concat(data.namespace) : '');
      this.fire(event, {
        message: data.message,
        type: data.type,
        title: data.title || ''
      });
    }
    /**
     * Fired when one of the `showSuccess()`, `showInfo()`, `showWarning()` methods is called.
     *
     * @event show
     * @param {Object} data The notification data.
     * @param {String} data.message The content of the notification.
     * @param {String} data.title The title of the notification.
     * @param {'success'|'info'|'warning'} data.type The type of the notification.
     */

    /**
     * Fired when the `showSuccess()` method is called.
     *
     * @event show:success
     * @param {Object} data The notification data.
     * @param {String} data.message The content of the notification.
     * @param {String} data.title The title of the notification.
     * @param {'success'} data.type The type of the notification.
     */

    /**
     * Fired when the `showInfo()` method is called.
     *
     * @event show:info
     * @param {Object} data The notification data.
     * @param {String} data.message The content of the notification.
     * @param {String} data.title The title of the notification.
     * @param {'info'} data.type The type of the notification.
     */

    /**
     * Fired when the `showWarning()` method is called.
     *
     * When this event is not handled or stopped by `event.stop()`, the `data.message` of this event will
     * be automatically displayed as a system alert.
     *
     * @event show:warning
     * @param {Object} data The notification data.
     * @param {String} data.message The content of the notification.
     * @param {String} data.title The title of the notification.
     * @param {'warning'} data.type The type of the notification.
     */

  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'Notification';
    }
  }]);

  return Notification;
}(contextplugin_ContextPlugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ckfinder/src/ckfindercommand.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* global window */

/**
 * @module ckfinder/ckfindercommand
 */


/**
 * The CKFinder command. It is used by the {@link module:ckfinder/ckfinderediting~CKFinderEditing CKFinder editing feature}
 * to open the CKFinder file manager to insert an image or a link to a file into the editor content.
 *
 *		editor.execute( 'ckfinder' );
 *
 * **Note:** This command uses other features to perform tasks:
 * - To insert images the {@link module:image/image/imageinsertcommand~ImageInsertCommand 'imageInsert'} command
 * from the {@link module:image/image~Image Image feature}.
 * - To insert links to files the {@link module:link/linkcommand~LinkCommand 'link'} command
 * from the {@link module:link/link~Link Link feature}.
 *
 * @extends module:core/command~Command
 */

var ckfindercommand_CKFinderCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(CKFinderCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(CKFinderCommand);

  /**
   * @inheritDoc
   */
  function CKFinderCommand(editor) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, CKFinderCommand);

    _this = _super.call(this, editor); // Remove default document listener to lower its priority.

    _this.stopListening(_this.editor.model.document, 'change'); // Lower this command listener priority to be sure that refresh() will be called after link & image refresh.


    _this.listenTo(_this.editor.model.document, 'change', function () {
      return _this.refresh();
    }, {
      priority: 'low'
    });

    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(CKFinderCommand, [{
    key: "refresh",
    value: function refresh() {
      var imageCommand = this.editor.commands.get('imageInsert');
      var linkCommand = this.editor.commands.get('link'); // The CKFinder command is enabled when one of image or link command is enabled.

      this.isEnabled = imageCommand.isEnabled || linkCommand.isEnabled;
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "execute",
    value: function execute() {
      var editor = this.editor;
      var openerMethod = this.editor.config.get('ckfinder.openerMethod') || 'modal';

      if (openerMethod != 'popup' && openerMethod != 'modal') {
        throw new ckeditorerror["b" /* default */]('ckfinder-unknown-openerMethod: The openerMethod config option must by "popup" or "modal".', editor);
      }

      var options = this.editor.config.get('ckfinder.options') || {};
      options.chooseFiles = true; // Cache the user-defined onInit method

      var originalOnInit = options.onInit; // Pass the lang code to the CKFinder if not defined by user.

      if (!options.language) {
        options.language = editor.locale.uiLanguage;
      } // The onInit method allows to extend CKFinder's behavior. It is used to attach event listeners to file choosing related events.


      options.onInit = function (finder) {
        // Call original options.onInit if it was defined by user.
        if (originalOnInit) {
          originalOnInit(finder);
        }

        finder.on('files:choose', function (evt) {
          var files = evt.data.files.toArray(); // Insert links

          var links = files.filter(function (file) {
            return !file.isImage();
          });
          var images = files.filter(function (file) {
            return file.isImage();
          });

          var _iterator = _createForOfIteratorHelper(links),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var linkFile = _step.value;
              editor.execute('link', linkFile.getUrl());
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          var imagesUrls = [];

          var _iterator2 = _createForOfIteratorHelper(images),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var image = _step2.value;
              var url = image.getUrl();
              imagesUrls.push(url ? url : finder.request('file:getProxyUrl', {
                file: image
              }));
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          if (imagesUrls.length) {
            insertImages(editor, imagesUrls);
          }
        });
        finder.on('file:choose:resizedImage', function (evt) {
          var resizedUrl = evt.data.resizedUrl;

          if (!resizedUrl) {
            var notification = editor.plugins.get('Notification');
            var t = editor.locale.t;
            notification.showWarning(t('Could not obtain resized image URL.'), {
              title: t('Selecting resized image failed'),
              namespace: 'ckfinder'
            });
            return;
          }

          insertImages(editor, [resizedUrl]);
        });
      };

      window.CKFinder[openerMethod](options);
    }
  }]);

  return CKFinderCommand;
}(command_Command);



function insertImages(editor, urls) {
  var imageCommand = editor.commands.get('imageInsert'); // Check if inserting an image is actually possible - it might be possible to only insert a link.

  if (!imageCommand.isEnabled) {
    var notification = editor.plugins.get('Notification');
    var t = editor.locale.t;
    notification.showWarning(t('Could not insert image at the current position.'), {
      title: t('Inserting image failed'),
      namespace: 'ckfinder'
    });
    return;
  }

  editor.execute('imageInsert', {
    source: urls
  });
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ckfinder/src/ckfinderediting.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ckfinder/ckfinderediting
 */





/**
 * The CKFinder editing feature. It introduces the {@link module:ckfinder/ckfindercommand~CKFinderCommand CKFinder command}.
 *
 * @extends module:core/plugin~Plugin
 */

var ckfinderediting_CKFinderEditing = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(CKFinderEditing, _Plugin);

  var _super = Object(createSuper["a" /* default */])(CKFinderEditing);

  function CKFinderEditing() {
    Object(classCallCheck["a" /* default */])(this, CKFinderEditing);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(CKFinderEditing, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var editor = this.editor;
      editor.commands.add('ckfinder', new ckfindercommand_CKFinderCommand(editor));
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'CKFinderEditing';
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "requires",
    get: function get() {
      return [notification_Notification, imageediting_ImageEditing, linkediting_LinkEditing];
    }
  }]);

  return CKFinderEditing;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ckfinder/src/ckfinder.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ckfinder/ckfinder
 */




/**
 * The CKFinder feature, a bridge between the CKEditor 5 WYSIWYG editor and the
 * [CKFinder](https://ckeditor.com/ckfinder) file manager and uploader.
 *
 * This is a "glue" plugin which enables:
 *
 * * {@link module:ckfinder/ckfinderediting~CKFinderEditing},
 * * {@link module:ckfinder/ckfinderui~CKFinderUI},
 * * {@link module:adapter-ckfinder/uploadadapter~CKFinderUploadAdapter}.
 *
 * See the {@glink features/image-upload/ckfinder "CKFinder integration" guide} to learn how to configure
 * and use this feature.
 *
 * Check out the {@glink features/image-upload/image-upload comprehensive "Image upload" guide} to learn about
 * other ways to upload images into CKEditor 5.
 *
 * @extends module:core/plugin~Plugin
 */

var ckfinder_CKFinder = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(CKFinder, _Plugin);

  var _super = Object(createSuper["a" /* default */])(CKFinder);

  function CKFinder() {
    Object(classCallCheck["a" /* default */])(this, CKFinder);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(CKFinder, null, [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'CKFinder';
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "requires",
    get: function get() {
      return [ckfinderediting_CKFinderEditing, ckfinderui_CKFinderUI, uploadadapter_CKFinderUploadAdapter];
    }
  }]);

  return CKFinder;
}(plugin_Plugin);
/**
 * The configuration of the {@link module:ckfinder/ckfinder~CKFinder CKFinder feature}.
 *
 * Read more in {@link module:ckfinder/ckfinder~CKFinderConfig}.
 *
 * @member {module:ckfinder/ckfinder~CKFinderConfig} module:core/editor/editorconfig~EditorConfig#ckfinder
 */

/**
 * The configuration of the {@link module:ckfinder/ckfinder~CKFinder CKFinder feature}
 * and its {@link module:adapter-ckfinder/uploadadapter~CKFinderUploadAdapter upload adapter}.
 *
 *		ClassicEditor
 *			.create( editorElement, {
 *				ckfinder: {
 *					options: {
 *						resourceType: 'Images'
 *					}
 *				}
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * See {@link module:core/editor/editorconfig~EditorConfig all editor options}.
 *
 * @interface CKFinderConfig
 */

/**
 * The configuration options passed to the CKFinder file manager instance.
 *
 * Check the file manager [documentation](https://ckeditor.com/docs/ckfinder/ckfinder3/#!/api/CKFinder.Config-cfg-language)
 * for the complete list of options.
 *
 * @member {Object} module:ckfinder/ckfinder~CKFinderConfig#options
 */

/**
 * The type of the CKFinder opener method.
 *
 * Supported types are:
 *
 * * `'modal'` &ndash; Opens CKFinder in a modal,
 * * `'popup'` &ndash; Opens CKFinder in a new "pop-up" window.
 *
 * Defaults to `'modal'`.
 *
 * @member {String} module:ckfinder/ckfinder~CKFinderConfig#openerMethod
 */

/**
 * The path (URL) to the connector which handles the file upload in CKFinder file manager.
 * When specified, it enables the automatic upload of resources such as images inserted into the content.
 *
 * For instance, to use CKFinder's
 * [quick upload](https://ckeditor.com/docs/ckfinder/ckfinder3-php/commands.html#command_quick_upload)
 * command, your can use the following (or similar) path:
 *
 *		ClassicEditor
 *			.create( editorElement, {
 *				ckfinder: {
 *					uploadUrl: '/ckfinder/core/connector/php/connector.php?command=QuickUpload&type=Files&responseType=json'
 *				}
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * Used by the {@link module:adapter-ckfinder/uploadadapter~CKFinderUploadAdapter upload adapter}.
 *
 * @member {String} module:ckfinder/ckfinder~CKFinderConfig#uploadUrl
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor-cloud-services-core/src/uploadgateway/fileuploader.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module cloud-services-core/uploadgateway/fileuploader
 */

/* globals XMLHttpRequest, FormData, Blob, atob */





const BASE64_HEADER_REG_EXP = /^data:(\S*?);base64,/;

/**
 * FileUploader class used to upload single file.
 */
class fileuploader_FileUploader {
	/**
	 * Creates `FileUploader` instance.
	 *
	 * @param {Blob|String} fileOrData A blob object or a data string encoded with Base64.
	 * @param {module:cloud-services-core/token~Token} token Token used for authentication.
	 * @param {String} apiAddress API address.
	 */
	constructor( fileOrData, token, apiAddress ) {
		if ( !fileOrData ) {
			/**
			 * File must be provided as the first argument.
			 *
			 * @error fileuploader-missing-file
			 */
			throw new ckeditorerror["b" /* default */]( 'fileuploader-missing-file: File must be provided as the first argument', null );
		}

		if ( !token ) {
			/**
			 * Token must be provided as the second argument.
			 *
			 * @error fileuploader-missing-token
			 */
			throw new ckeditorerror["b" /* default */]( 'fileuploader-missing-token: Token must be provided as the second argument.', null );
		}

		if ( !apiAddress ) {
			/**
			 * Api address must be provided as the third argument.
			 *
			 * @error fileuploader-missing-api-address
			 */
			throw new ckeditorerror["b" /* default */]( 'fileuploader-missing-api-address: Api address must be provided as the third argument.', null );
		}

		/**
		 * A file that is being uploaded.
		 *
		 * @type {Blob}
		 */
		this.file = _isBase64( fileOrData ) ? _base64ToBlob( fileOrData ) : fileOrData;

		/**
		 * CKEditor Cloud Services access token.
		 *
		 * @type {module:cloud-services-core/token~Token}
		 * @private
		 */
		this._token = token;

		/**
		 * CKEditor Cloud Services API address.
		 *
		 * @type {String}
		 * @private
		 */
		this._apiAddress = apiAddress;
	}

	/**
	 * Registers callback on `progress` event.
	 *
	 * @chainable
	 * @param {Function} callback
	 * @returns {module:cloud-services-core/uploadgateway/fileuploader~FileUploader}
	 */
	onProgress( callback ) {
		this.on( 'progress', ( event, data ) => callback( data ) );

		return this;
	}

	/**
	 * Registers callback on `error` event. Event is called once when error occurs.
	 *
	 * @chainable
	 * @param {Function} callback
	 * @returns {module:cloud-services-core/uploadgateway/fileuploader~FileUploader}
	 */
	onError( callback ) {
		this.once( 'error', ( event, data ) => callback( data ) );

		return this;
	}

	/**
	 * Aborts upload process.
	 */
	abort() {
		this.xhr.abort();
	}

	/**
	 * Sends XHR request to API.
	 *
	 * @chainable
	 * @returns {Promise.<Object>}
	 */
	send() {
		this._prepareRequest();
		this._attachXHRListeners();

		return this._sendRequest();
	}

	/**
	 * Prepares XHR request.
	 *
	 * @private
	 */
	_prepareRequest() {
		const xhr = new XMLHttpRequest();

		xhr.open( 'POST', this._apiAddress );
		xhr.setRequestHeader( 'Authorization', this._token.value );
		xhr.responseType = 'json';

		this.xhr = xhr;
	}

	/**
	 * Attaches listeners to the XHR.
	 *
	 * @private
	 */
	_attachXHRListeners() {
		const that = this;
		const xhr = this.xhr;

		xhr.addEventListener( 'error', onError( 'Network Error' ) );
		xhr.addEventListener( 'abort', onError( 'Abort' ) );

		/* istanbul ignore else */
		if ( xhr.upload ) {
			xhr.upload.addEventListener( 'progress', event => {
				if ( event.lengthComputable ) {
					this.fire( 'progress', {
						total: event.total,
						uploaded: event.loaded
					} );
				}
			} );
		}

		xhr.addEventListener( 'load', () => {
			const statusCode = xhr.status;
			const xhrResponse = xhr.response;

			if ( statusCode < 200 || statusCode > 299 ) {
				return this.fire( 'error', xhrResponse.message || xhrResponse.error );
			}
		} );

		function onError( message ) {
			return () => that.fire( 'error', message );
		}
	}

	/**
	 * Sends XHR request.
	 *
	 * @private
	 */
	_sendRequest() {
		const formData = new FormData();
		const xhr = this.xhr;

		formData.append( 'file', this.file );

		return new Promise( ( resolve, reject ) => {
			xhr.addEventListener( 'load', () => {
				const statusCode = xhr.status;
				const xhrResponse = xhr.response;

				if ( statusCode < 200 || statusCode > 299 ) {
					if ( xhrResponse.message ) {
						/**
						 * Uploading file failed.
						 *
						 * @error fileuploader-uploading-data-failed
						 */
						return reject( new ckeditorerror["b" /* default */](
							'fileuploader-uploading-data-failed: Uploading file failed.',
							this,
							{ message: xhrResponse.message }
						) );
					}

					return reject( xhrResponse.error );
				}

				return resolve( xhrResponse );
			} );

			xhr.addEventListener( 'error', () => reject( new Error( 'Network Error' ) ) );
			xhr.addEventListener( 'abort', () => reject( new Error( 'Abort' ) ) );

			xhr.send( formData );
		} );
	}

	/**
	 * Fired when error occurs.
	 *
	 * @event error
	 * @param {String} error Error message
	 */

	/**
	 * Fired on upload progress.
	 *
	 * @event progress
	 * @param {Object} status Total and uploaded status
	 */
}

mix( fileuploader_FileUploader, emittermixin );

/**
 * Transforms Base64 string data into file.
 *
 * @param {String} base64 String data.
 * @param {Number} [sliceSize=512]
 * @returns {Blob}
 * @private
 */
function _base64ToBlob( base64, sliceSize = 512 ) {
	try {
		const contentType = base64.match( BASE64_HEADER_REG_EXP )[ 1 ];
		const base64Data = atob( base64.replace( BASE64_HEADER_REG_EXP, '' ) );

		const byteArrays = [];

		for ( let offset = 0; offset < base64Data.length; offset += sliceSize ) {
			const slice = base64Data.slice( offset, offset + sliceSize );
			const byteNumbers = new Array( slice.length );

			for ( let i = 0; i < slice.length; i++ ) {
				byteNumbers[ i ] = slice.charCodeAt( i );
			}

			byteArrays.push( new Uint8Array( byteNumbers ) );
		}

		return new Blob( byteArrays, { type: contentType } );
	} catch ( error ) {
		/**
		 * Problem with decoding Base64 image data.
		 *
		 * @error fileuploader-decoding-image-data-error
		 */
		throw new ckeditorerror["b" /* default */]( 'fileuploader-decoding-image-data-error: Problem with decoding Base64 image data.', null );
	}
}

/**
 * Checks that string is Base64.
 *
 * @param {String} string
 * @returns {Boolean}
 * @private
 */
function _isBase64( string ) {
	if ( typeof string !== 'string' ) {
		return false;
	}

	const match = string.match( BASE64_HEADER_REG_EXP );
	return !!( match && match.length );
}

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor-cloud-services-core/src/uploadgateway/uploadgateway.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module cloud-services-core/uploadgateway/uploadgateway
 */




/**
 * UploadGateway abstracts file uploads to CKEditor Cloud Services.
 */
class uploadgateway_UploadGateway {
	/**
	 * Creates `UploadGateway` instance.
	 *
	 * @param {module:cloud-services-core/token~Token} token Token used for authentication.
	 * @param {String} apiAddress API address.
	 */
	constructor( token, apiAddress ) {
		if ( !token ) {
			/**
			 * Token must be provided.
			 *
			 * @error uploadgateway-missing-token
			 */
			throw new ckeditorerror["b" /* default */]( 'uploadgateway-missing-token: Token must be provided.', null );
		}

		if ( !apiAddress ) {
			/**
			 * Api address must be provided.
			 *
			 * @error uploadgateway-missing-api-address
			 */
			throw new ckeditorerror["b" /* default */]( 'uploadgateway-missing-api-address: Api address must be provided.', null );
		}

		/**
		 * CKEditor Cloud Services access token.
		 *
		 * @type {module:cloud-services-core/token~Token}
		 * @private
		 */
		this._token = token;

		/**
		 * CKEditor Cloud Services API address.
		 *
		 * @type {String}
		 * @private
		 */
		this._apiAddress = apiAddress;
	}

	/**
	 * Creates a {@link module:cloud-services-core/uploadgateway/fileuploader~FileUploader} instance that wraps
	 * file upload process. The file is being sent at a time when the
	 * {@link module:cloud-services-core/uploadgateway/fileuploader~FileUploader#send} method is called.
	 *
	 *     const token = await Token.create( 'https://token-endpoint' );
	 *     new UploadGateway( token, 'https://example.org' )
	 *        .upload( 'FILE' )
	 *        .onProgress( ( data ) => console.log( data ) )
	 *        .send()
	 *        .then( ( response ) => console.log( response ) );
	 *
	 * @param {Blob|String} fileOrData A blob object or a data string encoded with Base64.
	 * @returns {module:cloud-services-core/uploadgateway/fileuploader~FileUploader} Returns `FileUploader` instance.
	 */
	upload( fileOrData ) {
		return new fileuploader_FileUploader( fileOrData, this._token, this._apiAddress );
	}
}


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor-cloud-services-core/src/token/token.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module cloud-services-core/token
 */

/* globals XMLHttpRequest, setInterval, clearInterval */





const DEFAULT_OPTIONS = { refreshInterval: 3600000, autoRefresh: true };

/**
 * Class representing the token used for communication with CKEditor Cloud Services.
 * Value of the token is retrieving from the specified URL and is refreshed every 1 hour by default.
 *
 * @mixes ObservableMixin
 */
class token_Token {
	/**
	 * Creates `Token` instance.
	 * Method `init` should be called after using the constructor or use `create` method instead.
	 *
	 * @param {String|Function} tokenUrlOrRefreshToken Endpoint address to download the token or a callback that provides the token. If the
	 * value is a function it has to match the {@link module:cloud-services-core/token~refreshToken} interface.
	 * @param {Object} options
	 * @param {String} [options.initValue] Initial value of the token.
	 * @param {Number} [options.refreshInterval=3600000] Delay between refreshes. Default 1 hour.
	 * @param {Boolean} [options.autoRefresh=true] Specifies whether to start the refresh automatically.
	 */
	constructor( tokenUrlOrRefreshToken, options = DEFAULT_OPTIONS ) {
		if ( !tokenUrlOrRefreshToken ) {
			/**
			 * A `tokenUrl` must be provided as the first constructor argument.
			 *
			 * @error token-missing-token-url
			 */
			throw new ckeditorerror["b" /* default */](
				'token-missing-token-url: A `tokenUrl` must be provided as the first constructor argument.',
				this
			);
		}

		/**
		 * Value of the token.
		 * The value of the token is null if `initValue` is not provided or `init` method was not called.
		 * `create` method creates token with initialized value from url.
		 *
		 * @name value
		 * @member {String} #value
		 * @observable
		 * @readonly
		 */
		this.set( 'value', options.initValue );

		/**
		 * Base refreshing function.
		 *
		 * @private
		 * @member {String|Function} #_refresh
		 */
		if ( typeof tokenUrlOrRefreshToken === 'function' ) {
			this._refresh = tokenUrlOrRefreshToken;
		} else {
			this._refresh = () => defaultRefreshToken( tokenUrlOrRefreshToken );
		}

		/**
		 * @type {Object}
		 * @private
		 */
		this._options = Object.assign( {}, DEFAULT_OPTIONS, options );
	}

	/**
	 * Initializes the token.
	 *
	 * @returns {Promise.<module:cloud-services-core/token~Token>}
	 */
	init() {
		return new Promise( ( resolve, reject ) => {
			if ( this._options.autoRefresh ) {
				this._startRefreshing();
			}

			if ( !this.value ) {
				this.refreshToken()
					.then( resolve )
					.catch( reject );

				return;
			}

			resolve( this );
		} );
	}

	/**
	 * Refresh token method. Useful in a method form as it can be override in tests.
	 * @returns {Promise.<String>}
	 */
	refreshToken() {
		return this._refresh()
			.then( value => this.set( 'value', value ) )
			.then( () => this );
	}

	/**
	 * Destroys token instance. Stops refreshing.
	 */
	destroy() {
		this._stopRefreshing();
	}

	/**
	 * Starts value refreshing every `refreshInterval` time.
	 *
	 * @protected
	 */
	_startRefreshing() {
		this._refreshInterval = setInterval( () => this.refreshToken(), this._options.refreshInterval );
	}

	/**
	 * Stops value refreshing.
	 *
	 * @protected
	 */
	_stopRefreshing() {
		clearInterval( this._refreshInterval );
	}

	/**
	 * Creates a initialized {@link module:cloud-services-core/token~Token} instance.
	 *
	 * @param {String|Function} tokenUrlOrRefreshToken Endpoint address to download the token or a callback that provides the token. If the
	 * value is a function it has to match the {@link module:cloud-services-core/token~refreshToken} interface.
	 * @param {Object} options
	 * @param {String} [options.initValue] Initial value of the token.
	 * @param {Number} [options.refreshInterval=3600000] Delay between refreshes. Default 1 hour.
	 * @param {Boolean} [options.autoRefresh=true] Specifies whether to start the refresh automatically.
	 * @returns {Promise.<module:cloud-services-core/token~Token>}
	 */
	static create( tokenUrlOrRefreshToken, options = DEFAULT_OPTIONS ) {
		const token = new token_Token( tokenUrlOrRefreshToken, options );

		return token.init();
	}
}

mix( token_Token, observablemixin );

/**
 * This function is called in a defined interval by the {@link ~Token} class. It also can be invoked manually.
 * It should return a promise, which resolves with the new token value.
 * If any error occurs it should return a rejected promise with an error message.
 *
 * @function refreshToken
 * @returns {Promise.<String>}
 */

/**
 * @private
 * @param {String} tokenUrl
 */
function defaultRefreshToken( tokenUrl ) {
	return new Promise( ( resolve, reject ) => {
		const xhr = new XMLHttpRequest();

		xhr.open( 'GET', tokenUrl );

		xhr.addEventListener( 'load', () => {
			const statusCode = xhr.status;
			const xhrResponse = xhr.response;

			if ( statusCode < 200 || statusCode > 299 ) {
				/**
				 * Cannot download new token from the provided url.
				 *
				 * @error token-cannot-download-new-token
				 */
				return reject(
					new ckeditorerror["b" /* default */]( 'token-cannot-download-new-token: Cannot download new token from the provided url.', null )
				);
			}

			return resolve( xhrResponse );
		} );

		xhr.addEventListener( 'error', () => reject( new Error( 'Network Error' ) ) );
		xhr.addEventListener( 'abort', () => reject( new Error( 'Abort' ) ) );

		xhr.send();
	} );
}

/* harmony default export */ var token_token = (token_Token);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-cloud-services/src/cloudservices.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module cloud-services/cloudservices
 */


/**
 * Plugin introducing integration between CKEditor 5 and CKEditor Cloud Services .
 *
 * It initializes the token provider based on
 * the {@link module:cloud-services/cloudservices~CloudServicesConfig `config.cloudService`}.
 *
 * @extends module:core/plugin~Plugin
 */

var cloudservices_CloudServices = /*#__PURE__*/function (_ContextPlugin) {
  Object(inherits["a" /* default */])(CloudServices, _ContextPlugin);

  var _super = Object(createSuper["a" /* default */])(CloudServices);

  function CloudServices() {
    Object(classCallCheck["a" /* default */])(this, CloudServices);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(CloudServices, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var config = this.context.config;
      var options = config.get('cloudServices') || {};

      for (var optionName in options) {
        this[optionName] = options[optionName];
      }
      /**
       * The authentication token URL for CKEditor Cloud Services or a callback to the token value promise. See the
       * {@link module:cloud-services/cloudservices~CloudServicesConfig#tokenUrl} for more details.
       *
       * @readonly
       * @member {String|Function|undefined} #tokenUrl
       */

      /**
       * The URL to which the files should be uploaded.
       *
       * @readonly
       * @member {String} #uploadUrl
       */

      /**
       * Other plugins use this token for the authorization process. It handles token requesting and refreshing.
       * Its value is `null` when {@link module:cloud-services/cloudservices~CloudServicesConfig#tokenUrl} is not provided.
       *
       * @readonly
       * @member {Object|null} #token
       */


      if (!this.tokenUrl) {
        this.token = null;
        return;
      }

      this.token = new CloudServices.Token(this.tokenUrl);
      return this.token.init();
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "destroy",
    value: function destroy() {
      get_get(Object(getPrototypeOf["a" /* default */])(CloudServices.prototype), "destroy", this).call(this);

      if (this.token) {
        this.token.destroy();
      }
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritdoc
     */
    get: function get() {
      return 'CloudServices';
    }
  }]);

  return CloudServices;
}(contextplugin_ContextPlugin);


cloudservices_CloudServices.Token = token_token;
/**
 * The configuration of CKEditor Cloud Services. Introduced by the {@link module:cloud-services/cloudservices~CloudServices} plugin.
 *
 * Read more in {@link module:cloud-services/cloudservices~CloudServicesConfig}.
 *
 * @member {module:cloud-services/cloudservices~CloudServicesConfig} module:core/editor/editorconfig~EditorConfig#cloudServices
 */

/**
 * The configuration for all plugins using CKEditor Cloud Services.
 *
 *		ClassicEditor
 *			.create( document.querySelector( '#editor' ), {
 *				cloudServices: {
 *					tokenUrl: 'https://example.com/cs-token-endpoint',
 *					uploadUrl: 'https://your-organization-id.cke-cs.com/easyimage/upload/'
 *				}
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * See {@link module:core/editor/editorconfig~EditorConfig all editor options}.
 *
 * @interface CloudServicesConfig
 */

/**
 * A token URL or a token request function.
 *
 * As a string, it should be a URL to the security token endpoint in your application. The role of this endpoint is to securely authorize
 * the end users of your application to use [CKEditor Cloud Services](https://ckeditor.com/ckeditor-cloud-services) only
 * if they should have access e.g. to upload files with {@glink @cs guides/easy-image/quick-start Easy Image} or to use the
 * {@glink @cs guides/collaboration/quick-start Collaboration} service.
 *
 *		ClassicEditor
 *			.create( document.querySelector( '#editor' ), {
 *				cloudServices: {
 *					tokenUrl: 'https://example.com/cs-token-endpoint',
 *					...
 *				}
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * As a function, it should provide a promise to the token value, so you can highly customize the token and provide your token URL endpoint.
 * By using this approach you can set your own headers for the request.
 *
 * 		ClassicEditor
 *			.create( document.querySelector( '#editor' ), {
 *				cloudServices: {
 *					tokenUrl: () => new Promise( ( resolve, reject ) => {
 *						const xhr = new XMLHttpRequest();
 *
 *						xhr.open( 'GET', 'https://example.com/cs-token-endpoint' );
 *
 *						xhr.addEventListener( 'load', () => {
 *							const statusCode = xhr.status;
 *							const xhrResponse = xhr.response;
 *
 *							if ( statusCode < 200 || statusCode > 299 ) {
 *								return reject( new Error( 'Cannot download new token!' ) );
 *							}
 *
 *							return resolve( xhrResponse );
 *						} );
 *
 *						xhr.addEventListener( 'error', () => reject( new Error( 'Network Error' ) ) );
 *						xhr.addEventListener( 'abort', () => reject( new Error( 'Abort' ) ) );
 *
 *						xhr.setRequestHeader( customHeader, customValue );
 *
 *						xhr.send();
 *					} ),
 *					...
 *				}
 *			} )
 *
 * You can find more information about token endpoints in the
 * {@glink @cs guides/easy-image/quick-start#create-token-endpoint Cloud Services - Quick start}
 * and {@glink @cs guides/security/token-endpoint Cloud Services - Token endpoint} documentation.
 *
 * Without a properly working token endpoint (token URL) CKEditor plugins will not be able to connect to CKEditor Cloud Services.
 *
 * @member {String|Function} module:cloud-services/cloudservices~CloudServicesConfig#tokenUrl
 */

/**
 * The endpoint URL for [CKEditor Cloud Services](https://ckeditor.com/ckeditor-cloud-services) uploads.
 * This option must be set for Easy Image to work correctly.
 *
 * The upload URL is unique for each customer and can be found in the
 * [CKEditor Ecosystem customer dashboard](https://dashboard.ckeditor.com) after subscribing to the Easy Image service.
 * To learn how to start using Easy Image, check the {@glink @cs guides/easy-image/quick-start Easy Image - Quick start} documentation.
 *
 * Note: Make sure to also set the {@link module:cloud-services/cloudservices~CloudServicesConfig#tokenUrl} configuration option.
 *
 * @member {String} module:cloud-services/cloudservices~CloudServicesConfig#uploadUrl
 */

/**
 * The URL for web socket communication, used by the `RealTimeCollaborativeEditing` plugin. Every customer (organization in the CKEditor
 * Ecosystem dashboard) has their own, unique URLs to communicate with CKEditor Cloud Services. The URL can be found in the
 * CKEditor Ecosystem customer dashboard.
 *
 * Note: Unlike most plugins, `RealTimeCollaborativeEditing` is not included in any CKEditor 5 build and needs to be installed manually.
 * Check [Collaboration overview](https://ckeditor.com/docs/ckeditor5/latest/features/collaboration/overview.html) for more details.
 *
 * @member {String} module:cloud-services/cloudservices~CloudServicesConfig#webSocketUrl
 */

/**
 * An optional parameter used for integration with CKEditor Cloud Services when uploading the editor build to cloud services.
 *
 * Whenever the editor build or the configuration changes, this parameter should be set to a new, unique value to differentiate
 * the new bundle (build + configuration) from the old ones.
 *
 * @member {String} module:cloud-services/cloudservices~CloudServicesConfig#bundleVersion
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-easy-image/src/cloudservicesuploadadapter.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
* @module easy-image/cloudservicesuploadadapter
*/




/**
 * A plugin that enables upload to [CKEditor Cloud Services](https://ckeditor.com/ckeditor-cloud-services/).
 *
 * It is mainly used by the {@link module:easy-image/easyimage~EasyImage} feature.
 *
 * After enabling this adapter you need to configure the CKEditor Cloud Services integration through
 * {@link module:cloud-services/cloudservices~CloudServicesConfig `config.cloudServices`}.
 *
 * @extends module:core/plugin~Plugin
 */

var cloudservicesuploadadapter_CloudServicesUploadAdapter = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(CloudServicesUploadAdapter, _Plugin);

  var _super = Object(createSuper["a" /* default */])(CloudServicesUploadAdapter);

  function CloudServicesUploadAdapter() {
    Object(classCallCheck["a" /* default */])(this, CloudServicesUploadAdapter);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(CloudServicesUploadAdapter, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this = this;

      var editor = this.editor;
      var cloudServices = editor.plugins.get(cloudservices_CloudServices);
      var token = cloudServices.token;
      var uploadUrl = cloudServices.uploadUrl;

      if (!token) {
        return;
      }

      this._uploadGateway = new CloudServicesUploadAdapter._UploadGateway(token, uploadUrl);

      editor.plugins.get(filerepository_FileRepository).createUploadAdapter = function (loader) {
        return new cloudservicesuploadadapter_Adapter(_this._uploadGateway, loader);
      };
    }
  }], [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [filerepository_FileRepository, cloudservices_CloudServices];
    }
  }]);

  return CloudServicesUploadAdapter;
}(plugin_Plugin);
/**
 * @private
 */




var cloudservicesuploadadapter_Adapter = /*#__PURE__*/function () {
  function Adapter(uploadGateway, loader) {
    Object(classCallCheck["a" /* default */])(this, Adapter);

    this.uploadGateway = uploadGateway;
    this.loader = loader;
  }

  Object(createClass["a" /* default */])(Adapter, [{
    key: "upload",
    value: function upload() {
      var _this2 = this;

      return this.loader.file.then(function (file) {
        _this2.fileUploader = _this2.uploadGateway.upload(file);

        _this2.fileUploader.on('progress', function (evt, data) {
          _this2.loader.uploadTotal = data.total;
          _this2.loader.uploaded = data.uploaded;
        });

        return _this2.fileUploader.send();
      });
    }
  }, {
    key: "abort",
    value: function abort() {
      this.fileUploader.abort();
    }
  }]);

  return Adapter;
}(); // Store the API in static property to easily overwrite it in tests.
// Too bad dependency injection does not work in Webpack + ES 6 (const) + Babel.


cloudservicesuploadadapter_CloudServicesUploadAdapter._UploadGateway = uploadgateway_UploadGateway;
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-widget/theme/icons/return-arrow.svg
var return_arrow = __webpack_require__("c7cb");
var return_arrow_default = /*#__PURE__*/__webpack_require__.n(return_arrow);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-widget/theme/widgettypearound.css
var widgettypearound = __webpack_require__("e472");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-widget/src/widgettypearound/widgettypearound.js










/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/* global DOMParser */

/**
 * @module widget/widgettypearound
 */








var POSSIBLE_INSERTION_POSITIONS = ['before', 'after']; // Do the SVG parsing once and then clone the result <svg> DOM element for each new button.

var RETURN_ARROW_ICON_ELEMENT = new DOMParser().parseFromString(return_arrow_default.a, 'image/svg+xml').firstChild;
/**
 * A plugin that allows users to type around widgets where normally it is impossible to place the caret due
 * to limitations of web browsers. These "tight spots" occur, for instance, before (or after) a widget being
 * the first (or last) child of its parent or between two block widgets.
 *
 * This plugin extends the {@link module:widget/widget~Widget `Widget`} plugin and injects a user interface
 * with two buttons into each widget instance in the editor. Each of the buttons can be clicked by the
 * user if the widget is next to the "tight spot". Once clicked, a paragraph is created with the selection anchored
 * in it so that users can type (or insert content, paste, etc.) straight away.
 *
 * @extends module:core/plugin~Plugin
 * @private
 */

var widgettypearound_WidgetTypeAround = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(WidgetTypeAround, _Plugin);

  var _super = Object(createSuper["a" /* default */])(WidgetTypeAround);

  Object(createClass["a" /* default */])(WidgetTypeAround, null, [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'WidgetTypeAround';
    }
    /**
     * @inheritDoc
     */

  }]);

  function WidgetTypeAround(editor) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, WidgetTypeAround);

    _this = _super.call(this, editor);
    /**
     * A reference to the model widget element that has the "fake caret" active
     * on either side of it. It is later used to remove CSS classes associated with the "fake caret"
     * when the widget no longer needs it.
     *
     * @private
     * @member {module:engine/model/element~Element|null}
     */

    _this._currentFakeCaretModelElement = null;
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(WidgetTypeAround, [{
    key: "init",
    value: function init() {
      this._enableTypeAroundUIInjection();

      this._enableInsertingParagraphsOnButtonClick();

      this._enableInsertingParagraphsOnEnterKeypress();

      this._enableInsertingParagraphsOnTypingKeystroke();

      this._enableTypeAroundFakeCaretActivationUsingKeyboardArrows();

      this._enableDeleteIntegration();

      this._enableInsertContentIntegration();
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this._currentFakeCaretModelElement = null;
    }
    /**
     * Inserts a new paragraph next to a widget element with the selection anchored in it.
     *
     * **Note**: This method is heavily user-oriented and will both focus the editing view and scroll
     * the viewport to the selection in the inserted paragraph.
     *
     * @protected
     * @param {module:engine/model/element~Element} widgetModelElement The model widget element next to which a paragraph is inserted.
     * @param {'before'|'after'} position The position where the paragraph is inserted. Either `'before'` or `'after'` the widget.
     */

  }, {
    key: "_insertParagraph",
    value: function _insertParagraph(widgetModelElement, position) {
      var editor = this.editor;
      var editingView = editor.editing.view;
      editor.execute('insertParagraph', {
        position: editor.model.createPositionAt(widgetModelElement, position)
      });
      editingView.focus();
      editingView.scrollToTheSelection();
    }
    /**
     * Similar to {@link #_insertParagraph}, this method inserts a paragraph except that it
     * does not expect a position but it performs the insertion next to a selected widget
     * according to the "widget-type-around" model selection attribute value ("fake caret" position).
     *
     * Because this method requires the "widget-type-around" attribute to be set,
     * the insertion can only happen when the widget "fake caret" is active (e.g. activated
     * using the keyboard).
     *
     * @private
     * @returns {Boolean} Returns `true` when the paragraph was inserted (the attribute was present) and `false` otherwise.
     */

  }, {
    key: "_insertParagraphAccordingToFakeCaretPosition",
    value: function _insertParagraphAccordingToFakeCaretPosition() {
      var editor = this.editor;
      var model = editor.model;
      var modelSelection = model.document.selection;
      var typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);

      if (!typeAroundFakeCaretPosition) {
        return false;
      }

      var selectedModelElement = modelSelection.getSelectedElement();

      this._insertParagraph(selectedModelElement, typeAroundFakeCaretPosition);

      return true;
    }
    /**
     * Creates a listener in the editing conversion pipeline that injects the type around
     * UI into every single widget instance created in the editor.
     *
     * The UI is delivered as a {@link module:engine/view/uielement~UIElement}
     * wrapper which renders DOM buttons that users can use to insert paragraphs.
     *
     * @private
     */

  }, {
    key: "_enableTypeAroundUIInjection",
    value: function _enableTypeAroundUIInjection() {
      var editor = this.editor;
      var schema = editor.model.schema;
      var t = editor.locale.t;
      var buttonTitles = {
        before: t('Insert paragraph before block'),
        after: t('Insert paragraph after block')
      };
      editor.editing.downcastDispatcher.on('insert', function (evt, data, conversionApi) {
        var viewElement = conversionApi.mapper.toViewElement(data.item); // Filter out non-widgets and inline widgets.

        if (isTypeAroundWidget(viewElement, data.item, schema)) {
          injectUIIntoWidget(conversionApi.writer, buttonTitles, viewElement);
        }
      }, {
        priority: 'low'
      });
    }
    /**
     * Brings support for the "fake caret" that appears when either:
     *
     * * the selection moves from a position next to a widget (to a widget) using arrow keys,
     * * the arrow key is pressed when the widget is already selected.
     *
     * The "fake caret" lets the user know that they can start typing or just press
     * enter to insert a paragraph at the position next to a widget as suggested by the "fake caret".
     *
     * The "fake caret" disappears when the user changes the selection or the editor
     * gets blurred.
     *
     * The whole idea is as follows:
     *
     * 1. A user does one of the 2 scenarios described at the beginning.
     * 2. The "keydown" listener is executed and the decision is made whether to show or hide the "fake caret".
     * 3. If it should show up, the "widget-type-around" model selection attribute is set indicating
     *    on which side of the widget it should appear.
     * 4. The selection dispatcher reacts to the selection attribute and sets CSS classes responsible for the
     *    "fake caret" on the view widget.
     * 5. If the "fake caret" should disappear, the selection attribute is removed and the dispatcher
     *    does the CSS class clean-up in the view.
     * 6. Additionally, "change:range" and FocusTracker#isFocused listeners also remove the selection
     *    attribute (the former also removes widget CSS classes).
     *
     * @private
     */

  }, {
    key: "_enableTypeAroundFakeCaretActivationUsingKeyboardArrows",
    value: function _enableTypeAroundFakeCaretActivationUsingKeyboardArrows() {
      var _this2 = this;

      var editor = this.editor;
      var model = editor.model;
      var modelSelection = model.document.selection;
      var schema = model.schema;
      var editingView = editor.editing.view; // This is the main listener responsible for the "fake caret".
      // Note: The priority must precede the default Widget class keydown handler ("high") and the
      // TableKeyboard keydown handler ("high-10").

      editingView.document.on('keydown', function (evt, domEventData) {
        if (isArrowKeyCode(domEventData.keyCode)) {
          _this2._handleArrowKeyPress(evt, domEventData);
        }
      }, {
        priority: src_priorities.get('high') + 10
      }); // This listener makes sure the widget type around selection attribute will be gone from the model
      // selection as soon as the model range changes. This attribute only makes sense when a widget is selected
      // (and the "fake horizontal caret" is visible) so whenever the range changes (e.g. selection moved somewhere else),
      // let's get rid of the attribute so that the selection downcast dispatcher isn't even bothered.

      modelSelection.on('change:range', function (evt, data) {
        // Do not reset the selection attribute when the change was indirect.
        if (!data.directChange) {
          return;
        } // Get rid of the widget type around attribute of the selection on every change:range.
        // If the range changes, it means for sure, the user is no longer in the active ("fake horizontal caret") mode.


        editor.model.change(function (writer) {
          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
        });
      }); // Get rid of the widget type around attribute of the selection on every document change
      // that makes widget not selected any more (i.e. widget was removed).

      model.document.on('change:data', function () {
        var selectedModelElement = modelSelection.getSelectedElement();

        if (selectedModelElement) {
          var selectedViewElement = editor.editing.mapper.toViewElement(selectedModelElement);

          if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
            return;
          }
        }

        editor.model.change(function (writer) {
          writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
        });
      }); // React to changes of the model selection attribute made by the arrow keys listener.
      // If the block widget is selected and the attribute changes, downcast the attribute to special
      // CSS classes associated with the active ("fake horizontal caret") mode of the widget.

      editor.editing.downcastDispatcher.on('selection', function (evt, data, conversionApi) {
        var writer = conversionApi.writer;

        if (_this2._currentFakeCaretModelElement) {
          var _selectedViewElement = conversionApi.mapper.toViewElement(_this2._currentFakeCaretModelElement);

          if (_selectedViewElement) {
            // Get rid of CSS classes associated with the active ("fake horizontal caret") mode from the view widget.
            writer.removeClass(POSSIBLE_INSERTION_POSITIONS.map(positionToWidgetCssClass), _selectedViewElement);
            _this2._currentFakeCaretModelElement = null;
          }
        }

        var selectedModelElement = data.selection.getSelectedElement();

        if (!selectedModelElement) {
          return;
        }

        var selectedViewElement = conversionApi.mapper.toViewElement(selectedModelElement);

        if (!isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
          return;
        }

        var typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(data.selection);

        if (!typeAroundFakeCaretPosition) {
          return;
        }

        writer.addClass(positionToWidgetCssClass(typeAroundFakeCaretPosition), selectedViewElement); // Remember the view widget that got the "fake-caret" CSS class. This class should be removed ASAP when the
        // selection changes

        _this2._currentFakeCaretModelElement = selectedModelElement;
      });
      this.listenTo(editor.ui.focusTracker, 'change:isFocused', function (evt, name, isFocused) {
        if (!isFocused) {
          editor.model.change(function (writer) {
            writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
          });
        }
      });

      function positionToWidgetCssClass(position) {
        return "ck-widget_type-around_show-fake-caret_".concat(position);
      }
    }
    /**
     * A listener executed on each "keydown" in the view document, a part of
     * {@link #_enableTypeAroundFakeCaretActivationUsingKeyboardArrows}.
     *
     * It decides whether the arrow key press should activate the "fake caret" or not (also whether it should
     * be deactivated).
     *
     * The "fake caret" activation is done by setting the "widget-type-around" model selection attribute
     * in this listener and stopping&preventing the event that would normally be handled by the Widget
     * plugin that is responsible for the regular keyboard navigation near/across all widgets (that
     * includes inline widgets, which are ignored by the WidgetTypeAround plugin).
     *
     * @private
     */

  }, {
    key: "_handleArrowKeyPress",
    value: function _handleArrowKeyPress(evt, domEventData) {
      var editor = this.editor;
      var model = editor.model;
      var modelSelection = model.document.selection;
      var schema = model.schema;
      var editingView = editor.editing.view;
      var keyCode = domEventData.keyCode;
      var isForward = isForwardArrowKeyCode(keyCode, editor.locale.contentLanguageDirection);
      var selectedViewElement = editingView.document.selection.getSelectedElement();
      var selectedModelElement = editor.editing.mapper.toModelElement(selectedViewElement);
      var shouldStopAndPreventDefault; // Handle keyboard navigation when a type-around-compatible widget is currently selected.

      if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
        shouldStopAndPreventDefault = this._handleArrowKeyPressOnSelectedWidget(isForward);
      } // Handle keyboard arrow navigation when the selection is next to a type-around-compatible widget
      // and the widget is about to be selected.
      else if (modelSelection.isCollapsed) {
          shouldStopAndPreventDefault = this._handleArrowKeyPressWhenSelectionNextToAWidget(isForward);
        }

      if (shouldStopAndPreventDefault) {
        domEventData.preventDefault();
        evt.stop();
      }
    }
    /**
     * Handles the keyboard navigation on "keydown" when a widget is currently selected and activates or deactivates
     * the "fake caret" for that widget, depending on the current value of the "widget-type-around" model
     * selection attribute and the direction of the pressed arrow key.
     *
     * @private
     * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement
     * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
     * @returns {Boolean} `true` when the key press was handled and no other keydown listener of the editor should
     * process the event any further. `false` otherwise.
     */

  }, {
    key: "_handleArrowKeyPressOnSelectedWidget",
    value: function _handleArrowKeyPressOnSelectedWidget(isForward) {
      var editor = this.editor;
      var model = editor.model;
      var modelSelection = model.document.selection;
      var typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(modelSelection);
      return model.change(function (writer) {
        // If the fake caret is displayed...
        if (typeAroundFakeCaretPosition) {
          var isLeavingWidget = typeAroundFakeCaretPosition === (isForward ? 'after' : 'before'); // If the keyboard arrow works against the value of the selection attribute...
          // then remove the selection attribute but prevent default DOM actions
          // and do not let the Widget plugin listener move the selection. This brings
          // the widget back to the state, for instance, like if was selected using the mouse.
          //
          // **Note**: If leaving the widget when the "fake caret" is active, then the default
          // Widget handler will change the selection and, in turn, this will automatically discard
          // the selection attribute.

          if (!isLeavingWidget) {
            writer.removeSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE);
            return true;
          }
        } // If the fake caret wasn't displayed, let's set it now according to the direction of the arrow
        // key press. This also means we cannot let the Widget plugin listener move the selection.
        else {
            writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'after' : 'before');
            return true;
          }

        return false;
      });
    }
    /**
     * Handles the keyboard navigation on "keydown" when **no** widget is selected but the selection is **directly** next
     * to one and upon the "fake caret" should become active for this widget upon arrow key press
     * (AKA entering/selecting the widget).
     *
     * **Note**: This code mirrors the implementation from the Widget plugin but also adds the selection attribute.
     * Unfortunately, there's no safe way to let the Widget plugin do the selection part first and then just set the
     * selection attribute here in the WidgetTypeAround plugin. This is why this code must duplicate some from the Widget plugin.
     *
     * @private
     * @param {Boolean} isForward `true` when the pressed arrow key was responsible for the forward model selection movement
     * as in {@link module:utils/keyboard~isForwardArrowKeyCode}.
     * @returns {Boolean} `true` when the key press was handled and no other keydown listener of the editor should
     * process the event any further. `false` otherwise.
     */

  }, {
    key: "_handleArrowKeyPressWhenSelectionNextToAWidget",
    value: function _handleArrowKeyPressWhenSelectionNextToAWidget(isForward) {
      var editor = this.editor;
      var model = editor.model;
      var schema = model.schema;
      var widgetPlugin = editor.plugins.get('Widget'); // This is the widget the selection is about to be set on.

      var modelElementNextToSelection = widgetPlugin._getObjectElementNextToSelection(isForward);

      var viewElementNextToSelection = editor.editing.mapper.toViewElement(modelElementNextToSelection);

      if (isTypeAroundWidget(viewElementNextToSelection, modelElementNextToSelection, schema)) {
        model.change(function (writer) {
          widgetPlugin._setSelectionOverElement(modelElementNextToSelection);

          writer.setSelectionAttribute(TYPE_AROUND_SELECTION_ATTRIBUTE, isForward ? 'before' : 'after');
        }); // The change() block above does the same job as the Widget plugin. The event can
        // be safely canceled.

        return true;
      }

      return false;
    }
    /**
     * Registers a `mousedown` listener for the view document which intercepts events
     * coming from the type around UI, which happens when a user clicks one of the buttons
     * that insert a paragraph next to a widget.
     *
     * @private
     */

  }, {
    key: "_enableInsertingParagraphsOnButtonClick",
    value: function _enableInsertingParagraphsOnButtonClick() {
      var _this3 = this;

      var editor = this.editor;
      var editingView = editor.editing.view;
      editingView.document.on('mousedown', function (evt, domEventData) {
        var button = getClosestTypeAroundDomButton(domEventData.domTarget);

        if (!button) {
          return;
        }

        var buttonPosition = getTypeAroundButtonPosition(button);
        var widgetViewElement = getClosestWidgetViewElement(button, editingView.domConverter);
        var widgetModelElement = editor.editing.mapper.toModelElement(widgetViewElement);

        _this3._insertParagraph(widgetModelElement, buttonPosition);

        domEventData.preventDefault();
        evt.stop();
      });
    }
    /**
     * Creates the "enter" key listener on the view document that allows the user to insert a paragraph
     * near the widget when either:
     *
     * * The "fake caret" was first activated using the arrow keys,
     * * The entire widget is selected in the model.
     *
     * In the first case, the new paragraph is inserted according to the "widget-type-around" selection
     * attribute (see {@link #_handleArrowKeyPress}).
     *
     * It the second case, the new paragraph is inserted based on whether a soft (Shift+Enter) keystroke
     * was pressed or not.
     *
     * @private
     */

  }, {
    key: "_enableInsertingParagraphsOnEnterKeypress",
    value: function _enableInsertingParagraphsOnEnterKeypress() {
      var _this4 = this;

      var editor = this.editor;
      var editingView = editor.editing.view;
      this.listenTo(editingView.document, 'enter', function (evt, domEventData) {
        var selectedViewElement = editingView.document.selection.getSelectedElement();
        var selectedModelElement = editor.editing.mapper.toModelElement(selectedViewElement);
        var schema = editor.model.schema;
        var wasHandled; // First check if the widget is selected and there's a type around selection attribute associated
        // with the "fake caret" that would tell where to insert a new paragraph.

        if (_this4._insertParagraphAccordingToFakeCaretPosition()) {
          wasHandled = true;
        } // Then, if there is no selection attribute associated with the "fake caret", check if the widget
        // simply is selected and create a new paragraph according to the keystroke (Shift+)Enter.
        else if (isTypeAroundWidget(selectedViewElement, selectedModelElement, schema)) {
            _this4._insertParagraph(selectedModelElement, domEventData.isSoft ? 'before' : 'after');

            wasHandled = true;
          }

        if (wasHandled) {
          domEventData.preventDefault();
          evt.stop();
        }
      });
    }
    /**
     * Similar to the {@link #_enableInsertingParagraphsOnEnterKeypress}, it allows the user
     * to insert a paragraph next to a widget when the "fake caret" was activated using arrow
     * keys but it responds to "typing keystrokes" instead of "enter".
     *
     * "Typing keystrokes" are keystrokes that insert new content into the document
     * like, for instance, letters ("a") or numbers ("4"). The "keydown" listener enabled by this method
     * will insert a new paragraph according to the "widget-type-around" model selection attribute
     * as the user simply starts typing, which creates the impression that the "fake caret"
     * behaves like a "real one" rendered by the browser (AKA your text appears where the caret was).
     *
     * **Note**: ATM this listener creates 2 undo steps: one for the "insertParagraph" command
     * and the second for the actual typing. It's not a disaster but this may need to be fixed
     * sooner or later.
     *
     * Learn more in {@link module:typing/utils/injectunsafekeystrokeshandling}.
     *
     * @private
     */

  }, {
    key: "_enableInsertingParagraphsOnTypingKeystroke",
    value: function _enableInsertingParagraphsOnTypingKeystroke() {
      var _this5 = this;

      var editor = this.editor;
      var editingView = editor.editing.view;
      var keyCodesHandledSomewhereElse = [keyCodes.enter, keyCodes.delete, keyCodes.backspace]; // Note: The priority must precede the default Widget class keydown handler ("high") and the
      // TableKeyboard keydown handler ("high + 1").

      editingView.document.on('keydown', function (evt, domEventData) {
        // Don't handle enter/backspace/delete here. They are handled in dedicated listeners.
        if (!keyCodesHandledSomewhereElse.includes(domEventData.keyCode) && !isNonTypingKeystroke(domEventData)) {
          _this5._insertParagraphAccordingToFakeCaretPosition();
        }
      }, {
        priority: src_priorities.get('high') + 1
      });
    }
    /**
     * It creates a "delete" event listener on the view document to handle cases when delete/backspace
     * is pressed and the "fake caret" is currently active.
     *
     * The "fake caret" should create an illusion of a "real browser caret" so that when it appears
     * before/after a widget, pressing delete/backspace should remove a widget or delete a content
     * before/after a widget (depending on the content surrounding the widget).
     *
     * @private
     */

  }, {
    key: "_enableDeleteIntegration",
    value: function _enableDeleteIntegration() {
      var editor = this.editor;
      var editingView = editor.editing.view;
      var model = editor.model;
      var schema = model.schema; // Note: The priority must precede the default Widget class delete handler.

      this.listenTo(editingView.document, 'delete', function (evt, domEventData) {
        var typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(model.document.selection); // This listener handles only these cases when the "fake caret" is active.

        if (!typeAroundFakeCaretPosition) {
          return;
        }

        var direction = domEventData.direction;
        var selectedModelWidget = model.document.selection.getSelectedElement();
        var isFakeCaretBefore = typeAroundFakeCaretPosition === 'before';
        var isForwardDelete = direction == 'forward';
        var shouldDeleteEntireWidget = isFakeCaretBefore === isForwardDelete;

        if (shouldDeleteEntireWidget) {
          editor.execute('delete', {
            selection: model.createSelection(selectedModelWidget, 'on')
          });
        } else {
          var range = schema.getNearestSelectionRange(model.createPositionAt(selectedModelWidget, typeAroundFakeCaretPosition), direction); // If there is somewhere to move selection to, then there will be something to delete.

          if (range) {
            // If the range is NOT collapsed, then we know that the range contains an object (see getNearestSelectionRange() docs).
            if (!range.isCollapsed) {
              model.change(function (writer) {
                writer.setSelection(range);
                editor.execute(isForwardDelete ? 'forwardDelete' : 'delete');
              });
            } else {
              var probe = model.createSelection(range.start);
              model.modifySelection(probe, {
                direction: direction
              }); // If the range is collapsed, let's see if a non-collapsed range exists that can could be deleted.
              // If such range exists, use the editor command because it it safe for collaboration (it merges where it can).

              if (!probe.focus.isEqual(range.start)) {
                model.change(function (writer) {
                  writer.setSelection(range);
                  editor.execute(isForwardDelete ? 'forwardDelete' : 'delete');
                });
              } // If there is no non-collapsed range to be deleted then we are sure that there is an empty element
              // next to a widget that should be removed. "delete" and "forwardDelete" commands cannot get rid of it
              // so calling Model#deleteContent here manually.
              else {
                  var deepestEmptyRangeAncestor = getDeepestEmptyElementAncestor(schema, range.start.parent);
                  model.deleteContent(model.createSelection(deepestEmptyRangeAncestor, 'on'), {
                    doNotAutoparagraph: true
                  });
                }
            }
          }
        } // If some content was deleted, don't let the handler from the Widget plugin kick in.
        // If nothing was deleted, then the default handler will have nothing to do anyway.


        domEventData.preventDefault();
        evt.stop();
      }, {
        priority: src_priorities.get('high') + 1
      });
    }
    /**
     * Attaches the {@link module:engine/model/model~Model#event:insertContent} event listener that, for instance, allows the user to paste
     * content near a widget when the "fake caret" was first activated using the arrow keys.
     *
     * The content is inserted according to the "widget-type-around" selection attribute (see {@link #_handleArrowKeyPress}).
     *
     * @private
     */

  }, {
    key: "_enableInsertContentIntegration",
    value: function _enableInsertContentIntegration() {
      var editor = this.editor;
      var model = this.editor.model;
      var documentSelection = model.document.selection;
      this.listenTo(editor.model, 'insertContent', function (evt, _ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            content = _ref2[0],
            selectable = _ref2[1];

        if (selectable && !selectable.is('documentSelection')) {
          return;
        }

        var typeAroundFakeCaretPosition = getTypeAroundFakeCaretPosition(documentSelection);

        if (!typeAroundFakeCaretPosition) {
          return;
        }

        evt.stop();
        return model.change(function (writer) {
          var selectedElement = documentSelection.getSelectedElement();
          var position = model.createPositionAt(selectedElement, typeAroundFakeCaretPosition);
          var selection = writer.createSelection(position);
          var result = model.insertContent(content, selection);
          writer.setSelection(selection);
          return result;
        });
      }, {
        priority: 'high'
      });
    }
  }]);

  return WidgetTypeAround;
}(plugin_Plugin); // Injects the type around UI into a view widget instance.
//
// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter
// @param {Object.<String,String>} buttonTitles
// @param {module:engine/view/element~Element} widgetViewElement




function injectUIIntoWidget(viewWriter, buttonTitles, widgetViewElement) {
  var typeAroundWrapper = viewWriter.createUIElement('div', {
    class: 'ck ck-reset_all ck-widget__type-around'
  }, function (domDocument) {
    var wrapperDomElement = this.toDomElement(domDocument);
    injectButtons(wrapperDomElement, buttonTitles);
    injectFakeCaret(wrapperDomElement);
    return wrapperDomElement;
  }); // Inject the type around wrapper into the widget's wrapper.

  viewWriter.insert(viewWriter.createPositionAt(widgetViewElement, 'end'), typeAroundWrapper);
} // FYI: Not using the IconView class because each instance would need to be destroyed to avoid memory leaks
// and it's pretty hard to figure out when a view (widget) is gone for good so it's cheaper to use raw
// <svg> here.
//
// @param {HTMLElement} wrapperDomElement
// @param {Object.<String,String>} buttonTitles


function injectButtons(wrapperDomElement, buttonTitles) {
  var _iterator = _createForOfIteratorHelper(POSSIBLE_INSERTION_POSITIONS),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var position = _step.value;
      var buttonTemplate = new template_Template({
        tag: 'div',
        attributes: {
          class: ['ck', 'ck-widget__type-around__button', "ck-widget__type-around__button_".concat(position)],
          title: buttonTitles[position]
        },
        children: [wrapperDomElement.ownerDocument.importNode(RETURN_ARROW_ICON_ELEMENT, true)]
      });
      wrapperDomElement.appendChild(buttonTemplate.render());
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
} // @param {HTMLElement} wrapperDomElement


function injectFakeCaret(wrapperDomElement) {
  var caretTemplate = new template_Template({
    tag: 'div',
    attributes: {
      class: ['ck', 'ck-widget__type-around__fake-caret']
    }
  });
  wrapperDomElement.appendChild(caretTemplate.render());
} // Returns the ancestor of an element closest to the root which is empty. For instance,
// for `<baz>`:
//
//		<foo>abc<bar><baz></baz></bar></foo>
//
// it returns `<bar>`.
//
// @param {module:engine/model/schema~Schema} schema
// @param {module:engine/model/element~Element} element
// @returns {module:engine/model/element~Element|null}


function getDeepestEmptyElementAncestor(schema, element) {
  var deepestEmptyAncestor = element;

  var _iterator2 = _createForOfIteratorHelper(element.getAncestors({
    parentFirst: true
  })),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var ancestor = _step2.value;

      if (ancestor.childCount > 1 || schema.isLimit(ancestor)) {
        break;
      }

      deepestEmptyAncestor = ancestor;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return deepestEmptyAncestor;
}
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-widget/theme/widget.css
var theme_widget = __webpack_require__("fecc");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-widget/src/widget.js















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module widget/widget
 */








/**
 * The widget plugin. It enables base support for widgets.
 *
 * See {@glink api/widget package page} for more details and documentation.
 *
 * This plugin enables multiple behaviors required by widgets:
 *
 * * The model to view selection converter for the editing pipeline (it handles widget custom selection rendering).
 * If a converted selection wraps around a widget element, that selection is marked as
 * {@link module:engine/view/selection~Selection#isFake fake}. Additionally, the `ck-widget_selected` CSS class
 * is added to indicate that widget has been selected.
 * * The mouse and keyboard events handling on and around widget elements.
 *
 * @extends module:core/plugin~Plugin
 */

var widget_Widget = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(Widget, _Plugin);

  var _super = Object(createSuper["a" /* default */])(Widget);

  function Widget() {
    Object(classCallCheck["a" /* default */])(this, Widget);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Widget, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this = this;

      var view = this.editor.editing.view;
      var viewDocument = view.document;
      /**
       * Holds previously selected widgets.
       *
       * @private
       * @type {Set.<module:engine/view/element~Element>}
       */

      this._previouslySelected = new Set(); // Model to view selection converter.
      // Converts selection placed over widget element to fake selection

      this.editor.editing.downcastDispatcher.on('selection', function (evt, data, conversionApi) {
        // Remove selected class from previously selected widgets.
        _this._clearPreviouslySelectedWidgets(conversionApi.writer);

        var viewWriter = conversionApi.writer;
        var viewSelection = viewWriter.document.selection;
        var selectedElement = viewSelection.getSelectedElement();
        var lastMarked = null;

        var _iterator = _createForOfIteratorHelper(viewSelection.getRanges()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var range = _step.value;

            var _iterator2 = _createForOfIteratorHelper(range),
                _step2;

            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var value = _step2.value;
                var node = value.item; // Do not mark nested widgets in selected one. See: #57.

                if (isWidget(node) && !isChild(node, lastMarked)) {
                  viewWriter.addClass(WIDGET_SELECTED_CLASS_NAME, node);

                  _this._previouslySelected.add(node);

                  lastMarked = node; // Check if widget is a single element selected.

                  if (node == selectedElement) {
                    viewWriter.setSelection(viewSelection.getRanges(), {
                      fake: true,
                      label: getLabel(selectedElement)
                    });
                  }
                }
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }, {
        priority: 'low'
      }); // If mouse down is pressed on widget - create selection over whole widget.

      view.addObserver(mouseobserver_MouseObserver);
      this.listenTo(viewDocument, 'mousedown', function () {
        return _this._onMousedown.apply(_this, arguments);
      }); // There are two keydown listeners working on different priorities. This allows other
      // features such as WidgetTypeAround or TableKeyboard to attach their listeners in between
      // and customize the behavior even further in different content/selection scenarios.
      //
      // * The first listener handles changing the selection on arrow key press
      // if the widget is selected or if the selection is next to a widget and the widget
      // should become selected upon the arrow key press.
      //
      // * The second (late) listener makes sure the default browser action on arrow key press is
      // prevented when a widget is selected. This prevents the selection from being moved
      // from a fake selection container.

      this.listenTo(viewDocument, 'keydown', function () {
        _this._handleSelectionChangeOnArrowKeyPress.apply(_this, arguments);
      }, {
        priority: 'high'
      });
      this.listenTo(viewDocument, 'keydown', function () {
        _this._preventDefaultOnArrowKeyPress.apply(_this, arguments);
      }, {
        priority: src_priorities.get('high') - 20
      }); // Handle custom delete behaviour.

      this.listenTo(viewDocument, 'delete', function (evt, data) {
        if (_this._handleDelete(data.direction == 'forward')) {
          data.preventDefault();
          evt.stop();
        }
      }, {
        priority: 'high'
      });
    }
    /**
     * Handles {@link module:engine/view/document~Document#event:mousedown mousedown} events on widget elements.
     *
     * @private
     * @param {module:utils/eventinfo~EventInfo} eventInfo
     * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData
     */

  }, {
    key: "_onMousedown",
    value: function _onMousedown(eventInfo, domEventData) {
      var editor = this.editor;
      var view = editor.editing.view;
      var viewDocument = view.document;
      var element = domEventData.target; // Do nothing for single or double click inside nested editable.

      if (isInsideNestedEditable(element)) {
        // But at least triple click inside nested editable causes broken selection in Safari.
        // For such event, we select the entire nested editable element.
        // See: https://github.com/ckeditor/ckeditor5/issues/1463.
        if (src_env.isSafari && domEventData.domEvent.detail >= 3) {
          var mapper = editor.editing.mapper;

          var _modelElement = mapper.toModelElement(element);

          this.editor.model.change(function (writer) {
            domEventData.preventDefault();
            writer.setSelection(_modelElement, 'in');
          });
        }

        return;
      } // If target is not a widget element - check if one of the ancestors is.


      if (!isWidget(element)) {
        element = element.findAncestor(isWidget);

        if (!element) {
          return;
        }
      }

      domEventData.preventDefault(); // Focus editor if is not focused already.

      if (!viewDocument.isFocused) {
        view.focus();
      } // Create model selection over widget.


      var modelElement = editor.editing.mapper.toModelElement(element);

      this._setSelectionOverElement(modelElement);
    }
    /**
     * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and changes
     * the model selection when:
     *
     * * arrow key is pressed when the widget is selected,
     * * the selection is next to a widget and the widget should become selected upon the arrow key press.
     *
     * See {@link #_preventDefaultOnArrowKeyPress}.
     *
     * @private
     * @param {module:utils/eventinfo~EventInfo} eventInfo
     * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData
     */

  }, {
    key: "_handleSelectionChangeOnArrowKeyPress",
    value: function _handleSelectionChangeOnArrowKeyPress(eventInfo, domEventData) {
      var keyCode = domEventData.keyCode; // Checks if the keys were handled and then prevents the default event behaviour and stops
      // the propagation.

      if (!isArrowKeyCode(keyCode)) {
        return;
      }

      var model = this.editor.model;
      var schema = model.schema;
      var modelSelection = model.document.selection;
      var objectElement = modelSelection.getSelectedElement();
      var isForward = isForwardArrowKeyCode(keyCode, this.editor.locale.contentLanguageDirection); // If object element is selected.

      if (objectElement && schema.isObject(objectElement)) {
        var position = isForward ? modelSelection.getLastPosition() : modelSelection.getFirstPosition();
        var newRange = schema.getNearestSelectionRange(position, isForward ? 'forward' : 'backward');

        if (newRange) {
          model.change(function (writer) {
            writer.setSelection(newRange);
          });
          domEventData.preventDefault();
          eventInfo.stop();
        }

        return;
      } // If selection is next to object element.
      // Return if not collapsed.


      if (!modelSelection.isCollapsed) {
        return;
      }

      var objectElementNextToSelection = this._getObjectElementNextToSelection(isForward);

      if (objectElementNextToSelection && schema.isObject(objectElementNextToSelection)) {
        this._setSelectionOverElement(objectElementNextToSelection);

        domEventData.preventDefault();
        eventInfo.stop();
      }
    }
    /**
     * Handles {@link module:engine/view/document~Document#event:keydown keydown} events and prevents
     * the default browser behavior to make sure the fake selection is not being moved from a fake selection
     * container.
     *
     * See {@link #_handleSelectionChangeOnArrowKeyPress}.
     *
     * @private
     * @param {module:utils/eventinfo~EventInfo} eventInfo
     * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData
     */

  }, {
    key: "_preventDefaultOnArrowKeyPress",
    value: function _preventDefaultOnArrowKeyPress(eventInfo, domEventData) {
      var keyCode = domEventData.keyCode; // Checks if the keys were handled and then prevents the default event behaviour and stops
      // the propagation.

      if (!isArrowKeyCode(keyCode)) {
        return;
      }

      var model = this.editor.model;
      var schema = model.schema;
      var objectElement = model.document.selection.getSelectedElement(); // If object element is selected.

      if (objectElement && schema.isObject(objectElement)) {
        domEventData.preventDefault();
        eventInfo.stop();
      }
    }
    /**
     * Handles delete keys: backspace and delete.
     *
     * @private
     * @param {Boolean} isForward Set to true if delete was performed in forward direction.
     * @returns {Boolean|undefined} Returns `true` if keys were handled correctly.
     */

  }, {
    key: "_handleDelete",
    value: function _handleDelete(isForward) {
      var _this2 = this;

      // Do nothing when the read only mode is enabled.
      if (this.editor.isReadOnly) {
        return;
      }

      var modelDocument = this.editor.model.document;
      var modelSelection = modelDocument.selection; // Do nothing on non-collapsed selection.

      if (!modelSelection.isCollapsed) {
        return;
      }

      var objectElement = this._getObjectElementNextToSelection(isForward);

      if (objectElement) {
        this.editor.model.change(function (writer) {
          var previousNode = modelSelection.anchor.parent; // Remove previous element if empty.

          while (previousNode.isEmpty) {
            var nodeToRemove = previousNode;
            previousNode = nodeToRemove.parent;
            writer.remove(nodeToRemove);
          }

          _this2._setSelectionOverElement(objectElement);
        });
        return true;
      }
    }
    /**
     * Sets {@link module:engine/model/selection~Selection document's selection} over given element.
     *
     * @protected
     * @param {module:engine/model/element~Element} element
     */

  }, {
    key: "_setSelectionOverElement",
    value: function _setSelectionOverElement(element) {
      this.editor.model.change(function (writer) {
        writer.setSelection(writer.createRangeOn(element));
      });
    }
    /**
     * Checks if {@link module:engine/model/element~Element element} placed next to the current
     * {@link module:engine/model/selection~Selection model selection} exists and is marked in
     * {@link module:engine/model/schema~Schema schema} as `object`.
     *
     * @protected
     * @param {Boolean} forward Direction of checking.
     * @returns {module:engine/model/element~Element|null}
     */

  }, {
    key: "_getObjectElementNextToSelection",
    value: function _getObjectElementNextToSelection(forward) {
      var model = this.editor.model;
      var schema = model.schema;
      var modelSelection = model.document.selection; // Clone current selection to use it as a probe. We must leave default selection as it is so it can return
      // to its current state after undo.

      var probe = model.createSelection(modelSelection);
      model.modifySelection(probe, {
        direction: forward ? 'forward' : 'backward'
      });
      var objectElement = forward ? probe.focus.nodeBefore : probe.focus.nodeAfter;

      if (!!objectElement && schema.isObject(objectElement)) {
        return objectElement;
      }

      return null;
    }
    /**
     * Removes CSS class from previously selected widgets.
     *
     * @private
     * @param {module:engine/view/downcastwriter~DowncastWriter} writer
     */

  }, {
    key: "_clearPreviouslySelectedWidgets",
    value: function _clearPreviouslySelectedWidgets(writer) {
      var _iterator3 = _createForOfIteratorHelper(this._previouslySelected),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var widget = _step3.value;
          writer.removeClass(WIDGET_SELECTED_CLASS_NAME, widget);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this._previouslySelected.clear();
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'Widget';
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "requires",
    get: function get() {
      return [widgettypearound_WidgetTypeAround];
    }
  }]);

  return Widget;
}(plugin_Plugin); // Returns `true` when element is a nested editable or is placed inside one.
//
// @param {module:engine/view/element~Element}
// @returns {Boolean}




function isInsideNestedEditable(element) {
  while (element) {
    if (element.is('editableElement') && !element.is('rootElement')) {
      return true;
    } // Click on nested widget should select it.


    if (isWidget(element)) {
      return false;
    }

    element = element.parent;
  }

  return false;
} // Checks whether the specified `element` is a child of the `parent` element.
//
// @param {module:engine/view/element~Element} element An element to check.
// @param {module:engine/view/element~Element|null} parent A parent for the element.
// @returns {Boolean}


function isChild(element, parent) {
  if (!parent) {
    return false;
  }

  return Array.from(element.getAncestors()).includes(parent);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imagetextalternative/imagetextalternativecommand.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imagetextalternative/imagetextalternativecommand
 */


/**
 * The image text alternative command. It is used to change the `alt` attribute of `<image>` elements.
 *
 * @extends module:core/command~Command
 */

var imagetextalternativecommand_ImageTextAlternativeCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(ImageTextAlternativeCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(ImageTextAlternativeCommand);

  function ImageTextAlternativeCommand() {
    Object(classCallCheck["a" /* default */])(this, ImageTextAlternativeCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ImageTextAlternativeCommand, [{
    key: "refresh",

    /**
     * The command value: `false` if there is no `alt` attribute, otherwise the value of the `alt` attribute.
     *
     * @readonly
     * @observable
     * @member {String|Boolean} #value
     */

    /**
     * @inheritDoc
     */
    value: function refresh() {
      var element = this.editor.model.document.selection.getSelectedElement();
      this.isEnabled = isImage(element);

      if (isImage(element) && element.hasAttribute('alt')) {
        this.value = element.getAttribute('alt');
      } else {
        this.value = false;
      }
    }
    /**
     * Executes the command.
     *
     * @fires execute
     * @param {Object} options
     * @param {String} options.newValue The new value of the `alt` attribute to set.
     */

  }, {
    key: "execute",
    value: function execute(options) {
      var model = this.editor.model;
      var imageElement = model.document.selection.getSelectedElement();
      model.change(function (writer) {
        writer.setAttribute('alt', options.newValue, imageElement);
      });
    }
  }]);

  return ImageTextAlternativeCommand;
}(command_Command);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imagetextalternative/imagetextalternativeediting.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imagetextalternative/imagetextalternativeediting
 */


/**
 * The image text alternative editing plugin.
 *
 * Registers the `'imageTextAlternative'` command.
 *
 * @extends module:core/plugin~Plugin
 */

var imagetextalternativeediting_ImageTextAlternativeEditing = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ImageTextAlternativeEditing, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ImageTextAlternativeEditing);

  function ImageTextAlternativeEditing() {
    Object(classCallCheck["a" /* default */])(this, ImageTextAlternativeEditing);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ImageTextAlternativeEditing, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      this.editor.commands.add('imageTextAlternative', new imagetextalternativecommand_ImageTextAlternativeCommand(this.editor));
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'ImageTextAlternativeEditing';
    }
  }]);

  return ImageTextAlternativeEditing;
}(plugin_Plugin);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/components/labeledfield/labeledfieldview.css
var labeledfieldview = __webpack_require__("d2df");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/labeledfield/labeledfieldview.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/labeledfield/labeledfieldview
 */




/**
 * The labeled field view class. It can be used to enhance any view with the following features:
 *
 * * a label,
 * * (optional) an error message,
 * * (optional) an info (status) text,
 *
 * all bound logically by proper DOM attributes for UX and accessibility.  It also provides an interface
 * (e.g. observable properties) that allows controlling those additional features.
 *
 * The constructor of this class requires a callback that returns a view to be labeled. The callback
 * is called with unique ids that allow binding of DOM properties:
 *
 *		const labeledInputView = new LabeledFieldView( locale, ( labeledFieldView, viewUid, statusUid ) => {
 *			const inputView = new InputTextView( labeledFieldView.locale );
 *
 *			inputView.set( {
 *				id: viewUid,
 *				ariaDescribedById: statusUid
 *			} );
 *
 *			inputView.bind( 'isReadOnly' ).to( labeledFieldView, 'isEnabled', value => !value );
 *			inputView.bind( 'hasError' ).to( labeledFieldView, 'errorText', value => !!value );
 *
 *			return inputView;
 *		} );
 *
 *		labeledInputView.label = 'User name';
 *		labeledInputView.infoText = 'Full name like for instance, John Doe.';
 *		labeledInputView.render();
 *
 *		document.body.append( labeledInputView.element );
 *
 * See {@link module:ui/labeledfield/utils} to discover ready–to–use labeled input helpers for common
 * UI components.
 *
 * @extends module:ui/view~View
 */

var labeledfieldview_LabeledFieldView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(LabeledFieldView, _View);

  var _super = Object(createSuper["a" /* default */])(LabeledFieldView);

  /**
   * Creates an instance of the labeled field view class using a provided creator function
   * that provides the view to be labeled.
   *
   * @param {module:utils/locale~Locale} locale The locale instance.
   * @param {Function} viewCreator A function that returns a {@link module:ui/view~View}
   * that will be labeled. The following arguments are passed to the creator function:
   *
   * * an instance of the `LabeledFieldView` to allow binding observable properties,
   * * an UID string that connects the {@link #labelView label} and the labeled field view in DOM,
   * * an UID string that connects the {@link #statusView status} and the labeled field view in DOM.
   */
  function LabeledFieldView(locale, viewCreator) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, LabeledFieldView);

    _this = _super.call(this, locale);
    var viewUid = "ck-labeled-field-view-".concat(uid_uid());
    var statusUid = "ck-labeled-field-view-status-".concat(uid_uid());
    /**
     * The field view that gets labeled.
     *
     * @member {module:ui/view~View} #fieldView
     */

    _this.fieldView = viewCreator(Object(assertThisInitialized["a" /* default */])(_this), viewUid, statusUid);
    /**
     * The text of the label.
     *
     * @observable
     * @member {String} #label
     */

    _this.set('label');
    /**
     * Controls whether the component is in read-only mode.
     *
     * @observable
     * @member {Boolean} #isEnabled
     */


    _this.set('isEnabled', true);
    /**
     * The validation error text. When set, it will be displayed
     * next to the {@link #fieldView} as a typical validation error message.
     * Set it to `null` to hide the message.
     *
     * **Note:** Setting this property to anything but `null` will automatically
     * make the `hasError` of the {@link #fieldView} `true`.
     *
     * @observable
     * @member {String|null} #errorText
     */


    _this.set('errorText', null);
    /**
     * The additional information text displayed next to the {@link #fieldView} which can
     * be used to inform the user about its purpose, provide help or hints.
     *
     * Set it to `null` to hide the message.
     *
     * **Note:** This text will be displayed in the same place as {@link #errorText} but the
     * latter always takes precedence: if the {@link #errorText} is set, it replaces
     * {@link #infoText}.
     *
     * @observable
     * @member {String|null} #infoText
     */


    _this.set('infoText', null);
    /**
     * (Optional) The additional CSS class set on the dropdown {@link #element}.
     *
     * @observable
     * @member {String} #class
     */


    _this.set('class');
    /**
     * The label view instance that describes the entire view.
     *
     * @member {module:ui/label/labelview~LabelView} #labelView
     */


    _this.labelView = _this._createLabelView(viewUid);
    /**
     * The status view for the {@link #fieldView}. It displays {@link #errorText} and
     * {@link #infoText}.
     *
     * @member {module:ui/view~View} #statusView
     */

    _this.statusView = _this._createStatusView(statusUid);
    /**
     * The combined status text made of {@link #errorText} and {@link #infoText}.
     * Note that when present, {@link #errorText} always takes precedence in the
     * status.
     *
     * @see #errorText
     * @see #infoText
     * @see #statusView
     * @private
     * @observable
     * @member {String|null} #_statusText
     */

    _this.bind('_statusText').to(Object(assertThisInitialized["a" /* default */])(_this), 'errorText', Object(assertThisInitialized["a" /* default */])(_this), 'infoText', function (errorText, infoText) {
      return errorText || infoText;
    });

    var bind = _this.bindTemplate;

    _this.setTemplate({
      tag: 'div',
      attributes: {
        class: ['ck', 'ck-labeled-field-view', bind.to('class'), bind.if('isEnabled', 'ck-disabled', function (value) {
          return !value;
        })]
      },
      children: [_this.labelView, _this.fieldView, _this.statusView]
    });

    return _this;
  }
  /**
   * Creates label view class instance and bind with view.
   *
   * @private
   * @param {String} id Unique id to set as labelView#for attribute.
   * @returns {module:ui/label/labelview~LabelView}
   */


  Object(createClass["a" /* default */])(LabeledFieldView, [{
    key: "_createLabelView",
    value: function _createLabelView(id) {
      var labelView = new labelview_LabelView(this.locale);
      labelView.for = id;
      labelView.bind('text').to(this, 'label');
      return labelView;
    }
    /**
     * Creates the status view instance. It displays {@link #errorText} and {@link #infoText}
     * next to the {@link #fieldView}. See {@link #_statusText}.
     *
     * @private
     * @param {String} statusUid Unique id of the status, shared with the {@link #fieldView view's}
     * `aria-describedby` attribute.
     * @returns {module:ui/view~View}
     */

  }, {
    key: "_createStatusView",
    value: function _createStatusView(statusUid) {
      var statusView = new src_view_View(this.locale);
      var bind = this.bindTemplate;
      statusView.setTemplate({
        tag: 'div',
        attributes: {
          class: ['ck', 'ck-labeled-field-view__status', bind.if('errorText', 'ck-labeled-field-view__status_error'), bind.if('_statusText', 'ck-hidden', function (value) {
            return !value;
          })],
          id: statusUid,
          role: bind.if('errorText', 'alert')
        },
        children: [{
          text: bind.to('_statusText')
        }]
      });
      return statusView;
    }
    /**
     * Focuses the {@link #fieldView}.
     */

  }, {
    key: "focus",
    value: function focus() {
      this.fieldView.focus();
    }
  }]);

  return LabeledFieldView;
}(src_view_View);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/components/inputtext/inputtext.css
var inputtext = __webpack_require__("3d1d");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/inputtext/inputtextview.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/inputtext/inputtextview
 */


/**
 * The text input view class.
 *
 * @extends module:ui/view~View
 */

var inputtextview_InputTextView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(InputTextView, _View);

  var _super = Object(createSuper["a" /* default */])(InputTextView);

  /**
   * @inheritDoc
   */
  function InputTextView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, InputTextView);

    _this = _super.call(this, locale);
    /**
     * The value of the input.
     *
     * @observable
     * @member {String} #value
     */

    _this.set('value');
    /**
     * The `id` attribute of the input (i.e. to pair with a `<label>` element).
     *
     * @observable
     * @member {String} #id
     */


    _this.set('id');
    /**
     * The `placeholder` attribute of the input.
     *
     * @observable
     * @member {String} #placeholder
     */


    _this.set('placeholder');
    /**
     * Controls whether the input view is in read-only mode.
     *
     * @observable
     * @member {Boolean} #isReadOnly
     */


    _this.set('isReadOnly', false);
    /**
     * Set to `true` when the field has some error. Usually controlled via
     * {@link module:ui/labeledinput/labeledinputview~LabeledInputView#errorText}.
     *
     * @observable
     * @member {Boolean} #hasError
     */


    _this.set('hasError', false);
    /**
     * The `id` of the element describing this field, e.g. when it has
     * some error, it helps screen readers read the error text.
     *
     * @observable
     * @member {Boolean} #ariaDescribedById
     */


    _this.set('ariaDescribedById');

    var bind = _this.bindTemplate;

    _this.setTemplate({
      tag: 'input',
      attributes: {
        type: 'text',
        class: ['ck', 'ck-input', 'ck-input-text', bind.if('hasError', 'ck-error')],
        id: bind.to('id'),
        placeholder: bind.to('placeholder'),
        readonly: bind.to('isReadOnly'),
        'aria-invalid': bind.if('hasError', true),
        'aria-describedby': bind.to('ariaDescribedById')
      },
      on: {
        input: bind.to('input')
      }
    });
    /**
     * Fired when the user types in the input. Corresponds to the native
     * DOM `input` event.
     *
     * @event input
     */


    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(InputTextView, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      get_get(Object(getPrototypeOf["a" /* default */])(InputTextView.prototype), "render", this).call(this);

      var setValue = function setValue(value) {
        _this2.element.value = !value && value !== 0 ? '' : value;
      };

      setValue(this.value); // Bind `this.value` to the DOM element's value.
      // We cannot use `value` DOM attribute because removing it on Edge does not clear the DOM element's value property.

      this.on('change:value', function (evt, name, value) {
        setValue(value);
      });
    }
    /**
     * Moves the focus to the input and selects the value.
     */

  }, {
    key: "select",
    value: function select() {
      this.element.select();
    }
    /**
     * Focuses the input.
     */

  }, {
    key: "focus",
    value: function focus() {
      this.element.focus();
    }
  }]);

  return InputTextView;
}(src_view_View);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/labeledfield/utils.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/labeledfield/utils
 */


/**
 * A helper for creating labeled inputs.
 *
 * It creates an instance of a {@link module:ui/inputtext/inputtextview~InputTextView input text} that is
 * logically related to a {@link module:ui/labeledfield/labeledfieldview~LabeledFieldView labeled view} in DOM.
 *
 * The helper does the following:
 *
 * * It sets input's `id` and `ariaDescribedById` attributes.
 * * It binds input's `isReadOnly` to the labeled view.
 * * It binds input's `hasError` to the labeled view.
 * * It enables a logic that cleans up the error when user starts typing in the input..
 *
 * Usage:
 *
 *		const labeledInputView = new LabeledFieldView( locale, createLabeledDropdown );
 *		console.log( labeledInputView.view ); // An input instance.
 *
 * @param {module:ui/labeledfield/labeledfieldview~LabeledFieldView} labeledFieldView The instance of the labeled field view.
 * @param {String} viewUid An UID string that allows DOM logical connection between the
 * {@link module:ui/labeledfield/labeledfieldview~LabeledFieldView#labelView labeled view's label} and the input.
 * @param {String} statusUid An UID string that allows DOM logical connection between the
 * {@link module:ui/labeledfield/labeledfieldview~LabeledFieldView#statusView labeled view's status} and the input.
 * @returns {module:ui/inputtext/inputtextview~InputTextView} The input text view instance.
 */

function createLabeledInputText(labeledFieldView, viewUid, statusUid) {
  var inputView = new inputtextview_InputTextView(labeledFieldView.locale);
  inputView.set({
    id: viewUid,
    ariaDescribedById: statusUid
  });
  inputView.bind('isReadOnly').to(labeledFieldView, 'isEnabled', function (value) {
    return !value;
  });
  inputView.bind('hasError').to(labeledFieldView, 'errorText', function (value) {
    return !!value;
  });
  inputView.on('input', function () {
    // UX: Make the error text disappear and disable the error indicator as the user
    // starts fixing the errors.
    labeledFieldView.errorText = null;
  });
  return inputView;
}
/**
 * A helper for creating labeled dropdowns.
 *
 * It creates an instance of a {@link module:ui/dropdown/dropdownview~DropdownView dropdown} that is
 * logically related to a {@link module:ui/labeledfield/labeledfieldview~LabeledFieldView labeled field view}.
 *
 * The helper does the following:
 *
 * * It sets dropdown's `id` and `ariaDescribedById` attributes.
 * * It binds input's `isEnabled` to the labeled view.
 *
 * Usage:
 *
 *		const labeledInputView = new LabeledFieldView( locale, createLabeledDropdown );
 *		console.log( labeledInputView.view ); // A dropdown instance.
 *
 * @param {module:ui/labeledfield/labeledfieldview~LabeledFieldView} labeledFieldView The instance of the labeled field view.
 * @param {String} viewUid An UID string that allows DOM logical connection between the
 * {@link module:ui/labeledfield/labeledfieldview~LabeledFieldView#labelView labeled view label} and the dropdown.
 * @param {String} statusUid An UID string that allows DOM logical connection between the
 * {@link module:ui/labeledfield/labeledfieldview~LabeledFieldView#statusView labeled view status} and the dropdown.
 * @returns {module:ui/dropdown/dropdownview~DropdownView} The dropdown view instance.
 */

function createLabeledDropdown(labeledFieldView, viewUid, statusUid) {
  var dropdownView = createDropdown(labeledFieldView.locale);
  dropdownView.set({
    id: viewUid,
    ariaDescribedById: statusUid
  });
  dropdownView.bind('isEnabled').to(labeledFieldView);
  return dropdownView;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/bindings/submithandler.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/bindings/submithandler
 */

/**
 * A handler useful for {@link module:ui/view~View views} working as HTML forms. It intercepts a native DOM
 * `submit` event, prevents the default web browser behavior (navigation and page reload) and
 * fires the `submit` event on a view instead. Such a custom event can be then used by any
 * {@link module:utils/dom/emittermixin~Emitter emitter}, e.g. to serialize the form data.
 *
 *		import submitHandler from '@ckeditor/ckeditor5-ui/src/bindings/submithandler';
 *
 *		// ...
 *
 *		class AnyFormView extends View {
 *			constructor() {
 *				super();
 *
 *				// ...
 *
 *				submitHandler( {
 *					view: this
 *				} );
 *			}
 *		}
 *
 *		// ...
 *
 *		const view = new AnyFormView();
 *
 *		// A sample listener attached by an emitter working with the view.
 *		this.listenTo( view, 'submit', () => {
 *			saveTheFormData();
 *			hideTheForm();
 *		} );
 *
 * @param {Object} [options] Configuration options.
 * @param {module:ui/view~View} options.view The view which DOM `submit` events should be handled.
 */
function submitHandler(_ref) {
  var view = _ref.view;
  view.listenTo(view.element, 'submit', function (evt, domEvt) {
    domEvt.preventDefault();
    view.fire('submit');
  }, {
    useCapture: true
  });
}
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-core/theme/icons/check.svg
var check = __webpack_require__("18ce");
var check_default = /*#__PURE__*/__webpack_require__.n(check);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-core/theme/icons/cancel.svg
var icons_cancel = __webpack_require__("8ef8");
var cancel_default = /*#__PURE__*/__webpack_require__.n(icons_cancel);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-image/theme/textalternativeform.css
var textalternativeform = __webpack_require__("6649");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imagetextalternative/ui/textalternativeformview.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imagetextalternative/ui/textalternativeformview
 */












/**
 * The TextAlternativeFormView class.
 *
 * @extends module:ui/view~View
 */

var textalternativeformview_TextAlternativeFormView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(TextAlternativeFormView, _View);

  var _super = Object(createSuper["a" /* default */])(TextAlternativeFormView);

  /**
   * @inheritDoc
   */
  function TextAlternativeFormView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, TextAlternativeFormView);

    _this = _super.call(this, locale);
    var t = _this.locale.t;
    /**
     * Tracks information about the DOM focus in the form.
     *
     * @readonly
     * @member {module:utils/focustracker~FocusTracker}
     */

    _this.focusTracker = new focustracker_FocusTracker();
    /**
     * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
     *
     * @readonly
     * @member {module:utils/keystrokehandler~KeystrokeHandler}
     */

    _this.keystrokes = new keystrokehandler_KeystrokeHandler();
    /**
     * An input with a label.
     *
     * @member {module:ui/labeledfield/labeledfieldview~LabeledFieldView} #labeledInput
     */

    _this.labeledInput = _this._createLabeledInputView();
    /**
     * A button used to submit the form.
     *
     * @member {module:ui/button/buttonview~ButtonView} #saveButtonView
     */

    _this.saveButtonView = _this._createButton(t('Save'), check_default.a, 'ck-button-save');
    _this.saveButtonView.type = 'submit';
    /**
     * A button used to cancel the form.
     *
     * @member {module:ui/button/buttonview~ButtonView} #cancelButtonView
     */

    _this.cancelButtonView = _this._createButton(t('Cancel'), cancel_default.a, 'ck-button-cancel', 'cancel');
    /**
     * A collection of views which can be focused in the form.
     *
     * @readonly
     * @protected
     * @member {module:ui/viewcollection~ViewCollection}
     */

    _this._focusables = new viewcollection_ViewCollection();
    /**
     * Helps cycling over {@link #_focusables} in the form.
     *
     * @readonly
     * @protected
     * @member {module:ui/focuscycler~FocusCycler}
     */

    _this._focusCycler = new focuscycler_FocusCycler({
      focusables: _this._focusables,
      focusTracker: _this.focusTracker,
      keystrokeHandler: _this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: 'shift + tab',
        // Navigate form fields forwards using the Tab key.
        focusNext: 'tab'
      }
    });

    _this.setTemplate({
      tag: 'form',
      attributes: {
        class: ['ck', 'ck-text-alternative-form'],
        // https://github.com/ckeditor/ckeditor5-image/issues/40
        tabindex: '-1'
      },
      children: [_this.labeledInput, _this.saveButtonView, _this.cancelButtonView]
    });

    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(TextAlternativeFormView, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      get_get(Object(getPrototypeOf["a" /* default */])(TextAlternativeFormView.prototype), "render", this).call(this);

      this.keystrokes.listenTo(this.element);
      submitHandler({
        view: this
      });
      [this.labeledInput, this.saveButtonView, this.cancelButtonView].forEach(function (v) {
        // Register the view as focusable.
        _this2._focusables.add(v); // Register the view in the focus tracker.


        _this2.focusTracker.add(v.element);
      });
    }
    /**
     * Creates the button view.
     *
     * @private
     * @param {String} label The button label
     * @param {String} icon The button's icon.
     * @param {String} className The additional button CSS class name.
     * @param {String} [eventName] The event name that the ButtonView#execute event will be delegated to.
     * @returns {module:ui/button/buttonview~ButtonView} The button view instance.
     */

  }, {
    key: "_createButton",
    value: function _createButton(label, icon, className, eventName) {
      var button = new buttonview_ButtonView(this.locale);
      button.set({
        label: label,
        icon: icon,
        tooltip: true
      });
      button.extendTemplate({
        attributes: {
          class: className
        }
      });

      if (eventName) {
        button.delegate('execute').to(this, eventName);
      }

      return button;
    }
    /**
     * Creates an input with a label.
     *
     * @private
     * @returns {module:ui/labeledfield/labeledfieldview~LabeledFieldView} Labeled field view instance.
     */

  }, {
    key: "_createLabeledInputView",
    value: function _createLabeledInputView() {
      var t = this.locale.t;
      var labeledInput = new labeledfieldview_LabeledFieldView(this.locale, createLabeledInputText);
      labeledInput.label = t('Text alternative');
      labeledInput.fieldView.placeholder = t('Text alternative');
      return labeledInput;
    }
  }]);

  return TextAlternativeFormView;
}(src_view_View);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/icons/previous-arrow.svg
var previous_arrow = __webpack_require__("74c7");
var previous_arrow_default = /*#__PURE__*/__webpack_require__.n(previous_arrow);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/icons/next-arrow.svg
var next_arrow = __webpack_require__("f422");
var next_arrow_default = /*#__PURE__*/__webpack_require__.n(next_arrow);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/balloonrotator.css
var balloonrotator = __webpack_require__("e348");

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/components/panel/fakepanel.css
var fakepanel = __webpack_require__("51a6");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/panel/balloon/contextualballoon.js


















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/panel/balloon/contextualballoon
 */












var contextualballoon_toPx = toUnit('px');
/**
 * Provides the common contextual balloon for the editor.
 *
 * The role of this plugin is to unify the contextual balloons logic, simplify views management and help
 * avoid the unnecessary complexity of handling multiple {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView}
 * instances in the editor.
 *
 * This plugin allows for creating single or multiple panel stacks.
 *
 * Each stack may have multiple views, with the one on the top being visible. When the visible view is removed from the stack,
 * the previous view becomes visible.
 *
 * It might be useful to implement nested navigation in a balloon. For instance, a toolbar view may contain a link button.
 * When you click it, a link view (which lets you set the URL) is created and put on top of the toolbar view, so the link panel
 * is displayed. When you finish editing the link and close (remove) the link view, the toolbar view is visible again.
 *
 * However, there are cases when there are multiple independent balloons to be displayed, for instance, if the selection
 * is inside two inline comments at the same time. For such cases, you can create two independent panel stacks.
 * The contextual balloon plugin will create a navigation bar to let the users switch between these panel stacks using the "Next"
 * and "Previous" buttons.
 *
 * If there are no views in the current stack, the balloon panel will try to switch to the next stack. If there are no
 * panels in any stack, the balloon panel will be hidden.
 *
 * **Note**: To force the balloon panel to show only one view, even if there are other stacks, use the `singleViewMode=true` option
 * when {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon#add adding} a view to a panel.
 *
 * From the implementation point of view, the contextual ballon plugin is reusing a single
 * {@link module:ui/panel/balloon/balloonpanelview~BalloonPanelView} instance to display multiple contextual balloon
 * panels in the editor. It also creates a special {@link module:ui/panel/balloon/contextualballoon~RotatorView rotator view},
 * used to manage multiple panel stacks. Rotator view is a child of the balloon panel view and the parent of the specific
 * view you want to display. If there is more than one panel stack to be displayed, the rotator view will add a
 * navigation bar. If there is only one stack, the rotator view is transparent (it does not add any UI elements).
 *
 * @extends module:core/plugin~Plugin
 */

var contextualballoon_ContextualBalloon = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ContextualBalloon, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ContextualBalloon);

  Object(createClass["a" /* default */])(ContextualBalloon, null, [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'ContextualBalloon';
    }
    /**
     * @inheritDoc
     */

  }]);

  function ContextualBalloon(editor) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, ContextualBalloon);

    _this = _super.call(this, editor);
    /**
     * The {@link module:utils/dom/position~Options#limiter position limiter}
     * for the {@link #view balloon}, used when no `limiter` has been passed into {@link #add}
     * or {@link #updatePosition}.
     *
     * By default, a function that obtains the farthest DOM
     * {@link module:engine/view/rooteditableelement~RootEditableElement}
     * of the {@link module:engine/view/document~Document#selection}.
     *
     * @member {module:utils/dom/position~Options#limiter} #positionLimiter
     */

    _this.positionLimiter = function () {
      var view = _this.editor.editing.view;
      var viewDocument = view.document;
      var editableElement = viewDocument.selection.editableElement;

      if (editableElement) {
        return view.domConverter.mapViewToDom(editableElement.root);
      }

      return null;
    };
    /**
     * The currently visible view or `null` when there are no views in any stack.
     *
     * @readonly
     * @observable
     * @member {module:ui/view~View|null} #visibleView
     */


    _this.set('visibleView', null);
    /**
     * The common balloon panel view.
     *
     * @readonly
     * @member {module:ui/panel/balloon/balloonpanelview~BalloonPanelView} #view
     */


    _this.view = new balloonpanelview_BalloonPanelView(editor.locale);
    editor.ui.view.body.add(_this.view);
    editor.ui.focusTracker.add(_this.view.element);
    /**
     * The map of views and their stacks.
     *
     * @private
     * @type {Map.<module:ui/view~View,Set>}
     */

    _this._viewToStack = new Map();
    /**
     * The map of IDs and stacks.
     *
     * @private
     * @type {Map.<String,Set>}
     */

    _this._idToStack = new Map();
    /**
     * A total number of all stacks in the balloon.
     *
     * @private
     * @readonly
     * @observable
     * @member {Number} #_numberOfStacks
     */

    _this.set('_numberOfStacks', 0);
    /**
     * A flag that controls the single view mode.
     *
     * @private
     * @readonly
     * @observable
     * @member {Boolean} #_singleViewMode
     */


    _this.set('_singleViewMode', false);
    /**
     * Rotator view embedded in the contextual balloon.
     * Displays the currently visible view in the balloon and provides navigation for switching stacks.
     *
     * @private
     * @type {module:ui/panel/balloon/contextualballoon~RotatorView}
     */


    _this._rotatorView = _this._createRotatorView();
    /**
     * Displays fake panels under the balloon panel view when multiple stacks are added to the balloon.
     *
     * @private
     * @type {module:ui/view~View}
     */

    _this._fakePanelsView = _this._createFakePanelsView();
    return _this;
  }
  /**
   * Returns `true` when the given view is in one of the stacks. Otherwise returns `false`.
   *
   * @param {module:ui/view~View} view
   * @returns {Boolean}
   */


  Object(createClass["a" /* default */])(ContextualBalloon, [{
    key: "hasView",
    value: function hasView(view) {
      return Array.from(this._viewToStack.keys()).includes(view);
    }
    /**
     * Adds a new view to the stack and makes it visible if the current stack is visible
     * or it is the first view in the balloon.
     *
     * @param {Object} data The configuration of the view.
     * @param {String} [data.stackId='main'] The ID of the stack that the view is added to.
     * @param {module:ui/view~View} [data.view] The content of the balloon.
     * @param {module:utils/dom/position~Options} [data.position] Positioning options.
     * @param {String} [data.balloonClassName] An additional CSS class added to the {@link #view balloon} when visible.
     * @param {Boolean} [data.withArrow=true] Whether the {@link #view balloon} should be rendered with an arrow.
     * @param {Boolean} [data.singleViewMode=false] Whether the view should be the only visible view even if other stacks were added.
     */

  }, {
    key: "add",
    value: function add(data) {
      if (this.hasView(data.view)) {
        /**
         * Trying to add configuration of the same view more than once.
         *
         * @error contextualballoon-add-view-exist
         */
        throw new ckeditorerror["b" /* default */]('contextualballoon-add-view-exist: Cannot add configuration of the same view twice.', [this, data]);
      }

      var stackId = data.stackId || 'main'; // If new stack is added, creates it and show view from this stack.

      if (!this._idToStack.has(stackId)) {
        this._idToStack.set(stackId, new Map([[data.view, data]]));

        this._viewToStack.set(data.view, this._idToStack.get(stackId));

        this._numberOfStacks = this._idToStack.size;

        if (!this._visibleStack || data.singleViewMode) {
          this.showStack(stackId);
        }

        return;
      }

      var stack = this._idToStack.get(stackId);

      if (data.singleViewMode) {
        this.showStack(stackId);
      } // Add new view to the stack.


      stack.set(data.view, data);

      this._viewToStack.set(data.view, stack); // And display it if is added to the currently visible stack.


      if (stack === this._visibleStack) {
        this._showView(data);
      }
    }
    /**
     * Removes the given view from the stack. If the removed view was visible,
     * the view preceding it in the stack will become visible instead.
     * When there is no view in the stack, the next stack will be displayed.
     * When there are no more stacks, the balloon will hide.
     *
     * @param {module:ui/view~View} view A view to be removed from the balloon.
     */

  }, {
    key: "remove",
    value: function remove(view) {
      if (!this.hasView(view)) {
        /**
         * Trying to remove the configuration of the view not defined in the stack.
         *
         * @error contextualballoon-remove-view-not-exist
         */
        throw new ckeditorerror["b" /* default */]('contextualballoon-remove-view-not-exist: Cannot remove the configuration of a non-existent view.', [this, view]);
      }

      var stack = this._viewToStack.get(view);

      if (this._singleViewMode && this.visibleView === view) {
        this._singleViewMode = false;
      } // When visible view will be removed we need to show a preceding view or next stack
      // if a view is the only view in the stack.


      if (this.visibleView === view) {
        if (stack.size === 1) {
          if (this._idToStack.size > 1) {
            this._showNextStack();
          } else {
            this.view.hide();
            this.visibleView = null;

            this._rotatorView.hideView();
          }
        } else {
          this._showView(Array.from(stack.values())[stack.size - 2]);
        }
      }

      if (stack.size === 1) {
        this._idToStack.delete(this._getStackId(stack));

        this._numberOfStacks = this._idToStack.size;
      } else {
        stack.delete(view);
      }

      this._viewToStack.delete(view);
    }
    /**
     * Updates the position of the balloon using the position data of the first visible view in the stack.
     * When new position data is given, the position data of the currently visible view will be updated.
     *
     * @param {module:utils/dom/position~Options} [position] position options.
     */

  }, {
    key: "updatePosition",
    value: function updatePosition(position) {
      if (position) {
        this._visibleStack.get(this.visibleView).position = position;
      }

      this.view.pin(this._getBalloonPosition());

      this._fakePanelsView.updatePosition();
    }
    /**
     * Shows the last view from the stack of a given ID.
     *
     * @param {String} id
     */

  }, {
    key: "showStack",
    value: function showStack(id) {
      this.visibleStack = id;

      var stack = this._idToStack.get(id);

      if (!stack) {
        /**
         * Trying to show a stack that does not exist.
         *
         * @error contextualballoon-showstack-stack-not-exist
         */
        throw new ckeditorerror["b" /* default */]('contextualballoon-showstack-stack-not-exist: Cannot show a stack that does not exist.', this);
      }

      if (this._visibleStack === stack) {
        return;
      }

      this._showView(Array.from(stack.values()).pop());
    }
    /**
     * Returns the stack of the currently visible view.
     *
     * @private
     * @type {Set}
     */

  }, {
    key: "_getStackId",

    /**
     * Returns the ID of the given stack.
     *
     * @private
     * @param {Set} stack
     * @returns {String}
     */
    value: function _getStackId(stack) {
      var entry = Array.from(this._idToStack.entries()).find(function (entry) {
        return entry[1] === stack;
      });
      return entry[0];
    }
    /**
     * Shows the last view from the next stack.
     *
     * @private
     */

  }, {
    key: "_showNextStack",
    value: function _showNextStack() {
      var stacks = Array.from(this._idToStack.values());
      var nextIndex = stacks.indexOf(this._visibleStack) + 1;

      if (!stacks[nextIndex]) {
        nextIndex = 0;
      }

      this.showStack(this._getStackId(stacks[nextIndex]));
    }
    /**
     * Shows the last view from the previous stack.
     *
     * @private
     */

  }, {
    key: "_showPrevStack",
    value: function _showPrevStack() {
      var stacks = Array.from(this._idToStack.values());
      var nextIndex = stacks.indexOf(this._visibleStack) - 1;

      if (!stacks[nextIndex]) {
        nextIndex = stacks.length - 1;
      }

      this.showStack(this._getStackId(stacks[nextIndex]));
    }
    /**
     * Creates a rotator view.
     *
     * @private
     * @returns {module:ui/panel/balloon/contextualballoon~RotatorView}
     */

  }, {
    key: "_createRotatorView",
    value: function _createRotatorView() {
      var _this2 = this;

      var view = new contextualballoon_RotatorView(this.editor.locale);
      var t = this.editor.locale.t;
      this.view.content.add(view); // Hide navigation when there is only a one stack & not in single view mode.

      view.bind('isNavigationVisible').to(this, '_numberOfStacks', this, '_singleViewMode', function (value, isSingleViewMode) {
        return !isSingleViewMode && value > 1;
      }); // Update balloon position after toggling navigation.

      view.on('change:isNavigationVisible', function () {
        return _this2.updatePosition();
      }, {
        priority: 'low'
      }); // Update stacks counter value.

      view.bind('counter').to(this, 'visibleView', this, '_numberOfStacks', function (visibleView, numberOfStacks) {
        if (numberOfStacks < 2) {
          return '';
        }

        var current = Array.from(_this2._idToStack.values()).indexOf(_this2._visibleStack) + 1;
        return t('%0 of %1', [current, numberOfStacks]);
      });
      view.buttonNextView.on('execute', function () {
        // When current view has a focus then move focus to the editable before removing it,
        // otherwise editor will lost focus.
        if (view.focusTracker.isFocused) {
          _this2.editor.editing.view.focus();
        }

        _this2._showNextStack();
      });
      view.buttonPrevView.on('execute', function () {
        // When current view has a focus then move focus to the editable before removing it,
        // otherwise editor will lost focus.
        if (view.focusTracker.isFocused) {
          _this2.editor.editing.view.focus();
        }

        _this2._showPrevStack();
      });
      return view;
    }
    /**
     * @returns {module:ui/view~View}
     */

  }, {
    key: "_createFakePanelsView",
    value: function _createFakePanelsView() {
      var view = new contextualballoon_FakePanelsView(this.editor.locale, this.view);
      view.bind('numberOfPanels').to(this, '_numberOfStacks', this, '_singleViewMode', function (number, isSingleViewMode) {
        var showPanels = !isSingleViewMode && number >= 2;
        return showPanels ? Math.min(number - 1, 2) : 0;
      });
      view.listenTo(this.view, 'change:top', function () {
        return view.updatePosition();
      });
      view.listenTo(this.view, 'change:left', function () {
        return view.updatePosition();
      });
      this.editor.ui.view.body.add(view);
      return view;
    }
    /**
     * Sets the view as the content of the balloon and attaches the balloon using position
     * options of the first view.
     *
     * @private
     * @param {Object} data Configuration.
     * @param {module:ui/view~View} [data.view] The view to show in the balloon.
     * @param {String} [data.balloonClassName=''] Additional class name which will be added to the {@link #view balloon}.
     * @param {Boolean} [data.withArrow=true] Whether the {@link #view balloon} should be rendered with an arrow.
     */

  }, {
    key: "_showView",
    value: function _showView(_ref) {
      var view = _ref.view,
          _ref$balloonClassName = _ref.balloonClassName,
          balloonClassName = _ref$balloonClassName === void 0 ? '' : _ref$balloonClassName,
          _ref$withArrow = _ref.withArrow,
          withArrow = _ref$withArrow === void 0 ? true : _ref$withArrow,
          _ref$singleViewMode = _ref.singleViewMode,
          singleViewMode = _ref$singleViewMode === void 0 ? false : _ref$singleViewMode;
      this.view.class = balloonClassName;
      this.view.withArrow = withArrow;

      this._rotatorView.showView(view);

      this.visibleView = view;
      this.view.pin(this._getBalloonPosition());

      this._fakePanelsView.updatePosition();

      if (singleViewMode) {
        this._singleViewMode = true;
      }
    }
    /**
     * Returns position options of the last view in the stack.
     * This keeps the balloon in the same position when the view is changed.
     *
     * @private
     * @returns {module:utils/dom/position~Options}
     */

  }, {
    key: "_getBalloonPosition",
    value: function _getBalloonPosition() {
      var position = Array.from(this._visibleStack.values()).pop().position; // Use the default limiter if none has been specified.

      if (position && !position.limiter) {
        // Don't modify the original options object.
        position = Object.assign({}, position, {
          limiter: this.positionLimiter
        });
      }

      return position;
    }
  }, {
    key: "_visibleStack",
    get: function get() {
      return this._viewToStack.get(this.visibleView);
    }
  }]);

  return ContextualBalloon;
}(plugin_Plugin);
/**
 * Rotator view is a helper class for the {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon ContextualBalloon}.
 * It is used for displaying the last view from the current stack and providing navigation buttons for switching stacks.
 * See the {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon ContextualBalloon} documentation to learn more.
 *
 * @extends module:ui/view~View
 */




var contextualballoon_RotatorView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(RotatorView, _View);

  var _super2 = Object(createSuper["a" /* default */])(RotatorView);

  /**
   * @inheritDoc
   */
  function RotatorView(locale) {
    var _this3;

    Object(classCallCheck["a" /* default */])(this, RotatorView);

    _this3 = _super2.call(this, locale);
    var t = locale.t;
    var bind = _this3.bindTemplate;
    /**
     * Defines whether navigation is visible or not.
     *
     * @member {Boolean} #isNavigationVisible
     */

    _this3.set('isNavigationVisible', true);
    /**
     * Used for checking if a view is focused or not.
     *
     * @type {module:utils/focustracker~FocusTracker}
     */


    _this3.focusTracker = new focustracker_FocusTracker();
    /**
     * Navigation button for switching the stack to the previous one.
     *
     * @type {module:ui/button/buttonview~ButtonView}
     */

    _this3.buttonPrevView = _this3._createButtonView(t('Previous'), previous_arrow_default.a);
    /**
     * Navigation button for switching the stack to the next one.
     *
     * @type {module:ui/button/buttonview~ButtonView}
     */

    _this3.buttonNextView = _this3._createButtonView(t('Next'), next_arrow_default.a);
    /**
     * A collection of the child views that creates the rotator content.
     *
     * @readonly
     * @type {module:ui/viewcollection~ViewCollection}
     */

    _this3.content = _this3.createCollection();

    _this3.setTemplate({
      tag: 'div',
      attributes: {
        class: ['ck', 'ck-balloon-rotator'],
        'z-index': '-1'
      },
      children: [{
        tag: 'div',
        attributes: {
          class: ['ck-balloon-rotator__navigation', bind.to('isNavigationVisible', function (value) {
            return value ? '' : 'ck-hidden';
          })]
        },
        children: [_this3.buttonPrevView, {
          tag: 'span',
          attributes: {
            class: ['ck-balloon-rotator__counter']
          },
          children: [{
            text: bind.to('counter')
          }]
        }, _this3.buttonNextView]
      }, {
        tag: 'div',
        attributes: {
          class: 'ck-balloon-rotator__content'
        },
        children: _this3.content
      }]
    });

    return _this3;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(RotatorView, [{
    key: "render",
    value: function render() {
      get_get(Object(getPrototypeOf["a" /* default */])(RotatorView.prototype), "render", this).call(this);

      this.focusTracker.add(this.element);
    }
    /**
     * Shows a given view.
     *
     * @param {module:ui/view~View} view The view to show.
     */

  }, {
    key: "showView",
    value: function showView(view) {
      this.hideView();
      this.content.add(view);
    }
    /**
     * Hides the currently displayed view.
     */

  }, {
    key: "hideView",
    value: function hideView() {
      this.content.clear();
    }
    /**
     * Creates a navigation button view.
     *
     * @private
     * @param {String} label The button label.
     * @param {String} icon The button icon.
     * @returns {module:ui/button/buttonview~ButtonView}
     */

  }, {
    key: "_createButtonView",
    value: function _createButtonView(label, icon) {
      var view = new buttonview_ButtonView(this.locale);
      view.set({
        label: label,
        icon: icon,
        tooltip: true
      });
      return view;
    }
  }]);

  return RotatorView;
}(src_view_View); // Displays additional layers under the balloon when multiple stacks are added to the balloon.
//
// @private
// @extends module:ui/view~View


var contextualballoon_FakePanelsView = /*#__PURE__*/function (_View2) {
  Object(inherits["a" /* default */])(FakePanelsView, _View2);

  var _super3 = Object(createSuper["a" /* default */])(FakePanelsView);

  // @inheritDoc
  function FakePanelsView(locale, balloonPanelView) {
    var _this4;

    Object(classCallCheck["a" /* default */])(this, FakePanelsView);

    _this4 = _super3.call(this, locale);
    var bind = _this4.bindTemplate; // Fake panels top offset.
    //
    // @observable
    // @member {Number} #top

    _this4.set('top', 0); // Fake panels left offset.
    //
    // @observable
    // @member {Number} #left


    _this4.set('left', 0); // Fake panels height.
    //
    // @observable
    // @member {Number} #height


    _this4.set('height', 0); // Fake panels width.
    //
    // @observable
    // @member {Number} #width


    _this4.set('width', 0); // Number of rendered fake panels.
    //
    // @observable
    // @member {Number} #numberOfPanels


    _this4.set('numberOfPanels', 0); // Collection of the child views which creates fake panel content.
    //
    // @readonly
    // @type {module:ui/viewcollection~ViewCollection}


    _this4.content = _this4.createCollection(); // Context.
    //
    // @private
    // @type {module:ui/panel/balloon/balloonpanelview~BalloonPanelView}

    _this4._balloonPanelView = balloonPanelView;

    _this4.setTemplate({
      tag: 'div',
      attributes: {
        class: ['ck-fake-panel', bind.to('numberOfPanels', function (number) {
          return number ? '' : 'ck-hidden';
        })],
        style: {
          top: bind.to('top', contextualballoon_toPx),
          left: bind.to('left', contextualballoon_toPx),
          width: bind.to('width', contextualballoon_toPx),
          height: bind.to('height', contextualballoon_toPx)
        }
      },
      children: _this4.content
    });

    _this4.on('change:numberOfPanels', function (evt, name, next, prev) {
      if (next > prev) {
        _this4._addPanels(next - prev);
      } else {
        _this4._removePanels(prev - next);
      }

      _this4.updatePosition();
    });

    return _this4;
  } // @private
  // @param {Number} number


  Object(createClass["a" /* default */])(FakePanelsView, [{
    key: "_addPanels",
    value: function _addPanels(number) {
      while (number--) {
        var view = new src_view_View();
        view.setTemplate({
          tag: 'div'
        });
        this.content.add(view);
        this.registerChild(view);
      }
    } // @private
    // @param {Number} number

  }, {
    key: "_removePanels",
    value: function _removePanels(number) {
      while (number--) {
        var view = this.content.last;
        this.content.remove(view);
        this.deregisterChild(view);
        view.destroy();
      }
    } // Updates coordinates of fake panels.

  }, {
    key: "updatePosition",
    value: function updatePosition() {
      if (this.numberOfPanels) {
        var _this$_balloonPanelVi = this._balloonPanelView,
            top = _this$_balloonPanelVi.top,
            left = _this$_balloonPanelVi.left;

        var _Rect = new rect_Rect(this._balloonPanelView.element),
            width = _Rect.width,
            height = _Rect.height;

        Object.assign(this, {
          top: top,
          left: left,
          width: width,
          height: height
        });
      }
    }
  }]);

  return FakePanelsView;
}(src_view_View);
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-core/theme/icons/low-vision.svg
var low_vision = __webpack_require__("546e");
var low_vision_default = /*#__PURE__*/__webpack_require__.n(low_vision);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/image/ui/utils.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/image/ui/utils
 */


/**
 * A helper utility that positions the
 * {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon contextual balloon} instance
 * with respect to the image in the editor content, if one is selected.
 *
 * @param {module:core/editor/editor~Editor} editor The editor instance.
 */

function repositionContextualBalloon(editor) {
  var balloon = editor.plugins.get('ContextualBalloon');

  if (getSelectedImageWidget(editor.editing.view.document.selection)) {
    var position = getBalloonPositionData(editor);
    balloon.updatePosition(position);
  }
}
/**
 * Returns the positioning options that control the geometry of the
 * {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon contextual balloon} with respect
 * to the selected element in the editor content.
 *
 * @param {module:core/editor/editor~Editor} editor The editor instance.
 * @returns {module:utils/dom/position~Options}
 */

function getBalloonPositionData(editor) {
  var editingView = editor.editing.view;
  var defaultPositions = balloonpanelview_BalloonPanelView.defaultPositions;
  return {
    target: editingView.domConverter.viewToDom(editingView.document.selection.getSelectedElement()),
    positions: [defaultPositions.northArrowSouth, defaultPositions.northArrowSouthWest, defaultPositions.northArrowSouthEast, defaultPositions.southArrowNorth, defaultPositions.southArrowNorthWest, defaultPositions.southArrowNorthEast]
  };
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imagetextalternative/imagetextalternativeui.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imagetextalternative/imagetextalternativeui
 */








/**
 * The image text alternative UI plugin.
 *
 * The plugin uses the {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon}.
 *
 * @extends module:core/plugin~Plugin
 */

var imagetextalternativeui_ImageTextAlternativeUI = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ImageTextAlternativeUI, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ImageTextAlternativeUI);

  function ImageTextAlternativeUI() {
    Object(classCallCheck["a" /* default */])(this, ImageTextAlternativeUI);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ImageTextAlternativeUI, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      this._createButton();

      this._createForm();
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "destroy",
    value: function destroy() {
      get_get(Object(getPrototypeOf["a" /* default */])(ImageTextAlternativeUI.prototype), "destroy", this).call(this); // Destroy created UI components as they are not automatically destroyed (see ckeditor5#1341).


      this._form.destroy();
    }
    /**
     * Creates a button showing the balloon panel for changing the image text alternative and
     * registers it in the editor {@link module:ui/componentfactory~ComponentFactory ComponentFactory}.
     *
     * @private
     */

  }, {
    key: "_createButton",
    value: function _createButton() {
      var _this = this;

      var editor = this.editor;
      var t = editor.t;
      editor.ui.componentFactory.add('imageTextAlternative', function (locale) {
        var command = editor.commands.get('imageTextAlternative');
        var view = new buttonview_ButtonView(locale);
        view.set({
          label: t('Change image text alternative'),
          icon: low_vision_default.a,
          tooltip: true
        });
        view.bind('isEnabled').to(command, 'isEnabled');

        _this.listenTo(view, 'execute', function () {
          _this._showForm();
        });

        return view;
      });
    }
    /**
     * Creates the {@link module:image/imagetextalternative/ui/textalternativeformview~TextAlternativeFormView}
     * form.
     *
     * @private
     */

  }, {
    key: "_createForm",
    value: function _createForm() {
      var _this2 = this;

      var editor = this.editor;
      var view = editor.editing.view;
      var viewDocument = view.document;
      /**
       * The contextual balloon plugin instance.
       *
       * @private
       * @member {module:ui/panel/balloon/contextualballoon~ContextualBalloon}
       */

      this._balloon = this.editor.plugins.get('ContextualBalloon');
      /**
       * A form containing a textarea and buttons, used to change the `alt` text value.
       *
       * @member {module:image/imagetextalternative/ui/textalternativeformview~TextAlternativeFormView}
       */

      this._form = new textalternativeformview_TextAlternativeFormView(editor.locale); // Render the form so its #element is available for clickOutsideHandler.

      this._form.render();

      this.listenTo(this._form, 'submit', function () {
        editor.execute('imageTextAlternative', {
          newValue: _this2._form.labeledInput.fieldView.element.value
        });

        _this2._hideForm(true);
      });
      this.listenTo(this._form, 'cancel', function () {
        _this2._hideForm(true);
      }); // Close the form on Esc key press.

      this._form.keystrokes.set('Esc', function (data, cancel) {
        _this2._hideForm(true);

        cancel();
      }); // Reposition the balloon or hide the form if an image widget is no longer selected.


      this.listenTo(editor.ui, 'update', function () {
        if (!getSelectedImageWidget(viewDocument.selection)) {
          _this2._hideForm(true);
        } else if (_this2._isVisible) {
          repositionContextualBalloon(editor);
        }
      }); // Close on click outside of balloon panel element.

      clickOutsideHandler({
        emitter: this._form,
        activator: function activator() {
          return _this2._isVisible;
        },
        contextElements: [this._balloon.view.element],
        callback: function callback() {
          return _this2._hideForm();
        }
      });
    }
    /**
     * Shows the {@link #_form} in the {@link #_balloon}.
     *
     * @private
     */

  }, {
    key: "_showForm",
    value: function _showForm() {
      if (this._isVisible) {
        return;
      }

      var editor = this.editor;
      var command = editor.commands.get('imageTextAlternative');
      var labeledInput = this._form.labeledInput;

      if (!this._isInBalloon) {
        this._balloon.add({
          view: this._form,
          position: getBalloonPositionData(editor)
        });
      } // Make sure that each time the panel shows up, the field remains in sync with the value of
      // the command. If the user typed in the input, then canceled the balloon (`labeledInput#value`
      // stays unaltered) and re-opened it without changing the value of the command, they would see the
      // old value instead of the actual value of the command.
      // https://github.com/ckeditor/ckeditor5-image/issues/114


      labeledInput.fieldView.value = labeledInput.fieldView.element.value = command.value || '';

      this._form.labeledInput.fieldView.select();
    }
    /**
     * Removes the {@link #_form} from the {@link #_balloon}.
     *
     * @param {Boolean} [focusEditable=false] Controls whether the editing view is focused afterwards.
     * @private
     */

  }, {
    key: "_hideForm",
    value: function _hideForm(focusEditable) {
      if (!this._isInBalloon) {
        return;
      } // Blur the input element before removing it from DOM to prevent issues in some browsers.
      // See https://github.com/ckeditor/ckeditor5/issues/1501.


      if (this._form.focusTracker.isFocused) {
        this._form.saveButtonView.focus();
      }

      this._balloon.remove(this._form);

      if (focusEditable) {
        this.editor.editing.view.focus();
      }
    }
    /**
     * Returns `true` when the {@link #_form} is the visible view in the {@link #_balloon}.
     *
     * @private
     * @type {Boolean}
     */

  }, {
    key: "_isVisible",
    get: function get() {
      return this._balloon.visibleView === this._form;
    }
    /**
     * Returns `true` when the {@link #_form} is in the {@link #_balloon}.
     *
     * @private
     * @type {Boolean}
     */

  }, {
    key: "_isInBalloon",
    get: function get() {
      return this._balloon.hasView(this._form);
    }
  }], [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [contextualballoon_ContextualBalloon];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'ImageTextAlternativeUI';
    }
  }]);

  return ImageTextAlternativeUI;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imagetextalternative.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imagetextalternative
 */



/**
 * The image text alternative plugin.
 *
 * For a detailed overview, check the {@glink features/image#image-styles image styles} documentation.
 *
 * This is a "glue" plugin which loads the
 *  {@link module:image/imagetextalternative/imagetextalternativeediting~ImageTextAlternativeEditing}
 * and {@link module:image/imagetextalternative/imagetextalternativeui~ImageTextAlternativeUI} plugins.
 *
 * @extends module:core/plugin~Plugin
 */

var imagetextalternative_ImageTextAlternative = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ImageTextAlternative, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ImageTextAlternative);

  function ImageTextAlternative() {
    Object(classCallCheck["a" /* default */])(this, ImageTextAlternative);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ImageTextAlternative, null, [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [imagetextalternativeediting_ImageTextAlternativeEditing, imagetextalternativeui_ImageTextAlternativeUI];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'ImageTextAlternative';
    }
  }]);

  return ImageTextAlternative;
}(plugin_Plugin);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-image/theme/image.css
var theme_image = __webpack_require__("92bd");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/image.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/image
 */





/**
 * The image plugin.
 *
 * For a detailed overview, check the {@glink features/image image feature} documentation.
 *
 * This is a "glue" plugin which loads the following plugins:
 *
 * * {@link module:image/image/imageediting~ImageEditing},
 * * {@link module:image/imagetextalternative~ImageTextAlternative}.
 *
 * Usually, it is used in conjuction with other plugins from this package. See the {@glink api/image package page}
 * for more information.
 *
 * @extends module:core/plugin~Plugin
 */

var image_Image = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(Image, _Plugin);

  var _super = Object(createSuper["a" /* default */])(Image);

  function Image() {
    Object(classCallCheck["a" /* default */])(this, Image);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Image, null, [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [imageediting_ImageEditing, widget_Widget, imagetextalternative_ImageTextAlternative];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'Image';
    }
  }]);

  return Image;
}(plugin_Plugin);
/**
 * The configuration of the image features. Used by the image features in the `@ckeditor/ckeditor5-image` package.
 *
 * Read more in {@link module:image/image~ImageConfig}.
 *
 * @member {module:image/image~ImageConfig} module:core/editor/editorconfig~EditorConfig#image
 */

/**
 * The configuration of the image features. Used by the image features in the `@ckeditor/ckeditor5-image` package.
 *
 *		ClassicEditor
 *			.create( editorElement, {
 * 				image: ... // Image feature options.
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * See {@link module:core/editor/editorconfig~EditorConfig all editor options}.
 *
 * @interface ImageConfig
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-upload/src/ui/filedialogbuttonview.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module upload/ui/filedialogbuttonview
 */


/**
 * The file dialog button view.
 *
 * This component provides a button that opens the native file selection dialog.
 * It can be used to implement the UI of a file upload feature.
 *
 *		const view = new FileDialogButtonView( locale );
 *
 *		view.set( {
 *			acceptedType: 'image/*',
 *			allowMultipleFiles: true
 *		} );
 *
 *		view.buttonView.set( {
 *			label: t( 'Insert image' ),
 *			icon: imageIcon,
 *			tooltip: true
 *		} );
 *
 *		view.on( 'done', ( evt, files ) => {
 *			for ( const file of Array.from( files ) ) {
 *				console.log( 'Selected file', file );
 *			}
 *		} );
 *
 * @extends module:ui/view~View
 */

var filedialogbuttonview_FileDialogButtonView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(FileDialogButtonView, _View);

  var _super = Object(createSuper["a" /* default */])(FileDialogButtonView);

  /**
   * @inheritDoc
   */
  function FileDialogButtonView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, FileDialogButtonView);

    _this = _super.call(this, locale);
    /**
     * The button view of the component.
     *
     * @member {module:ui/button/buttonview~ButtonView}
     */

    _this.buttonView = new buttonview_ButtonView(locale);
    /**
     * A hidden `<input>` view used to execute file dialog.
     *
     * @protected
     * @member {module:upload/ui/filedialogbuttonview~FileInputView}
     */

    _this._fileInputView = new filedialogbuttonview_FileInputView(locale);
    /**
     * Accepted file types. Can be provided in form of file extensions, media type or one of:
     * * `audio/*`,
     * * `video/*`,
     * * `image/*`.
     *
     * @observable
     * @member {String} #acceptedType
     */

    _this._fileInputView.bind('acceptedType').to(Object(assertThisInitialized["a" /* default */])(_this));
    /**
     * Indicates if multiple files can be selected. Defaults to `true`.
     *
     * @observable
     * @member {Boolean} #allowMultipleFiles
     */


    _this._fileInputView.bind('allowMultipleFiles').to(Object(assertThisInitialized["a" /* default */])(_this));
    /**
     * Fired when file dialog is closed with file selected.
     *
     *		view.on( 'done', ( evt, files ) => {
     *			for ( const file of files ) {
     *				console.log( 'Selected file', file );
     *			}
     *		}
     *
     * @event done
     * @param {Array.<File>} files Array of selected files.
     */


    _this._fileInputView.delegate('done').to(Object(assertThisInitialized["a" /* default */])(_this));

    _this.setTemplate({
      tag: 'span',
      attributes: {
        class: 'ck-file-dialog-button'
      },
      children: [_this.buttonView, _this._fileInputView]
    });

    _this.buttonView.on('execute', function () {
      _this._fileInputView.open();
    });

    return _this;
  }
  /**
   * Focuses the {@link #buttonView}.
   */


  Object(createClass["a" /* default */])(FileDialogButtonView, [{
    key: "focus",
    value: function focus() {
      this.buttonView.focus();
    }
  }]);

  return FileDialogButtonView;
}(src_view_View);
/**
 * The hidden file input view class.
 *
 * @private
 * @extends module:ui/view~View
 */




var filedialogbuttonview_FileInputView = /*#__PURE__*/function (_View2) {
  Object(inherits["a" /* default */])(FileInputView, _View2);

  var _super2 = Object(createSuper["a" /* default */])(FileInputView);

  /**
   * @inheritDoc
   */
  function FileInputView(locale) {
    var _this2;

    Object(classCallCheck["a" /* default */])(this, FileInputView);

    _this2 = _super2.call(this, locale);
    /**
     * Accepted file types. Can be provided in form of file extensions, media type or one of:
     * * `audio/*`,
     * * `video/*`,
     * * `image/*`.
     *
     * @observable
     * @member {String} #acceptedType
     */

    _this2.set('acceptedType');
    /**
     * Indicates if multiple files can be selected. Defaults to `false`.
     *
     * @observable
     * @member {Boolean} #allowMultipleFiles
     */


    _this2.set('allowMultipleFiles', false);

    var bind = _this2.bindTemplate;

    _this2.setTemplate({
      tag: 'input',
      attributes: {
        class: ['ck-hidden'],
        type: 'file',
        tabindex: '-1',
        accept: bind.to('acceptedType'),
        multiple: bind.to('allowMultipleFiles')
      },
      on: {
        // Removing from code coverage since we cannot programmatically set input element files.
        change: bind.to(
        /* istanbul ignore next */
        function () {
          if (_this2.element && _this2.element.files && _this2.element.files.length) {
            _this2.fire('done', _this2.element.files);
          }

          _this2.element.value = '';
        })
      }
    });

    return _this2;
  }
  /**
   * Opens file dialog.
   */


  Object(createClass["a" /* default */])(FileInputView, [{
    key: "open",
    value: function open() {
      this.element.click();
    }
  }]);

  return FileInputView;
}(src_view_View);
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-core/theme/icons/image.svg
var icons_image = __webpack_require__("1414");
var icons_image_default = /*#__PURE__*/__webpack_require__.n(icons_image);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imageupload/utils.js










/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imageupload/utils
 */

/* global fetch, File */

/**
 * Creates a regular expression used to test for image files.
 *
 *		const imageType = createImageTypeRegExp( [ 'png', 'jpeg', 'svg+xml', 'vnd.microsoft.icon' ] );
 *
 *		console.log( 'is supported image', imageType.test( file.type ) );
 *
 * @param {Array.<String>} types
 * @returns {RegExp}
 */
function createImageTypeRegExp(types) {
  // Sanitize the MIME type name which may include: "+", "-" or ".".
  var regExpSafeNames = types.map(function (type) {
    return type.replace('+', '\\+');
  });
  return new RegExp("^image\\/(".concat(regExpSafeNames.join('|'), ")$"));
}
/**
 * Creates a promise that fetches the image local source (Base64 or blob) and resolves with a `File` object.
 *
 * @param {module:engine/view/element~Element} image Image whose source to fetch.
 * @returns {Promise.<File>} A promise which resolves when an image source is fetched and converted to a `File` instance.
 * It resolves with a `File` object. If there were any errors during file processing, the promise will be rejected.
 */

function fetchLocalImage(image) {
  return new Promise(function (resolve, reject) {
    var imageSrc = image.getAttribute('src'); // Fetch works asynchronously and so does not block browser UI when processing data.

    fetch(imageSrc).then(function (resource) {
      return resource.blob();
    }).then(function (blob) {
      var mimeType = getImageMimeType(blob, imageSrc);
      var ext = mimeType.replace('image/', '');
      var filename = "image.".concat(ext);
      var file = new File([blob], filename, {
        type: mimeType
      });
      resolve(file);
    }).catch(reject);
  });
}
/**
 * Checks whether a given node is an image element with a local source (Base64 or blob).
 *
 * @param {module:engine/view/node~Node} node The node to check.
 * @returns {Boolean}
 */

function isLocalImage(node) {
  if (!node.is('element', 'img') || !node.getAttribute('src')) {
    return false;
  }

  return node.getAttribute('src').match(/^data:image\/\w+;base64,/g) || node.getAttribute('src').match(/^blob:/g);
} // Extracts an image type based on its blob representation or its source.
//
// @param {String} src Image `src` attribute value.
// @param {Blob} blob Image blob representation.
// @returns {String}

function getImageMimeType(blob, src) {
  if (blob.type) {
    return blob.type;
  } else if (src.match(/data:(image\/\w+);base64/)) {
    return src.match(/data:(image\/\w+);base64/)[1].toLowerCase();
  } else {
    // Fallback to 'jpeg' as common extension.
    return 'image/jpeg';
  }
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imageupload/imageuploadui.js










/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imageupload/imageuploadui
 */




/**
 * The image upload button plugin.
 *
 * For a detailed overview, check the {@glink features/image-upload/image-upload Image upload feature} documentation.
 *
 * Adds the `'imageUpload'` button to the {@link module:ui/componentfactory~ComponentFactory UI component factory}.
 *
 * @extends module:core/plugin~Plugin
 */

var imageuploadui_ImageUploadUI = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ImageUploadUI, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ImageUploadUI);

  function ImageUploadUI() {
    Object(classCallCheck["a" /* default */])(this, ImageUploadUI);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ImageUploadUI, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var editor = this.editor;
      var t = editor.t; // Setup `imageUpload` button.

      editor.ui.componentFactory.add('imageUpload', function (locale) {
        var view = new filedialogbuttonview_FileDialogButtonView(locale);
        var command = editor.commands.get('imageUpload');
        var imageTypes = editor.config.get('image.upload.types');
        var imageTypesRegExp = createImageTypeRegExp(imageTypes);
        view.set({
          acceptedType: imageTypes.map(function (type) {
            return "image/".concat(type);
          }).join(','),
          allowMultipleFiles: true
        });
        view.buttonView.set({
          label: t('Insert image'),
          icon: icons_image_default.a,
          tooltip: true
        });
        view.buttonView.bind('isEnabled').to(command);
        view.on('done', function (evt, files) {
          var imagesToUpload = Array.from(files).filter(function (file) {
            return imageTypesRegExp.test(file.type);
          });

          if (imagesToUpload.length) {
            editor.execute('imageUpload', {
              file: imagesToUpload
            });
          }
        });
        return view;
      });
    }
  }]);

  return ImageUploadUI;
}(plugin_Plugin);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-image/theme/icons/image_placeholder.svg
var image_placeholder = __webpack_require__("3879");
var image_placeholder_default = /*#__PURE__*/__webpack_require__.n(image_placeholder);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadprogress.css
var imageuploadprogress = __webpack_require__("8030");

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadicon.css
var imageuploadicon = __webpack_require__("bcf9");

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-image/theme/imageuploadloader.css
var imageuploadloader = __webpack_require__("5f69");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imageupload/imageuploadprogress.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imageupload/imageuploadprogress
 */

/* globals setTimeout */







/**
 * The image upload progress plugin.
 * It shows a placeholder when the image is read from the disk and a progress bar while the image is uploading.
 *
 * @extends module:core/plugin~Plugin
 */

var imageuploadprogress_ImageUploadProgress = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ImageUploadProgress, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ImageUploadProgress);

  /**
   * @inheritDoc
   */
  function ImageUploadProgress(editor) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, ImageUploadProgress);

    _this = _super.call(this, editor);
    /**
     * The image placeholder that is displayed before real image data can be accessed.
     *
     * @protected
     * @member {String} #placeholder
     */

    _this.placeholder = 'data:image/svg+xml;utf8,' + encodeURIComponent(image_placeholder_default.a);
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(ImageUploadProgress, [{
    key: "init",
    value: function init() {
      var _this2 = this;

      var editor = this.editor; // Upload status change - update image's view according to that status.

      editor.editing.downcastDispatcher.on('attribute:uploadStatus:image', function () {
        return _this2.uploadStatusChange.apply(_this2, arguments);
      });
    }
    /**
     * This method is called each time the image `uploadStatus` attribute is changed.
     *
     * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
     * @param {Object} data Additional information about the change.
     * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi
     */

  }, {
    key: "uploadStatusChange",
    value: function uploadStatusChange(evt, data, conversionApi) {
      var editor = this.editor;
      var modelImage = data.item;
      var uploadId = modelImage.getAttribute('uploadId');

      if (!conversionApi.consumable.consume(data.item, evt.name)) {
        return;
      }

      var fileRepository = editor.plugins.get(filerepository_FileRepository);
      var status = uploadId ? data.attributeNewValue : null;
      var placeholder = this.placeholder;
      var viewFigure = editor.editing.mapper.toViewElement(modelImage);
      var viewWriter = conversionApi.writer;

      if (status == 'reading') {
        // Start "appearing" effect and show placeholder with infinite progress bar on the top
        // while image is read from disk.
        _startAppearEffect(viewFigure, viewWriter);

        _showPlaceholder(placeholder, viewFigure, viewWriter);

        return;
      } // Show progress bar on the top of the image when image is uploading.


      if (status == 'uploading') {
        var loader = fileRepository.loaders.get(uploadId); // Start appear effect if needed - see https://github.com/ckeditor/ckeditor5-image/issues/191.

        _startAppearEffect(viewFigure, viewWriter);

        if (!loader) {
          // There is no loader associated with uploadId - this means that image came from external changes.
          // In such cases we still want to show the placeholder until image is fully uploaded.
          // Show placeholder if needed - see https://github.com/ckeditor/ckeditor5-image/issues/191.
          _showPlaceholder(placeholder, viewFigure, viewWriter);
        } else {
          // Hide placeholder and initialize progress bar showing upload progress.
          _hidePlaceholder(viewFigure, viewWriter);

          _showProgressBar(viewFigure, viewWriter, loader, editor.editing.view);

          _displayLocalImage(viewFigure, viewWriter, loader);
        }

        return;
      }

      if (status == 'complete' && fileRepository.loaders.get(uploadId)) {
        _showCompleteIcon(viewFigure, viewWriter, editor.editing.view);
      } // Clean up.


      _hideProgressBar(viewFigure, viewWriter);

      _hidePlaceholder(viewFigure, viewWriter);

      _stopAppearEffect(viewFigure, viewWriter);
    }
  }]);

  return ImageUploadProgress;
}(plugin_Plugin); // Adds ck-appear class to the image figure if one is not already applied.
//
// @param {module:engine/view/containerelement~ContainerElement} viewFigure
// @param {module:engine/view/downcastwriter~DowncastWriter} writer




function _startAppearEffect(viewFigure, writer) {
  if (!viewFigure.hasClass('ck-appear')) {
    writer.addClass('ck-appear', viewFigure);
  }
} // Removes ck-appear class to the image figure if one is not already removed.
//
// @param {module:engine/view/containerelement~ContainerElement} viewFigure
// @param {module:engine/view/downcastwriter~DowncastWriter} writer


function _stopAppearEffect(viewFigure, writer) {
  writer.removeClass('ck-appear', viewFigure);
} // Shows placeholder together with infinite progress bar on given image figure.
//
// @param {String} Data-uri with a svg placeholder.
// @param {module:engine/view/containerelement~ContainerElement} viewFigure
// @param {module:engine/view/downcastwriter~DowncastWriter} writer


function _showPlaceholder(placeholder, viewFigure, writer) {
  if (!viewFigure.hasClass('ck-image-upload-placeholder')) {
    writer.addClass('ck-image-upload-placeholder', viewFigure);
  }

  var viewImg = getViewImgFromWidget(viewFigure);

  if (viewImg.getAttribute('src') !== placeholder) {
    writer.setAttribute('src', placeholder, viewImg);
  }

  if (!_getUIElement(viewFigure, 'placeholder')) {
    writer.insert(writer.createPositionAfter(viewImg), _createPlaceholder(writer));
  }
} // Removes placeholder together with infinite progress bar on given image figure.
//
// @param {module:engine/view/containerelement~ContainerElement} viewFigure
// @param {module:engine/view/downcastwriter~DowncastWriter} writer


function _hidePlaceholder(viewFigure, writer) {
  if (viewFigure.hasClass('ck-image-upload-placeholder')) {
    writer.removeClass('ck-image-upload-placeholder', viewFigure);
  }

  _removeUIElement(viewFigure, writer, 'placeholder');
} // Shows progress bar displaying upload progress.
// Attaches it to the file loader to update when upload percentace is changed.
//
// @param {module:engine/view/containerelement~ContainerElement} viewFigure
// @param {module:engine/view/downcastwriter~DowncastWriter} writer
// @param {module:upload/filerepository~FileLoader} loader
// @param {module:engine/view/view~View} view


function _showProgressBar(viewFigure, writer, loader, view) {
  var progressBar = _createProgressBar(writer);

  writer.insert(writer.createPositionAt(viewFigure, 'end'), progressBar); // Update progress bar width when uploadedPercent is changed.

  loader.on('change:uploadedPercent', function (evt, name, value) {
    view.change(function (writer) {
      writer.setStyle('width', value + '%', progressBar);
    });
  });
} // Hides upload progress bar.
//
// @param {module:engine/view/containerelement~ContainerElement} viewFigure
// @param {module:engine/view/downcastwriter~DowncastWriter} writer


function _hideProgressBar(viewFigure, writer) {
  _removeUIElement(viewFigure, writer, 'progressBar');
} // Shows complete icon and hides after a certain amount of time.
//
// @param {module:engine/view/containerelement~ContainerElement} viewFigure
// @param {module:engine/view/downcastwriter~DowncastWriter} writer
// @param {module:engine/view/view~View} view


function _showCompleteIcon(viewFigure, writer, view) {
  var completeIcon = writer.createUIElement('div', {
    class: 'ck-image-upload-complete-icon'
  });
  writer.insert(writer.createPositionAt(viewFigure, 'end'), completeIcon);
  setTimeout(function () {
    view.change(function (writer) {
      return writer.remove(writer.createRangeOn(completeIcon));
    });
  }, 3000);
} // Create progress bar element using {@link module:engine/view/uielement~UIElement}.
//
// @private
// @param {module:engine/view/downcastwriter~DowncastWriter} writer
// @returns {module:engine/view/uielement~UIElement}


function _createProgressBar(writer) {
  var progressBar = writer.createUIElement('div', {
    class: 'ck-progress-bar'
  });
  writer.setCustomProperty('progressBar', true, progressBar);
  return progressBar;
} // Create placeholder element using {@link module:engine/view/uielement~UIElement}.
//
// @private
// @param {module:engine/view/downcastwriter~DowncastWriter} writer
// @returns {module:engine/view/uielement~UIElement}


function _createPlaceholder(writer) {
  var placeholder = writer.createUIElement('div', {
    class: 'ck-upload-placeholder-loader'
  });
  writer.setCustomProperty('placeholder', true, placeholder);
  return placeholder;
} // Returns {@link module:engine/view/uielement~UIElement} of given unique property from image figure element.
// Returns `undefined` if element is not found.
//
// @private
// @param {module:engine/view/element~Element} imageFigure
// @param {String} uniqueProperty
// @returns {module:engine/view/uielement~UIElement|undefined}


function _getUIElement(imageFigure, uniqueProperty) {
  var _iterator = _createForOfIteratorHelper(imageFigure.getChildren()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var child = _step.value;

      if (child.getCustomProperty(uniqueProperty)) {
        return child;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
} // Removes {@link module:engine/view/uielement~UIElement} of given unique property from image figure element.
//
// @private
// @param {module:engine/view/element~Element} imageFigure
// @param {module:engine/view/downcastwriter~DowncastWriter} writer
// @param {String} uniqueProperty


function _removeUIElement(viewFigure, writer, uniqueProperty) {
  var element = _getUIElement(viewFigure, uniqueProperty);

  if (element) {
    writer.remove(writer.createRangeOn(element));
  }
} // Displays local data from file loader.
//
// @param {module:engine/view/element~Element} imageFigure
// @param {module:engine/view/downcastwriter~DowncastWriter} writer
// @param {module:upload/filerepository~FileLoader} loader


function _displayLocalImage(viewFigure, writer, loader) {
  if (loader.data) {
    var viewImg = getViewImgFromWidget(viewFigure);
    writer.setAttribute('src', loader.data, viewImg);
  }
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/upcastwriter.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module module:engine/view/upcastwriter
 */







/**
 * View upcast writer. It provides a set of methods used to manipulate non-semantic view trees.
 *
 * It should be used only while working on a non-semantic view
 * (e.g. a view created from HTML string on paste).
 * To manipulate a view which was or is being downcasted from the the model use the
 * {@link module:engine/view/downcastwriter~DowncastWriter downcast writer}.
 *
 * Read more about changing the view in the {@glink framework/guides/architecture/editing-engine#changing-the-view Changing the view}
 * section of the {@glink framework/guides/architecture/editing-engine Editing engine architecture} guide.
 *
 * Unlike `DowncastWriter`, which is available in the {@link module:engine/view/view~View#change `View#change()`} block,
 * `UpcastWriter` can be created wherever you need it:
 *
 *		const writer = new UpcastWriter( viewDocument );
 *		const text = writer.createText( 'foo!' );
 *
 *		writer.appendChild( text, someViewElement );
 */

var upcastwriter_UpcastWriter = /*#__PURE__*/function () {
  /**
   * @param {module:engine/view/document~Document} document The view document instance in which this upcast writer operates.
   */
  function UpcastWriter(document) {
    Object(classCallCheck["a" /* default */])(this, UpcastWriter);

    /**
     * The view document instance in which this upcast writer operates.
     *
     * @readonly
     * @type {module:engine/view/document~Document}
     */
    this.document = document;
  }
  /**
   * Creates a new {@link module:engine/view/documentfragment~DocumentFragment} instance.
   *
   * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]
   * A list of nodes to be inserted into the created document fragment.
   * @returns {module:engine/view/documentfragment~DocumentFragment} The created document fragment.
   */


  Object(createClass["a" /* default */])(UpcastWriter, [{
    key: "createDocumentFragment",
    value: function createDocumentFragment(children) {
      return new documentfragment_DocumentFragment(this.document, children);
    }
    /**
     * Creates a new {@link module:engine/view/element~Element} instance.
     *
     * Attributes can be passed in various formats:
     *
     *		upcastWriter.createElement( 'div', { class: 'editor', contentEditable: 'true' } ); // object
     *		upcastWriter.createElement( 'div', [ [ 'class', 'editor' ], [ 'contentEditable', 'true' ] ] ); // map-like iterator
     *		upcastWriter.createElement( 'div', mapOfAttributes ); // map
     *
     * @param {String} name Node name.
     * @param {Object|Iterable} [attrs] Collection of attributes.
     * @param {module:engine/view/node~Node|Iterable.<module:engine/view/node~Node>} [children]
     * A list of nodes to be inserted into created element.
     * @returns {module:engine/view/element~Element} Created element.
     */

  }, {
    key: "createElement",
    value: function createElement(name, attrs, children) {
      return new element_Element(this.document, name, attrs, children);
    }
    /**
     * Creates a new {@link module:engine/view/text~Text} instance.
     *
     * @param {String} data The text's data.
     * @returns {module:engine/view/text~Text} The created text node.
     */

  }, {
    key: "createText",
    value: function createText(data) {
      return new text_Text(this.document, data);
    }
    /**
     * Clones the provided element.
     *
     * @see module:engine/view/element~Element#_clone
     * @param {module:engine/view/element~Element} element Element to be cloned.
     * @param {Boolean} [deep=false] If set to `true` clones element and all its children recursively. When set to `false`,
     * element will be cloned without any children.
     * @returns {module:engine/view/element~Element} Clone of this element.
     */

  }, {
    key: "clone",
    value: function clone(element) {
      var deep = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      return element._clone(deep);
    }
    /**
     * Appends a child node or a list of child nodes at the end of this node
     * and sets the parent of these nodes to this element.
     *
     * @see module:engine/view/element~Element#_appendChild
     * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.
     * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} element Element
     * to which items will be appended.
     * @fires module:engine/view/node~Node#event:change
     * @returns {Number} Number of appended nodes.
     */

  }, {
    key: "appendChild",
    value: function appendChild(items, element) {
      return element._appendChild(items);
    }
    /**
     * Inserts a child node or a list of child nodes on the given index and sets the parent of these nodes to
     * this element.
     *
     * @see module:engine/view/element~Element#_insertChild
     * @param {Number} index Offset at which nodes should be inserted.
     * @param {module:engine/view/item~Item|Iterable.<module:engine/view/item~Item>} items Items to be inserted.
     * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} element Element
     * to which items will be inserted.
     * @fires module:engine/view/node~Node#event:change
     * @returns {Number} Number of inserted nodes.
     */

  }, {
    key: "insertChild",
    value: function insertChild(index, items, element) {
      return element._insertChild(index, items);
    }
    /**
     * Removes the given number of child nodes starting at the given index and set the parent of these nodes to `null`.
     *
     * @see module:engine/view/element~Element#_removeChildren
     * @param {Number} index Offset from which nodes will be removed.
     * @param {Number} howMany Number of nodes to remove.
     * @param {module:engine/view/element~Element|module:engine/view/documentfragment~DocumentFragment} element Element
     * which children will be removed.
     * @fires module:engine/view/node~Node#event:change
     * @returns {Array.<module:engine/view/node~Node>} The array containing removed nodes.
     */

  }, {
    key: "removeChildren",
    value: function removeChildren(index, howMany, element) {
      return element._removeChildren(index, howMany);
    }
    /**
     * Removes given element from the view structure. Will not have effect on detached elements.
     *
     * @param {module:engine/view/element~Element} element Element which will be removed.
     * @returns {Array.<module:engine/view/node~Node>} The array containing removed nodes.
     */

  }, {
    key: "remove",
    value: function remove(element) {
      var parent = element.parent;

      if (parent) {
        return this.removeChildren(parent.getChildIndex(element), 1, parent);
      }

      return [];
    }
    /**
     * Replaces given element with the new one in the view structure. Will not have effect on detached elements.
     *
     * @param {module:engine/view/element~Element} oldElement Element which will be replaced.
     * @param {module:engine/view/element~Element} newElement Element which will be inserted in the place of the old element.
     * @returns {Boolean} Whether old element was successfully replaced.
     */

  }, {
    key: "replace",
    value: function replace(oldElement, newElement) {
      var parent = oldElement.parent;

      if (parent) {
        var index = parent.getChildIndex(oldElement);
        this.removeChildren(index, 1, parent);
        this.insertChild(index, newElement, parent);
        return true;
      }

      return false;
    }
    /**
     * Removes given element from view structure and places its children in its position.
     * It does nothing if element has no parent.
     *
     * @param {module:engine/view/element~Element} element Element to unwrap.
     */

  }, {
    key: "unwrapElement",
    value: function unwrapElement(element) {
      var parent = element.parent;

      if (parent) {
        var index = parent.getChildIndex(element);
        this.remove(element);
        this.insertChild(index, element.getChildren(), parent);
      }
    }
    /**
     * Renames element by creating a copy of a given element but with its name changed and then moving contents of the
     * old element to the new one.
     *
     * Since this function creates a new element and removes the given one, the new element is returned to keep reference.
     *
     * @param {String} newName New element name.
     * @param {module:engine/view/element~Element} element Element to be renamed.
     * @returns {module:engine/view/element~Element|null} New element or null if the old element
     * was not replaced (happens for detached elements).
     */

  }, {
    key: "rename",
    value: function rename(newName, element) {
      var newElement = new element_Element(this.document, newName, element.getAttributes(), element.getChildren());
      return this.replace(element, newElement) ? newElement : null;
    }
    /**
     * Adds or overwrites element's attribute with a specified key and value.
     *
     *		writer.setAttribute( linkElement, 'href', 'http://ckeditor.com' );
     *
     * @see module:engine/view/element~Element#_setAttribute
     * @param {String} key Attribute key.
     * @param {String} value Attribute value.
     * @param {module:engine/view/element~Element} element Element for which attribute will be set.
     */

  }, {
    key: "setAttribute",
    value: function setAttribute(key, value, element) {
      element._setAttribute(key, value);
    }
    /**
     * Removes attribute from the element.
     *
     *		writer.removeAttribute( linkElement, 'href' );
     *
     * @see module:engine/view/element~Element#_removeAttribute
     * @param {String} key Attribute key.
     * @param {module:engine/view/element~Element} element Element from which attribute will be removed.
     */

  }, {
    key: "removeAttribute",
    value: function removeAttribute(key, element) {
      element._removeAttribute(key);
    }
    /**
     * Adds specified class to the element.
     *
     *		writer.addClass( linkElement, 'foo' );
     *		writer.addClass( linkElement, [ 'foo', 'bar' ] );
     *
     * @see module:engine/view/element~Element#_addClass
     * @param {Array.<String>|String} className Single class name or array of class names which will be added.
     * @param {module:engine/view/element~Element} element Element for which class will be added.
     */

  }, {
    key: "addClass",
    value: function addClass(className, element) {
      element._addClass(className);
    }
    /**
     * Removes specified class from the element.
     *
     *		writer.removeClass( linkElement, 'foo' );
     *		writer.removeClass( linkElement, [ 'foo', 'bar' ] );
     *
     * @see module:engine/view/element~Element#_removeClass
     * @param {Array.<String>|String} className Single class name or array of class names which will be removed.
     * @param {module:engine/view/element~Element} element Element from which class will be removed.
     */

  }, {
    key: "removeClass",
    value: function removeClass(className, element) {
      element._removeClass(className);
    }
    /**
     * Adds style to the element.
     *
     *		writer.setStyle( element, 'color', 'red' );
     *		writer.setStyle( element, {
     *			color: 'red',
     *			position: 'fixed'
     *		} );
     *
     * **Note**: This method can work with normalized style names if
     * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
     * See {@link module:engine/view/stylesmap~StylesMap#set `StylesMap#set()`} for details.
     *
     * @see module:engine/view/element~Element#_setStyle
     * @param {String|Object} property Property name or object with key - value pairs.
     * @param {String} [value] Value to set. This parameter is ignored if object is provided as the first parameter.
     * @param {module:engine/view/element~Element} element Element for which style will be added.
     */

  }, {
    key: "setStyle",
    value: function setStyle(property, value, element) {
      if (lodash_es_isPlainObject(property) && element === undefined) {
        element = value;
      }

      element._setStyle(property, value);
    }
    /**
     * Removes specified style from the element.
     *
     *		writer.removeStyle( element, 'color' );  // Removes 'color' style.
     *		writer.removeStyle( element, [ 'color', 'border-top' ] ); // Removes both 'color' and 'border-top' styles.
     *
     * **Note**: This method can work with normalized style names if
     * {@link module:engine/controller/datacontroller~DataController#addStyleProcessorRules a particular style processor rule is enabled}.
     * See {@link module:engine/view/stylesmap~StylesMap#remove `StylesMap#remove()`} for details.
     *
     * @see module:engine/view/element~Element#_removeStyle
     * @param {Array.<String>|String} property Style property name or names to be removed.
     * @param {module:engine/view/element~Element} element Element from which style will be removed.
     */

  }, {
    key: "removeStyle",
    value: function removeStyle(property, element) {
      element._removeStyle(property);
    }
    /**
     * Sets a custom property on element. Unlike attributes, custom properties are not rendered to the DOM,
     * so they can be used to add special data to elements.
     *
     * @see module:engine/view/element~Element#_setCustomProperty
     * @param {String|Symbol} key Custom property name/key.
     * @param {*} value Custom property value to be stored.
     * @param {module:engine/view/element~Element} element Element for which custom property will be set.
     */

  }, {
    key: "setCustomProperty",
    value: function setCustomProperty(key, value, element) {
      element._setCustomProperty(key, value);
    }
    /**
     * Removes a custom property stored under the given key.
     *
     * @see module:engine/view/element~Element#_removeCustomProperty
     * @param {String|Symbol} key Name/key of the custom property to be removed.
     * @param {module:engine/view/element~Element} element Element from which the custom property will be removed.
     * @returns {Boolean} Returns true if property was removed.
     */

  }, {
    key: "removeCustomProperty",
    value: function removeCustomProperty(key, element) {
      return element._removeCustomProperty(key);
    }
    /**
     * Creates position at the given location. The location can be specified as:
     *
     * * a {@link module:engine/view/position~Position position},
     * * parent element and offset (offset defaults to `0`),
     * * parent element and `'end'` (sets position at the end of that element),
     * * {@link module:engine/view/item~Item view item} and `'before'` or `'after'` (sets position before or after given view item).
     *
     * This method is a shortcut to other constructors such as:
     *
     * * {@link #createPositionBefore},
     * * {@link #createPositionAfter},
     *
     * @param {module:engine/view/item~Item|module:engine/model/position~Position} itemOrPosition
     * @param {Number|'end'|'before'|'after'} [offset] Offset or one of the flags. Used only when
     * first parameter is a {@link module:engine/view/item~Item view item}.
     */

  }, {
    key: "createPositionAt",
    value: function createPositionAt(itemOrPosition, offset) {
      return position_Position._createAt(itemOrPosition, offset);
    }
    /**
     * Creates a new position after given view item.
     *
     * @param {module:engine/view/item~Item} item View item after which the position should be located.
     * @returns {module:engine/view/position~Position}
     */

  }, {
    key: "createPositionAfter",
    value: function createPositionAfter(item) {
      return position_Position._createAfter(item);
    }
    /**
     * Creates a new position before given view item.
     *
     * @param {module:engine/view/item~Item} item View item before which the position should be located.
     * @returns {module:engine/view/position~Position}
     */

  }, {
    key: "createPositionBefore",
    value: function createPositionBefore(item) {
      return position_Position._createBefore(item);
    }
    /**
     * Creates a range spanning from `start` position to `end` position.
     *
     * **Note:** This factory method creates it's own {@link module:engine/view/position~Position} instances basing on passed values.
     *
     * @param {module:engine/view/position~Position} start Start position.
     * @param {module:engine/view/position~Position} [end] End position. If not set, range will be collapsed at `start` position.
     * @returns {module:engine/view/range~Range}
     */

  }, {
    key: "createRange",
    value: function createRange(start, end) {
      return new range_Range(start, end);
    }
    /**
     * Creates a range that starts before given {@link module:engine/view/item~Item view item} and ends after it.
     *
     * @param {module:engine/view/item~Item} item
     * @returns {module:engine/view/range~Range}
     */

  }, {
    key: "createRangeOn",
    value: function createRangeOn(item) {
      return range_Range._createOn(item);
    }
    /**
     * Creates a range inside an {@link module:engine/view/element~Element element} which starts before the first child of
     * that element and ends after the last child of that element.
     *
     * @param {module:engine/view/element~Element} element Element which is a parent for the range.
     * @returns {module:engine/view/range~Range}
     */

  }, {
    key: "createRangeIn",
    value: function createRangeIn(element) {
      return range_Range._createIn(element);
    }
    /**
     * Creates a new {@link module:engine/view/selection~Selection} instance.
     *
     * 		// Creates empty selection without ranges.
     *		const selection = writer.createSelection();
     *
     *		// Creates selection at the given range.
     *		const range = writer.createRange( start, end );
     *		const selection = writer.createSelection( range );
     *
     *		// Creates selection at the given ranges
     * 		const ranges = [ writer.createRange( start1, end2 ), writer.createRange( star2, end2 ) ];
     *		const selection = writer.createSelection( ranges );
     *
     *		// Creates selection from the other selection.
     *		const otherSelection = writer.createSelection();
     *		const selection = writer.createSelection( otherSelection );
     *
     *		// Creates selection from the document selection.
     *		const selection = writer.createSelection( editor.editing.view.document.selection );
     *
     * 		// Creates selection at the given position.
     *		const position = writer.createPositionFromPath( root, path );
     *		const selection = writer.createSelection( position );
     *
     *		// Creates collapsed selection at the position of given item and offset.
     *		const paragraph = writer.createContainerElement( 'paragraph' );
     *		const selection = writer.createSelection( paragraph, offset );
     *
     *		// Creates a range inside an {@link module:engine/view/element~Element element} which starts before the
     *		// first child of that element and ends after the last child of that element.
     *		const selection = writer.createSelection( paragraph, 'in' );
     *
     *		// Creates a range on an {@link module:engine/view/item~Item item} which starts before the item and ends
     *		// just after the item.
     *		const selection = writer.createSelection( paragraph, 'on' );
     *
     * `Selection`'s constructor allow passing additional options (`backward`, `fake` and `label`) as the last argument.
     *
     *		// Creates backward selection.
     *		const selection = writer.createSelection( range, { backward: true } );
     *
     * Fake selection does not render as browser native selection over selected elements and is hidden to the user.
     * This way, no native selection UI artifacts are displayed to the user and selection over elements can be
     * represented in other way, for example by applying proper CSS class.
     *
     * Additionally fake's selection label can be provided. It will be used to describe fake selection in DOM
     * (and be  properly handled by screen readers).
     *
     *		// Creates fake selection with label.
     *		const selection = writer.createSelection( range, { fake: true, label: 'foo' } );
     *
     * @param {module:engine/view/selection~Selectable} [selectable=null]
     * @param {Number|'before'|'end'|'after'|'on'|'in'} [placeOrOffset] Offset or place when selectable is an `Item`.
     * @param {Object} [options]
     * @param {Boolean} [options.backward] Sets this selection instance to be backward.
     * @param {Boolean} [options.fake] Sets this selection instance to be marked as `fake`.
     * @param {String} [options.label] Label for the fake selection.
     * @returns {module:engine/view/selection~Selection}
     */

  }, {
    key: "createSelection",
    value: function createSelection(selectable, placeOrOffset, options) {
      return new selection_Selection(selectable, placeOrOffset, options);
    }
  }]);

  return UpcastWriter;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imageupload/imageuploadcommand.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */



/**
 * @module image/imageupload/imageuploadcommand
 */

/**
 * The image upload command.
 *
 * The command is registered by the {@link module:image/imageupload/imageuploadediting~ImageUploadEditing} plugin as `'imageUpload'`.
 *
 * In order to upload an image at the current selection position
 * (according to the {@link module:widget/utils~findOptimalInsertionPosition} algorithm),
 * execute the command and pass the native image file instance:
 *
 *		this.listenTo( editor.editing.view.document, 'clipboardInput', ( evt, data ) => {
 *			// Assuming that only images were pasted:
 *			const images = Array.from( data.dataTransfer.files );
 *
 *			// Upload the first image:
 *			editor.execute( 'imageUpload', { file: images[ 0 ] } );
 *		} );
 *
 * It is also possible to insert multiple images at once:
 *
 *		editor.execute( 'imageUpload', {
 *			file: [
 *				file1,
 *				file2
 *			]
 *		} );
 *
 * @extends module:core/command~Command
 */

var imageuploadcommand_ImageUploadCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(ImageUploadCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(ImageUploadCommand);

  function ImageUploadCommand() {
    Object(classCallCheck["a" /* default */])(this, ImageUploadCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ImageUploadCommand, [{
    key: "refresh",

    /**
     * @inheritDoc
     */
    value: function refresh() {
      this.isEnabled = isImageAllowed(this.editor.model);
    }
    /**
     * Executes the command.
     *
     * @fires execute
     * @param {Object} options Options for the executed command.
     * @param {File|Array.<File>} options.file The image file or an array of image files to upload.
     */

  }, {
    key: "execute",
    value: function execute(options) {
      var editor = this.editor;
      var model = editor.model;
      var fileRepository = editor.plugins.get(filerepository_FileRepository);
      model.change(function (writer) {
        var filesToUpload = Array.isArray(options.file) ? options.file : [options.file];

        var _iterator = _createForOfIteratorHelper(filesToUpload),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var file = _step.value;
            uploadImage(writer, model, fileRepository, file);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
    }
  }]);

  return ImageUploadCommand;
}(command_Command); // Handles uploading single file.
//
// @param {module:engine/model/writer~writer} writer
// @param {module:engine/model/model~Model} model
// @param {File} file




function uploadImage(writer, model, fileRepository, file) {
  var loader = fileRepository.createLoader(file); // Do not throw when upload adapter is not set. FileRepository will log an error anyway.

  if (!loader) {
    return;
  }

  insertImage(writer, model, {
    uploadId: loader.id
  });
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imageupload/imageuploadediting.js
















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imageupload/imageuploadediting
 */










/**
 * The editing part of the image upload feature. It registers the `'imageUpload'` command.
 *
 * @extends module:core/plugin~Plugin
 */

var imageuploadediting_ImageUploadEditing = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ImageUploadEditing, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ImageUploadEditing);

  Object(createClass["a" /* default */])(ImageUploadEditing, null, [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [filerepository_FileRepository, notification_Notification, clipboard_Clipboard];
    }
  }, {
    key: "pluginName",
    get: function get() {
      return 'ImageUploadEditing';
    }
    /**
     * @inheritDoc
     */

  }]);

  function ImageUploadEditing(editor) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, ImageUploadEditing);

    _this = _super.call(this, editor);
    editor.config.define('image', {
      upload: {
        types: ['jpeg', 'png', 'gif', 'bmp', 'webp', 'tiff']
      }
    });
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(ImageUploadEditing, [{
    key: "init",
    value: function init() {
      var _this2 = this;

      var editor = this.editor;
      var doc = editor.model.document;
      var schema = editor.model.schema;
      var conversion = editor.conversion;
      var fileRepository = editor.plugins.get(filerepository_FileRepository);
      var imageTypes = createImageTypeRegExp(editor.config.get('image.upload.types')); // Setup schema to allow uploadId and uploadStatus for images.

      schema.extend('image', {
        allowAttributes: ['uploadId', 'uploadStatus']
      }); // Register imageUpload command.

      editor.commands.add('imageUpload', new imageuploadcommand_ImageUploadCommand(editor)); // Register upcast converter for uploadId.

      conversion.for('upcast').attributeToAttribute({
        view: {
          name: 'img',
          key: 'uploadId'
        },
        model: 'uploadId'
      }); // Handle pasted images.
      // For every image file, a new file loader is created and a placeholder image is
      // inserted into the content. Then, those images are uploaded once they appear in the model
      // (see Document#change listener below).

      this.listenTo(editor.editing.view.document, 'clipboardInput', function (evt, data) {
        // Skip if non empty HTML data is included.
        // https://github.com/ckeditor/ckeditor5-upload/issues/68
        if (isHtmlIncluded(data.dataTransfer)) {
          return;
        }

        var images = Array.from(data.dataTransfer.files).filter(function (file) {
          // See https://github.com/ckeditor/ckeditor5-image/pull/254.
          if (!file) {
            return false;
          }

          return imageTypes.test(file.type);
        });
        var ranges = data.targetRanges.map(function (viewRange) {
          return editor.editing.mapper.toModelRange(viewRange);
        });
        editor.model.change(function (writer) {
          // Set selection to paste target.
          writer.setSelection(ranges);

          if (images.length) {
            evt.stop(); // Upload images after the selection has changed in order to ensure the command's state is refreshed.

            editor.model.enqueueChange('default', function () {
              editor.execute('imageUpload', {
                file: images
              });
            });
          }
        });
      }); // Handle HTML pasted with images with base64 or blob sources.
      // For every image file, a new file loader is created and a placeholder image is
      // inserted into the content. Then, those images are uploaded once they appear in the model
      // (see Document#change listener below).

      this.listenTo(editor.plugins.get(clipboard_Clipboard), 'inputTransformation', function (evt, data) {
        var fetchableImages = Array.from(editor.editing.view.createRangeIn(data.content)).filter(function (value) {
          return isLocalImage(value.item) && !value.item.getAttribute('uploadProcessed');
        }).map(function (value) {
          return {
            promise: fetchLocalImage(value.item),
            imageElement: value.item
          };
        });

        if (!fetchableImages.length) {
          return;
        }

        var writer = new upcastwriter_UpcastWriter(editor.editing.view.document);

        var _iterator = _createForOfIteratorHelper(fetchableImages),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var fetchableImage = _step.value;
            // Set attribute marking that the image was processed already.
            writer.setAttribute('uploadProcessed', true, fetchableImage.imageElement);
            var loader = fileRepository.createLoader(fetchableImage.promise);

            if (loader) {
              writer.setAttribute('src', '', fetchableImage.imageElement);
              writer.setAttribute('uploadId', loader.id, fetchableImage.imageElement);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }); // Prevents from the browser redirecting to the dropped image.

      editor.editing.view.document.on('dragover', function (evt, data) {
        data.preventDefault();
      }); // Upload placeholder images that appeared in the model.

      doc.on('change', function () {
        var changes = doc.differ.getChanges({
          includeChangesInGraveyard: true
        });

        var _iterator2 = _createForOfIteratorHelper(changes),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var entry = _step2.value;

            if (entry.type == 'insert' && entry.name != '$text') {
              var item = entry.position.nodeAfter;
              var isInGraveyard = entry.position.root.rootName == '$graveyard';

              var _iterator3 = _createForOfIteratorHelper(getImagesFromChangeItem(editor, item)),
                  _step3;

              try {
                for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
                  var image = _step3.value;
                  // Check if the image element still has upload id.
                  var uploadId = image.getAttribute('uploadId');

                  if (!uploadId) {
                    continue;
                  } // Check if the image is loaded on this client.


                  var loader = fileRepository.loaders.get(uploadId);

                  if (!loader) {
                    continue;
                  }

                  if (isInGraveyard) {
                    // If the image was inserted to the graveyard - abort the loading process.
                    loader.abort();
                  } else if (loader.status == 'idle') {
                    // If the image was inserted into content and has not been loaded yet, start loading it.
                    _this2._readAndUpload(loader, image);
                  }
                }
              } catch (err) {
                _iterator3.e(err);
              } finally {
                _iterator3.f();
              }
            }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      });
    }
    /**
     * Reads and uploads an image.
     *
     * The image is read from the disk and as a Base64-encoded string it is set temporarily to
     * `image[src]`. When the image is successfully uploaded, the temporary data is replaced with the target
     * image's URL (the URL to the uploaded image on the server).
     *
     * @protected
     * @param {module:upload/filerepository~FileLoader} loader
     * @param {module:engine/model/element~Element} imageElement
     * @returns {Promise}
     */

  }, {
    key: "_readAndUpload",
    value: function _readAndUpload(loader, imageElement) {
      var _this3 = this;

      var editor = this.editor;
      var model = editor.model;
      var t = editor.locale.t;
      var fileRepository = editor.plugins.get(filerepository_FileRepository);
      var notification = editor.plugins.get(notification_Notification);
      model.enqueueChange('transparent', function (writer) {
        writer.setAttribute('uploadStatus', 'reading', imageElement);
      });
      return loader.read().then(function () {
        var promise = loader.upload(); // Force re–paint in Safari. Without it, the image will display with a wrong size.
        // https://github.com/ckeditor/ckeditor5/issues/1975

        /* istanbul ignore next */

        if (src_env.isSafari) {
          var viewFigure = editor.editing.mapper.toViewElement(imageElement);
          var viewImg = getViewImgFromWidget(viewFigure);
          editor.editing.view.once('render', function () {
            // Early returns just to be safe. There might be some code ran
            // in between the outer scope and this callback.
            if (!viewImg.parent) {
              return;
            }

            var domFigure = editor.editing.view.domConverter.mapViewToDom(viewImg.parent);

            if (!domFigure) {
              return;
            }

            var originalDisplay = domFigure.style.display;
            domFigure.style.display = 'none'; // Make sure this line will never be removed during minification for having "no effect".

            domFigure._ckHack = domFigure.offsetHeight;
            domFigure.style.display = originalDisplay;
          });
        }

        model.enqueueChange('transparent', function (writer) {
          writer.setAttribute('uploadStatus', 'uploading', imageElement);
        });
        return promise;
      }).then(function (data) {
        model.enqueueChange('transparent', function (writer) {
          writer.setAttributes({
            uploadStatus: 'complete',
            src: data.default
          }, imageElement);

          _this3._parseAndSetSrcsetAttributeOnImage(data, imageElement, writer);
        });
        clean();
      }).catch(function (error) {
        // If status is not 'error' nor 'aborted' - throw error because it means that something else went wrong,
        // it might be generic error and it would be real pain to find what is going on.
        if (loader.status !== 'error' && loader.status !== 'aborted') {
          throw error;
        } // Might be 'aborted'.


        if (loader.status == 'error' && error) {
          notification.showWarning(error, {
            title: t('Upload failed'),
            namespace: 'upload'
          });
        }

        clean(); // Permanently remove image from insertion batch.

        model.enqueueChange('transparent', function (writer) {
          writer.remove(imageElement);
        });
      });

      function clean() {
        model.enqueueChange('transparent', function (writer) {
          writer.removeAttribute('uploadId', imageElement);
          writer.removeAttribute('uploadStatus', imageElement);
        });
        fileRepository.destroyLoader(loader);
      }
    }
    /**
     * Creates the `srcset` attribute based on a given file upload response and sets it as an attribute to a specific image element.
     *
     * @protected
     * @param {Object} data Data object from which `srcset` will be created.
     * @param {module:engine/model/element~Element} image The image element on which the `srcset` attribute will be set.
     * @param {module:engine/model/writer~Writer} writer
     */

  }, {
    key: "_parseAndSetSrcsetAttributeOnImage",
    value: function _parseAndSetSrcsetAttributeOnImage(data, image, writer) {
      // Srcset attribute for responsive images support.
      var maxWidth = 0;
      var srcsetAttribute = Object.keys(data) // Filter out keys that are not integers.
      .filter(function (key) {
        var width = parseInt(key, 10);

        if (!isNaN(width)) {
          maxWidth = Math.max(maxWidth, width);
          return true;
        }
      }) // Convert each key to srcset entry.
      .map(function (key) {
        return "".concat(data[key], " ").concat(key, "w");
      }) // Join all entries.
      .join(', ');

      if (srcsetAttribute != '') {
        writer.setAttribute('srcset', {
          data: srcsetAttribute,
          width: maxWidth
        }, image);
      }
    }
  }]);

  return ImageUploadEditing;
}(plugin_Plugin); // Returns `true` if non-empty `text/html` is included in the data transfer.
//
// @param {module:clipboard/datatransfer~DataTransfer} dataTransfer
// @returns {Boolean}



function isHtmlIncluded(dataTransfer) {
  return Array.from(dataTransfer.types).includes('text/html') && dataTransfer.getData('text/html') !== '';
}

function getImagesFromChangeItem(editor, item) {
  return Array.from(editor.model.createRangeOn(item)).filter(function (value) {
    return value.item.is('image');
  }).map(function (value) {
    return value.item;
  });
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imageupload.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imageupload
 */




/**
 * The image upload plugin.
 *
 * For a detailed overview, check the {@glink features/image-upload/image-upload image upload feature} documentation.
 *
 * This plugin does not do anything directly, but it loads a set of specific plugins to enable image uploading:
 *
 * * {@link module:image/imageupload/imageuploadediting~ImageUploadEditing},
 * * {@link module:image/imageupload/imageuploadui~ImageUploadUI},
 * * {@link module:image/imageupload/imageuploadprogress~ImageUploadProgress}.
 *
 * @extends module:core/plugin~Plugin
 */

var imageupload_ImageUpload = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ImageUpload, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ImageUpload);

  function ImageUpload() {
    Object(classCallCheck["a" /* default */])(this, ImageUpload);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ImageUpload, null, [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'ImageUpload';
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "requires",
    get: function get() {
      return [imageuploadediting_ImageUploadEditing, imageuploadui_ImageUploadUI, imageuploadprogress_ImageUploadProgress];
    }
  }]);

  return ImageUpload;
}(plugin_Plugin);
/**
 * Image upload configuration.
 *
 * @member {module:image/imageupload~ImageUploadConfig} module:image/image~ImageConfig#upload
 */

/**
 * The configuration of the image upload feature. Used by the image upload feature in the `@ckeditor/ckeditor5-image` package.
 *
 *		ClassicEditor
 *			.create( editorElement, {
 * 				image: {
 * 					upload:  ... // Image upload feature options.
 * 				}
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * See {@link module:core/editor/editorconfig~EditorConfig all editor options}.
 *
 * @interface module:image/imageupload~ImageUploadConfig
 */

/**
 * The list of accepted image types.
 *
 * The accepted types of images can be customized to allow only certain types of images:
 *
 *		// Allow only JPEG and PNG images:
 *		const imageUploadConfig = {
 *			types: [ 'png', 'jpeg' ]
 *		};
 *
 * The type string should match [one of the sub-types](https://www.iana.org/assignments/media-types/media-types.xhtml#image)
 * of the image MIME type. E.g. for the `image/jpeg` MIME type, add `'jpeg'` to your image upload configuration.
 *
 * **Note:** This setting only restricts some image types to be selected and uploaded through the CKEditor UI and commands. Image type
 * recognition and filtering should also be implemented on the server which accepts image uploads.
 *
 * @member {Array.<String>} module:image/imageupload~ImageUploadConfig#types
 * @default [ 'jpeg', 'png', 'gif', 'bmp', 'webp', 'tiff' ]
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-easy-image/src/easyimage.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module easy-image/easyimage
 */




/**
 * The Easy Image feature, which makes the image upload in CKEditor 5 possible with virtually zero
 * server setup. A part of the [CKEditor Cloud Services](https://ckeditor.com/ckeditor-cloud-services/)
 * family.
 *
 * This is a "glue" plugin which enables:
 *
 * * {@link module:image/image~Image},
 * * {@link module:image/imageupload~ImageUpload},
 * * {@link module:easy-image/cloudservicesuploadadapter~CloudServicesUploadAdapter}.
 *
 * See the {@glink features/image-upload/easy-image "Easy Image integration" guide} to learn how to configure
 * and use this feature.
 *
 * Check out the {@glink features/image-upload/image-upload comprehensive "Image upload" guide} to learn about
 * other ways to upload images into CKEditor 5.
 *
 * **Note**: After enabling the Easy Image plugin you need to configure the
 * [CKEditor Cloud Services](https://ckeditor.com/ckeditor-cloud-services/)
 * integration through {@link module:cloud-services/cloudservices~CloudServicesConfig `config.cloudServices`}.
 *
 * @extends module:core/plugin~Plugin
 */

var easyimage_EasyImage = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(EasyImage, _Plugin);

  var _super = Object(createSuper["a" /* default */])(EasyImage);

  function EasyImage() {
    Object(classCallCheck["a" /* default */])(this, EasyImage);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(EasyImage, null, [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [cloudservicesuploadadapter_CloudServicesUploadAdapter, image_Image, imageupload_ImageUpload];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'EasyImage';
    }
  }]);

  return EasyImage;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-paragraph/src/paragraphcommand.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module paragraph/paragraphcommand
 */


/**
 * The paragraph command.
 *
 * @extends module:core/command~Command
 */

var paragraphcommand_ParagraphCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(ParagraphCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(ParagraphCommand);

  function ParagraphCommand() {
    Object(classCallCheck["a" /* default */])(this, ParagraphCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ParagraphCommand, [{
    key: "refresh",

    /**
     * The value of the command. Indicates whether the selection start is placed in a paragraph.
     *
     * @readonly
     * @observable
     * @member {Boolean} #value
     */

    /**
     * @inheritDoc
     */
    value: function refresh() {
      var model = this.editor.model;
      var document = model.document;
      var block = first_first(document.selection.getSelectedBlocks());
      this.value = !!block && block.is('paragraph');
      this.isEnabled = !!block && checkCanBecomeParagraph(block, model.schema);
    }
    /**
     * Executes the command. All the blocks (see {@link module:engine/model/schema~Schema}) in the selection
     * will be turned to paragraphs.
     *
     * @fires execute
     * @param {Object} [options] Options for the executed command.
     * @param {module:engine/model/selection~Selection|module:engine/model/documentselection~DocumentSelection} [options.selection]
     * The selection that the command should be applied to.
     * By default, if not provided, the command is applied to the {@link module:engine/model/document~Document#selection}.
     */

  }, {
    key: "execute",
    value: function execute() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var model = this.editor.model;
      var document = model.document;
      model.change(function (writer) {
        var blocks = (options.selection || document.selection).getSelectedBlocks();

        var _iterator = _createForOfIteratorHelper(blocks),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var block = _step.value;

            if (!block.is('paragraph') && checkCanBecomeParagraph(block, model.schema)) {
              writer.rename(block, 'paragraph');
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
    }
  }]);

  return ParagraphCommand;
}(command_Command); // Checks whether the given block can be replaced by a paragraph.
//
// @private
// @param {module:engine/model/element~Element} block A block to be tested.
// @param {module:engine/model/schema~Schema} schema The schema of the document.
// @returns {Boolean}




function checkCanBecomeParagraph(block, schema) {
  return schema.checkChild(block.parent, 'paragraph') && !schema.isObject(block);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-paragraph/src/insertparagraphcommand.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module paragraph/insertparagraphcommand
 */

/**
 * The insert paragraph command. It inserts a new paragraph at a specific
 * {@link module:engine/model/position~Position document position}.
 *
 *		// Insert a new paragraph before an element in the document.
 *		editor.execute( 'insertParagraph', {
 *			position: editor.model.createPositionBefore( element )
 *		} );
 *
 * If a paragraph is disallowed in the context of the specific position, the command
 * will attempt to split position ancestors to find a place where it is possible
 * to insert a paragraph.
 *
 * **Note**: This command moves the selection to the inserted paragraph.
 *
 * @extends module:core/command~Command
 */

var insertparagraphcommand_InsertParagraphCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(InsertParagraphCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(InsertParagraphCommand);

  function InsertParagraphCommand() {
    Object(classCallCheck["a" /* default */])(this, InsertParagraphCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(InsertParagraphCommand, [{
    key: "execute",

    /**
     * Executes the command.
     *
     * @param {Object} options Options for the executed command.
     * @param {module:engine/model/position~Position} options.position The model position at which
     * the new paragraph will be inserted.
     * @fires execute
     */
    value: function execute(options) {
      var model = this.editor.model;
      var position = options.position;
      model.change(function (writer) {
        var paragraph = writer.createElement('paragraph');

        if (!model.schema.checkChild(position.parent, paragraph)) {
          var allowedParent = model.schema.findAllowedParent(position, paragraph); // It could be there's no ancestor limit that would allow paragraph.
          // In theory, "paragraph" could be disallowed even in the "$root".

          if (!allowedParent) {
            return;
          }

          position = writer.split(position, allowedParent).position;
        }

        model.insertContent(paragraph, position);
        writer.setSelection(paragraph, 'in');
      });
    }
  }]);

  return InsertParagraphCommand;
}(command_Command);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-paragraph/src/paragraph.js













/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module paragraph/paragraph
 */



/**
 * The paragraph feature for the editor.
 *
 * It introduces the `<paragraph>` element in the model which renders as a `<p>` element in the DOM and data.
 *
 * It also brings two editors commands:
 *
 * * The {@link module:paragraph/paragraphcommand~ParagraphCommand `'paragraph'`} command that converts all
 * blocks in the model selection into paragraphs.
 * * The {@link module:paragraph/insertparagraphcommand~InsertParagraphCommand `'insertParagraph'`} command
 * that inserts a new paragraph at a specified location in the model.
 *
 * @extends module:core/plugin~Plugin
 */

var paragraph_Paragraph = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(Paragraph, _Plugin);

  var _super = Object(createSuper["a" /* default */])(Paragraph);

  function Paragraph() {
    Object(classCallCheck["a" /* default */])(this, Paragraph);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Paragraph, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this = this;

      var editor = this.editor;
      var model = editor.model;
      var data = editor.data;
      editor.commands.add('paragraph', new paragraphcommand_ParagraphCommand(editor));
      editor.commands.add('insertParagraph', new insertparagraphcommand_InsertParagraphCommand(editor)); // Schema.

      model.schema.register('paragraph', {
        inheritAllFrom: '$block'
      });
      editor.conversion.elementToElement({
        model: 'paragraph',
        view: 'p'
      }); // Content autoparagraphing. --------------------------------------------------
      // Handles element which has not been converted by any plugin and checks if it would be converted if
      // we wrap it in a paragraph or change it to a paragraph.

      editor.conversion.for('upcast').elementToElement({
        model: function model(viewElement, modelWriter) {
          if (!Paragraph.paragraphLikeElements.has(viewElement.name)) {
            return null;
          } // Do not auto-paragraph empty elements.


          if (viewElement.isEmpty) {
            return null;
          }

          return modelWriter.createElement('paragraph');
        },
        converterPriority: 'low'
      });
      data.upcastDispatcher.on('element', function (evt, data, conversionApi) {
        // Do not try auto-paragraphing if the element was already converted.
        if (!conversionApi.consumable.test(data.viewItem, {
          name: data.viewItem.name
        })) {
          return;
        } // If the element is not paragraph-like try wrapping it in a paragraph.


        if (isParagraphable(data.viewItem, data.modelCursor, conversionApi.schema)) {
          Object.assign(data, wrapInParagraph(data.viewItem, data.modelCursor, conversionApi));
        }
      }, {
        priority: 'low'
      }); // Handles not converted text nodes and checks if would be converted if we wraps then by a paragraph.

      data.upcastDispatcher.on('text', function (evt, data, conversionApi) {
        // When node is already converted then do nothing.
        if (data.modelRange) {
          return;
        }

        if (isParagraphable(data.viewItem, data.modelCursor, conversionApi.schema)) {
          Object.assign(data, wrapInParagraph(data.viewItem, data.modelCursor, conversionApi));
        }
      }, {
        priority: 'lowest'
      }); // Empty roots autoparagraphing. -----------------------------------------------
      // Post-fixer which takes care of adding empty paragraph elements to empty roots.
      // Besides fixing content on #changesDone we also need to handle editor.data#ready event because
      // if initial data is empty or setData() wasn't even called there will be no #change fired.

      model.document.registerPostFixer(function (writer) {
        return _this._autoparagraphEmptyRoots(writer);
      });
      editor.data.on('ready', function () {
        model.enqueueChange('transparent', function (writer) {
          return _this._autoparagraphEmptyRoots(writer);
        });
      }, {
        priority: 'lowest'
      });
    }
    /**
     * Fixes all empty roots.
     *
     * @private
     * @returns {Boolean} `true` if any change has been applied, `false` otherwise.
     */

  }, {
    key: "_autoparagraphEmptyRoots",
    value: function _autoparagraphEmptyRoots(writer) {
      var model = this.editor.model;

      var _iterator = _createForOfIteratorHelper(model.document.getRootNames()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var rootName = _step.value;
          var root = model.document.getRoot(rootName);

          if (root.isEmpty && root.rootName != '$graveyard') {
            // If paragraph element is allowed in the root, create paragraph element.
            if (model.schema.checkChild(root, 'paragraph')) {
              writer.insertElement('paragraph', root);
              return true;
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'Paragraph';
    }
  }]);

  return Paragraph;
}(plugin_Plugin);
/**
 * A list of element names which should be treated by the autoparagraphing algorithms as
 * paragraph-like. This means that e.g. the following content:
 *
 *		<h1>Foo</h1>
 *		<table>
 *			<tr>
 *				<td>X</td>
 *				<td>
 *					<ul>
 *						<li>Y</li>
 *						<li>Z</li>
 *					</ul>
 *				</td>
 *			</tr>
 *		</table>
 *
 * contains five paragraph-like elements: `<h1>`, two `<td>`s and two `<li>`s.
 * Hence, if none of the features is going to convert those elements the above content will be automatically handled
 * by the paragraph feature and converted to:
 *
 *		<p>Foo</p>
 *		<p>X</p>
 *		<p>Y</p>
 *		<p>Z</p>
 *
 * Note: The `<td>` containing two `<li>` elements was ignored as the innermost paragraph-like elements
 * have a priority upon conversion.
 *
 * @member {Set.<String>} module:paragraph/paragraph~Paragraph.paragraphLikeElements
 */



paragraph_Paragraph.paragraphLikeElements = new Set(['blockquote', 'dd', 'div', 'dt', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'li', 'p', 'td']);

function wrapInParagraph(input, position, conversionApi) {
  var paragraph = conversionApi.writer.createElement('paragraph');
  conversionApi.writer.insert(paragraph, position);
  return conversionApi.convertItem(input, conversionApi.writer.createPositionAt(paragraph, 0));
}

function isParagraphable(node, position, schema) {
  var context = schema.createContext(position); // When paragraph is allowed in this context...

  if (!schema.checkChild(context, 'paragraph')) {
    return false;
  } // And a node would be allowed in this paragraph...


  if (!schema.checkChild(context.push('paragraph'), node)) {
    return false;
  }

  return true;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-heading/src/headingcommand.js













/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module heading/headingcommand
 */


/**
 * The heading command. It is used by the {@link module:heading/heading~Heading heading feature} to apply headings.
 *
 * @extends module:core/command~Command
 */

var headingcommand_HeadingCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(HeadingCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(HeadingCommand);

  /**
   * Creates an instance of the command.
   *
   * @param {module:core/editor/editor~Editor} editor Editor instance.
   * @param {Array.<String>} modelElements Names of the element which this command can apply in the model.
   */
  function HeadingCommand(editor, modelElements) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, HeadingCommand);

    _this = _super.call(this, editor);
    /**
     * If the selection starts in a heading (which {@link #modelElements is supported by this command})
     * the value is set to the name of that heading model element.
     * It is  set to `false` otherwise.
     *
     * @observable
     * @readonly
     * @member {Boolean|String} #value
     */

    /**
     * Set of defined model's elements names that this command support.
     * See {@link module:heading/heading~HeadingOption}.
     *
     * @readonly
     * @member {Array.<String>}
     */

    _this.modelElements = modelElements;
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(HeadingCommand, [{
    key: "refresh",
    value: function refresh() {
      var _this2 = this;

      var block = first_first(this.editor.model.document.selection.getSelectedBlocks());
      this.value = !!block && this.modelElements.includes(block.name) && block.name;
      this.isEnabled = !!block && this.modelElements.some(function (heading) {
        return checkCanBecomeHeading(block, heading, _this2.editor.model.schema);
      });
    }
    /**
     * Executes the command. Applies the heading to the selected blocks or, if the first selected
     * block is a heading already, turns selected headings (of this level only) to paragraphs.
     *
     * @param {Object} options
     * @param {String} options.value Name of the element which this command will apply in the model.
     * @fires execute
     */

  }, {
    key: "execute",
    value: function execute(options) {
      var model = this.editor.model;
      var document = model.document;
      var modelElement = options.value;
      model.change(function (writer) {
        var blocks = Array.from(document.selection.getSelectedBlocks()).filter(function (block) {
          return checkCanBecomeHeading(block, modelElement, model.schema);
        });

        var _iterator = _createForOfIteratorHelper(blocks),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var block = _step.value;

            if (!block.is(modelElement)) {
              writer.rename(block, modelElement);
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
    }
  }]);

  return HeadingCommand;
}(command_Command); // Checks whether the given block can be replaced by a specific heading.
//
// @private
// @param {module:engine/model/element~Element} block A block to be tested.
// @param {module:heading/headingcommand~HeadingCommand#modelElement} heading Command element name in the model.
// @param {module:engine/model/schema~Schema} schema The schema of the document.
// @returns {Boolean}




function checkCanBecomeHeading(block, heading, schema) {
  return schema.checkChild(block.parent, heading) && !schema.isObject(block);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-heading/src/headingediting.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module heading/headingediting
 */




var defaultModelElement = 'paragraph';
/**
 * The headings engine feature. It handles switching between block formats &ndash; headings and paragraph.
 * This class represents the engine part of the heading feature. See also {@link module:heading/heading~Heading}.
 * It introduces `heading1`-`headingN` commands which allow to convert paragraphs into headings.
 *
 * @extends module:core/plugin~Plugin
 */

var headingediting_HeadingEditing = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(HeadingEditing, _Plugin);

  var _super = Object(createSuper["a" /* default */])(HeadingEditing);

  Object(createClass["a" /* default */])(HeadingEditing, null, [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'HeadingEditing';
    }
    /**
     * @inheritDoc
     */

  }]);

  function HeadingEditing(editor) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, HeadingEditing);

    _this = _super.call(this, editor);
    editor.config.define('heading', {
      options: [{
        model: 'paragraph',
        title: 'Paragraph',
        class: 'ck-heading_paragraph'
      }, {
        model: 'heading1',
        view: 'h2',
        title: 'Heading 1',
        class: 'ck-heading_heading1'
      }, {
        model: 'heading2',
        view: 'h3',
        title: 'Heading 2',
        class: 'ck-heading_heading2'
      }, {
        model: 'heading3',
        view: 'h4',
        title: 'Heading 3',
        class: 'ck-heading_heading3'
      }]
    });
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(HeadingEditing, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var editor = this.editor;
      var options = editor.config.get('heading.options');
      var modelElements = [];

      var _iterator = _createForOfIteratorHelper(options),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var option = _step.value;

          // Skip paragraph - it is defined in required Paragraph feature.
          if (option.model !== defaultModelElement) {
            // Schema.
            editor.model.schema.register(option.model, {
              inheritAllFrom: '$block'
            });
            editor.conversion.elementToElement(option);
            modelElements.push(option.model);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this._addDefaultH1Conversion(editor); // Register the heading command for this option.


      editor.commands.add('heading', new headingcommand_HeadingCommand(editor, modelElements));
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "afterInit",
    value: function afterInit() {
      // If the enter command is added to the editor, alter its behavior.
      // Enter at the end of a heading element should create a paragraph.
      var editor = this.editor;
      var enterCommand = editor.commands.get('enter');
      var options = editor.config.get('heading.options');

      if (enterCommand) {
        this.listenTo(enterCommand, 'afterExecute', function (evt, data) {
          var positionParent = editor.model.document.selection.getFirstPosition().parent;
          var isHeading = options.some(function (option) {
            return positionParent.is(option.model);
          });

          if (isHeading && !positionParent.is(defaultModelElement) && positionParent.childCount === 0) {
            data.writer.rename(positionParent, defaultModelElement);
          }
        });
      }
    }
    /**
     * Adds default conversion for `h1` -> `heading1` with a low priority.
     *
     * @private
     * @param {module:core/editor/editor~Editor} editor Editor instance on which to add the `h1` conversion.
     */

  }, {
    key: "_addDefaultH1Conversion",
    value: function _addDefaultH1Conversion(editor) {
      editor.conversion.for('upcast').elementToElement({
        model: 'heading1',
        view: 'h1',
        // With a `low` priority, `paragraph` plugin autoparagraphing mechanism is executed. Make sure
        // this listener is called before it. If not, `h1` will be transformed into a paragraph.
        converterPriority: src_priorities.get('low') + 1
      });
    }
  }], [{
    key: "requires",
    get: function get() {
      return [paragraph_Paragraph];
    }
  }]);

  return HeadingEditing;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/model.js


/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/model
 */



/**
 * The base MVC model class.
 *
 * @mixes module:utils/observablemixin~ObservableMixin
 */

var src_model_Model =
/**
 * Creates a new Model instance.
 *
 * @param {Object} [attributes] The model state attributes to be defined during the instance creation.
 * @param {Object} [properties] The (out of state) properties to be appended to the instance during creation.
 */
function Model(attributes, properties) {
  Object(classCallCheck["a" /* default */])(this, Model);

  // Extend this instance with the additional (out of state) properties.
  if (properties) {
    lodash_es_assignIn(this, properties);
  } // Initialize the attributes.


  if (attributes) {
    this.set(attributes);
  }
};


mix(src_model_Model, observablemixin);
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-heading/src/utils.js


/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module heading/utils
 */

/**
 * Returns heading options as defined in `config.heading.options` but processed to consider
 * the editor localization, i.e. to display {@link module:heading/heading~HeadingOption}
 * in the correct language.
 *
 * Note: The reason behind this method is that there is no way to use {@link module:utils/locale~Locale#t}
 * when the user configuration is defined because the editor does not exist yet.
 *
 * @param {module:core/editor/editor~Editor} editor
 * @returns {Array.<module:heading/heading~HeadingOption>}.
 */
function getLocalizedOptions(editor) {
  var t = editor.t;
  var localizedTitles = {
    Paragraph: t('Paragraph'),
    'Heading 1': t('Heading 1'),
    'Heading 2': t('Heading 2'),
    'Heading 3': t('Heading 3'),
    'Heading 4': t('Heading 4'),
    'Heading 5': t('Heading 5'),
    'Heading 6': t('Heading 6')
  };
  return editor.config.get('heading.options').map(function (option) {
    var title = localizedTitles[option.title];

    if (title && title != option.title) {
      option.title = title;
    }

    return option;
  });
}
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-heading/theme/heading.css
var heading = __webpack_require__("8b56");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-heading/src/headingui.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module heading/headingui
 */






/**
 * The headings UI feature. It introduces the `headings` dropdown.
 *
 * @extends module:core/plugin~Plugin
 */

var headingui_HeadingUI = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(HeadingUI, _Plugin);

  var _super = Object(createSuper["a" /* default */])(HeadingUI);

  function HeadingUI() {
    Object(classCallCheck["a" /* default */])(this, HeadingUI);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(HeadingUI, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this = this;

      var editor = this.editor;
      var t = editor.t;
      var options = getLocalizedOptions(editor);
      var defaultTitle = t('Choose heading');
      var dropdownTooltip = t('Heading'); // Register UI component.

      editor.ui.componentFactory.add('heading', function (locale) {
        var titles = {};
        var itemDefinitions = new collection_Collection();
        var headingCommand = editor.commands.get('heading');
        var paragraphCommand = editor.commands.get('paragraph');
        var commands = [headingCommand];

        var _iterator = _createForOfIteratorHelper(options),
            _step;

        try {
          var _loop = function _loop() {
            var option = _step.value;
            var def = {
              type: 'button',
              model: new src_model_Model({
                label: option.title,
                class: option.class,
                withText: true
              })
            };

            if (option.model === 'paragraph') {
              def.model.bind('isOn').to(paragraphCommand, 'value');
              def.model.set('commandName', 'paragraph');
              commands.push(paragraphCommand);
            } else {
              def.model.bind('isOn').to(headingCommand, 'value', function (value) {
                return value === option.model;
              });
              def.model.set({
                commandName: 'heading',
                commandValue: option.model
              });
            } // Add the option to the collection.


            itemDefinitions.add(def);
            titles[option.model] = option.title;
          };

          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            _loop();
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        var dropdownView = createDropdown(locale);
        addListToDropdown(dropdownView, itemDefinitions);
        dropdownView.buttonView.set({
          isOn: false,
          withText: true,
          tooltip: dropdownTooltip
        });
        dropdownView.extendTemplate({
          attributes: {
            class: ['ck-heading-dropdown']
          }
        });
        dropdownView.bind('isEnabled').toMany(commands, 'isEnabled', function () {
          for (var _len = arguments.length, areEnabled = new Array(_len), _key = 0; _key < _len; _key++) {
            areEnabled[_key] = arguments[_key];
          }

          return areEnabled.some(function (isEnabled) {
            return isEnabled;
          });
        });
        dropdownView.buttonView.bind('label').to(headingCommand, 'value', paragraphCommand, 'value', function (value, para) {
          var whichModel = value || para && 'paragraph'; // If none of the commands is active, display default title.

          return titles[whichModel] ? titles[whichModel] : defaultTitle;
        }); // Execute command when an item from the dropdown is selected.

        _this.listenTo(dropdownView, 'execute', function (evt) {
          editor.execute(evt.source.commandName, evt.source.commandValue ? {
            value: evt.source.commandValue
          } : undefined);
          editor.editing.view.focus();
        });

        return dropdownView;
      });
    }
  }]);

  return HeadingUI;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-heading/src/heading.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module heading/heading
 */




/**
 * The headings feature.
 *
 * For a detailed overview, check the {@glink features/headings Headings feature documentation}
 * and the {@glink api/heading package page}.
 *
 * This is a "glue" plugin which loads the {@link module:heading/headingediting~HeadingEditing heading editing feature}
 * and {@link module:heading/headingui~HeadingUI heading UI feature}.
 *
 * @extends module:core/plugin~Plugin
 */

var heading_Heading = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(Heading, _Plugin);

  var _super = Object(createSuper["a" /* default */])(Heading);

  function Heading() {
    Object(classCallCheck["a" /* default */])(this, Heading);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Heading, null, [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [headingediting_HeadingEditing, headingui_HeadingUI];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'Heading';
    }
  }]);

  return Heading;
}(plugin_Plugin);
/**
 * The configuration of the heading feature. Introduced by the {@link module:heading/headingediting~HeadingEditing} feature.
 *
 * Read more in {@link module:heading/heading~HeadingConfig}.
 *
 * @member {module:heading/heading~HeadingConfig} module:core/editor/editorconfig~EditorConfig#heading
 */

/**
 * The configuration of the heading feature.
 * The option is used by the {@link module:heading/headingediting~HeadingEditing} feature.
 *
 *		ClassicEditor
 *			.create( {
 * 				heading: ... // Heading feature config.
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * See {@link module:core/editor/editorconfig~EditorConfig all editor options}.
 *
 * @interface HeadingConfig
 */

/**
 * The available heading options.
 *
 * The default value is:
 *
 *		const headingConfig = {
 *			options: [
 *				{ model: 'paragraph', title: 'Paragraph', class: 'ck-heading_paragraph' },
 *				{ model: 'heading1', view: 'h2', title: 'Heading 1', class: 'ck-heading_heading1' },
 *				{ model: 'heading2', view: 'h3', title: 'Heading 2', class: 'ck-heading_heading2' },
 *				{ model: 'heading3', view: 'h4', title: 'Heading 3', class: 'ck-heading_heading3' }
 *			]
 *		};
 *
 * It defines 3 levels of headings. In the editor model they will use `heading1`, `heading2`, and `heading3` elements.
 * Their respective view elements (so the elements output by the editor) will be: `h2`, `h3`, and `h4`. This means that
 * if you choose "Heading 1" in the headings dropdown the editor will turn the current block to `<heading1>` in the model
 * which will result in rendering (and outputting to data) the `<h2>` element.
 *
 * The `title` and `class` properties will be used by the `headings` dropdown to render available options.
 * Usually, the first option in the headings dropdown is the "Paragraph" option, hence it's also defined on the list.
 * However, you don't need to define its view representation because it's handled by
 * the {@link module:paragraph/paragraph~Paragraph} feature (which is required by
 * the {@link module:heading/headingediting~HeadingEditing} feature).
 *
 * You can **read more** about configuring heading levels and **see more examples** in
 * the {@glink features/headings Headings} guide.
 *
 * Note: In the model you should always start from `heading1`, regardless of how the headings are represented in the view.
 * That's assumption is used by features like {@link module:autoformat/autoformat~Autoformat} to know which element
 * they should use when applying the first level heading.
 *
 * The defined headings are also available as values passed to the `'heading'` command under their model names.
 * For example, the below code will apply `<heading1>` to the current selection:
 *
 *		editor.execute( 'heading', { value: 'heading1' } );
 *
 * @member {Array.<module:heading/heading~HeadingOption>} module:heading/heading~HeadingConfig#options
 */

/**
 * Heading option descriptor.
 *
 * @typedef {Object} module:heading/heading~HeadingOption
 * @property {String} model Name of the model element to convert.
 * @property {module:engine/view/elementdefinition~ElementDefinition} view Definition of a view element to convert from/to.
 * @property {String} title The user-readable title of the option.
 * @property {String} class The class which will be added to the dropdown item representing this option.
 * @property {String} [icon] Icon used by {@link module:heading/headingbuttonsui~HeadingButtonsUI}. It can be omitted when using
 * the default configuration.
 * @extends module:engine/conversion/conversion~ConverterDefinition
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imagecaption/utils.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imagecaption/utils
 */


/**
 * Returns a function that creates a caption editable element for the given {@link module:engine/view/document~Document}.
 *
 * @param {module:engine/view/view~View} view
 * @param {String} placeholderText The text to be displayed when the caption is empty.
 * @returns {Function}
 */

function captionElementCreator(view, placeholderText) {
  return function (writer) {
    var editable = writer.createEditableElement('figcaption');
    writer.setCustomProperty('imageCaption', true, editable);
    enablePlaceholder({
      view: view,
      element: editable,
      text: placeholderText
    });
    return toWidgetEditable(editable, writer);
  };
}
/**
 * Returns `true` if a given view element is the image caption editable.
 *
 * @param {module:engine/view/element~Element} viewElement
 * @returns {Boolean}
 */

function isCaption(viewElement) {
  return !!viewElement.getCustomProperty('imageCaption');
}
/**
 * Returns the caption model element from a given image element. Returns `null` if no caption is found.
 *
 * @param {module:engine/model/element~Element} imageModelElement
 * @returns {module:engine/model/element~Element|null}
 */

function getCaptionFromImage(imageModelElement) {
  var _iterator = _createForOfIteratorHelper(imageModelElement.getChildren()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var node = _step.value;

      if (!!node && node.is('caption')) {
        return node;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return null;
}
/**
 * {@link module:engine/view/matcher~Matcher} pattern. Checks if a given element is a `<figcaption>` element that is placed
 * inside the image `<figure>` element.
 *
 * @param {module:engine/view/element~Element} element
 * @returns {Object|null} Returns the object accepted by {@link module:engine/view/matcher~Matcher} or `null` if the element
 * cannot be matched.
 */

function matchImageCaption(element) {
  var parent = element.parent; // Convert only captions for images.

  if (element.name == 'figcaption' && parent && parent.name == 'figure' && parent.hasClass('image')) {
    return {
      name: true
    };
  }

  return null;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imagecaption/imagecaptionediting.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imagecaption/imagecaptionediting
 */



/**
 * The image caption engine plugin.
 *
 * It registers proper converters. It takes care of adding a caption element if the image without it is inserted
 * to the model document.
 *
 * @extends module:core/plugin~Plugin
 */

var imagecaptionediting_ImageCaptionEditing = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ImageCaptionEditing, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ImageCaptionEditing);

  function ImageCaptionEditing() {
    Object(classCallCheck["a" /* default */])(this, ImageCaptionEditing);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ImageCaptionEditing, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this = this;

      var editor = this.editor;
      var view = editor.editing.view;
      var schema = editor.model.schema;
      var data = editor.data;
      var editing = editor.editing;
      var t = editor.t;
      /**
       * The last selected caption editable.
       * It is used for hiding the editable when it is empty and the image widget is no longer selected.
       *
       * @private
       * @member {module:engine/view/editableelement~EditableElement} #_lastSelectedCaption
       */
      // Schema configuration.

      schema.register('caption', {
        allowIn: 'image',
        allowContentOf: '$block',
        isLimit: true
      }); // Add caption element to each image inserted without it.

      editor.model.document.registerPostFixer(function (writer) {
        return _this._insertMissingModelCaptionElement(writer);
      }); // View to model converter for the data pipeline.

      editor.conversion.for('upcast').elementToElement({
        view: matchImageCaption,
        model: 'caption'
      }); // Model to view converter for the data pipeline.

      var createCaptionForData = function createCaptionForData(writer) {
        return writer.createContainerElement('figcaption');
      };

      data.downcastDispatcher.on('insert:caption', captionModelToView(createCaptionForData, false)); // Model to view converter for the editing pipeline.

      var createCaptionForEditing = captionElementCreator(view, t('Enter image caption'));
      editing.downcastDispatcher.on('insert:caption', captionModelToView(createCaptionForEditing)); // Always show caption in view when something is inserted in model.

      editing.downcastDispatcher.on('insert', this._fixCaptionVisibility(function (data) {
        return data.item;
      }), {
        priority: 'high'
      }); // Hide caption when everything is removed from it.

      editing.downcastDispatcher.on('remove', this._fixCaptionVisibility(function (data) {
        return data.position.parent;
      }), {
        priority: 'high'
      }); // Update caption visibility on view in post fixer.

      view.document.registerPostFixer(function (writer) {
        return _this._updateCaptionVisibility(writer);
      });
    }
    /**
     * Updates the view before each rendering, making sure that empty captions (so unnecessary ones) are hidden
     * and then visible when the image is selected.
     *
     * @private
     * @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter
     * @returns {Boolean} Returns `true` when the view is updated.
     */

  }, {
    key: "_updateCaptionVisibility",
    value: function _updateCaptionVisibility(viewWriter) {
      var mapper = this.editor.editing.mapper;
      var lastCaption = this._lastSelectedCaption;
      var viewCaption; // If whole image is selected.

      var modelSelection = this.editor.model.document.selection;
      var selectedElement = modelSelection.getSelectedElement();

      if (selectedElement && selectedElement.is('image')) {
        var _modelCaption = getCaptionFromImage(selectedElement);

        viewCaption = mapper.toViewElement(_modelCaption);
      } // If selection is placed inside caption.


      var position = modelSelection.getFirstPosition();
      var modelCaption = getParentCaption(position.parent);

      if (modelCaption) {
        viewCaption = mapper.toViewElement(modelCaption);
      } // Is currently any caption selected?


      if (viewCaption) {
        // Was any caption selected before?
        if (lastCaption) {
          // Same caption as before?
          if (lastCaption === viewCaption) {
            return showCaption(viewCaption, viewWriter);
          } else {
            hideCaptionIfEmpty(lastCaption, viewWriter);
            this._lastSelectedCaption = viewCaption;
            return showCaption(viewCaption, viewWriter);
          }
        } else {
          this._lastSelectedCaption = viewCaption;
          return showCaption(viewCaption, viewWriter);
        }
      } else {
        // Was any caption selected before?
        if (lastCaption) {
          var viewModified = hideCaptionIfEmpty(lastCaption, viewWriter);
          this._lastSelectedCaption = null;
          return viewModified;
        } else {
          return false;
        }
      }
    }
    /**
     * Returns a converter that fixes caption visibility during the model-to-view conversion.
     * Checks if the changed node is placed inside the caption element and fixes its visibility in the view.
     *
     * @private
     * @param {Function} nodeFinder
     * @returns {Function}
     */

  }, {
    key: "_fixCaptionVisibility",
    value: function _fixCaptionVisibility(nodeFinder) {
      var _this2 = this;

      return function (evt, data, conversionApi) {
        var node = nodeFinder(data);
        var modelCaption = getParentCaption(node);
        var mapper = _this2.editor.editing.mapper;
        var viewWriter = conversionApi.writer;

        if (modelCaption) {
          var viewCaption = mapper.toViewElement(modelCaption);

          if (viewCaption) {
            if (modelCaption.childCount) {
              viewWriter.removeClass('ck-hidden', viewCaption);
            } else {
              viewWriter.addClass('ck-hidden', viewCaption);
            }
          }
        }
      };
    }
    /**
     * Checks whether the data inserted to the model document have an image element that has no caption element inside it.
     * If there is none, it adds it to the image element.
     *
     * @private
     * @param {module:engine/model/writer~Writer} writer The writer to make changes with.
     * @returns {Boolean} `true` if any change was applied, `false` otherwise.
     */

  }, {
    key: "_insertMissingModelCaptionElement",
    value: function _insertMissingModelCaptionElement(writer) {
      var model = this.editor.model;
      var changes = model.document.differ.getChanges();
      var imagesWithoutCaption = [];

      var _iterator = _createForOfIteratorHelper(changes),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var entry = _step.value;

          if (entry.type == 'insert' && entry.name != '$text') {
            var item = entry.position.nodeAfter;

            if (item.is('image') && !getCaptionFromImage(item)) {
              imagesWithoutCaption.push(item);
            } // Check elements with children for nested images.


            if (!item.is('image') && item.childCount) {
              var _iterator2 = _createForOfIteratorHelper(model.createRangeIn(item).getItems()),
                  _step2;

              try {
                for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                  var nestedItem = _step2.value;

                  if (nestedItem.is('image') && !getCaptionFromImage(nestedItem)) {
                    imagesWithoutCaption.push(nestedItem);
                  }
                }
              } catch (err) {
                _iterator2.e(err);
              } finally {
                _iterator2.f();
              }
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      for (var _i = 0, _imagesWithoutCaption = imagesWithoutCaption; _i < _imagesWithoutCaption.length; _i++) {
        var image = _imagesWithoutCaption[_i];
        writer.appendElement('caption', image);
      }

      return !!imagesWithoutCaption.length;
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'ImageCaptionEditing';
    }
  }]);

  return ImageCaptionEditing;
}(plugin_Plugin); // Creates a converter that converts image caption model element to view element.
//
// @private
// @param {Function} elementCreator
// @param {Boolean} [hide=true] When set to `false` view element will not be inserted when it's empty.
// @returns {Function}




function captionModelToView(elementCreator) {
  var hide = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;
  return function (evt, data, conversionApi) {
    var captionElement = data.item; // Return if element shouldn't be present when empty.

    if (!captionElement.childCount && !hide) {
      return;
    }

    if (isImage(captionElement.parent)) {
      if (!conversionApi.consumable.consume(data.item, 'insert')) {
        return;
      }

      var viewImage = conversionApi.mapper.toViewElement(data.range.start.parent);
      var viewCaption = elementCreator(conversionApi.writer);
      var viewWriter = conversionApi.writer; // Hide if empty.

      if (!captionElement.childCount) {
        viewWriter.addClass('ck-hidden', viewCaption);
      }

      insertViewCaptionAndBind(viewCaption, data.item, viewImage, conversionApi);
    }
  };
} // Inserts `viewCaption` at the end of `viewImage` and binds it to `modelCaption`.
//
// @private
// @param {module:engine/view/containerelement~ContainerElement} viewCaption
// @param {module:engine/model/element~Element} modelCaption
// @param {module:engine/view/containerelement~ContainerElement} viewImage
// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi


function insertViewCaptionAndBind(viewCaption, modelCaption, viewImage, conversionApi) {
  var viewPosition = conversionApi.writer.createPositionAt(viewImage, 'end');
  conversionApi.writer.insert(viewPosition, viewCaption);
  conversionApi.mapper.bindElements(modelCaption, viewCaption);
} // Checks if the provided node or one of its ancestors is a caption element, and returns it.
//
// @private
// @param {module:engine/model/node~Node} node
// @returns {module:engine/model/element~Element|null}


function getParentCaption(node) {
  var ancestors = node.getAncestors({
    includeSelf: true
  });
  var caption = ancestors.find(function (ancestor) {
    return ancestor.name == 'caption';
  });

  if (caption && caption.parent && caption.parent.name == 'image') {
    return caption;
  }

  return null;
} // Hides a given caption in the view if it is empty.
//
// @private
// @param {module:engine/view/containerelement~ContainerElement} caption
// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter
// @returns {Boolean} Returns `true` if the view was modified.


function hideCaptionIfEmpty(caption, viewWriter) {
  if (!caption.childCount && !caption.hasClass('ck-hidden')) {
    viewWriter.addClass('ck-hidden', caption);
    return true;
  }

  return false;
} // Shows the caption.
//
// @private
// @param {module:engine/view/containerelement~ContainerElement} caption
// @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter
// @returns {Boolean} Returns `true` if the view was modified.


function showCaption(caption, viewWriter) {
  if (caption.hasClass('ck-hidden')) {
    viewWriter.removeClass('ck-hidden', caption);
    return true;
  }

  return false;
}
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-image/theme/imagecaption.css
var imagecaption = __webpack_require__("c44c");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imagecaption.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imagecaption
 */



/**
 * The image caption plugin.
 *
 * For a detailed overview, check the {@glink features/image#image-captions image caption} documentation.
 *
 * @extends module:core/plugin~Plugin
 */

var imagecaption_ImageCaption = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ImageCaption, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ImageCaption);

  function ImageCaption() {
    Object(classCallCheck["a" /* default */])(this, ImageCaption);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ImageCaption, null, [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [imagecaptionediting_ImageCaptionEditing];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'ImageCaption';
    }
  }]);

  return ImageCaption;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imagestyle/imagestylecommand.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imagestyle/imagestylecommand
 */


/**
 * The image style command. It is used to apply different image styles.
 *
 * @extends module:core/command~Command
 */

var imagestylecommand_ImageStyleCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(ImageStyleCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(ImageStyleCommand);

  /**
   * Creates an instance of the image style command. Each command instance is handling one style.
   *
   * @param {module:core/editor/editor~Editor} editor The editor instance.
   * @param {Array.<module:image/imagestyle/imagestyleediting~ImageStyleFormat>} styles The styles that this command supports.
   */
  function ImageStyleCommand(editor, styles) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, ImageStyleCommand);

    _this = _super.call(this, editor);
    /**
     * The name of the default style, if it is present. If there is no default style, it defaults to `false`.
     *
     * @readonly
     * @type {Boolean|String}
     */

    _this.defaultStyle = false;
    /**
     * A style handled by this command.
     *
     * @readonly
     * @member {Array.<module:image/imagestyle/imagestyleediting~ImageStyleFormat>} #styles
     */

    _this.styles = styles.reduce(function (styles, style) {
      styles[style.name] = style;

      if (style.isDefault) {
        _this.defaultStyle = style.name;
      }

      return styles;
    }, {});
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(ImageStyleCommand, [{
    key: "refresh",
    value: function refresh() {
      var element = this.editor.model.document.selection.getSelectedElement();
      this.isEnabled = isImage(element);

      if (!element) {
        this.value = false;
      } else if (element.hasAttribute('imageStyle')) {
        var attributeValue = element.getAttribute('imageStyle');
        this.value = this.styles[attributeValue] ? attributeValue : false;
      } else {
        this.value = this.defaultStyle;
      }
    }
    /**
     * Executes the command.
     *
     *		editor.execute( 'imageStyle', { value: 'side' } );
     *
     * @param {Object} options
     * @param {String} options.value The name of the style (based on the
     * {@link module:image/image~ImageConfig#styles `image.styles`} configuration option).
     * @fires execute
     */

  }, {
    key: "execute",
    value: function execute(options) {
      var _this2 = this;

      var styleName = options.value;
      var model = this.editor.model;
      var imageElement = model.document.selection.getSelectedElement();
      model.change(function (writer) {
        // Default style means that there is no `imageStyle` attribute in the model.
        // https://github.com/ckeditor/ckeditor5-image/issues/147
        if (_this2.styles[styleName].isDefault) {
          writer.removeAttribute('imageStyle', imageElement);
        } else {
          writer.setAttribute('imageStyle', styleName, imageElement);
        }
      });
    }
  }]);

  return ImageStyleCommand;
}(command_Command);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imagestyle/converters.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imagestyle/converters
 */

/**
 * Returns a converter for the `imageStyle` attribute. It can be used for adding, changing and removing the attribute.
 *
 * @param {Object} styles An object containing available styles. See {@link module:image/imagestyle/imagestyleediting~ImageStyleFormat}
 * for more details.
 * @returns {Function} A model-to-view attribute converter.
 */

function modelToViewStyleAttribute(styles) {
  return function (evt, data, conversionApi) {
    if (!conversionApi.consumable.consume(data.item, evt.name)) {
      return;
    } // Check if there is class name associated with given value.


    var newStyle = getStyleByName(data.attributeNewValue, styles);
    var oldStyle = getStyleByName(data.attributeOldValue, styles);
    var viewElement = conversionApi.mapper.toViewElement(data.item);
    var viewWriter = conversionApi.writer;

    if (oldStyle) {
      viewWriter.removeClass(oldStyle.className, viewElement);
    }

    if (newStyle) {
      viewWriter.addClass(newStyle.className, viewElement);
    }
  };
}
/**
 * Returns a view-to-model converter converting image CSS classes to a proper value in the model.
 *
 * @param {Array.<module:image/imagestyle/imagestyleediting~ImageStyleFormat>} styles The styles for which the converter is created.
 * @returns {Function} A view-to-model converter.
 */

function viewToModelStyleAttribute(styles) {
  // Convert only non–default styles.
  var filteredStyles = styles.filter(function (style) {
    return !style.isDefault;
  });
  return function (evt, data, conversionApi) {
    if (!data.modelRange) {
      return;
    }

    var viewFigureElement = data.viewItem;
    var modelImageElement = first_first(data.modelRange.getItems()); // Check if `imageStyle` attribute is allowed for current element.

    if (!conversionApi.schema.checkAttribute(modelImageElement, 'imageStyle')) {
      return;
    } // Convert style one by one.


    var _iterator = _createForOfIteratorHelper(filteredStyles),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var style = _step.value;

        // Try to consume class corresponding with style.
        if (conversionApi.consumable.consume(viewFigureElement, {
          classes: style.className
        })) {
          // And convert this style to model attribute.
          conversionApi.writer.setAttribute('imageStyle', style.name, modelImageElement);
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  };
} // Returns the style with a given `name` from an array of styles.
//
// @param {String} name
// @param {Array.<module:image/imagestyle/imagestyleediting~ImageStyleFormat> } styles
// @returns {module:image/imagestyle/imagestyleediting~ImageStyleFormat|undefined}

function getStyleByName(name, styles) {
  var _iterator2 = _createForOfIteratorHelper(styles),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var style = _step2.value;

      if (style.name === name) {
        return style;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
}
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-core/theme/icons/object-full-width.svg
var object_full_width = __webpack_require__("660d");
var object_full_width_default = /*#__PURE__*/__webpack_require__.n(object_full_width);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-core/theme/icons/object-left.svg
var object_left = __webpack_require__("1a1b");
var object_left_default = /*#__PURE__*/__webpack_require__.n(object_left);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-core/theme/icons/object-center.svg
var object_center = __webpack_require__("0524");
var object_center_default = /*#__PURE__*/__webpack_require__.n(object_center);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-core/theme/icons/object-right.svg
var object_right = __webpack_require__("0db1");
var object_right_default = /*#__PURE__*/__webpack_require__.n(object_right);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imagestyle/utils.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imagestyle/utils
 */

/* globals console */





/**
 * Default image styles provided by the plugin that can be referred in the
 * {@link module:image/image~ImageConfig#styles} configuration.
 *
 * Among them, 2 default semantic content styles are available:
 *
 * * `full` is a full–width image without any CSS class,
 * * `side` is a side image styled with the `image-style-side` CSS class.
 *
 * There are also 3 styles focused on formatting:
 *
 * * `alignLeft` aligns the image to the left using the `image-style-align-left` class,
 * * `alignCenter` centers the image using the `image-style-align-center` class,
 * * `alignRight` aligns the image to the right using the `image-style-align-right` class,
 *
 * @member {Object.<String,Object>}
 */

var defaultStyles = {
  // This option is equal to the situation when no style is applied.
  full: {
    name: 'full',
    title: 'Full size image',
    icon: object_full_width_default.a,
    isDefault: true
  },
  // This represents a side image.
  side: {
    name: 'side',
    title: 'Side image',
    icon: object_right_default.a,
    className: 'image-style-side'
  },
  // This style represents an image aligned to the left.
  alignLeft: {
    name: 'alignLeft',
    title: 'Left aligned image',
    icon: object_left_default.a,
    className: 'image-style-align-left'
  },
  // This style represents a centered image.
  alignCenter: {
    name: 'alignCenter',
    title: 'Centered image',
    icon: object_center_default.a,
    className: 'image-style-align-center'
  },
  // This style represents an image aligned to the right.
  alignRight: {
    name: 'alignRight',
    title: 'Right aligned image',
    icon: object_right_default.a,
    className: 'image-style-align-right'
  }
};
/**
 * Default image style icons provided by the plugin that can be referred in the
 * {@link module:image/image~ImageConfig#styles} configuration.
 *
 * There are 4 icons available: `'full'`, `'left'`, `'center'` and `'right'`.
 *
 * @member {Object.<String, String>}
 */

var defaultIcons = {
  full: object_full_width_default.a,
  left: object_left_default.a,
  right: object_right_default.a,
  center: object_center_default.a
};
/**
 * Returns a {@link module:image/image~ImageConfig#styles} array with items normalized in the
 * {@link module:image/imagestyle/imagestyleediting~ImageStyleFormat} format and a complete `icon` markup for each style.
 *
 * @returns {Array.<module:image/imagestyle/imagestyleediting~ImageStyleFormat>}
 */

function normalizeImageStyles() {
  var configuredStyles = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return configuredStyles.map(_normalizeStyle);
} // Normalizes an image style provided in the {@link module:image/image~ImageConfig#styles}
// and returns it in a {@link module:image/imagestyle/imagestyleediting~ImageStyleFormat}.
//
// @param {Object} style
// @returns {@link module:image/imagestyle/imagestyleediting~ImageStyleFormat}

function _normalizeStyle(style) {
  // Just the name of the style has been passed.
  if (typeof style == 'string') {
    var styleName = style; // If it's one of the defaults, just use it.

    if (defaultStyles[styleName]) {
      // Clone the style to avoid overriding defaults.
      style = Object.assign({}, defaultStyles[styleName]);
    } // If it's just a name but none of the defaults, warn because probably it's a mistake.
    else {
        console.warn(Object(ckeditorerror["a" /* attachLinkToDocumentation */])('image-style-not-found: There is no such image style of given name.'), {
          name: styleName
        }); // Normalize the style anyway to prevent errors.

        style = {
          name: styleName
        };
      }
  } // If an object style has been passed and if the name matches one of the defaults,
  // extend it with defaults – the user wants to customize a default style.
  // Note: Don't override the user–defined style object, clone it instead.
  else if (defaultStyles[style.name]) {
      var defaultStyle = defaultStyles[style.name];
      var extendedStyle = Object.assign({}, style);

      for (var prop in defaultStyle) {
        if (!Object.prototype.hasOwnProperty.call(style, prop)) {
          extendedStyle[prop] = defaultStyle[prop];
        }
      }

      style = extendedStyle;
    } // If an icon is defined as a string and correspond with a name
  // in default icons, use the default icon provided by the plugin.


  if (typeof style.icon == 'string' && defaultIcons[style.icon]) {
    style.icon = defaultIcons[style.icon];
  }

  return style;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imagestyle/imagestyleediting.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imagestyle/imagestyleediting
 */




/**
 * The image style engine plugin. It sets the default configuration, creates converters and registers
 * {@link module:image/imagestyle/imagestylecommand~ImageStyleCommand ImageStyleCommand}.
 *
 * @extends module:core/plugin~Plugin
 */

var imagestyleediting_ImageStyleEditing = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ImageStyleEditing, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ImageStyleEditing);

  function ImageStyleEditing() {
    Object(classCallCheck["a" /* default */])(this, ImageStyleEditing);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ImageStyleEditing, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var editor = this.editor;
      var schema = editor.model.schema;
      var data = editor.data;
      var editing = editor.editing; // Define default configuration.

      editor.config.define('image.styles', ['full', 'side']); // Get configuration.

      var styles = normalizeImageStyles(editor.config.get('image.styles')); // Allow imageStyle attribute in image.
      // We could call it 'style' but https://github.com/ckeditor/ckeditor5-engine/issues/559.

      schema.extend('image', {
        allowAttributes: 'imageStyle'
      }); // Converters for imageStyle attribute from model to view.

      var modelToViewConverter = modelToViewStyleAttribute(styles);
      editing.downcastDispatcher.on('attribute:imageStyle:image', modelToViewConverter);
      data.downcastDispatcher.on('attribute:imageStyle:image', modelToViewConverter); // Converter for figure element from view to model.

      data.upcastDispatcher.on('element:figure', viewToModelStyleAttribute(styles), {
        priority: 'low'
      }); // Register imageStyle command.

      editor.commands.add('imageStyle', new imagestylecommand_ImageStyleCommand(editor, styles));
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'ImageStyleEditing';
    }
  }]);

  return ImageStyleEditing;
}(plugin_Plugin);
/**
 * The image style format descriptor.
 *
 *		import fullSizeIcon from 'path/to/icon.svg';
 *
 *		const imageStyleFormat = {
 *			name: 'fullSize',
 *			icon: fullSizeIcon,
 *			title: 'Full size image',
 *			className: 'image-full-size'
 *		}
 *
 * @typedef {Object} module:image/imagestyle/imagestyleediting~ImageStyleFormat
 *
 * @property {String} name The unique name of the style. It will be used to:
 *
 * * Store the chosen style in the model by setting the `imageStyle` attribute of the `<image>` element.
 * * As a value of the {@link module:image/imagestyle/imagestylecommand~ImageStyleCommand#execute `imageStyle` command},
 * * when registering a button for each of the styles (`'imageStyle:{name}'`) in the
 * {@link module:ui/componentfactory~ComponentFactory UI components factory} (this functionality is provided by the
 * {@link module:image/imagestyle/imagestyleui~ImageStyleUI} plugin).
 *
 * @property {Boolean} [isDefault] When set, the style will be used as the default one.
 * A default style does not apply any CSS class to the view element.
 *
 * @property {String} icon One of the following to be used when creating the style's button:
 *
 * * An SVG icon source (as an XML string).
 * * One of {@link module:image/imagestyle/utils~defaultIcons} to use a default icon provided by the plugin.
 *
 * @property {String} title The style's title.
 *
 * @property {String} className The CSS class used to represent the style in the view.
 */



// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-image/theme/imagestyle.css
var imagestyle = __webpack_require__("7201");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imagestyle/imagestyleui.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imagestyle/imagestyleui
 */




/**
 * The image style UI plugin.
 *
 * @extends module:core/plugin~Plugin
 */

var imagestyleui_ImageStyleUI = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ImageStyleUI, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ImageStyleUI);

  function ImageStyleUI() {
    Object(classCallCheck["a" /* default */])(this, ImageStyleUI);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ImageStyleUI, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var editor = this.editor;
      var configuredStyles = editor.config.get('image.styles');
      var translatedStyles = translateStyles(normalizeImageStyles(configuredStyles), this.localizedDefaultStylesTitles);

      var _iterator = _createForOfIteratorHelper(translatedStyles),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var style = _step.value;

          this._createButton(style);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Creates a button for each style and stores it in the editor {@link module:ui/componentfactory~ComponentFactory ComponentFactory}.
     *
     * @private
     * @param {module:image/imagestyle/imagestyleediting~ImageStyleFormat} style
     */

  }, {
    key: "_createButton",
    value: function _createButton(style) {
      var _this = this;

      var editor = this.editor;
      var componentName = "imageStyle:".concat(style.name);
      editor.ui.componentFactory.add(componentName, function (locale) {
        var command = editor.commands.get('imageStyle');
        var view = new buttonview_ButtonView(locale);
        view.set({
          label: style.title,
          icon: style.icon,
          tooltip: true,
          isToggleable: true
        });
        view.bind('isEnabled').to(command, 'isEnabled');
        view.bind('isOn').to(command, 'value', function (value) {
          return value === style.name;
        });

        _this.listenTo(view, 'execute', function () {
          editor.execute('imageStyle', {
            value: style.name
          });
          editor.editing.view.focus();
        });

        return view;
      });
    }
  }, {
    key: "localizedDefaultStylesTitles",

    /**
     * Returns the default localized style titles provided by the plugin.
     *
     * The following localized titles corresponding with
     * {@link module:image/imagestyle/utils~defaultStyles} are available:
     *
     * * `'Full size image'`,
     * * `'Side image'`,
     * * `'Left aligned image'`,
     * * `'Centered image'`,
     * * `'Right aligned image'`
     *
     * @returns {Object.<String,String>}
     */
    get: function get() {
      var t = this.editor.t;
      return {
        'Full size image': t('Full size image'),
        'Side image': t('Side image'),
        'Left aligned image': t('Left aligned image'),
        'Centered image': t('Centered image'),
        'Right aligned image': t('Right aligned image')
      };
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'ImageStyleUI';
    }
  }]);

  return ImageStyleUI;
}(plugin_Plugin);
/**
 * Returns the translated `title` from the passed styles array.
 *
 * @param {Array.<module:image/imagestyle/imagestyleediting~ImageStyleFormat>} styles
 * @param titles
 * @returns {Array.<module:image/imagestyle/imagestyleediting~ImageStyleFormat>}
 */




function translateStyles(styles, titles) {
  var _iterator2 = _createForOfIteratorHelper(styles),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var style = _step2.value;

      // Localize the titles of the styles, if a title corresponds with
      // a localized default provided by the plugin.
      if (titles[style.title]) {
        style.title = titles[style.title];
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return styles;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imagestyle.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imagestyle
 */



/**
 * The image style plugin.
 *
 * For a detailed overview, check the {@glink features/image#image-styles image styles} documentation.
 *
 * This is a "glue" plugin which loads the {@link module:image/imagestyle/imagestyleediting~ImageStyleEditing}
 * and {@link module:image/imagestyle/imagestyleui~ImageStyleUI} plugins.
 *
 * @extends module:core/plugin~Plugin
 */

var imagestyle_ImageStyle = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ImageStyle, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ImageStyle);

  function ImageStyle() {
    Object(classCallCheck["a" /* default */])(this, ImageStyle);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ImageStyle, null, [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [imagestyleediting_ImageStyleEditing, imagestyleui_ImageStyleUI];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'ImageStyle';
    }
  }]);

  return ImageStyle;
}(plugin_Plugin);
/**
 * Available image styles.
 *
 * The default value is:
 *
 *		const imageConfig = {
 *			styles: [ 'full', 'side' ]
 *		};
 *
 * which configures two default styles:
 *
 *  * the "full" style which does not apply any class, e.g. for images styled to span 100% width of the content,
 *  * the "side" style with the `.image-style-side` CSS class.
 *
 * See {@link module:image/imagestyle/utils~defaultStyles} to learn more about default
 * styles provided by the image feature.
 *
 * The {@link module:image/imagestyle/utils~defaultStyles default styles} can be customized,
 * e.g. to change the icon, title or CSS class of the style. The feature also provides several
 * {@link module:image/imagestyle/utils~defaultIcons default icons} to choose from.
 *
 *		import customIcon from 'custom-icon.svg';
 *
 *		// ...
 *
 *		const imageConfig = {
 *			styles: [
 *				// This will only customize the icon of the "full" style.
 *				// Note: 'right' is one of default icons provided by the feature.
 *				{ name: 'full', icon: 'right' },
 *
 *				// This will customize the icon, title and CSS class of the default "side" style.
 *				{ name: 'side', icon: customIcon, title: 'My side style', className: 'custom-side-image' }
 *			]
 *		};
 *
 * If none of the default styles is good enough, it is possible to define independent custom styles, too:
 *
 *		import fullSizeIcon from '@ckeditor/ckeditor5-core/theme/icons/object-center.svg';
 *		import sideIcon from '@ckeditor/ckeditor5-core/theme/icons/object-right.svg';
 *
 *		// ...
 *
 *		const imageConfig = {
 *			styles: [
 *				// A completely custom full size style with no class, used as a default.
 *				{ name: 'fullSize', title: 'Full size', icon: fullSizeIcon, isDefault: true },
 *
 *				{ name: 'side', title: 'To the side', icon: sideIcon, className: 'side-image' }
 *			]
 *		};
 *
 * Note: Setting `title` to one of {@link module:image/imagestyle/imagestyleui~ImageStyleUI#localizedDefaultStylesTitles}
 * will automatically translate it to the language of the editor.
 *
 * Read more about styling images in the {@glink features/image#image-styles Image styles guide}.
 *
 * The feature creates commands based on defined styles, so you can change the style of a selected image by executing
 * the following command:
 *
 *		editor.execute( 'imageStyle' { value: 'side' } );
 *
 * The feature also creates buttons that execute the commands. So, assuming that you use the
 * default image styles setting, you can {@link module:image/image~ImageConfig#toolbar configure the image toolbar}
 * (or any other toolbar) to contain these options:
 *
 *		const imageConfig = {
 *			toolbar: [ 'imageStyle:full', 'imageStyle:side' ]
 *		};
 *
 * @member {Array.<module:image/imagestyle/imagestyleediting~ImageStyleFormat>} module:image/image~ImageConfig#styles
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-widget/src/widgettoolbarrepository.js













/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module widget/widgettoolbarrepository
 */

/* global console */






/**
 * Widget toolbar repository plugin. A central point for registering widget toolbars. This plugin handles the whole
 * toolbar rendering process and exposes a concise API.
 *
 * To add a toolbar for your widget use the {@link ~WidgetToolbarRepository#register `WidgetToolbarRepository#register()`} method.
 *
 * The following example comes from the {@link module:image/imagetoolbar~ImageToolbar} plugin:
 *
 * 		class ImageToolbar extends Plugin {
 *			static get requires() {
 *				return [ WidgetToolbarRepository ];
 *			}
 *
 *			afterInit() {
 *				const editor = this.editor;
 *				const widgetToolbarRepository = editor.plugins.get( WidgetToolbarRepository );
 *
 *				widgetToolbarRepository.register( 'image', {
 *					items: editor.config.get( 'image.toolbar' ),
 *					getRelatedElement: getSelectedImageWidget
 *				} );
 *			}
 *		}
 */

var widgettoolbarrepository_WidgetToolbarRepository = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(WidgetToolbarRepository, _Plugin);

  var _super = Object(createSuper["a" /* default */])(WidgetToolbarRepository);

  function WidgetToolbarRepository() {
    Object(classCallCheck["a" /* default */])(this, WidgetToolbarRepository);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(WidgetToolbarRepository, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this = this;

      var editor = this.editor; // Disables the default balloon toolbar for all widgets.

      if (editor.plugins.has('BalloonToolbar')) {
        var balloonToolbar = editor.plugins.get('BalloonToolbar');
        this.listenTo(balloonToolbar, 'show', function (evt) {
          if (isWidgetSelected(editor.editing.view.document.selection)) {
            evt.stop();
          }
        }, {
          priority: 'high'
        });
      }
      /**
       * A map of toolbar definitions.
       *
       * @protected
       * @member {Map.<String,module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition>} #_toolbarDefinitions
       */


      this._toolbarDefinitions = new Map();
      /**
       * @private
       */

      this._balloon = this.editor.plugins.get('ContextualBalloon');
      this.on('change:isEnabled', function () {
        _this._updateToolbarsVisibility();
      });
      this.listenTo(editor.ui, 'update', function () {
        _this._updateToolbarsVisibility();
      }); // UI#update is not fired after focus is back in editor, we need to check if balloon panel should be visible.

      this.listenTo(editor.ui.focusTracker, 'change:isFocused', function () {
        _this._updateToolbarsVisibility();
      }, {
        priority: 'low'
      });
    }
  }, {
    key: "destroy",
    value: function destroy() {
      get_get(Object(getPrototypeOf["a" /* default */])(WidgetToolbarRepository.prototype), "destroy", this).call(this);

      var _iterator = _createForOfIteratorHelper(this._toolbarDefinitions.values()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var toolbarConfig = _step.value;
          toolbarConfig.view.destroy();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Registers toolbar in the WidgetToolbarRepository. It renders it in the `ContextualBalloon` based on the value of the invoked
     * `getRelatedElement` function. Toolbar items are gathered from `items` array.
     * The balloon's CSS class is by default `ck-toolbar-container` and may be override with the `balloonClassName` option.
     *
     * Note: This method should be called in the {@link module:core/plugin~PluginInterface#afterInit `Plugin#afterInit()`}
     * callback (or later) to make sure that the given toolbar items were already registered by other plugins.
     *
     * @param {String} toolbarId An id for the toolbar. Used to
     * @param {Object} options
     * @param {String} [options.ariaLabel] Label used by assistive technologies to describe this toolbar element.
     * @param {Array.<String>} options.items Array of toolbar items.
     * @param {Function} options.getRelatedElement Callback which returns an element the toolbar should be attached to.
     * @param {String} [options.balloonClassName='ck-toolbar-container'] CSS class for the widget balloon.
     */

  }, {
    key: "register",
    value: function register(toolbarId, _ref) {
      var ariaLabel = _ref.ariaLabel,
          items = _ref.items,
          getRelatedElement = _ref.getRelatedElement,
          _ref$balloonClassName = _ref.balloonClassName,
          balloonClassName = _ref$balloonClassName === void 0 ? 'ck-toolbar-container' : _ref$balloonClassName;

      // Trying to register a toolbar without any item.
      if (!items.length) {
        /**
         * When {@link #register} a new toolbar, you need to provide a non-empty array with
         * the items that will be inserted into the toolbar.
         *
         * @error widget-toolbar-no-items
         */
        console.warn(Object(ckeditorerror["a" /* attachLinkToDocumentation */])('widget-toolbar-no-items: Trying to register a toolbar without items.'), {
          toolbarId: toolbarId
        });
        return;
      }

      var editor = this.editor;
      var t = editor.t;
      var toolbarView = new toolbarview_ToolbarView(editor.locale);
      toolbarView.ariaLabel = ariaLabel || t('Widget toolbar');

      if (this._toolbarDefinitions.has(toolbarId)) {
        /**
         * Toolbar with the given id was already added.
         *
         * @error widget-toolbar-duplicated
         * @param toolbarId Toolbar id.
         */
        throw new ckeditorerror["b" /* default */]('widget-toolbar-duplicated: Toolbar with the given id was already added.', this, {
          toolbarId: toolbarId
        });
      }

      toolbarView.fillFromConfig(items, editor.ui.componentFactory);

      this._toolbarDefinitions.set(toolbarId, {
        view: toolbarView,
        getRelatedElement: getRelatedElement,
        balloonClassName: balloonClassName
      });
    }
    /**
     * Iterates over stored toolbars and makes them visible or hidden.
     *
     * @private
     */

  }, {
    key: "_updateToolbarsVisibility",
    value: function _updateToolbarsVisibility() {
      var maxRelatedElementDepth = 0;
      var deepestRelatedElement = null;
      var deepestToolbarDefinition = null;

      var _iterator2 = _createForOfIteratorHelper(this._toolbarDefinitions.values()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var definition = _step2.value;
          var relatedElement = definition.getRelatedElement(this.editor.editing.view.document.selection);

          if (!this.isEnabled || !relatedElement) {
            if (this._isToolbarInBalloon(definition)) {
              this._hideToolbar(definition);
            }
          } else if (!this.editor.ui.focusTracker.isFocused) {
            if (this._isToolbarVisible(definition)) {
              this._hideToolbar(definition);
            }
          } else {
            var relatedElementDepth = relatedElement.getAncestors().length; // Many toolbars can express willingness to be displayed but they do not know about
            // each other. Figure out which toolbar is deepest in the view tree to decide which
            // should be displayed. For instance, if a selected image is inside a table cell, display
            // the ImageToolbar rather than the TableToolbar (#60).

            if (relatedElementDepth > maxRelatedElementDepth) {
              maxRelatedElementDepth = relatedElementDepth;
              deepestRelatedElement = relatedElement;
              deepestToolbarDefinition = definition;
            }
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      if (deepestToolbarDefinition) {
        this._showToolbar(deepestToolbarDefinition, deepestRelatedElement);
      }
    }
    /**
     * Hides the given toolbar.
     *
     * @private
     * @param {module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition} toolbarDefinition
     */

  }, {
    key: "_hideToolbar",
    value: function _hideToolbar(toolbarDefinition) {
      this._balloon.remove(toolbarDefinition.view);

      this.stopListening(this._balloon, 'change:visibleView');
    }
    /**
     * Shows up the toolbar if the toolbar is not visible.
     * Otherwise, repositions the toolbar's balloon when toolbar's view is the most top view in balloon stack.
     *
     * It might happen here that the toolbar's view is under another view. Then do nothing as the other toolbar view
     * should be still visible after the {@link module:core/editor/editorui~EditorUI#event:update}.
     *
     * @private
     * @param {module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition} toolbarDefinition
     * @param {module:engine/view/element~Element} relatedElement
     */

  }, {
    key: "_showToolbar",
    value: function _showToolbar(toolbarDefinition, relatedElement) {
      var _this2 = this;

      if (this._isToolbarVisible(toolbarDefinition)) {
        widgettoolbarrepository_repositionContextualBalloon(this.editor, relatedElement);
      } else if (!this._isToolbarInBalloon(toolbarDefinition)) {
        this._balloon.add({
          view: toolbarDefinition.view,
          position: widgettoolbarrepository_getBalloonPositionData(this.editor, relatedElement),
          balloonClassName: toolbarDefinition.balloonClassName
        }); // Update toolbar position each time stack with toolbar view is switched to visible.
        // This is in a case target element has changed when toolbar was in invisible stack
        // e.g. target image was wrapped by a block quote.
        // See https://github.com/ckeditor/ckeditor5-widget/issues/92.


        this.listenTo(this._balloon, 'change:visibleView', function () {
          var _iterator3 = _createForOfIteratorHelper(_this2._toolbarDefinitions.values()),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var definition = _step3.value;

              if (_this2._isToolbarVisible(definition)) {
                var _relatedElement = definition.getRelatedElement(_this2.editor.editing.view.document.selection);

                widgettoolbarrepository_repositionContextualBalloon(_this2.editor, _relatedElement);
              }
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        });
      }
    }
    /**
     * @private
     * @param {Object} toolbar
     * @returns {Boolean}
     */

  }, {
    key: "_isToolbarVisible",
    value: function _isToolbarVisible(toolbar) {
      return this._balloon.visibleView === toolbar.view;
    }
    /**
     * @private
     * @param {Object} toolbar
     * @returns {Boolean}
     */

  }, {
    key: "_isToolbarInBalloon",
    value: function _isToolbarInBalloon(toolbar) {
      return this._balloon.hasView(toolbar.view);
    }
  }], [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [contextualballoon_ContextualBalloon];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'WidgetToolbarRepository';
    }
  }]);

  return WidgetToolbarRepository;
}(plugin_Plugin);



function widgettoolbarrepository_repositionContextualBalloon(editor, relatedElement) {
  var balloon = editor.plugins.get('ContextualBalloon');
  var position = widgettoolbarrepository_getBalloonPositionData(editor, relatedElement);
  balloon.updatePosition(position);
}

function widgettoolbarrepository_getBalloonPositionData(editor, relatedElement) {
  var editingView = editor.editing.view;
  var defaultPositions = balloonpanelview_BalloonPanelView.defaultPositions;
  return {
    target: editingView.domConverter.mapViewToDom(relatedElement),
    positions: [defaultPositions.northArrowSouth, defaultPositions.northArrowSouthWest, defaultPositions.northArrowSouthEast, defaultPositions.southArrowNorth, defaultPositions.southArrowNorthWest, defaultPositions.southArrowNorthEast, centeredBalloonPositionForLongWidgets]
  };
}

function isWidgetSelected(selection) {
  var viewElement = selection.getSelectedElement();
  return !!(viewElement && isWidget(viewElement));
}
/**
 * The toolbar definition object used by the toolbar repository to manage toolbars.
 * It contains information necessary to display the toolbar in the
 * {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon contextual balloon} and
 * update it during its life (display) cycle.
 *
 * @typedef {Object} module:widget/widgettoolbarrepository~WidgetRepositoryToolbarDefinition
 *
 * @property {module:ui/view~View} view The UI view of the toolbar.
 * @property {Function} getRelatedElement A function that returns an engine {@link module:engine/view/view~View}
 * element the toolbar is to be attached to. For instance, an image widget or a table widget (or `null` when
 * there is no such element). The function accepts an instance of {@link module:engine/view/selection~Selection}.
 * @property {String} balloonClassName CSS class for the widget balloon when a toolbar is displayed.
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-image/src/imagetoolbar.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module image/imagetoolbar
 */



/**
 * The image toolbar plugin. It creates and manages the image toolbar (the toolbar displayed when an image is selected).
 *
 * For a detailed overview, check the {@glink features/image#image-contextual-toolbar image contextual toolbar} documentation.
 *
 * Instances of toolbar components (e.g. buttons) are created using the editor's
 * {@link module:ui/componentfactory~ComponentFactory component factory}
 * based on the {@link module:image/image~ImageConfig#toolbar `image.toolbar` configuration option}.
 *
 * The toolbar uses the {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon}.
 *
 * @extends module:core/plugin~Plugin
 */

var imagetoolbar_ImageToolbar = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ImageToolbar, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ImageToolbar);

  function ImageToolbar() {
    Object(classCallCheck["a" /* default */])(this, ImageToolbar);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ImageToolbar, [{
    key: "afterInit",

    /**
     * @inheritDoc
     */
    value: function afterInit() {
      var editor = this.editor;
      var t = editor.t;
      var widgetToolbarRepository = editor.plugins.get(widgettoolbarrepository_WidgetToolbarRepository);
      widgetToolbarRepository.register('image', {
        ariaLabel: t('Image toolbar'),
        items: editor.config.get('image.toolbar') || [],
        getRelatedElement: getSelectedImageWidget
      });
    }
  }], [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [widgettoolbarrepository_WidgetToolbarRepository];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'ImageToolbar';
    }
  }]);

  return ImageToolbar;
}(plugin_Plugin);
/**
 * Items to be placed in the image toolbar.
 * This option is used by the {@link module:image/imagetoolbar~ImageToolbar} feature.
 *
 * Assuming that you use the following features:
 *
 * * {@link module:image/imagestyle~ImageStyle} (with a default configuration),
 * * {@link module:image/imagetextalternative~ImageTextAlternative},
 *
 * three toolbar items will be available in {@link module:ui/componentfactory~ComponentFactory}:
 * `'imageStyle:full'`, `'imageStyle:side'`, and `'imageTextAlternative'` so you can configure the toolbar like this:
 *
 *		const imageConfig = {
 *			toolbar: [ 'imageStyle:full', 'imageStyle:side', '|', 'imageTextAlternative' ]
 *		};
 *
 * Of course, the same buttons can also be used in the
 * {@link module:core/editor/editorconfig~EditorConfig#toolbar main editor toolbar}.
 *
 * Read more about configuring toolbar in {@link module:core/editor/editorconfig~EditorConfig#toolbar}.
 *
 * @member {Array.<String>} module:image/image~ImageConfig#toolbar
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-engine/src/view/observer/clickobserver.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module engine/view/observer/clickobserver
 */

/**
 * {@link module:engine/view/document~Document#event:click Click} event observer.
 *
 * Note that this observer is not available by default. To make it available it needs to be added to
 * {@link module:engine/view/view~View view controller}
 * by a {@link module:engine/view/view~View#addObserver} method.
 *
 * @extends module:engine/view/observer/domeventobserver~DomEventObserver
 */

var clickobserver_ClickObserver = /*#__PURE__*/function (_DomEventObserver) {
  Object(inherits["a" /* default */])(ClickObserver, _DomEventObserver);

  var _super = Object(createSuper["a" /* default */])(ClickObserver);

  function ClickObserver(view) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, ClickObserver);

    _this = _super.call(this, view);
    _this.domEventType = 'click';
    return _this;
  }

  Object(createClass["a" /* default */])(ClickObserver, [{
    key: "onDomEvent",
    value: function onDomEvent(domEvent) {
      this.fire(domEvent.type, domEvent);
    }
  }]);

  return ClickObserver;
}(domeventobserver_DomEventObserver);
/**
 * Fired when one of the editables has been clicked.
 *
 * Introduced by {@link module:engine/view/observer/clickobserver~ClickObserver}.
 *
 * Note that this event is not available by default. To make it available
 * {@link module:engine/view/observer/clickobserver~ClickObserver} needs to be added
 * to {@link module:engine/view/view~View} by a {@link module:engine/view/view~View#addObserver} method.
 *
 * @see module:engine/view/observer/clickobserver~ClickObserver
 * @event module:engine/view/document~Document#event:click
 * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.
 */



// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-link/theme/linkform.css
var linkform = __webpack_require__("18ea");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-link/src/ui/linkformview.js

















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module link/ui/linkformview
 */













/**
 * The link form view controller class.
 *
 * See {@link module:link/ui/linkformview~LinkFormView}.
 *
 * @extends module:ui/view~View
 */

var linkformview_LinkFormView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(LinkFormView, _View);

  var _super = Object(createSuper["a" /* default */])(LinkFormView);

  /**
   * Creates an instance of the {@link module:link/ui/linkformview~LinkFormView} class.
   *
   * Also see {@link #render}.
   *
   * @param {module:utils/locale~Locale} [locale] The localization services instance.
   * @param {module:link/linkcommand~LinkCommand} linkCommand Reference to {@link module:link/linkcommand~LinkCommand}.
   * @param {String} [protocol] A value of a protocol to be displayed in the input's placeholder.
   */
  function LinkFormView(locale, linkCommand, protocol) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, LinkFormView);

    _this = _super.call(this, locale);
    var t = locale.t;
    /**
     * Tracks information about DOM focus in the form.
     *
     * @readonly
     * @member {module:utils/focustracker~FocusTracker}
     */

    _this.focusTracker = new focustracker_FocusTracker();
    /**
     * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
     *
     * @readonly
     * @member {module:utils/keystrokehandler~KeystrokeHandler}
     */

    _this.keystrokes = new keystrokehandler_KeystrokeHandler();
    /**
     * The URL input view.
     *
     * @member {module:ui/labeledfield/labeledfieldview~LabeledFieldView}
     */

    _this.urlInputView = _this._createUrlInput(protocol);
    /**
     * The Save button view.
     *
     * @member {module:ui/button/buttonview~ButtonView}
     */

    _this.saveButtonView = _this._createButton(t('Save'), check_default.a, 'ck-button-save');
    _this.saveButtonView.type = 'submit';
    /**
     * The Cancel button view.
     *
     * @member {module:ui/button/buttonview~ButtonView}
     */

    _this.cancelButtonView = _this._createButton(t('Cancel'), cancel_default.a, 'ck-button-cancel', 'cancel');
    /**
     * A collection of {@link module:ui/button/switchbuttonview~SwitchButtonView},
     * which corresponds to {@link module:link/linkcommand~LinkCommand#manualDecorators manual decorators}
     * configured in the editor.
     *
     * @private
     * @readonly
     * @type {module:ui/viewcollection~ViewCollection}
     */

    _this._manualDecoratorSwitches = _this._createManualDecoratorSwitches(linkCommand);
    /**
     * A collection of child views in the form.
     *
     * @readonly
     * @type {module:ui/viewcollection~ViewCollection}
     */

    _this.children = _this._createFormChildren(linkCommand.manualDecorators);
    /**
     * A collection of views that can be focused in the form.
     *
     * @readonly
     * @protected
     * @member {module:ui/viewcollection~ViewCollection}
     */

    _this._focusables = new viewcollection_ViewCollection();
    /**
     * Helps cycling over {@link #_focusables} in the form.
     *
     * @readonly
     * @protected
     * @member {module:ui/focuscycler~FocusCycler}
     */

    _this._focusCycler = new focuscycler_FocusCycler({
      focusables: _this._focusables,
      focusTracker: _this.focusTracker,
      keystrokeHandler: _this.keystrokes,
      actions: {
        // Navigate form fields backwards using the Shift + Tab keystroke.
        focusPrevious: 'shift + tab',
        // Navigate form fields forwards using the Tab key.
        focusNext: 'tab'
      }
    });
    var classList = ['ck', 'ck-link-form'];

    if (linkCommand.manualDecorators.length) {
      classList.push('ck-link-form_layout-vertical');
    }

    _this.setTemplate({
      tag: 'form',
      attributes: {
        class: classList,
        // https://github.com/ckeditor/ckeditor5-link/issues/90
        tabindex: '-1'
      },
      children: _this.children
    });

    return _this;
  }
  /**
   * Obtains the state of the {@link module:ui/button/switchbuttonview~SwitchButtonView switch buttons} representing
   * {@link module:link/linkcommand~LinkCommand#manualDecorators manual link decorators}
   * in the {@link module:link/ui/linkformview~LinkFormView}.
   *
   * @returns {Object.<String,Boolean>} Key-value pairs, where the key is the name of the decorator and the value is
   * its state.
   */


  Object(createClass["a" /* default */])(LinkFormView, [{
    key: "getDecoratorSwitchesState",
    value: function getDecoratorSwitchesState() {
      return Array.from(this._manualDecoratorSwitches).reduce(function (accumulator, switchButton) {
        accumulator[switchButton.name] = switchButton.isOn;
        return accumulator;
      }, {});
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      get_get(Object(getPrototypeOf["a" /* default */])(LinkFormView.prototype), "render", this).call(this);

      submitHandler({
        view: this
      });
      var childViews = [this.urlInputView].concat(_toConsumableArray(this._manualDecoratorSwitches), [this.saveButtonView, this.cancelButtonView]);
      childViews.forEach(function (v) {
        // Register the view as focusable.
        _this2._focusables.add(v); // Register the view in the focus tracker.


        _this2.focusTracker.add(v.element);
      }); // Start listening for the keystrokes coming from #element.

      this.keystrokes.listenTo(this.element);
    }
    /**
     * Focuses the fist {@link #_focusables} in the form.
     */

  }, {
    key: "focus",
    value: function focus() {
      this._focusCycler.focusFirst();
    }
    /**
     * Creates a labeled input view.
     *
     * @private
     * @param {String} [protocol=http://] A value of a protocol to be displayed in the input's placeholder.
     * @returns {module:ui/labeledfield/labeledfieldview~LabeledFieldView} Labeled field view instance.
     */

  }, {
    key: "_createUrlInput",
    value: function _createUrlInput() {
      var protocol = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'https://';
      var t = this.locale.t;
      var labeledInput = new labeledfieldview_LabeledFieldView(this.locale, createLabeledInputText);
      labeledInput.label = t('Link URL');
      labeledInput.fieldView.placeholder = protocol + 'example.com';
      return labeledInput;
    }
    /**
     * Creates a button view.
     *
     * @private
     * @param {String} label The button label.
     * @param {String} icon The button icon.
     * @param {String} className The additional button CSS class name.
     * @param {String} [eventName] An event name that the `ButtonView#execute` event will be delegated to.
     * @returns {module:ui/button/buttonview~ButtonView} The button view instance.
     */

  }, {
    key: "_createButton",
    value: function _createButton(label, icon, className, eventName) {
      var button = new buttonview_ButtonView(this.locale);
      button.set({
        label: label,
        icon: icon,
        tooltip: true
      });
      button.extendTemplate({
        attributes: {
          class: className
        }
      });

      if (eventName) {
        button.delegate('execute').to(this, eventName);
      }

      return button;
    }
    /**
     * Populates {@link module:ui/viewcollection~ViewCollection} of {@link module:ui/button/switchbuttonview~SwitchButtonView}
     * made based on {@link module:link/linkcommand~LinkCommand#manualDecorators}.
     *
     * @private
     * @param {module:link/linkcommand~LinkCommand} linkCommand A reference to the link command.
     * @returns {module:ui/viewcollection~ViewCollection} of switch buttons.
     */

  }, {
    key: "_createManualDecoratorSwitches",
    value: function _createManualDecoratorSwitches(linkCommand) {
      var _this3 = this;

      var switches = this.createCollection();

      var _iterator = _createForOfIteratorHelper(linkCommand.manualDecorators),
          _step;

      try {
        var _loop = function _loop() {
          var manualDecorator = _step.value;
          var switchButton = new switchbuttonview_SwitchButtonView(_this3.locale);
          switchButton.set({
            name: manualDecorator.id,
            label: manualDecorator.label,
            withText: true
          });
          switchButton.bind('isOn').toMany([manualDecorator, linkCommand], 'value', function (decoratorValue, commandValue) {
            return commandValue === undefined && decoratorValue === undefined ? manualDecorator.defaultValue : decoratorValue;
          });
          switchButton.on('execute', function () {
            manualDecorator.set('value', !switchButton.isOn);
          });
          switches.add(switchButton);
        };

        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          _loop();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return switches;
    }
    /**
     * Populates the {@link #children} collection of the form.
     *
     * If {@link module:link/linkcommand~LinkCommand#manualDecorators manual decorators} are configured in the editor, it creates an
     * additional `View` wrapping all {@link #_manualDecoratorSwitches} switch buttons corresponding
     * to these decorators.
     *
     * @private
     * @param {module:utils/collection~Collection} manualDecorators A reference to
     * the collection of manual decorators stored in the link command.
     * @returns {module:ui/viewcollection~ViewCollection} The children of link form view.
     */

  }, {
    key: "_createFormChildren",
    value: function _createFormChildren(manualDecorators) {
      var children = this.createCollection();
      children.add(this.urlInputView);

      if (manualDecorators.length) {
        var additionalButtonsView = new src_view_View();
        additionalButtonsView.setTemplate({
          tag: 'ul',
          children: this._manualDecoratorSwitches.map(function (switchButton) {
            return {
              tag: 'li',
              children: [switchButton],
              attributes: {
                class: ['ck', 'ck-list__item']
              }
            };
          }),
          attributes: {
            class: ['ck', 'ck-reset', 'ck-list']
          }
        });
        children.add(additionalButtonsView);
      }

      children.add(this.saveButtonView);
      children.add(this.cancelButtonView);
      return children;
    }
  }]);

  return LinkFormView;
}(src_view_View);
/**
 * Fired when the form view is submitted (when one of the children triggered the submit event),
 * for example with a click on {@link #saveButtonView}.
 *
 * @event submit
 */

/**
 * Fired when the form view is canceled, for example with a click on {@link #cancelButtonView}.
 *
 * @event cancel
 */



// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-link/theme/icons/unlink.svg
var unlink = __webpack_require__("1805");
var unlink_default = /*#__PURE__*/__webpack_require__.n(unlink);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-core/theme/icons/pencil.svg
var pencil = __webpack_require__("2609");
var pencil_default = /*#__PURE__*/__webpack_require__.n(pencil);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-link/theme/linkactions.css
var linkactions = __webpack_require__("2260");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-link/src/ui/linkactionsview.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module link/ui/linkactionsview
 */










/**
 * The link actions view class. This view displays the link preview, allows
 * unlinking or editing the link.
 *
 * @extends module:ui/view~View
 */

var linkactionsview_LinkActionsView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(LinkActionsView, _View);

  var _super = Object(createSuper["a" /* default */])(LinkActionsView);

  /**
   * @inheritDoc
   */
  function LinkActionsView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, LinkActionsView);

    _this = _super.call(this, locale);
    var t = locale.t;
    /**
     * Tracks information about DOM focus in the actions.
     *
     * @readonly
     * @member {module:utils/focustracker~FocusTracker}
     */

    _this.focusTracker = new focustracker_FocusTracker();
    /**
     * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
     *
     * @readonly
     * @member {module:utils/keystrokehandler~KeystrokeHandler}
     */

    _this.keystrokes = new keystrokehandler_KeystrokeHandler();
    /**
     * The href preview view.
     *
     * @member {module:ui/view~View}
     */

    _this.previewButtonView = _this._createPreviewButton();
    /**
     * The unlink button view.
     *
     * @member {module:ui/button/buttonview~ButtonView}
     */

    _this.unlinkButtonView = _this._createButton(t('Unlink'), unlink_default.a, 'unlink');
    /**
     * The edit link button view.
     *
     * @member {module:ui/button/buttonview~ButtonView}
     */

    _this.editButtonView = _this._createButton(t('Edit link'), pencil_default.a, 'edit');
    /**
     * The value of the "href" attribute of the link to use in the {@link #previewButtonView}.
     *
     * @observable
     * @member {String}
     */

    _this.set('href');
    /**
     * A collection of views that can be focused in the view.
     *
     * @readonly
     * @protected
     * @member {module:ui/viewcollection~ViewCollection}
     */


    _this._focusables = new viewcollection_ViewCollection();
    /**
     * Helps cycling over {@link #_focusables} in the view.
     *
     * @readonly
     * @protected
     * @member {module:ui/focuscycler~FocusCycler}
     */

    _this._focusCycler = new focuscycler_FocusCycler({
      focusables: _this._focusables,
      focusTracker: _this.focusTracker,
      keystrokeHandler: _this.keystrokes,
      actions: {
        // Navigate fields backwards using the Shift + Tab keystroke.
        focusPrevious: 'shift + tab',
        // Navigate fields forwards using the Tab key.
        focusNext: 'tab'
      }
    });

    _this.setTemplate({
      tag: 'div',
      attributes: {
        class: ['ck', 'ck-link-actions'],
        // https://github.com/ckeditor/ckeditor5-link/issues/90
        tabindex: '-1'
      },
      children: [_this.previewButtonView, _this.editButtonView, _this.unlinkButtonView]
    });

    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(LinkActionsView, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      get_get(Object(getPrototypeOf["a" /* default */])(LinkActionsView.prototype), "render", this).call(this);

      var childViews = [this.previewButtonView, this.editButtonView, this.unlinkButtonView];
      childViews.forEach(function (v) {
        // Register the view as focusable.
        _this2._focusables.add(v); // Register the view in the focus tracker.


        _this2.focusTracker.add(v.element);
      }); // Start listening for the keystrokes coming from #element.

      this.keystrokes.listenTo(this.element);
    }
    /**
     * Focuses the fist {@link #_focusables} in the actions.
     */

  }, {
    key: "focus",
    value: function focus() {
      this._focusCycler.focusFirst();
    }
    /**
     * Creates a button view.
     *
     * @private
     * @param {String} label The button label.
     * @param {String} icon The button icon.
     * @param {String} [eventName] An event name that the `ButtonView#execute` event will be delegated to.
     * @returns {module:ui/button/buttonview~ButtonView} The button view instance.
     */

  }, {
    key: "_createButton",
    value: function _createButton(label, icon, eventName) {
      var button = new buttonview_ButtonView(this.locale);
      button.set({
        label: label,
        icon: icon,
        tooltip: true
      });
      button.delegate('execute').to(this, eventName);
      return button;
    }
    /**
     * Creates a link href preview button.
     *
     * @private
     * @returns {module:ui/button/buttonview~ButtonView} The button view instance.
     */

  }, {
    key: "_createPreviewButton",
    value: function _createPreviewButton() {
      var button = new buttonview_ButtonView(this.locale);
      var bind = this.bindTemplate;
      var t = this.t;
      button.set({
        withText: true,
        tooltip: t('Open link in new tab')
      });
      button.extendTemplate({
        attributes: {
          class: ['ck', 'ck-link-actions__preview'],
          href: bind.to('href', function (href) {
            return href && ensureSafeUrl(href);
          }),
          target: '_blank',
          rel: 'noopener noreferrer'
        }
      });
      button.bind('label').to(this, 'href', function (href) {
        return href || t('This link has no URL');
      });
      button.bind('isEnabled').to(this, 'href', function (href) {
        return !!href;
      });
      button.template.tag = 'a';
      button.template.eventListeners = {};
      return button;
    }
  }]);

  return LinkActionsView;
}(src_view_View);
/**
 * Fired when the {@link #editButtonView} is clicked.
 *
 * @event edit
 */

/**
 * Fired when the {@link #unlinkButtonView} is clicked.
 *
 * @event unlink
 */



// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-link/theme/icons/link.svg
var icons_link = __webpack_require__("77bd");
var icons_link_default = /*#__PURE__*/__webpack_require__.n(icons_link);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-link/src/linkui.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module link/linkui
 */









var protocolRegExp = /^((\w+:(\/{2,})?)|(\W))/i;
var emailRegExp = /[\w-]+@[\w-]+\.+[\w-]+/i;
var VISUAL_SELECTION_MARKER_NAME = 'link-ui';
/**
 * The link UI plugin. It introduces the `'link'` and `'unlink'` buttons and support for the <kbd>Ctrl+K</kbd> keystroke.
 *
 * It uses the
 * {@link module:ui/panel/balloon/contextualballoon~ContextualBalloon contextual balloon plugin}.
 *
 * @extends module:core/plugin~Plugin
 */

var linkui_LinkUI = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(LinkUI, _Plugin);

  var _super = Object(createSuper["a" /* default */])(LinkUI);

  function LinkUI() {
    Object(classCallCheck["a" /* default */])(this, LinkUI);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(LinkUI, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var editor = this.editor;
      editor.editing.view.addObserver(clickobserver_ClickObserver);
      /**
       * The actions view displayed inside of the balloon.
       *
       * @member {module:link/ui/linkactionsview~LinkActionsView}
       */

      this.actionsView = this._createActionsView();
      /**
       * The form view displayed inside the balloon.
       *
       * @member {module:link/ui/linkformview~LinkFormView}
       */

      this.formView = this._createFormView();
      /**
       * The contextual balloon plugin instance.
       *
       * @private
       * @member {module:ui/panel/balloon/contextualballoon~ContextualBalloon}
       */

      this._balloon = editor.plugins.get(contextualballoon_ContextualBalloon); // Create toolbar buttons.

      this._createToolbarLinkButton(); // Attach lifecycle actions to the the balloon.


      this._enableUserBalloonInteractions(); // Renders a fake visual selection marker on an expanded selection.


      editor.conversion.for('downcast').markerToHighlight({
        model: VISUAL_SELECTION_MARKER_NAME,
        view: {
          classes: ['ck-fake-link-selection']
        }
      }); // Renders a fake visual selection marker on a collapsed selection.

      editor.conversion.for('downcast').markerToElement({
        model: VISUAL_SELECTION_MARKER_NAME,
        view: {
          name: 'span',
          classes: ['ck-fake-link-selection', 'ck-fake-link-selection_collapsed']
        }
      });
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "destroy",
    value: function destroy() {
      get_get(Object(getPrototypeOf["a" /* default */])(LinkUI.prototype), "destroy", this).call(this); // Destroy created UI components as they are not automatically destroyed (see ckeditor5#1341).


      this.formView.destroy();
    }
    /**
     * Creates the {@link module:link/ui/linkactionsview~LinkActionsView} instance.
     *
     * @private
     * @returns {module:link/ui/linkactionsview~LinkActionsView} The link actions view instance.
     */

  }, {
    key: "_createActionsView",
    value: function _createActionsView() {
      var _this = this;

      var editor = this.editor;
      var actionsView = new linkactionsview_LinkActionsView(editor.locale);
      var linkCommand = editor.commands.get('link');
      var unlinkCommand = editor.commands.get('unlink');
      actionsView.bind('href').to(linkCommand, 'value');
      actionsView.editButtonView.bind('isEnabled').to(linkCommand);
      actionsView.unlinkButtonView.bind('isEnabled').to(unlinkCommand); // Execute unlink command after clicking on the "Edit" button.

      this.listenTo(actionsView, 'edit', function () {
        _this._addFormView();
      }); // Execute unlink command after clicking on the "Unlink" button.

      this.listenTo(actionsView, 'unlink', function () {
        editor.execute('unlink');

        _this._hideUI();
      }); // Close the panel on esc key press when the **actions have focus**.

      actionsView.keystrokes.set('Esc', function (data, cancel) {
        _this._hideUI();

        cancel();
      }); // Open the form view on Ctrl+K when the **actions have focus**..

      actionsView.keystrokes.set(LINK_KEYSTROKE, function (data, cancel) {
        _this._addFormView();

        cancel();
      });
      return actionsView;
    }
    /**
     * Creates the {@link module:link/ui/linkformview~LinkFormView} instance.
     *
     * @private
     * @returns {module:link/ui/linkformview~LinkFormView} The link form view instance.
     */

  }, {
    key: "_createFormView",
    value: function _createFormView() {
      var _this2 = this;

      var editor = this.editor;
      var linkCommand = editor.commands.get('link');
      var defaultProtocol = editor.config.get('link.defaultProtocol');
      var formView = new linkformview_LinkFormView(editor.locale, linkCommand, defaultProtocol);
      formView.urlInputView.fieldView.bind('value').to(linkCommand, 'value'); // Form elements should be read-only when corresponding commands are disabled.

      formView.urlInputView.bind('isReadOnly').to(linkCommand, 'isEnabled', function (value) {
        return !value;
      });
      formView.saveButtonView.bind('isEnabled').to(linkCommand); // Execute link command after clicking the "Save" button.

      this.listenTo(formView, 'submit', function () {
        var value = formView.urlInputView.fieldView.element.value; // The regex checks for the protocol syntax ('xxxx://' or 'xxxx:')
        // or non-word characters at the beginning of the link ('/', '#' etc.).

        var isProtocolNeeded = !!defaultProtocol && !protocolRegExp.test(value);
        var isEmail = emailRegExp.test(value);
        var protocol = isEmail ? 'mailto:' : defaultProtocol;
        var parsedValue = value && isProtocolNeeded ? protocol + value : value;
        editor.execute('link', parsedValue, formView.getDecoratorSwitchesState());

        _this2._closeFormView();
      }); // Hide the panel after clicking the "Cancel" button.

      this.listenTo(formView, 'cancel', function () {
        _this2._closeFormView();
      }); // Close the panel on esc key press when the **form has focus**.

      formView.keystrokes.set('Esc', function (data, cancel) {
        _this2._closeFormView();

        cancel();
      });
      return formView;
    }
    /**
     * Creates a toolbar Link button. Clicking this button will show
     * a {@link #_balloon} attached to the selection.
     *
     * @private
     */

  }, {
    key: "_createToolbarLinkButton",
    value: function _createToolbarLinkButton() {
      var _this3 = this;

      var editor = this.editor;
      var linkCommand = editor.commands.get('link');
      var t = editor.t; // Handle the `Ctrl+K` keystroke and show the panel.

      editor.keystrokes.set(LINK_KEYSTROKE, function (keyEvtData, cancel) {
        // Prevent focusing the search bar in FF, Chrome and Edge. See https://github.com/ckeditor/ckeditor5/issues/4811.
        cancel();

        _this3._showUI(true);
      });
      editor.ui.componentFactory.add('link', function (locale) {
        var button = new buttonview_ButtonView(locale);
        button.isEnabled = true;
        button.label = t('Link');
        button.icon = icons_link_default.a;
        button.keystroke = LINK_KEYSTROKE;
        button.tooltip = true;
        button.isToggleable = true; // Bind button to the command.

        button.bind('isEnabled').to(linkCommand, 'isEnabled');
        button.bind('isOn').to(linkCommand, 'value', function (value) {
          return !!value;
        }); // Show the panel on button click.

        _this3.listenTo(button, 'execute', function () {
          return _this3._showUI(true);
        });

        return button;
      });
    }
    /**
     * Attaches actions that control whether the balloon panel containing the
     * {@link #formView} is visible or not.
     *
     * @private
     */

  }, {
    key: "_enableUserBalloonInteractions",
    value: function _enableUserBalloonInteractions() {
      var _this4 = this;

      var viewDocument = this.editor.editing.view.document; // Handle click on view document and show panel when selection is placed inside the link element.
      // Keep panel open until selection will be inside the same link element.

      this.listenTo(viewDocument, 'click', function () {
        var parentLink = _this4._getSelectedLinkElement();

        if (parentLink) {
          // Then show panel but keep focus inside editor editable.
          _this4._showUI();
        }
      }); // Focus the form if the balloon is visible and the Tab key has been pressed.

      this.editor.keystrokes.set('Tab', function (data, cancel) {
        if (_this4._areActionsVisible && !_this4.actionsView.focusTracker.isFocused) {
          _this4.actionsView.focus();

          cancel();
        }
      }, {
        // Use the high priority because the link UI navigation is more important
        // than other feature's actions, e.g. list indentation.
        // https://github.com/ckeditor/ckeditor5-link/issues/146
        priority: 'high'
      }); // Close the panel on the Esc key press when the editable has focus and the balloon is visible.

      this.editor.keystrokes.set('Esc', function (data, cancel) {
        if (_this4._isUIVisible) {
          _this4._hideUI();

          cancel();
        }
      }); // Close on click outside of balloon panel element.

      clickOutsideHandler({
        emitter: this.formView,
        activator: function activator() {
          return _this4._isUIInPanel;
        },
        contextElements: [this._balloon.view.element],
        callback: function callback() {
          return _this4._hideUI();
        }
      });
    }
    /**
     * Adds the {@link #actionsView} to the {@link #_balloon}.
     *
     * @protected
     */

  }, {
    key: "_addActionsView",
    value: function _addActionsView() {
      if (this._areActionsInPanel) {
        return;
      }

      this._balloon.add({
        view: this.actionsView,
        position: this._getBalloonPositionData()
      });
    }
    /**
     * Adds the {@link #formView} to the {@link #_balloon}.
     *
     * @protected
     */

  }, {
    key: "_addFormView",
    value: function _addFormView() {
      if (this._isFormInPanel) {
        return;
      }

      var editor = this.editor;
      var linkCommand = editor.commands.get('link');

      this._balloon.add({
        view: this.formView,
        position: this._getBalloonPositionData()
      }); // Select input when form view is currently visible.


      if (this._balloon.visibleView === this.formView) {
        this.formView.urlInputView.fieldView.select();
      } // Make sure that each time the panel shows up, the URL field remains in sync with the value of
      // the command. If the user typed in the input, then canceled the balloon (`urlInputView.fieldView#value` stays
      // unaltered) and re-opened it without changing the value of the link command (e.g. because they
      // clicked the same link), they would see the old value instead of the actual value of the command.
      // https://github.com/ckeditor/ckeditor5-link/issues/78
      // https://github.com/ckeditor/ckeditor5-link/issues/123


      this.formView.urlInputView.fieldView.element.value = linkCommand.value || '';
    }
    /**
     * Closes the form view. Decides whether the balloon should be hidden completely or if the action view should be shown. This is
     * decided upon the link command value (which has a value if the document selection is in the link).
     *
     * Additionally, if any {@link module:link/link~LinkConfig#decorators} are defined in the editor configuration, the state of
     * switch buttons responsible for manual decorator handling is restored.
     *
     * @private
     */

  }, {
    key: "_closeFormView",
    value: function _closeFormView() {
      var linkCommand = this.editor.commands.get('link'); // Restore manual decorator states to represent the current model state. This case is important to reset the switch buttons
      // when the user cancels the editing form.

      linkCommand.restoreManualDecoratorStates();

      if (linkCommand.value !== undefined) {
        this._removeFormView();
      } else {
        this._hideUI();
      }
    }
    /**
     * Removes the {@link #formView} from the {@link #_balloon}.
     *
     * @protected
     */

  }, {
    key: "_removeFormView",
    value: function _removeFormView() {
      if (this._isFormInPanel) {
        // Blur the input element before removing it from DOM to prevent issues in some browsers.
        // See https://github.com/ckeditor/ckeditor5/issues/1501.
        this.formView.saveButtonView.focus();

        this._balloon.remove(this.formView); // Because the form has an input which has focus, the focus must be brought back
        // to the editor. Otherwise, it would be lost.


        this.editor.editing.view.focus();

        this._hideFakeVisualSelection();
      }
    }
    /**
     * Shows the correct UI type. It is either {@link #formView} or {@link #actionsView}.
     *
     * @param {Boolean} forceVisible
     * @private
     */

  }, {
    key: "_showUI",
    value: function _showUI() {
      var forceVisible = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

      // When there's no link under the selection, go straight to the editing UI.
      if (!this._getSelectedLinkElement()) {
        this._addActionsView(); // Be sure panel with link is visible.


        if (forceVisible) {
          this._balloon.showStack('main');
        }

        this._addFormView(); // Show visual selection on a text without a link when the contextual balloon is displayed.
        // See https://github.com/ckeditor/ckeditor5/issues/4721.


        this._showFakeVisualSelection();
      } // If there's a link under the selection...
      else {
          // Go to the editing UI if actions are already visible.
          if (this._areActionsVisible) {
            this._addFormView();
          } // Otherwise display just the actions UI.
          else {
              this._addActionsView();
            } // Be sure panel with link is visible.


          if (forceVisible) {
            this._balloon.showStack('main');
          }
        } // Begin responding to ui#update once the UI is added.


      this._startUpdatingUI();
    }
    /**
     * Removes the {@link #formView} from the {@link #_balloon}.
     *
     * See {@link #_addFormView}, {@link #_addActionsView}.
     *
     * @protected
     */

  }, {
    key: "_hideUI",
    value: function _hideUI() {
      if (!this._isUIInPanel) {
        return;
      }

      var editor = this.editor;
      this.stopListening(editor.ui, 'update');
      this.stopListening(this._balloon, 'change:visibleView'); // Make sure the focus always gets back to the editable _before_ removing the focused form view.
      // Doing otherwise causes issues in some browsers. See https://github.com/ckeditor/ckeditor5-link/issues/193.

      editor.editing.view.focus(); // Remove form first because it's on top of the stack.

      this._removeFormView(); // Then remove the actions view because it's beneath the form.


      this._balloon.remove(this.actionsView);

      this._hideFakeVisualSelection();
    }
    /**
     * Makes the UI react to the {@link module:core/editor/editorui~EditorUI#event:update} event to
     * reposition itself when the editor UI should be refreshed.
     *
     * See: {@link #_hideUI} to learn when the UI stops reacting to the `update` event.
     *
     * @protected
     */

  }, {
    key: "_startUpdatingUI",
    value: function _startUpdatingUI() {
      var _this5 = this;

      var editor = this.editor;
      var viewDocument = editor.editing.view.document;

      var prevSelectedLink = this._getSelectedLinkElement();

      var prevSelectionParent = getSelectionParent();

      var update = function update() {
        var selectedLink = _this5._getSelectedLinkElement();

        var selectionParent = getSelectionParent(); // Hide the panel if:
        //
        // * the selection went out of the EXISTING link element. E.g. user moved the caret out
        //   of the link,
        // * the selection went to a different parent when creating a NEW link. E.g. someone
        //   else modified the document.
        // * the selection has expanded (e.g. displaying link actions then pressing SHIFT+Right arrow).
        //
        // Note: #_getSelectedLinkElement will return a link for a non-collapsed selection only
        // when fully selected.

        if (prevSelectedLink && !selectedLink || !prevSelectedLink && selectionParent !== prevSelectionParent) {
          _this5._hideUI();
        } // Update the position of the panel when:
        //  * link panel is in the visible stack
        //  * the selection remains in the original link element,
        //  * there was no link element in the first place, i.e. creating a new link
        else if (_this5._isUIVisible) {
            // If still in a link element, simply update the position of the balloon.
            // If there was no link (e.g. inserting one), the balloon must be moved
            // to the new position in the editing view (a new native DOM range).
            _this5._balloon.updatePosition(_this5._getBalloonPositionData());
          }

        prevSelectedLink = selectedLink;
        prevSelectionParent = selectionParent;
      };

      function getSelectionParent() {
        return viewDocument.selection.focus.getAncestors().reverse().find(function (node) {
          return node.is('element');
        });
      }

      this.listenTo(editor.ui, 'update', update);
      this.listenTo(this._balloon, 'change:visibleView', update);
    }
    /**
     * Returns `true` when {@link #formView} is in the {@link #_balloon}.
     *
     * @readonly
     * @protected
     * @type {Boolean}
     */

  }, {
    key: "_getBalloonPositionData",

    /**
     * Returns positioning options for the {@link #_balloon}. They control the way the balloon is attached
     * to the target element or selection.
     *
     * If the selection is collapsed and inside a link element, the panel will be attached to the
     * entire link element. Otherwise, it will be attached to the selection.
     *
     * @private
     * @returns {module:utils/dom/position~Options}
     */
    value: function _getBalloonPositionData() {
      var view = this.editor.editing.view;
      var viewDocument = view.document;

      var targetLink = this._getSelectedLinkElement();

      var target = targetLink ? // When selection is inside link element, then attach panel to this element.
      view.domConverter.mapViewToDom(targetLink) : // Otherwise attach panel to the selection.
      view.domConverter.viewRangeToDom(viewDocument.selection.getFirstRange());
      return {
        target: target
      };
    }
    /**
     * Returns the link {@link module:engine/view/attributeelement~AttributeElement} under
     * the {@link module:engine/view/document~Document editing view's} selection or `null`
     * if there is none.
     *
     * **Note**: For a non–collapsed selection, the link element is only returned when **fully**
     * selected and the **only** element within the selection boundaries.
     *
     * @private
     * @returns {module:engine/view/attributeelement~AttributeElement|null}
     */

  }, {
    key: "_getSelectedLinkElement",
    value: function _getSelectedLinkElement() {
      var view = this.editor.editing.view;
      var selection = view.document.selection;

      if (selection.isCollapsed) {
        return findLinkElementAncestor(selection.getFirstPosition());
      } else {
        // The range for fully selected link is usually anchored in adjacent text nodes.
        // Trim it to get closer to the actual link element.
        var range = selection.getFirstRange().getTrimmed();
        var startLink = findLinkElementAncestor(range.start);
        var endLink = findLinkElementAncestor(range.end);

        if (!startLink || startLink != endLink) {
          return null;
        } // Check if the link element is fully selected.


        if (view.createRangeIn(startLink).getTrimmed().isEqual(range)) {
          return startLink;
        } else {
          return null;
        }
      }
    }
    /**
     * Displays a fake visual selection when the contextual balloon is displayed.
     *
     * This adds a 'link-ui' marker into the document that is rendered as a highlight on selected text fragment.
     *
     * @private
     */

  }, {
    key: "_showFakeVisualSelection",
    value: function _showFakeVisualSelection() {
      var model = this.editor.model;
      model.change(function (writer) {
        if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
          writer.updateMarker(VISUAL_SELECTION_MARKER_NAME, {
            range: model.document.selection.getFirstRange()
          });
        } else {
          writer.addMarker(VISUAL_SELECTION_MARKER_NAME, {
            usingOperation: false,
            affectsData: false,
            range: model.document.selection.getFirstRange()
          });
        }
      });
    }
    /**
     * Hides the fake visual selection created in {@link #_showFakeVisualSelection}.
     *
     * @private
     */

  }, {
    key: "_hideFakeVisualSelection",
    value: function _hideFakeVisualSelection() {
      var model = this.editor.model;

      if (model.markers.has(VISUAL_SELECTION_MARKER_NAME)) {
        model.change(function (writer) {
          writer.removeMarker(VISUAL_SELECTION_MARKER_NAME);
        });
      }
    }
  }, {
    key: "_isFormInPanel",
    get: function get() {
      return this._balloon.hasView(this.formView);
    }
    /**
     * Returns `true` when {@link #actionsView} is in the {@link #_balloon}.
     *
     * @readonly
     * @protected
     * @type {Boolean}
     */

  }, {
    key: "_areActionsInPanel",
    get: function get() {
      return this._balloon.hasView(this.actionsView);
    }
    /**
     * Returns `true` when {@link #actionsView} is in the {@link #_balloon} and it is
     * currently visible.
     *
     * @readonly
     * @protected
     * @type {Boolean}
     */

  }, {
    key: "_areActionsVisible",
    get: function get() {
      return this._balloon.visibleView === this.actionsView;
    }
    /**
     * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon}.
     *
     * @readonly
     * @protected
     * @type {Boolean}
     */

  }, {
    key: "_isUIInPanel",
    get: function get() {
      return this._isFormInPanel || this._areActionsInPanel;
    }
    /**
     * Returns `true` when {@link #actionsView} or {@link #formView} is in the {@link #_balloon} and it is
     * currently visible.
     *
     * @readonly
     * @protected
     * @type {Boolean}
     */

  }, {
    key: "_isUIVisible",
    get: function get() {
      var visibleView = this._balloon.visibleView;
      return visibleView == this.formView || this._areActionsVisible;
    }
  }], [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [contextualballoon_ContextualBalloon];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'LinkUI';
    }
  }]);

  return LinkUI;
}(plugin_Plugin); // Returns a link element if there's one among the ancestors of the provided `Position`.
//
// @private
// @param {module:engine/view/position~Position} View position to analyze.
// @returns {module:engine/view/attributeelement~AttributeElement|null} Link element at the position or null.




function findLinkElementAncestor(position) {
  return position.getAncestors().find(function (ancestor) {
    return isLinkElement(ancestor);
  });
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-link/src/link.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module link/link
 */



/**
 * The link plugin.
 *
 * This is a "glue" plugin that loads the {@link module:link/linkediting~LinkEditing link editing feature}
 * and {@link module:link/linkui~LinkUI link UI feature}.
 *
 * @extends module:core/plugin~Plugin
 */

var link_Link = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(Link, _Plugin);

  var _super = Object(createSuper["a" /* default */])(Link);

  function Link() {
    Object(classCallCheck["a" /* default */])(this, Link);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Link, null, [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [linkediting_LinkEditing, linkui_LinkUI];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'Link';
    }
  }]);

  return Link;
}(plugin_Plugin);
/**
 * The configuration of the {@link module:link/link~Link} feature.
 *
 * Read more in {@link module:link/link~LinkConfig}.
 *
 * @member {module:link/link~LinkConfig} module:core/editor/editorconfig~EditorConfig#link
 */

/**
 * The configuration of the {@link module:link/link~Link link feature}.
 *
 *		ClassicEditor
 *			.create( editorElement, {
 * 				link:  ... // Link feature configuration.
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * See {@link module:core/editor/editorconfig~EditorConfig all editor options}.
 * @interface LinkConfig
 */

/**
 * When set, the editor will add the given protocol to the link when the user creates a link without one.
 * For example, when the user is creating a link and types `ckeditor.com` in the link form input — during link submission —
 * the editor will automatically add the `http://` protocol, so the link will be as follows: `http://ckeditor.com`.
 *
 * The feature also comes with an email auto-detection. When you submit `hello@example.com`
 * the plugin will automatically change it to `mailto:hello@example.com`.
 *
 * 		ClassicEditor
 *			.create( editorElement, {
 * 				link: {
 * 					defaultProtocol: 'http://'
 * 				}
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * **NOTE:** In case no configuration is provided, the editor won't auto-fix the links.
 *
 * @member {String} module:link/link~LinkConfig#defaultProtocol
 */

/**
 * When set to `true`, the `target="blank"` and `rel="noopener noreferrer"` attributes are automatically added to all external links
 * in the editor. "External links" are all links in the editor content starting with `http`, `https`, or `//`.
 *
 *		ClassicEditor
 *			.create( editorElement, {
 *				link: {
 *					addTargetToExternalLinks: true
 *				}
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * Internally, this option activates a predefined {@link module:link/link~LinkConfig#decorators automatic link decorator}
 * that extends all external links with the `target` and `rel` attributes.
 *
 * **Note**: To control the `target` and `rel` attributes of specific links in the edited content, a dedicated
 * {@link module:link/link~LinkDecoratorManualDefinition manual} decorator must be defined in the
 * {@link module:link/link~LinkConfig#decorators `config.link.decorators`} array. In such scenario,
 * the `config.link.addTargetToExternalLinks` option should remain `undefined` or `false` to not interfere with the manual decorator.
 *
 * It is possible to add other {@link module:link/link~LinkDecoratorAutomaticDefinition automatic}
 * or {@link module:link/link~LinkDecoratorManualDefinition manual} link decorators when this option is active.
 *
 * More information about decorators can be found in the {@link module:link/link~LinkConfig#decorators decorators configuration}
 * reference.
 *
 * @default false
 * @member {Boolean} module:link/link~LinkConfig#addTargetToExternalLinks
 */

/**
 * Decorators provide an easy way to configure and manage additional link attributes in the editor content. There are
 * two types of link decorators:
 *
 * * {@link module:link/link~LinkDecoratorAutomaticDefinition Automatic} &ndash; They match links against pre–defined rules and
 * manage their attributes based on the results.
 * * {@link module:link/link~LinkDecoratorManualDefinition Manual} &ndash; They allow users to control link attributes individually,
 *  using the editor UI.
 *
 * Link decorators are defined as objects with key-value pairs, where the key is the name provided for a given decorator and the
 * value is the decorator definition.
 *
 * The name of the decorator also corresponds to the {@glink framework/guides/architecture/editing-engine#text-attributes text attribute}
 * in the model. For instance, the `isExternal` decorator below is represented as a `linkIsExternal` attribute in the model.
 *
 *		ClassicEditor
 *			.create( editorElement, {
 *				link: {
 *					decorators: {
 *						isExternal: {
 *							mode: 'automatic',
 *							callback: url => url.startsWith( 'http://' ),
 *							attributes: {
 *								target: '_blank',
 *								rel: 'noopener noreferrer'
 *							}
 *						},
 *						isDownloadable: {
 *							mode: 'manual',
 *							label: 'Downloadable',
 *							attributes: {
 *								download: 'file.png',
 *							}
 *						},
 *						// ...
 *					}
 *				}
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * To learn more about the configuration syntax, check out the {@link module:link/link~LinkDecoratorAutomaticDefinition automatic}
 * and {@link module:link/link~LinkDecoratorManualDefinition manual} decorator option reference.
 *
 * **Warning:** Currently, link decorators work independently of one another and no conflict resolution mechanism exists.
 * For example, configuring the `target` attribute using both an automatic and a manual decorator at the same time could end up with
 * quirky results. The same applies if multiple manual or automatic decorators were defined for the same attribute.
 *
 * **Note**: Since the `target` attribute management for external links is a common use case, there is a predefined automatic decorator
 * dedicated for that purpose which can be enabled by turning a single option on. Check out the
 * {@link module:link/link~LinkConfig#addTargetToExternalLinks `config.link.addTargetToExternalLinks`}
 * configuration description to learn more.
 *
 * See also the {@glink features/link#custom-link-attributes-decorators link feature guide} for more information.
 *
 * @member {Object.<String, module:link/link~LinkDecoratorDefinition>} module:link/link~LinkConfig#decorators
 */

/**
 * A link decorator definition. Two types implement this defition:
 *
 * * {@link module:link/link~LinkDecoratorManualDefinition}
 * * {@link module:link/link~LinkDecoratorAutomaticDefinition}
 *
 * Refer to their document for more information about available options or to the
 * {@glink features/link#custom-link-attributes-decorators link feature guide} for general information.
 *
 * @interface LinkDecoratorDefinition
 */

/**
 * Link decorator type.
 *
 * Check out the {@glink features/link#custom-link-attributes-decorators link feature guide} for more information.
 *
 * @member {'manual'|'automatic'} module:link/link~LinkDecoratorDefinition#mode
 */

/**
 * Describes an automatic {@link module:link/link~LinkConfig#decorators link decorator}. This decorator type matches
 * all links in the editor content against a function that decides whether the link should receive a pre–defined set of attributes.
 *
 * It takes an object with key-value pairs of attributes and a callback function that must return a Boolean value based on the link's
 * `href` (URL). When the callback returns `true`, attributes are applied to the link.
 *
 * For example, to add the `target="_blank"` attribute to all links in the editor starting with `http://`, the
 * configuration could look like this:
 *
 *		{
 *			mode: 'automatic',
 *			callback: url => url.startsWith( 'http://' ),
 *			attributes: {
 *				target: '_blank'
 *			}
 *		}
 *
 * **Note**: Since the `target` attribute management for external links is a common use case, there is a predefined automatic decorator
 * dedicated for that purpose that can be enabled by turning a single option on. Check out the
 * {@link module:link/link~LinkConfig#addTargetToExternalLinks `config.link.addTargetToExternalLinks`}
 * configuration description to learn more.
 *
 * @typedef {Object} module:link/link~LinkDecoratorAutomaticDefinition
 * @property {'automatic'} mode Link decorator type. It is `'automatic'` for all automatic decorators.
 * @property {Function} callback Takes a `url` as a parameter and returns `true` if the `attributes` should be applied to the link.
 * @property {Object} attributes Key-value pairs used as link attributes added to the output during the
 * {@glink framework/guides/architecture/editing-engine#conversion downcasting}.
 * Attributes should follow the {@link module:engine/view/elementdefinition~ElementDefinition} syntax.
 */

/**
 * Describes a manual {@link module:link/link~LinkConfig#decorators link decorator}. This decorator type is represented in
 * the link feature's {@link module:link/linkui user interface} as a switch that the user can use to control the presence
 * of a predefined set of attributes.
 *
 * For instance, to allow the users to manually control the presence of the `target="_blank"` and
 * `rel="noopener noreferrer"` attributes on specific links, the decorator could look as follows:
 *
 *		{
 *			mode: 'manual',
 *			label: 'Open in a new tab',
 *			defaultValue: true,
 *			attributes: {
 *				target: '_blank',
 *				rel: 'noopener noreferrer'
 *			}
 *		}
 *
 * @typedef {Object} module:link/link~LinkDecoratorManualDefinition
 * @property {'manual'} mode Link decorator type. It is `'manual'` for all manual decorators.
 * @property {String} label The label of the UI button that the user can use to control the presence of link attributes.
 * @property {Object} attributes Key-value pairs used as link attributes added to the output during the
 * {@glink framework/guides/architecture/editing-engine#conversion downcasting}.
 * Attributes should follow the {@link module:engine/view/elementdefinition~ElementDefinition} syntax.
 * @property {Boolean} [defaultValue] Controls whether the decorator is "on" by default.
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-list/src/listcommand.js











/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module list/listcommand
 */


/**
 * The list command. It is used by the {@link module:list/list~List list feature}.
 *
 * @extends module:core/command~Command
 */

var listcommand_ListCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(ListCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(ListCommand);

  /**
   * Creates an instance of the command.
   *
   * @param {module:core/editor/editor~Editor} editor The editor instance.
   * @param {'numbered'|'bulleted'} type List type that will be handled by this command.
   */
  function ListCommand(editor, type) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, ListCommand);

    _this = _super.call(this, editor);
    /**
     * The type of the list created by the command.
     *
     * @readonly
     * @member {'numbered'|'bulleted'|'todo'}
     */

    _this.type = type;
    /**
     * A flag indicating whether the command is active, which means that the selection starts in a list of the same type.
     *
     * @observable
     * @readonly
     * @member {Boolean} #value
     */

    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(ListCommand, [{
    key: "refresh",
    value: function refresh() {
      this.value = this._getValue();
      this.isEnabled = this._checkEnabled();
    }
    /**
     * Executes the command.
     *
     * @protected
     */

  }, {
    key: "execute",
    value: function execute() {
      var _this2 = this;

      var model = this.editor.model;
      var document = model.document;
      var blocks = Array.from(document.selection.getSelectedBlocks()).filter(function (block) {
        return checkCanBecomeListItem(block, model.schema);
      }); // Whether we are turning off some items.

      var turnOff = this.value === true; // If we are turning off items, we are going to rename them to paragraphs.

      model.change(function (writer) {
        // If part of a list got turned off, we need to handle (outdent) all of sub-items of the last turned-off item.
        // To be sure that model is all the time in a good state, we first fix items below turned-off item.
        if (turnOff) {
          // Start from the model item that is just after the last turned-off item.
          var next = blocks[blocks.length - 1].nextSibling;
          var currentIndent = Number.POSITIVE_INFINITY;
          var changes = []; // Correct indent of all items after the last turned off item.
          // Rules that should be followed:
          // 1. All direct sub-items of turned-off item should become indent 0, because the first item after it
          //    will be the first item of a new list. Other items are at the same level, so should have same 0 index.
          // 2. All items with indent lower than indent of turned-off item should become indent 0, because they
          //    should not end up as a child of any of list items that they were not children of before.
          // 3. All other items should have their indent changed relatively to it's parent.
          //
          // For example:
          // 1  * --------
          // 2     * --------
          // 3        * --------			<-- this is turned off.
          // 4           * --------		<-- this has to become indent = 0, because it will be first item on a new list.
          // 5              * --------	<-- this should be still be a child of item above, so indent = 1.
          // 6        * --------			<-- this has to become indent = 0, because it should not be a child of any of items above.
          // 7           * --------		<-- this should be still be a child of item above, so indent = 1.
          // 8     * --------				<-- this has to become indent = 0.
          // 9        * --------			<-- this should still be a child of item above, so indent = 1.
          // 10          * --------		<-- this should still be a child of item above, so indent = 2.
          // 11          * --------		<-- this should still be at the same level as item above, so indent = 2.
          // 12 * --------				<-- this and all below are left unchanged.
          // 13    * --------
          // 14       * --------
          //
          // After turning off 3 the list becomes:
          //
          // 1  * --------
          // 2     * --------
          //
          // 3  --------
          //
          // 4  * --------
          // 5     * --------
          // 6  * --------
          // 7     * --------
          // 8  * --------
          // 9     * --------
          // 10       * --------
          // 11       * --------
          // 12 * --------
          // 13    * --------
          // 14       * --------
          //
          // Thanks to this algorithm no lists are mismatched and no items get unexpected children/parent, while
          // those parent-child connection which are possible to maintain are still maintained. It's worth noting
          // that this is the same effect that we would be get by multiple use of outdent command. However doing
          // it like this is much more efficient because it's less operation (less memory usage, easier OT) and
          // less conversion (faster).

          while (next && next.name == 'listItem' && next.getAttribute('listIndent') !== 0) {
            // Check each next list item, as long as its indent is bigger than 0.
            // If the indent is 0 we are not going to change anything anyway.
            var indent = next.getAttribute('listIndent'); // We check if that's item indent is lower as current relative indent.

            if (indent < currentIndent) {
              // If it is, current relative indent becomes that indent.
              currentIndent = indent;
            } // Fix indent relatively to current relative indent.
            // Note, that if we just changed the current relative indent, the newIndent will be equal to 0.


            var newIndent = indent - currentIndent; // Save the entry in changes array. We do not apply it at the moment, because we will need to
            // reverse the changes so the last item is changed first.
            // This is to keep model in correct state all the time.

            changes.push({
              element: next,
              listIndent: newIndent
            }); // Find next item.

            next = next.nextSibling;
          }

          changes = changes.reverse();

          var _iterator = _createForOfIteratorHelper(changes),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var item = _step.value;
              writer.setAttribute('listIndent', item.listIndent, item.element);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        } // If we are turning on, we might change some items that are already `listItem`s but with different type.
        // Changing one nested list item to other type should also trigger changing all its siblings so the
        // whole nested list is of the same type.
        // Example (assume changing to numbered list):
        // * ------				<-- do not fix, top level item
        //   * ------			<-- fix, because latter list item of this item's list is changed
        //      * ------		<-- do not fix, item is not affected (different list)
        //   * ------			<-- fix, because latter list item of this item's list is changed
        //      * ------		<-- fix, because latter list item of this item's list is changed
        //      * ---[--		<-- already in selection
        //   * ------			<-- already in selection
        //   * ------			<-- already in selection
        // * ------				<-- already in selection, but does not cause other list items to change because is top-level
        //   * ---]--			<-- already in selection
        //   * ------			<-- fix, because preceding list item of this item's list is changed
        //      * ------		<-- do not fix, item is not affected (different list)
        // * ------				<-- do not fix, top level item


        if (!turnOff) {
          // Find lowest indent among selected items. This will be indicator what is the indent of
          // top-most list affected by the command.
          var lowestIndent = Number.POSITIVE_INFINITY;

          var _iterator2 = _createForOfIteratorHelper(blocks),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var _item = _step2.value;

              if (_item.is('listItem') && _item.getAttribute('listIndent') < lowestIndent) {
                lowestIndent = _item.getAttribute('listIndent');
              }
            } // Do not execute the fix for top-level lists.

          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }

          lowestIndent = lowestIndent === 0 ? 1 : lowestIndent; // Fix types of list items that are "before" the selected blocks.

          _fixType(blocks, true, lowestIndent); // Fix types of list items that are "after" the selected blocks.


          _fixType(blocks, false, lowestIndent);
        } // Phew! Now it will be easier :).
        // For each block element that was in the selection, we will either: turn it to list item,
        // turn it to paragraph, or change it's type. Or leave it as it is.
        // Do it in reverse as there might be multiple blocks (same as with changing indents).


        var _iterator3 = _createForOfIteratorHelper(blocks.reverse()),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var element = _step3.value;

            if (turnOff && element.name == 'listItem') {
              // We are turning off and the element is a `listItem` - it should be converted to `paragraph`.
              // List item specific attributes are removed by post fixer.
              writer.rename(element, 'paragraph');
            } else if (!turnOff && element.name != 'listItem') {
              // We are turning on and the element is not a `listItem` - it should be converted to `listItem`.
              // The order of operations is important to keep model in correct state.
              writer.setAttributes({
                listType: _this2.type,
                listIndent: 0
              }, element);
              writer.rename(element, 'listItem');
            } else if (!turnOff && element.name == 'listItem' && element.getAttribute('listType') != _this2.type) {
              // We are turning on and the element is a `listItem` but has different type - change it's type and
              // type of it's all siblings that have same indent.
              writer.setAttribute('listType', _this2.type, element);
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      });
    }
    /**
     * Checks the command's {@link #value}.
     *
     * @private
     * @returns {Boolean} The current value.
     */

  }, {
    key: "_getValue",
    value: function _getValue() {
      // Check whether closest `listItem` ancestor of the position has a correct type.
      var listItem = first_first(this.editor.model.document.selection.getSelectedBlocks());
      return !!listItem && listItem.is('listItem') && listItem.getAttribute('listType') == this.type;
    }
    /**
     * Checks whether the command can be enabled in the current context.
     *
     * @private
     * @returns {Boolean} Whether the command should be enabled.
     */

  }, {
    key: "_checkEnabled",
    value: function _checkEnabled() {
      // If command value is true it means that we are in list item, so the command should be enabled.
      if (this.value) {
        return true;
      }

      var selection = this.editor.model.document.selection;
      var schema = this.editor.model.schema;
      var firstBlock = first_first(selection.getSelectedBlocks());

      if (!firstBlock) {
        return false;
      } // Otherwise, check if list item can be inserted at the position start.


      return checkCanBecomeListItem(firstBlock, schema);
    }
  }]);

  return ListCommand;
}(command_Command); // Helper function used when one or more list item have their type changed. Fixes type of other list items
// that are affected by the change (are in same lists) but are not directly in selection. The function got extracted
// not to duplicated code, as same fix has to be performed before and after selection.
//
// @param {Array.<module:engine/model/node~Node>} blocks Blocks that are in selection.
// @param {Boolean} isBackward Specified whether fix will be applied for blocks before first selected block (`true`)
// or blocks after last selected block (`false`).
// @param {Number} lowestIndent Lowest indent among selected blocks.




function _fixType(blocks, isBackward, lowestIndent) {
  // We need to check previous sibling of first changed item and next siblings of last changed item.
  var startingItem = isBackward ? blocks[0] : blocks[blocks.length - 1];

  if (startingItem.is('listItem')) {
    var item = startingItem[isBackward ? 'previousSibling' : 'nextSibling']; // During processing items, keeps the lowest indent of already processed items.
    // This saves us from changing too many items.
    // Following example is for going forward as it is easier to read, however same applies to going backward.
    // * ------
    //   * ------
    //     * --[---
    //   * ------		<-- `lowestIndent` should be 1
    //     * --]---		<-- `startingItem`, `currentIndent` = 2, `lowestIndent` == 1
    //     * ------		<-- should be fixed, `indent` == 2 == `currentIndent`
    //   * ------		<-- should be fixed, set `currentIndent` to 1, `indent` == 1 == `currentIndent`
    //     * ------		<-- should not be fixed, item is in different list, `indent` = 2, `indent` != `currentIndent`
    //   * ------		<-- should be fixed, `indent` == 1 == `currentIndent`
    // * ------			<-- break loop (`indent` < `lowestIndent`)

    var currentIndent = startingItem.getAttribute('listIndent'); // Look back until a list item with indent lower than reference `lowestIndent`.
    // That would be the parent of nested sublist which contains item having `lowestIndent`.

    while (item && item.is('listItem') && item.getAttribute('listIndent') >= lowestIndent) {
      if (currentIndent > item.getAttribute('listIndent')) {
        currentIndent = item.getAttribute('listIndent');
      } // Found an item that is in the same nested sublist.


      if (item.getAttribute('listIndent') == currentIndent) {
        // Just add the item to selected blocks like it was selected by the user.
        blocks[isBackward ? 'unshift' : 'push'](item);
      }

      item = item[isBackward ? 'previousSibling' : 'nextSibling'];
    }
  }
} // Checks whether the given block can be replaced by a listItem.
//
// @private
// @param {module:engine/model/element~Element} block A block to be tested.
// @param {module:engine/model/schema~Schema} schema The schema of the document.
// @returns {Boolean}


function checkCanBecomeListItem(block, schema) {
  return schema.checkChild(block.parent, 'listItem') && !schema.isObject(block);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-list/src/indentcommand.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module list/indentcommand
 */


/**
 * The list indent command. It is used by the {@link module:list/list~List list feature}.
 *
 * @extends module:core/command~Command
 */

var indentcommand_IndentCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(IndentCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(IndentCommand);

  /**
   * Creates an instance of the command.
   *
   * @param {module:core/editor/editor~Editor} editor The editor instance.
   * @param {'forward'|'backward'} indentDirection The direction of indent. If it is equal to `backward`, the command
   * will outdent a list item.
   */
  function IndentCommand(editor, indentDirection) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, IndentCommand);

    _this = _super.call(this, editor);
    /**
     * Determines by how much the command will change the list item's indent attribute.
     *
     * @readonly
     * @private
     * @member {Number}
     */

    _this._indentBy = indentDirection == 'forward' ? 1 : -1;
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(IndentCommand, [{
    key: "refresh",
    value: function refresh() {
      this.isEnabled = this._checkEnabled();
    }
    /**
     * Indents or outdents (depending on the {@link #constructor}'s `indentDirection` parameter) selected list items.
     *
     * @fires execute
     */

  }, {
    key: "execute",
    value: function execute() {
      var _this2 = this;

      var model = this.editor.model;
      var doc = model.document;
      var itemsToChange = Array.from(doc.selection.getSelectedBlocks());
      model.change(function (writer) {
        var lastItem = itemsToChange[itemsToChange.length - 1]; // Indenting a list item should also indent all the items that are already sub-items of indented item.

        var next = lastItem.nextSibling; // Check all items after last indented item, as long as their indent is bigger than indent of that item.

        while (next && next.name == 'listItem' && next.getAttribute('listIndent') > lastItem.getAttribute('listIndent')) {
          itemsToChange.push(next);
          next = next.nextSibling;
        } // We need to be sure to keep model in correct state after each small change, because converters
        // bases on that state and assumes that model is correct.
        // Because of that, if the command outdents items, we will outdent them starting from the last item, as
        // it is safer.


        if (_this2._indentBy < 0) {
          itemsToChange = itemsToChange.reverse();
        }

        var _iterator = _createForOfIteratorHelper(itemsToChange),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var item = _step.value;

            var indent = item.getAttribute('listIndent') + _this2._indentBy; // If indent is lower than 0, it means that the item got outdented when it was not indented.
            // This means that we need to convert that list item to paragraph.


            if (indent < 0) {
              // To keep the model as correct as possible, first rename listItem, then remove attributes,
              // as listItem without attributes is very incorrect and will cause problems in converters.
              // No need to remove attributes, will be removed by post fixer.
              writer.rename(item, 'paragraph');
            } // If indent is >= 0, change the attribute value.
            else {
                writer.setAttribute('listIndent', indent, item);
              }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      });
    }
    /**
     * Checks whether the command can be enabled in the current context.
     *
     * @private
     * @returns {Boolean} Whether the command should be enabled.
     */

  }, {
    key: "_checkEnabled",
    value: function _checkEnabled() {
      // Check whether any of position's ancestor is a list item.
      var listItem = first_first(this.editor.model.document.selection.getSelectedBlocks()); // If selection is not in a list item, the command is disabled.

      if (!listItem || !listItem.is('listItem')) {
        return false;
      }

      if (this._indentBy > 0) {
        // Cannot indent first item in it's list. Check if before `listItem` is a list item that is in same list.
        // To be in the same list, the item has to have same attributes and cannot be "split" by an item with lower indent.
        var indent = listItem.getAttribute('listIndent');
        var type = listItem.getAttribute('listType');
        var prev = listItem.previousSibling;

        while (prev && prev.is('listItem') && prev.getAttribute('listIndent') >= indent) {
          if (prev.getAttribute('listIndent') == indent) {
            // The item is on the same level.
            // If it has same type, it means that we found a preceding sibling from the same list.
            // If it does not have same type, it means that `listItem` is on different list (this can happen only
            // on top level lists, though).
            return prev.getAttribute('listType') == type;
          }

          prev = prev.previousSibling;
        } // Could not find similar list item, this means that `listItem` is first in its list.


        return false;
      } // If we are outdenting it is enough to be in list item. Every list item can always be outdented.


      return true;
    }
  }]);

  return IndentCommand;
}(command_Command);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-list/src/utils.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module list/utils
 */


/**
 * Creates a list item {@link module:engine/view/containerelement~ContainerElement}.
 *
 * @param {module:engine/view/downcastwriter~DowncastWriter} writer The writer instance.
 * @returns {module:engine/view/containerelement~ContainerElement}
 */

function createViewListItemElement(writer) {
  var viewItem = writer.createContainerElement('li');
  viewItem.getFillerOffset = getListItemFillerOffset;
  return viewItem;
}
/**
 * Helper function that creates a `<ul><li></li></ul>` or (`<ol>`) structure out of the given `modelItem` model `listItem` element.
 * Then, it binds the created view list item (<li>) with the model `listItem` element.
 * The function then returns the created view list item (<li>).
 *
 * @param {module:engine/model/item~Item} modelItem Model list item.
 * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface.
 * @returns {module:engine/view/containerelement~ContainerElement} View list element.
 */

function generateLiInUl(modelItem, conversionApi) {
  var mapper = conversionApi.mapper;
  var viewWriter = conversionApi.writer;
  var listType = modelItem.getAttribute('listType') == 'numbered' ? 'ol' : 'ul';
  var viewItem = createViewListItemElement(viewWriter);
  var viewList = viewWriter.createContainerElement(listType, null);
  viewWriter.insert(viewWriter.createPositionAt(viewList, 0), viewItem);
  mapper.bindElements(modelItem, viewItem);
  return viewItem;
}
/**
 * Helper function that inserts a view list at a correct place and merges it with its siblings.
 * It takes a model list item element (`modelItem`) and a corresponding view list item element (`injectedItem`). The view list item
 * should be in a view list element (`<ul>` or `<ol>`) and should be its only child.
 * See comments below to better understand the algorithm.
 *
 * @param {module:engine/view/item~Item} modelItem Model list item.
 * @param {module:engine/view/containerelement~ContainerElement} injectedItem
 * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface.
 * @param {module:engine/model/model~Model} model The model instance.
 */

function injectViewList(modelItem, injectedItem, conversionApi, model) {
  var injectedList = injectedItem.parent;
  var mapper = conversionApi.mapper;
  var viewWriter = conversionApi.writer; // The position where the view list will be inserted.

  var insertPosition = mapper.toViewPosition(model.createPositionBefore(modelItem)); // 1. Find the previous list item that has the same or smaller indent. Basically we are looking for the first model item
  // that is a "parent" or "sibling" of the injected model item.
  // If there is no such list item, it means that the injected list item is the first item in "its list".

  var refItem = getSiblingListItem(modelItem.previousSibling, {
    sameIndent: true,
    smallerIndent: true,
    listIndent: modelItem.getAttribute('listIndent')
  });
  var prevItem = modelItem.previousSibling;

  if (refItem && refItem.getAttribute('listIndent') == modelItem.getAttribute('listIndent')) {
    // There is a list item with the same indent - we found the same-level sibling.
    // Break the list after it. The inserted view item will be added in the broken space.
    var viewItem = mapper.toViewElement(refItem);
    insertPosition = viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem));
  } else {
    // There is no list item with the same indent. Check the previous model item.
    if (prevItem && prevItem.name == 'listItem') {
      // If it is a list item, it has to have a lower indent.
      // It means that the inserted item should be added to it as its nested item.
      insertPosition = mapper.toViewPosition(model.createPositionAt(prevItem, 'end'));
    } else {
      // The previous item is not a list item (or does not exist at all).
      // Just map the position and insert the view item at the mapped position.
      insertPosition = mapper.toViewPosition(model.createPositionBefore(modelItem));
    }
  }

  insertPosition = positionAfterUiElements(insertPosition); // Insert the view item.

  viewWriter.insert(insertPosition, injectedList); // 2. Handle possible children of the injected model item.

  if (prevItem && prevItem.name == 'listItem') {
    var prevView = mapper.toViewElement(prevItem);
    var walkerBoundaries = viewWriter.createRange(viewWriter.createPositionAt(prevView, 0), insertPosition);
    var walker = walkerBoundaries.getWalker({
      ignoreElementEnd: true
    });

    var _iterator = _createForOfIteratorHelper(walker),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var value = _step.value;

        if (value.item.is('li')) {
          var breakPosition = viewWriter.breakContainer(viewWriter.createPositionBefore(value.item));
          var viewList = value.item.parent;
          var targetPosition = viewWriter.createPositionAt(injectedItem, 'end');
          mergeViewLists(viewWriter, targetPosition.nodeBefore, targetPosition.nodeAfter);
          viewWriter.move(viewWriter.createRangeOn(viewList), targetPosition);
          walker.position = breakPosition;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  } else {
    var nextViewList = injectedList.nextSibling;

    if (nextViewList && (nextViewList.is('ul') || nextViewList.is('ol'))) {
      var lastSubChild = null;

      var _iterator2 = _createForOfIteratorHelper(nextViewList.getChildren()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var child = _step2.value;
          var modelChild = mapper.toModelElement(child);

          if (modelChild && modelChild.getAttribute('listIndent') > modelItem.getAttribute('listIndent')) {
            lastSubChild = child;
          } else {
            break;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      if (lastSubChild) {
        viewWriter.breakContainer(viewWriter.createPositionAfter(lastSubChild));
        viewWriter.move(viewWriter.createRangeOn(lastSubChild.parent), viewWriter.createPositionAt(injectedItem, 'end'));
      }
    }
  } // Merge the inserted view list with its possible neighbor lists.


  mergeViewLists(viewWriter, injectedList, injectedList.nextSibling);
  mergeViewLists(viewWriter, injectedList.previousSibling, injectedList);
}
/**
 * Helper function that takes two parameters that are expected to be view list elements, and merges them.
 * The merge happens only if both parameters are list elements of the same type (the same element name and the same class attributes).
 *
 * @param {module:engine/view/downcastwriter~DowncastWriter} viewWriter The writer instance.
 * @param {module:engine/view/item~Item} firstList The first element to compare.
 * @param {module:engine/view/item~Item} secondList The second element to compare.
 * @returns {module:engine/view/position~Position|null} The position after merge or `null` when there was no merge.
 */

function mergeViewLists(viewWriter, firstList, secondList) {
  // Check if two lists are going to be merged.
  if (!firstList || !secondList || firstList.name != 'ul' && firstList.name != 'ol') {
    return null;
  } // Both parameters are list elements, so compare types now.


  if (firstList.name != secondList.name || firstList.getAttribute('class') !== secondList.getAttribute('class')) {
    return null;
  }

  return viewWriter.mergeContainers(viewWriter.createPositionAfter(firstList));
}
/**
 * Helper function that for a given `view.Position`, returns a `view.Position` that is after all `view.UIElement`s that
 * are after the given position.
 *
 * For example:
 * `<container:p>foo^<ui:span></ui:span><ui:span></ui:span>bar</container:p>`
 * For position ^, the position before "bar" will be returned.
 *
 * @param {module:engine/view/position~Position} viewPosition
 * @returns {module:engine/view/position~Position}
 */

function positionAfterUiElements(viewPosition) {
  return viewPosition.getLastMatchingPosition(function (value) {
    return value.item.is('uiElement');
  });
}
/**
 * Helper function that searches for a previous list item sibling of a given model item that meets the given criteria
 * passed by the options object.
 *
 * @param {module:engine/model/item~Item} modelItem
 * @param {Object} options Search criteria.
 * @param {Boolean} [options.sameIndent=false] Whether the sought sibling should have the same indentation.
 * @param {Boolean} [options.smallerIndent=false] Whether the sought sibling should have a smaller indentation.
 * @param {Number} [options.listIndent] The reference indentation.
 * @returns {module:engine/model/item~Item|null}
 */

function getSiblingListItem(modelItem, options) {
  var sameIndent = !!options.sameIndent;
  var smallerIndent = !!options.smallerIndent;
  var indent = options.listIndent;
  var item = modelItem;

  while (item && item.name == 'listItem') {
    var itemIndent = item.getAttribute('listIndent');

    if (sameIndent && indent == itemIndent || smallerIndent && indent > itemIndent) {
      return item;
    }

    item = item.previousSibling;
  }

  return null;
}
/**
 * Helper method for creating a UI button and linking it with an appropriate command.
 *
 * @private
 * @param {module:core/editor/editor~Editor} editor The editor instance to which the UI component will be added.
 * @param {String} commandName The name of the command.
 * @param {Object} label The button label.
 * @param {String} icon The source of the icon.
 */

function createUIComponent(editor, commandName, label, icon) {
  editor.ui.componentFactory.add(commandName, function (locale) {
    var command = editor.commands.get(commandName);
    var buttonView = new buttonview_ButtonView(locale);
    buttonView.set({
      label: label,
      icon: icon,
      tooltip: true,
      isToggleable: true
    }); // Bind button model to command.

    buttonView.bind('isOn', 'isEnabled').to(command, 'value', 'isEnabled'); // Execute command.

    buttonView.on('execute', function () {
      editor.execute(commandName);
      editor.editing.view.focus();
    });
    return buttonView;
  });
} // Implementation of getFillerOffset for view list item element.
//
// @returns {Number|null} Block filler offset or `null` if block filler is not needed.

function getListItemFillerOffset() {
  var hasOnlyLists = !this.isEmpty && (this.getChild(0).name == 'ul' || this.getChild(0).name == 'ol');

  if (this.isEmpty || hasOnlyLists) {
    return 0;
  }

  return getFillerOffset.call(this);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-list/src/converters.js
















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module list/converters
 */


/**
 * A model-to-view converter for the `listItem` model element insertion.
 *
 * It creates a `<ul><li></li><ul>` (or `<ol>`) view structure out of a `listItem` model element, inserts it at the correct
 * position, and merges the list with surrounding lists (if available).
 *
 * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert
 * @param {module:engine/model/model~Model} model Model instance.
 * @returns {Function} Returns a conversion callback.
 */

function modelViewInsertion(model) {
  return function (evt, data, conversionApi) {
    var consumable = conversionApi.consumable;

    if (!consumable.test(data.item, 'insert') || !consumable.test(data.item, 'attribute:listType') || !consumable.test(data.item, 'attribute:listIndent')) {
      return;
    }

    consumable.consume(data.item, 'insert');
    consumable.consume(data.item, 'attribute:listType');
    consumable.consume(data.item, 'attribute:listIndent');
    var modelItem = data.item;
    var viewItem = generateLiInUl(modelItem, conversionApi);
    injectViewList(modelItem, viewItem, conversionApi, model);
  };
}
/**
 * A model-to-view converter for the `listItem` model element removal.
 *
 * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove
 * @param {module:engine/model/model~Model} model Model instance.
 * @returns {Function} Returns a conversion callback.
 */

function modelViewRemove(model) {
  return function (evt, data, conversionApi) {
    var viewStart = conversionApi.mapper.toViewPosition(data.position).getLastMatchingPosition(function (value) {
      return !value.item.is('li');
    });
    var viewItem = viewStart.nodeAfter;
    var viewWriter = conversionApi.writer; // 1. Break the container after and before the list item.
    // This will create a view list with one view list item - the one to remove.

    viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));
    viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem)); // 2. Remove the list with the item to remove.

    var viewList = viewItem.parent;
    var viewListPrev = viewList.previousSibling;
    var removeRange = viewWriter.createRangeOn(viewList);
    var removed = viewWriter.remove(removeRange); // 3. Merge the whole created by breaking and removing the list.

    if (viewListPrev && viewListPrev.nextSibling) {
      mergeViewLists(viewWriter, viewListPrev, viewListPrev.nextSibling);
    } // 4. Bring back nested list that was in the removed <li>.


    var modelItem = conversionApi.mapper.toModelElement(viewItem);
    hoistNestedLists(modelItem.getAttribute('listIndent') + 1, data.position, removeRange.start, viewItem, conversionApi, model); // 5. Unbind removed view item and all children.

    var _iterator = _createForOfIteratorHelper(viewWriter.createRangeIn(removed).getItems()),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var child = _step.value;
        conversionApi.mapper.unbindViewElement(child);
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }

    evt.stop();
  };
}
/**
 * A model-to-view converter for the `type` attribute change on the `listItem` model element.
 *
 * This change means that the `<li>` element parent changes from `<ul>` to `<ol>` (or vice versa). This is accomplished
 * by breaking view elements and changing their name. The next {@link module:list/converters~modelViewMergeAfterChangeType}
 * converter will attempt to merge split nodes.
 *
 * Splitting this conversion into 2 steps makes it possible to add an additional conversion in the middle.
 * Check {@link module:list/todolistconverters~modelViewChangeType} to see an example of it.
 *
 * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Object} data Additional information about the change.
 * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.
 */

function modelViewChangeType(evt, data, conversionApi) {
  if (!conversionApi.consumable.consume(data.item, 'attribute:listType')) {
    return;
  }

  var viewItem = conversionApi.mapper.toViewElement(data.item);
  var viewWriter = conversionApi.writer; // Break the container after and before the list item.
  // This will create a view list with one view list item -- the one that changed type.

  viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));
  viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem)); // Change name of the view list that holds the changed view item.
  // We cannot just change name property, because that would not render properly.

  var viewList = viewItem.parent;
  var listName = data.attributeNewValue == 'numbered' ? 'ol' : 'ul';
  viewWriter.rename(listName, viewList);
}
/**
 * A model-to-view converter that attempts to merge nodes split by {@link module:list/converters~modelViewChangeType}.
 *
 * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Object} data Additional information about the change.
 * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.
 */

function modelViewMergeAfterChangeType(evt, data, conversionApi) {
  var viewItem = conversionApi.mapper.toViewElement(data.item);
  var viewList = viewItem.parent;
  var viewWriter = conversionApi.writer; // Merge the changed view list with other lists, if possible.

  mergeViewLists(viewWriter, viewList, viewList.nextSibling);
  mergeViewLists(viewWriter, viewList.previousSibling, viewList); // Consumable insertion of children inside the item. They are already handled by re-building the item in view.

  var _iterator2 = _createForOfIteratorHelper(data.item.getChildren()),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var child = _step2.value;
      conversionApi.consumable.consume(child, 'insert');
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
}
/**
 * A model-to-view converter for the `listIndent` attribute change on the `listItem` model element.
 *
 * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:attribute
 * @param {module:engine/model/model~Model} model Model instance.
 * @returns {Function} Returns a conversion callback.
 */

function modelViewChangeIndent(model) {
  return function (evt, data, conversionApi) {
    if (!conversionApi.consumable.consume(data.item, 'attribute:listIndent')) {
      return;
    }

    var viewItem = conversionApi.mapper.toViewElement(data.item);
    var viewWriter = conversionApi.writer; // 1. Break the container after and before the list item.
    // This will create a view list with one view list item -- the one that changed type.

    viewWriter.breakContainer(viewWriter.createPositionBefore(viewItem));
    viewWriter.breakContainer(viewWriter.createPositionAfter(viewItem)); // 2. Extract view list with changed view list item and merge "hole" possibly created by breaking and removing elements.

    var viewList = viewItem.parent;
    var viewListPrev = viewList.previousSibling;
    var removeRange = viewWriter.createRangeOn(viewList);
    viewWriter.remove(removeRange);

    if (viewListPrev && viewListPrev.nextSibling) {
      mergeViewLists(viewWriter, viewListPrev, viewListPrev.nextSibling);
    } // 3. Bring back nested list that was in the removed <li>.


    hoistNestedLists(data.attributeOldValue + 1, data.range.start, removeRange.start, viewItem, conversionApi, model); // 4. Inject view list like it is newly inserted.

    injectViewList(data.item, viewItem, conversionApi, model); // 5. Consume insertion of children inside the item. They are already handled by re-building the item in view.

    var _iterator3 = _createForOfIteratorHelper(data.item.getChildren()),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var child = _step3.value;
        conversionApi.consumable.consume(child, 'insert');
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }
  };
}
/**
 * A special model-to-view converter introduced by the {@link module:list/list~List list feature}. This converter is fired for
 * insert change of every model item, and should be fired before the actual converter. The converter checks whether the inserted
 * model item is a non-`listItem` element. If it is, and it is inserted inside a view list, the converter breaks the
 * list so the model element is inserted to the view parent element corresponding to its model parent element.
 *
 * The converter prevents such situations:
 *
 *		// Model:                        // View:
 *		<listItem>foo</listItem>         <ul>
 *		<listItem>bar</listItem>             <li>foo</li>
 *		                                     <li>bar</li>
 *		                                 </ul>
 *
 *		// After change:                 // Correct view guaranteed by this converter:
 *		<listItem>foo</listItem>         <ul><li>foo</li></ul><p>xxx</p><ul><li>bar</li></ul>
 *		<paragraph>xxx</paragraph>       // Instead of this wrong view state:
 *		<listItem>bar</listItem>         <ul><li>foo</li><p>xxx</p><li>bar</li></ul>
 *
 * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:insert
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Object} data Additional information about the change.
 * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.
 */

function modelViewSplitOnInsert(evt, data, conversionApi) {
  if (data.item.name != 'listItem') {
    var viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
    var viewWriter = conversionApi.writer;
    var lists = []; // Break multiple ULs/OLs if there are.
    //
    // Imagine following list:
    //
    // 1 --------
    //   1.1 --------
    //     1.1.1 --------
    //     1.1.2 --------
    //     1.1.3 --------
    //       1.1.3.1 --------
    //   1.2 --------
    //     1.2.1 --------
    // 2 --------
    //
    // Insert paragraph after item 1.1.1:
    //
    // 1 --------
    //   1.1 --------
    //     1.1.1 --------
    //
    // Lorem ipsum.
    //
    //     1.1.2 --------
    //     1.1.3 --------
    //       1.1.3.1 --------
    //   1.2 --------
    //     1.2.1 --------
    // 2 --------
    //
    // In this case 1.1.2 has to become beginning of a new list.
    // We need to break list before 1.1.2 (obvious), then we need to break list also before 1.2.
    // Then we need to move those broken pieces one after another and merge:
    //
    // 1 --------
    //   1.1 --------
    //     1.1.1 --------
    //
    // Lorem ipsum.
    //
    // 1.1.2 --------
    //   1.1.3 --------
    //     1.1.3.1 --------
    // 1.2 --------
    //   1.2.1 --------
    // 2 --------
    //

    while (viewPosition.parent.name == 'ul' || viewPosition.parent.name == 'ol') {
      viewPosition = viewWriter.breakContainer(viewPosition);

      if (viewPosition.parent.name != 'li') {
        break;
      } // Remove lists that are after inserted element.
      // They will be brought back later, below the inserted element.


      var removeStart = viewPosition;
      var removeEnd = viewWriter.createPositionAt(viewPosition.parent, 'end'); // Don't remove if there is nothing to remove.

      if (!removeStart.isEqual(removeEnd)) {
        var removed = viewWriter.remove(viewWriter.createRange(removeStart, removeEnd));
        lists.push(removed);
      }

      viewPosition = viewWriter.createPositionAfter(viewPosition.parent);
    } // Bring back removed lists.


    if (lists.length > 0) {
      for (var i = 0; i < lists.length; i++) {
        var previousList = viewPosition.nodeBefore;
        var insertedRange = viewWriter.insert(viewPosition, lists[i]);
        viewPosition = insertedRange.end; // Don't merge first list! We want a split in that place (this is why this converter is introduced).

        if (i > 0) {
          var mergePos = mergeViewLists(viewWriter, previousList, previousList.nextSibling); // If `mergePos` is in `previousList` it means that the lists got merged.
          // In this case, we need to fix insert position.

          if (mergePos && mergePos.parent == previousList) {
            viewPosition.offset--;
          }
        }
      } // Merge last inserted list with element after it.


      mergeViewLists(viewWriter, viewPosition.nodeBefore, viewPosition.nodeAfter);
    }
  }
}
/**
 * A special model-to-view converter introduced by the {@link module:list/list~List list feature}. This converter takes care of
 * merging view lists after something is removed or moved from near them.
 *
 * Example:
 *
 *		// Model:                        // View:
 *		<listItem>foo</listItem>         <ul><li>foo</li></ul>
 *		<paragraph>xxx</paragraph>       <p>xxx</p>
 *		<listItem>bar</listItem>         <ul><li>bar</li></ul>
 *
 *		// After change:                 // Correct view guaranteed by this converter:
 *		<listItem>foo</listItem>         <ul>
 *		<listItem>bar</listItem>             <li>foo</li>
 *		                                     <li>bar</li>
 *		                                 </ul>
 *
 * @see module:engine/conversion/downcastdispatcher~DowncastDispatcher#event:remove
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Object} data Additional information about the change.
 * @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi Conversion interface.
 */

function modelViewMergeAfter(evt, data, conversionApi) {
  var viewPosition = conversionApi.mapper.toViewPosition(data.position);
  var viewItemPrev = viewPosition.nodeBefore;
  var viewItemNext = viewPosition.nodeAfter; // Merge lists if something (remove, move) was done from inside of list.
  // Merging will be done only if both items are view lists of the same type.
  // The check is done inside the helper function.

  mergeViewLists(conversionApi.writer, viewItemPrev, viewItemNext);
}
/**
 * A view-to-model converter that converts the `<li>` view elements into the `listItem` model elements.
 *
 * To set correct values of the `listType` and `listIndent` attributes the converter:
 * * checks `<li>`'s parent,
 * * stores and increases the `conversionApi.store.indent` value when `<li>`'s sub-items are converted.
 *
 * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.
 * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.
 */

function viewModelConverter(evt, data, conversionApi) {
  if (conversionApi.consumable.consume(data.viewItem, {
    name: true
  })) {
    var writer = conversionApi.writer; // 1. Create `listItem` model element.

    var listItem = writer.createElement('listItem'); // 2. Handle `listItem` model element attributes.

    var indent = getIndent(data.viewItem);
    writer.setAttribute('listIndent', indent, listItem); // Set 'bulleted' as default. If this item is pasted into a context,

    var type = data.viewItem.parent && data.viewItem.parent.name == 'ol' ? 'numbered' : 'bulleted';
    writer.setAttribute('listType', type, listItem); // Try to find allowed parent for list item.

    var splitResult = conversionApi.splitToAllowedParent(listItem, data.modelCursor); // When there is no allowed parent it means that list item cannot be converted at current model position
    // and in any of position ancestors.

    if (!splitResult) {
      return;
    }

    writer.insert(listItem, splitResult.position);
    var nextPosition = viewToModelListItemChildrenConverter(listItem, data.viewItem.getChildren(), conversionApi); // Result range starts before the first item and ends after the last.

    data.modelRange = writer.createRange(data.modelCursor, nextPosition); // When `data.modelCursor` parent had to be split to insert list item...

    if (splitResult.cursorParent) {
      // Continue conversion in the split element.
      data.modelCursor = writer.createPositionAt(splitResult.cursorParent, 0);
    } else {
      // Otherwise continue conversion after the last list item.
      data.modelCursor = data.modelRange.end;
    }
  }
}
/**
 * A view-to-model converter for the `<ul>` and `<ol>` view elements that cleans the input view of garbage.
 * This is mostly to clean whitespaces from between the `<li>` view elements inside the view list element, however, also
 * incorrect data can be cleared if the view was incorrect.
 *
 * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.
 * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.
 */

function cleanList(evt, data, conversionApi) {
  if (conversionApi.consumable.test(data.viewItem, {
    name: true
  })) {
    // Caching children because when we start removing them iterating fails.
    var children = Array.from(data.viewItem.getChildren());

    for (var _i = 0, _children = children; _i < _children.length; _i++) {
      var child = _children[_i];
      var isWrongElement = !(child.is('li') || isList(child));

      if (isWrongElement) {
        child._remove();
      }
    }
  }
}
/**
 * A view-to-model converter for the `<li>` elements that cleans whitespace formatting from the input view.
 *
 * @see module:engine/conversion/upcastdispatcher~UpcastDispatcher#event:element
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Object} data An object containing conversion input and a placeholder for conversion output and possibly other values.
 * @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.
 */

function cleanListItem(evt, data, conversionApi) {
  if (conversionApi.consumable.test(data.viewItem, {
    name: true
  })) {
    if (data.viewItem.childCount === 0) {
      return;
    }

    var children = _toConsumableArray(data.viewItem.getChildren());

    var foundList = false;
    var firstNode = true;

    var _iterator4 = _createForOfIteratorHelper(children),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var child = _step4.value;

        if (foundList && !isList(child)) {
          child._remove();
        }

        if (child.is('text')) {
          // If this is the first node and it's a text node, left-trim it.
          if (firstNode) {
            child._data = child.data.replace(/^\s+/, '');
          } // If this is the last text node before <ul> or <ol>, right-trim it.


          if (!child.nextSibling || isList(child.nextSibling)) {
            child._data = child.data.replace(/\s+$/, '');
          }
        } else if (isList(child)) {
          // If this is a <ul> or <ol>, do not process it, just mark that we already visited list element.
          foundList = true;
        }

        firstNode = false;
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
  }
}
/**
 * Returns a callback for model position to view position mapping for {@link module:engine/conversion/mapper~Mapper}. The callback fixes
 * positions between the `listItem` elements that would be incorrectly mapped because of how list items are represented in the model
 * and in the view.
 *
 * @see module:engine/conversion/mapper~Mapper#event:modelToViewPosition
 * @param {module:engine/view/view~View} view A view instance.
 * @returns {Function}
 */

function modelToViewPosition(view) {
  return function (evt, data) {
    if (data.isPhantom) {
      return;
    }

    var modelItem = data.modelPosition.nodeBefore;

    if (modelItem && modelItem.is('listItem')) {
      var viewItem = data.mapper.toViewElement(modelItem);
      var topmostViewList = viewItem.getAncestors().find(isList);
      var walker = view.createPositionAt(viewItem, 0).getWalker();

      var _iterator5 = _createForOfIteratorHelper(walker),
          _step5;

      try {
        for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
          var value = _step5.value;

          if (value.type == 'elementStart' && value.item.is('li')) {
            data.viewPosition = value.previousPosition;
            break;
          } else if (value.type == 'elementEnd' && value.item == topmostViewList) {
            data.viewPosition = value.nextPosition;
            break;
          }
        }
      } catch (err) {
        _iterator5.e(err);
      } finally {
        _iterator5.f();
      }
    }
  };
}
/**
 * The callback for view position to model position mapping for {@link module:engine/conversion/mapper~Mapper}. The callback fixes
 * positions between the `<li>` elements that would be incorrectly mapped because of how list items are represented in the model
 * and in the view.
 *
 * @see module:engine/conversion/mapper~Mapper#event:viewToModelPosition
 * @param {module:engine/model/model~Model} model Model instance.
 * @returns {Function} Returns a conversion callback.
 */

function viewToModelPosition(model) {
  return function (evt, data) {
    var viewPos = data.viewPosition;
    var viewParent = viewPos.parent;
    var mapper = data.mapper;

    if (viewParent.name == 'ul' || viewParent.name == 'ol') {
      // Position is directly in <ul> or <ol>.
      if (!viewPos.isAtEnd) {
        // If position is not at the end, it must be before <li>.
        // Get that <li>, map it to `listItem` and set model position before that `listItem`.
        var modelNode = mapper.toModelElement(viewPos.nodeAfter);
        data.modelPosition = model.createPositionBefore(modelNode);
      } else {
        // Position is at the end of <ul> or <ol>, so there is no <li> after it to be mapped.
        // There is <li> before the position, but we cannot just map it to `listItem` and set model position after it,
        // because that <li> may contain nested items.
        // We will check "model length" of that <li>, in other words - how many `listItem`s are in that <li>.
        var _modelNode = mapper.toModelElement(viewPos.nodeBefore);

        var modelLength = mapper.getModelLength(viewPos.nodeBefore); // Then we get model position before mapped `listItem` and shift it accordingly.

        data.modelPosition = model.createPositionBefore(_modelNode).getShiftedBy(modelLength);
      }

      evt.stop();
    } else if (viewParent.name == 'li' && viewPos.nodeBefore && (viewPos.nodeBefore.name == 'ul' || viewPos.nodeBefore.name == 'ol')) {
      // In most cases when view position is in <li> it is in text and this is a correct position.
      // However, if position is after <ul> or <ol> we have to fix it -- because in model <ul>/<ol> are not in the `listItem`.
      var _modelNode2 = mapper.toModelElement(viewParent); // Check all <ul>s and <ol>s that are in the <li> but before mapped position.
      // Get model length of those elements and then add it to the offset of `listItem` mapped to the original <li>.


      var _modelLength = 1; // Starts from 1 because the original <li> has to be counted in too.

      var viewList = viewPos.nodeBefore;

      while (viewList && isList(viewList)) {
        _modelLength += mapper.getModelLength(viewList);
        viewList = viewList.previousSibling;
      }

      data.modelPosition = model.createPositionBefore(_modelNode2).getShiftedBy(_modelLength);
      evt.stop();
    }
  };
}
/**
 * Post-fixer that reacts to changes on document and fixes incorrect model states.
 *
 * In the example below, there is a correct list structure.
 * Then the middle element is removed so the list structure will become incorrect:
 *
 *		<listItem listType="bulleted" listIndent=0>Item 1</listItem>
 *		<listItem listType="bulleted" listIndent=1>Item 2</listItem>   <--- this is removed.
 *		<listItem listType="bulleted" listIndent=2>Item 3</listItem>
 *
 * The list structure after the middle element is removed:
 *
 * 		<listItem listType="bulleted" listIndent=0>Item 1</listItem>
 *		<listItem listType="bulleted" listIndent=2>Item 3</listItem>
 *
 * Should become:
 *
 *		<listItem listType="bulleted" listIndent=0>Item 1</listItem>
 *		<listItem listType="bulleted" listIndent=1>Item 3</listItem>   <--- note that indent got post-fixed.
 *
 * @param {module:engine/model/model~Model} model The data model.
 * @param {module:engine/model/writer~Writer} writer The writer to do changes with.
 * @returns {Boolean} `true` if any change has been applied, `false` otherwise.
 */

function modelChangePostFixer(model, writer) {
  var changes = model.document.differ.getChanges();
  var itemToListHead = new Map();
  var applied = false;

  var _iterator6 = _createForOfIteratorHelper(changes),
      _step6;

  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var entry = _step6.value;

      if (entry.type == 'insert' && entry.name == 'listItem') {
        _addListToFix(entry.position);
      } else if (entry.type == 'insert' && entry.name != 'listItem') {
        if (entry.name != '$text') {
          // In case of renamed element.
          var item = entry.position.nodeAfter;

          if (item.hasAttribute('listIndent')) {
            writer.removeAttribute('listIndent', item);
            applied = true;
          }

          if (item.hasAttribute('listType')) {
            writer.removeAttribute('listType', item);
            applied = true;
          }

          var _iterator8 = _createForOfIteratorHelper(Array.from(model.createRangeIn(item)).filter(function (e) {
            return e.item.is('listItem');
          })),
              _step8;

          try {
            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
              var innerItem = _step8.value;

              _addListToFix(innerItem.previousPosition);
            }
          } catch (err) {
            _iterator8.e(err);
          } finally {
            _iterator8.f();
          }
        }

        var posAfter = entry.position.getShiftedBy(entry.length);

        _addListToFix(posAfter);
      } else if (entry.type == 'remove' && entry.name == 'listItem') {
        _addListToFix(entry.position);
      } else if (entry.type == 'attribute' && entry.attributeKey == 'listIndent') {
        _addListToFix(entry.range.start);
      } else if (entry.type == 'attribute' && entry.attributeKey == 'listType') {
        _addListToFix(entry.range.start);
      }
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  var _iterator7 = _createForOfIteratorHelper(itemToListHead.values()),
      _step7;

  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var listHead = _step7.value;

      _fixListIndents(listHead);

      _fixListTypes(listHead);
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }

  return applied;

  function _addListToFix(position) {
    var previousNode = position.nodeBefore;

    if (!previousNode || !previousNode.is('listItem')) {
      var item = position.nodeAfter;

      if (item && item.is('listItem')) {
        itemToListHead.set(item, item);
      }
    } else {
      var listHead = previousNode;

      if (itemToListHead.has(listHead)) {
        return;
      }

      for ( // Cache previousSibling and reuse for performance reasons. See #6581.
      var previousSibling = listHead.previousSibling; previousSibling && previousSibling.is('listItem'); previousSibling = listHead.previousSibling) {
        listHead = previousSibling;

        if (itemToListHead.has(listHead)) {
          return;
        }
      }

      itemToListHead.set(previousNode, listHead);
    }
  }

  function _fixListIndents(item) {
    var maxIndent = 0;
    var fixBy = null;

    while (item && item.is('listItem')) {
      var itemIndent = item.getAttribute('listIndent');

      if (itemIndent > maxIndent) {
        var newIndent = void 0;

        if (fixBy === null) {
          fixBy = itemIndent - maxIndent;
          newIndent = maxIndent;
        } else {
          if (fixBy > itemIndent) {
            fixBy = itemIndent;
          }

          newIndent = itemIndent - fixBy;
        }

        writer.setAttribute('listIndent', newIndent, item);
        applied = true;
      } else {
        fixBy = null;
        maxIndent = item.getAttribute('listIndent') + 1;
      }

      item = item.nextSibling;
    }
  }

  function _fixListTypes(item) {
    var typesStack = [];
    var prev = null;

    while (item && item.is('listItem')) {
      var itemIndent = item.getAttribute('listIndent');

      if (prev && prev.getAttribute('listIndent') > itemIndent) {
        typesStack = typesStack.slice(0, itemIndent + 1);
      }

      if (itemIndent != 0) {
        if (typesStack[itemIndent]) {
          var type = typesStack[itemIndent];

          if (item.getAttribute('listType') != type) {
            writer.setAttribute('listType', type, item);
            applied = true;
          }
        } else {
          typesStack[itemIndent] = item.getAttribute('listType');
        }
      }

      prev = item;
      item = item.nextSibling;
    }
  }
}
/**
 * A fixer for pasted content that includes list items.
 *
 * It fixes indentation of pasted list items so the pasted items match correctly to the context they are pasted into.
 *
 * Example:
 *
 *		<listItem listType="bulleted" listIndent=0>A</listItem>
 *		<listItem listType="bulleted" listIndent=1>B^</listItem>
 *		// At ^ paste:  <listItem listType="bulleted" listIndent=4>X</listItem>
 *		//              <listItem listType="bulleted" listIndent=5>Y</listItem>
 *		<listItem listType="bulleted" listIndent=2>C</listItem>
 *
 * Should become:
 *
 *		<listItem listType="bulleted" listIndent=0>A</listItem>
 *		<listItem listType="bulleted" listIndent=1>BX</listItem>
 *		<listItem listType="bulleted" listIndent=2>Y/listItem>
 *		<listItem listType="bulleted" listIndent=2>C</listItem>
 *
 * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the fired event.
 * @param {Array} args Arguments of {@link module:engine/model/model~Model#insertContent}.
 */

function modelIndentPasteFixer(evt, _ref) {
  var _ref2 = _slicedToArray(_ref, 2),
      content = _ref2[0],
      selectable = _ref2[1];

  // Check whether inserted content starts from a `listItem`. If it does not, it means that there are some other
  // elements before it and there is no need to fix indents, because even if we insert that content into a list,
  // that list will be broken.
  // Note: we also need to handle singular elements because inserting item with indent 0 into 0,1,[],2
  // would create incorrect model.
  var item = content.is('documentFragment') ? content.getChild(0) : content;
  var selection;

  if (!selectable) {
    selection = this.document.selection;
  } else {
    selection = this.createSelection(selectable);
  }

  if (item && item.is('listItem')) {
    // Get a reference list item. Inserted list items will be fixed according to that item.
    var pos = selection.getFirstPosition();
    var refItem = null;

    if (pos.parent.is('listItem')) {
      refItem = pos.parent;
    } else if (pos.nodeBefore && pos.nodeBefore.is('listItem')) {
      refItem = pos.nodeBefore;
    } // If there is `refItem` it means that we do insert list items into an existing list.


    if (refItem) {
      // First list item in `data` has indent equal to 0 (it is a first list item). It should have indent equal
      // to the indent of reference item. We have to fix the first item and all of it's children and following siblings.
      // Indent of all those items has to be adjusted to reference item.
      var indentChange = refItem.getAttribute('listIndent'); // Fix only if there is anything to fix.

      if (indentChange > 0) {
        // Adjust indent of all "first" list items in inserted data.
        while (item && item.is('listItem')) {
          item._setAttribute('listIndent', item.getAttribute('listIndent') + indentChange);

          item = item.nextSibling;
        }
      }
    }
  }
} // Helper function that converts children of a given `<li>` view element into corresponding model elements.
// The function maintains proper order of elements if model `listItem` is split during the conversion
// due to block children conversion.
//
// @param {module:engine/model/element~Element} listItemModel List item model element to which converted children will be inserted.
// @param {Iterable.<module:engine/view/node~Node>} viewChildren View elements which will be converted.
// @param {module:engine/conversion/upcastdispatcher~UpcastConversionApi} conversionApi Conversion interface to be used by the callback.
// @returns {module:engine/model/position~Position} Position on which next elements should be inserted after children conversion.

function viewToModelListItemChildrenConverter(listItemModel, viewChildren, conversionApi) {
  var writer = conversionApi.writer,
      schema = conversionApi.schema; // A position after the last inserted `listItem`.

  var nextPosition = writer.createPositionAfter(listItemModel); // Check all children of the converted `<li>`. At this point we assume there are no "whitespace" view text nodes
  // in view list, between view list items. This should be handled by `<ul>` and `<ol>` converters.

  var _iterator9 = _createForOfIteratorHelper(viewChildren),
      _step9;

  try {
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      var child = _step9.value;

      if (child.name == 'ul' || child.name == 'ol') {
        // If the children is a list, we will insert its conversion result after currently handled `listItem`.
        // Then, next insertion position will be set after all the new list items (and maybe other elements if
        // something split list item).
        //
        // If this is a list, we expect that some `listItem`s and possibly other blocks will be inserted, however `.modelCursor`
        // should be set after last `listItem` (or block). This is why it feels safe to use it as `nextPosition`
        nextPosition = conversionApi.convertItem(child, nextPosition).modelCursor;
      } else {
        // If this is not a list, try inserting content at the end of the currently handled `listItem`.
        var result = conversionApi.convertItem(child, writer.createPositionAt(listItemModel, 'end')); // It may end up that the current `listItem` becomes split (if that content cannot be inside `listItem`). For example:
        //
        // <li><p>Foo</p></li>
        //
        // will be converted to:
        //
        // <listItem></listItem><paragraph>Foo</paragraph><listItem></listItem>
        //

        var convertedChild = result.modelRange.start.nodeAfter;
        var wasSplit = convertedChild && convertedChild.is('element') && !schema.checkChild(listItemModel, convertedChild.name);

        if (wasSplit) {
          // As `lastListItem` got split, we need to update it to the second part of the split `listItem` element.
          //
          // `modelCursor` should be set to a position where the conversion should continue. There are multiple possible scenarios
          // that may happen. Usually, `modelCursor` (marked as `#` below) would point to the second list item after conversion:
          //
          //		`<li><p>Foo</p></li>` -> `<listItem></listItem><paragraph>Foo</paragraph><listItem>#</listItem>`
          //
          // However, in some cases, like auto-paragraphing, the position is placed at the end of the block element:
          //
          //		`<li><div>Foo</div></li>` -> `<listItem></listItem><paragraph>Foo#</paragraph><listItem></listItem>`
          //
          // or after an element if another element broken auto-paragraphed element:
          //
          //		`<li><div><h2>Foo</h2></div></li>` -> `<listItem></listItem><heading1>Foo</heading1>#<listItem></listItem>`
          //
          // We need to check for such cases and use proper list item and position based on it.
          //
          if (result.modelCursor.parent.is('listItem')) {
            // (1).
            listItemModel = result.modelCursor.parent;
          } else {
            // (2), (3).
            listItemModel = findNextListItem(result.modelCursor);
          }

          nextPosition = writer.createPositionAfter(listItemModel);
        }
      }
    }
  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }

  return nextPosition;
} // Helper function that seeks for a next list item starting from given `startPosition`.


function findNextListItem(startPosition) {
  var treeWalker = new model_treewalker_TreeWalker({
    startPosition: startPosition
  });
  var value;

  do {
    value = treeWalker.next();
  } while (!value.value.item.is('listItem'));

  return value.value.item;
} // Helper function that takes all children of given `viewRemovedItem` and moves them in a correct place, according
// to other given parameters.


function hoistNestedLists(nextIndent, modelRemoveStartPosition, viewRemoveStartPosition, viewRemovedItem, conversionApi, model) {
  // Find correct previous model list item element.
  // The element has to have either same or smaller indent than given reference indent.
  // This will be the model element which will get nested items (if it has smaller indent) or sibling items (if it has same indent).
  // Keep in mind that such element might not be found, if removed item was the first item.
  var prevModelItem = getSiblingListItem(modelRemoveStartPosition.nodeBefore, {
    sameIndent: true,
    smallerIndent: true,
    listIndent: nextIndent,
    foo: 'b'
  });
  var mapper = conversionApi.mapper;
  var viewWriter = conversionApi.writer; // Indent of found element or `null` if the element has not been found.

  var prevIndent = prevModelItem ? prevModelItem.getAttribute('listIndent') : null;
  var insertPosition;

  if (!prevModelItem) {
    // If element has not been found, simply insert lists at the position where the removed item was:
    //
    // Lorem ipsum.
    // 1 --------           <--- this is removed, no previous list item, put nested items in place of removed item.
    //   1.1 --------       <--- this is reference indent.
    //     1.1.1 --------
    //     1.1.2 --------
    //   1.2 --------
    //
    // Becomes:
    //
    // Lorem ipsum.
    // 1.1 --------
    //   1.1.1 --------
    //   1.1.2 --------
    // 1.2 --------
    insertPosition = viewRemoveStartPosition;
  } else if (prevIndent == nextIndent) {
    // If element has been found and has same indent as reference indent it means that nested items should
    // become siblings of found element:
    //
    // 1 --------
    //   1.1 --------
    //   1.2 --------       <--- this is `prevModelItem`.
    // 2 --------           <--- this is removed, previous list item has indent same as reference indent.
    //   2.1 --------       <--- this is reference indent, this and 2.2 should become siblings of 1.2.
    //   2.2 --------
    //
    // Becomes:
    //
    // 1 --------
    //   1.1 --------
    //   1.2 --------
    //   2.1 --------
    //   2.2 --------
    var prevViewList = mapper.toViewElement(prevModelItem).parent;
    insertPosition = viewWriter.createPositionAfter(prevViewList);
  } else {
    // If element has been found and has smaller indent as reference indent it means that nested items
    // should become nested items of found item:
    //
    // 1 --------           <--- this is `prevModelItem`.
    //   1.1 --------       <--- this is removed, previous list item has indent smaller than reference indent.
    //     1.1.1 --------   <--- this is reference indent, this and 1.1.1 should become nested items of 1.
    //     1.1.2 --------
    //   1.2 --------
    //
    // Becomes:
    //
    // 1 --------
    //   1.1.1 --------
    //   1.1.2 --------
    //   1.2 --------
    //
    // Note: in this case 1.1.1 have indent 2 while 1 have indent 0. In model that should not be possible,
    // because following item may have indent bigger only by one. But this is fixed by postfixer.
    var modelPosition = model.createPositionAt(prevModelItem, 'end');
    insertPosition = mapper.toViewPosition(modelPosition);
  }

  insertPosition = positionAfterUiElements(insertPosition); // Handle multiple lists. This happens if list item has nested numbered and bulleted lists. Following lists
  // are inserted after the first list (no need to recalculate insertion position for them).

  for (var _i2 = 0, _arr = _toConsumableArray(viewRemovedItem.getChildren()); _i2 < _arr.length; _i2++) {
    var child = _arr[_i2];

    if (isList(child)) {
      insertPosition = viewWriter.move(viewWriter.createRangeOn(child), insertPosition).end;
      mergeViewLists(viewWriter, child, child.nextSibling);
      mergeViewLists(viewWriter, child.previousSibling, child);
    }
  }
} // Checks if view element is a list type (ul or ol).
//
// @param {module:engine/view/element~Element} viewElement
// @returns {Boolean}


function isList(viewElement) {
  return viewElement.is('ol') || viewElement.is('ul');
} // Calculates the indent value for a list item. Handles HTML compliant and non-compliant lists.
//
// Also, fixes non HTML compliant lists indents:
//
//		before:                                     fixed list:
//		OL                                          OL
//		|-> LI (parent LIs: 0)                      |-> LI     (indent: 0)
//		    |-> OL                                  |-> OL
//		        |-> OL                                  |
//		        |   |-> OL                              |
//		        |       |-> OL                          |
//		        |           |-> LI (parent LIs: 1)      |-> LI (indent: 1)
//		        |-> LI (parent LIs: 1)                  |-> LI (indent: 1)
//
//		before:                                     fixed list:
//		OL                                          OL
//		|-> OL                                      |
//		    |-> OL                                  |
//		         |-> OL                             |
//		             |-> LI (parent LIs: 0)         |-> LI        (indent: 0)
//
//		before:                                     fixed list:
//		OL                                          OL
//		|-> LI (parent LIs: 0)                      |-> LI         (indent: 0)
//		|-> OL                                          |-> OL
//		    |-> LI (parent LIs: 0)                          |-> LI (indent: 1)
//
// @param {module:engine/view/element~Element} listItem
// @param {Object} conversionStore
// @returns {Number}


function getIndent(listItem) {
  var indent = 0;
  var parent = listItem.parent;

  while (parent) {
    // Each LI in the tree will result in an increased indent for HTML compliant lists.
    if (parent.is('li')) {
      indent++;
    } else {
      // If however the list is nested in other list we should check previous sibling of any of the list elements...
      var previousSibling = parent.previousSibling; // ...because the we might need increase its indent:
      //		before:                           fixed list:
      //		OL                                OL
      //		|-> LI (parent LIs: 0)            |-> LI         (indent: 0)
      //		|-> OL                                |-> OL
      //		    |-> LI (parent LIs: 0)                |-> LI (indent: 1)

      if (previousSibling && previousSibling.is('li')) {
        indent++;
      }
    }

    parent = parent.parent;
  }

  return indent;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-list/src/listediting.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module list/listediting
 */





/**
 * The engine of the list feature. It handles creating, editing and removing lists and list items.
 *
 * It registers the `'numberedList'`, `'bulletedList'`, `'indentList'` and `'outdentList'` commands.
 *
 * @extends module:core/plugin~Plugin
 */

var listediting_ListEditing = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ListEditing, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ListEditing);

  function ListEditing() {
    Object(classCallCheck["a" /* default */])(this, ListEditing);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ListEditing, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this = this;

      var editor = this.editor; // Schema.
      // Note: in case `$block` will ever be allowed in `listItem`, keep in mind that this feature
      // uses `Selection#getSelectedBlocks()` without any additional processing to obtain all selected list items.
      // If there are blocks allowed inside list item, algorithms using `getSelectedBlocks()` will have to be modified.

      editor.model.schema.register('listItem', {
        inheritAllFrom: '$block',
        allowAttributes: ['listType', 'listIndent']
      }); // Converters.

      var data = editor.data;
      var editing = editor.editing;
      editor.model.document.registerPostFixer(function (writer) {
        return modelChangePostFixer(editor.model, writer);
      });
      editing.mapper.registerViewToModelLength('li', getViewListItemLength);
      data.mapper.registerViewToModelLength('li', getViewListItemLength);
      editing.mapper.on('modelToViewPosition', modelToViewPosition(editing.view));
      editing.mapper.on('viewToModelPosition', viewToModelPosition(editor.model));
      data.mapper.on('modelToViewPosition', modelToViewPosition(editing.view));
      editor.conversion.for('editingDowncast').add(function (dispatcher) {
        dispatcher.on('insert', modelViewSplitOnInsert, {
          priority: 'high'
        });
        dispatcher.on('insert:listItem', modelViewInsertion(editor.model));
        dispatcher.on('attribute:listType:listItem', modelViewChangeType, {
          priority: 'high'
        });
        dispatcher.on('attribute:listType:listItem', modelViewMergeAfterChangeType, {
          priority: 'low'
        });
        dispatcher.on('attribute:listIndent:listItem', modelViewChangeIndent(editor.model));
        dispatcher.on('remove:listItem', modelViewRemove(editor.model));
        dispatcher.on('remove', modelViewMergeAfter, {
          priority: 'low'
        });
      });
      editor.conversion.for('dataDowncast').add(function (dispatcher) {
        dispatcher.on('insert', modelViewSplitOnInsert, {
          priority: 'high'
        });
        dispatcher.on('insert:listItem', modelViewInsertion(editor.model));
      });
      editor.conversion.for('upcast').add(function (dispatcher) {
        dispatcher.on('element:ul', cleanList, {
          priority: 'high'
        });
        dispatcher.on('element:ol', cleanList, {
          priority: 'high'
        });
        dispatcher.on('element:li', cleanListItem, {
          priority: 'high'
        });
        dispatcher.on('element:li', viewModelConverter);
      }); // Fix indentation of pasted items.

      editor.model.on('insertContent', modelIndentPasteFixer, {
        priority: 'high'
      }); // Register commands for numbered and bulleted list.

      editor.commands.add('numberedList', new listcommand_ListCommand(editor, 'numbered'));
      editor.commands.add('bulletedList', new listcommand_ListCommand(editor, 'bulleted')); // Register commands for indenting.

      editor.commands.add('indentList', new indentcommand_IndentCommand(editor, 'forward'));
      editor.commands.add('outdentList', new indentcommand_IndentCommand(editor, 'backward'));
      var viewDocument = editing.view.document; // Overwrite default Enter key behavior.
      // If Enter key is pressed with selection collapsed in empty list item, outdent it instead of breaking it.

      this.listenTo(viewDocument, 'enter', function (evt, data) {
        var doc = _this.editor.model.document;
        var positionParent = doc.selection.getLastPosition().parent;

        if (doc.selection.isCollapsed && positionParent.name == 'listItem' && positionParent.isEmpty) {
          _this.editor.execute('outdentList');

          data.preventDefault();
          evt.stop();
        }
      }); // Overwrite default Backspace key behavior.
      // If Backspace key is pressed with selection collapsed on first position in first list item, outdent it. #83

      this.listenTo(viewDocument, 'delete', function (evt, data) {
        // Check conditions from those that require less computations like those immediately available.
        if (data.direction !== 'backward') {
          return;
        }

        var selection = _this.editor.model.document.selection;

        if (!selection.isCollapsed) {
          return;
        }

        var firstPosition = selection.getFirstPosition();

        if (!firstPosition.isAtStart) {
          return;
        }

        var positionParent = firstPosition.parent;

        if (positionParent.name !== 'listItem') {
          return;
        }

        var previousIsAListItem = positionParent.previousSibling && positionParent.previousSibling.name === 'listItem';

        if (previousIsAListItem) {
          return;
        }

        _this.editor.execute('outdentList');

        data.preventDefault();
        evt.stop();
      }, {
        priority: 'high'
      });

      var getCommandExecuter = function getCommandExecuter(commandName) {
        return function (data, cancel) {
          var command = _this.editor.commands.get(commandName);

          if (command.isEnabled) {
            _this.editor.execute(commandName);

            cancel();
          }
        };
      };

      editor.keystrokes.set('Tab', getCommandExecuter('indentList'));
      editor.keystrokes.set('Shift+Tab', getCommandExecuter('outdentList'));
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "afterInit",
    value: function afterInit() {
      var commands = this.editor.commands;
      var indent = commands.get('indent');
      var outdent = commands.get('outdent');

      if (indent) {
        indent.registerChildCommand(commands.get('indentList'));
      }

      if (outdent) {
        outdent.registerChildCommand(commands.get('outdentList'));
      }
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'ListEditing';
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "requires",
    get: function get() {
      return [paragraph_Paragraph];
    }
  }]);

  return ListEditing;
}(plugin_Plugin);



function getViewListItemLength(element) {
  var length = 1;

  var _iterator = _createForOfIteratorHelper(element.getChildren()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var child = _step.value;

      if (child.name == 'ul' || child.name == 'ol') {
        var _iterator2 = _createForOfIteratorHelper(child.getChildren()),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var item = _step2.value;
            length += getViewListItemLength(item);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return length;
}
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-list/theme/icons/numberedlist.svg
var numberedlist = __webpack_require__("dde1");
var numberedlist_default = /*#__PURE__*/__webpack_require__.n(numberedlist);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-list/theme/icons/bulletedlist.svg
var bulletedlist = __webpack_require__("7eec");
var bulletedlist_default = /*#__PURE__*/__webpack_require__.n(bulletedlist);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-list/src/listui.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module list/listui
 */




/**
 * The list UI feature. It introduces the `'numberedList'` and `'bulletedList'` buttons that
 * allow to convert paragraphs to and from list items and indent or outdent them.
 *
 * @extends module:core/plugin~Plugin
 */

var listui_ListUI = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ListUI, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ListUI);

  function ListUI() {
    Object(classCallCheck["a" /* default */])(this, ListUI);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(ListUI, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var t = this.editor.t; // Create two buttons and link them with numberedList and bulletedList commands.

      createUIComponent(this.editor, 'numberedList', t('Numbered List'), numberedlist_default.a);
      createUIComponent(this.editor, 'bulletedList', t('Bulleted List'), bulletedlist_default.a);
    }
  }]);

  return ListUI;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-list/src/list.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module list/list
 */



/**
 * The list feature.
 *
 * This is a "glue" plugin that loads the {@link module:list/listediting~ListEditing list editing feature}
 * and {@link module:list/listui~ListUI list UI feature}.
 *
 * @extends module:core/plugin~Plugin
 */

var list_List = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(List, _Plugin);

  var _super = Object(createSuper["a" /* default */])(List);

  function List() {
    Object(classCallCheck["a" /* default */])(this, List);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(List, null, [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [listediting_ListEditing, listui_ListUI];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'List';
    }
  }]);

  return List;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/removeboldwrapper.js


/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module paste-from-office/filters/removeboldwrapper
 */

/**
 * Removes `<b>` tag wrapper added by Google Docs to a copied content.
 *
 * @param {module:engine/view/documentfragment~DocumentFragment} documentFragment element `data.content` obtained from clipboard
 * @param {module:engine/view/upcastwriter~UpcastWriter} writer
 */
function removeBoldWrapper(documentFragment, writer) {
  var _iterator = _createForOfIteratorHelper(documentFragment.getChildren()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var child = _step.value;

      if (child.is('b') && child.getStyle('font-weight') === 'normal') {
        var childIndex = documentFragment.getChildIndex(child);
        writer.remove(child);
        writer.insertChild(childIndex, child.getChildren(), documentFragment);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/list.js











/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module paste-from-office/filters/list
 */


/**
 * Transforms Word specific list-like elements to the semantic HTML lists.
 *
 * Lists in Word are represented by block elements with special attributes like:
 *
 *		<p class=MsoListParagraphCxSpFirst style='mso-list:l1 level1 lfo1'>...</p> // Paragraph based list.
 *		<h1 style='mso-list:l0 level1 lfo1'>...</h1> // Heading 1 based list.
 *
 * @param {module:engine/view/documentfragment~DocumentFragment} documentFragment The view structure to be transformed.
 * @param {String} stylesString Styles from which list-like elements styling will be extracted.
 */

function transformListItemLikeElementsIntoLists(documentFragment, stylesString) {
  if (!documentFragment.childCount) {
    return;
  }

  var writer = new upcastwriter_UpcastWriter(documentFragment.document);
  var itemLikeElements = findAllItemLikeElements(documentFragment, writer);

  if (!itemLikeElements.length) {
    return;
  }

  var currentList = null;
  var currentIndentation = 1;
  itemLikeElements.forEach(function (itemLikeElement, i) {
    var isDifferentList = isNewListNeeded(itemLikeElements[i - 1], itemLikeElement);
    var previousItemLikeElement = isDifferentList ? null : itemLikeElements[i - 1];
    var indentationDifference = getIndentationDifference(previousItemLikeElement, itemLikeElement);

    if (isDifferentList) {
      currentList = null;
      currentIndentation = 1;
    }

    if (!currentList || indentationDifference !== 0) {
      var listStyle = detectListStyle(itemLikeElement, stylesString);

      if (!currentList) {
        currentList = insertNewEmptyList(listStyle, itemLikeElement.element, writer);
      } else if (itemLikeElement.indent > currentIndentation) {
        var lastListItem = currentList.getChild(currentList.childCount - 1);
        var lastListItemChild = lastListItem.getChild(lastListItem.childCount - 1);
        currentList = insertNewEmptyList(listStyle, lastListItemChild, writer);
        currentIndentation += 1;
      } else if (itemLikeElement.indent < currentIndentation) {
        var differentIndentation = currentIndentation - itemLikeElement.indent;
        currentList = findParentListAtLevel(currentList, differentIndentation);
        currentIndentation = parseInt(itemLikeElement.indent);
      }

      if (itemLikeElement.indent <= currentIndentation) {
        if (!currentList.is(listStyle.type)) {
          currentList = writer.rename(listStyle.type, currentList);
        }
      }
    }

    var listItem = transformElementIntoListItem(itemLikeElement.element, writer);
    writer.appendChild(listItem, currentList);
  });
}
/**
 * Removes paragraph wrapping content inside a list item.
 *
 * @param {module:engine/view/documentfragment~DocumentFragment} documentFragment
 * @param {module:engine/view/upcastwriter~UpcastWriter} writer
 */

function unwrapParagraphInListItem(documentFragment, writer) {
  var _iterator = _createForOfIteratorHelper(writer.createRangeIn(documentFragment)),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var value = _step.value;
      var element = value.item;

      if (element.is('li')) {
        // Google Docs allows on single paragraph inside LI.
        var firstChild = element.getChild(0);

        if (firstChild.is('p')) {
          writer.unwrapElement(firstChild);
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
} // Finds all list-like elements in a given document fragment.
//
// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment
// in which to look for list-like nodes.
// @param {module:engine/view/upcastwriter~UpcastWriter} writer
// @returns {Array.<Object>} Array of found list-like items. Each item is an object containing:
//
//		* {module:engine/src/view/element~Element} element List-like element.
//		* {Number} id List item id parsed from `mso-list` style (see `getListItemData()` function).
//		* {Number} order List item creation order parsed from `mso-list` style (see `getListItemData()` function).
//		* {Number} indent List item indentation level parsed from `mso-list` style (see `getListItemData()` function).

function findAllItemLikeElements(documentFragment, writer) {
  var range = writer.createRangeIn(documentFragment); // Matcher for finding list-like elements.

  var itemLikeElementsMatcher = new matcher_Matcher({
    name: /^p|h\d+$/,
    styles: {
      'mso-list': /.*/
    }
  });
  var itemLikeElements = [];

  var _iterator2 = _createForOfIteratorHelper(range),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var value = _step2.value;

      if (value.type === 'elementStart' && itemLikeElementsMatcher.match(value.item)) {
        var itemData = getListItemData(value.item);
        itemLikeElements.push({
          element: value.item,
          id: itemData.id,
          order: itemData.order,
          indent: itemData.indent
        });
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return itemLikeElements;
} // Extracts list item style from the provided CSS.
//
// List item style is extracted from CSS stylesheet. Each list with its specific style attribute
// value (`mso-list:l1 level1 lfo1`) has its dedicated properties in a CSS stylesheet defined with a selector like:
//
// 		@list l1:level1 { ... }
//
// It contains `mso-level-number-format` property which defines list numbering/bullet style. If this property
// is not defined it means default `decimal` numbering.
//
// Here CSS string representation is used as `mso-level-number-format` property is an invalid CSS property
// and will be removed during CSS parsing.
//
// @param {Object} listLikeItem List-like item for which list style will be searched for. Usually
// a result of `findAllItemLikeElements()` function.
// @param {String} stylesString CSS stylesheet.
// @returns {Object} result
// @returns {String} result.type List type, could be `ul` or `ol`.
// @returns {String} result.style List style, for example: `decimal`, `lower-roman`, etc. It is extracted
// directly from Word stylesheet without further processing and may be not compatible
// with CSS `list-style-type` property accepted values.


function detectListStyle(listLikeItem, stylesString) {
  var listStyleRegexp = new RegExp("@list l".concat(listLikeItem.id, ":level").concat(listLikeItem.indent, "\\s*({[^}]*)"), 'gi');
  var listStyleTypeRegex = /mso-level-number-format:([^;]*);/gi;
  var listStyleMatch = listStyleRegexp.exec(stylesString);
  var listStyleType = 'decimal'; // Decimal is default one.

  if (listStyleMatch && listStyleMatch[1]) {
    var listStyleTypeMatch = listStyleTypeRegex.exec(listStyleMatch[1]);

    if (listStyleTypeMatch && listStyleTypeMatch[1]) {
      listStyleType = listStyleTypeMatch[1].trim();
    }
  }

  return {
    type: listStyleType !== 'bullet' && listStyleType !== 'image' ? 'ol' : 'ul',
    style: listStyleType
  };
} // Creates empty list of a given type and inserts it after a specified element.
//
// @param {Object} listStyle List style object which determines the type of newly created list.
// Usually a result of `detectListStyle()` function.
// @param {module:engine/view/element~Element} element Element after which list is inserted.
// @param {module:engine/view/upcastwriter~UpcastWriter} writer
// @returns {module:engine/view/element~Element} Newly created list element.


function insertNewEmptyList(listStyle, element, writer) {
  var parent = element.parent;
  var list = writer.createElement(listStyle.type);
  var position = parent.getChildIndex(element) + 1;
  writer.insertChild(position, list, parent);
  return list;
} // Transforms given element into a semantic list item. As the function operates on a provided
// {module:engine/src/view/element~Element element} it will modify the view structure to which this element belongs.
//
// @param {module:engine/view/element~Element} element Element which will be transformed into list item.
// @param {module:engine/view/upcastwriter~UpcastWriter} writer
// @returns {module:engine/view/element~Element} New element to which the given one was transformed. It is
// inserted in place of the old element (the reference to the old element is lost due to renaming).


function transformElementIntoListItem(element, writer) {
  removeBulletElement(element, writer);
  return writer.rename('li', element);
} // Extracts list item information from Word specific list-like element style:
//
//		`style="mso-list:l1 level1 lfo1"`
//
// where:
//
//		* `l1` is a list id (however it does not mean this is a continuous list - see #43),
//		* `level1` is a list item indentation level,
//		* `lfo1` is a list insertion order in a document.
//
// @param {module:engine/view/element~Element} element Element from which style data is extracted.
// @returns {Object} result
// @returns {Number} result.id Parent list id.
// @returns {Number} result.order List item creation order.
// @returns {Number} result.indent List item indentation level.


function getListItemData(element) {
  var data = {};
  var listStyle = element.getStyle('mso-list');

  if (listStyle) {
    var idMatch = listStyle.match(/(^|\s+)l(\d+)/i);
    var orderMatch = listStyle.match(/\s*lfo(\d+)/i);
    var indentMatch = listStyle.match(/\s*level(\d+)/i);

    if (idMatch && orderMatch && indentMatch) {
      data.id = idMatch[2];
      data.order = orderMatch[1];
      data.indent = indentMatch[1];
    }
  }

  return data;
} // Removes span with a numbering/bullet from a given element.
//
// @param {module:engine/view/element~Element} element
// @param {module:engine/view/upcastwriter~UpcastWriter} writer


function removeBulletElement(element, writer) {
  // Matcher for finding `span` elements holding lists numbering/bullets.
  var bulletMatcher = new matcher_Matcher({
    name: 'span',
    styles: {
      'mso-list': 'Ignore'
    }
  });
  var range = writer.createRangeIn(element);

  var _iterator3 = _createForOfIteratorHelper(range),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var value = _step3.value;

      if (value.type === 'elementStart' && bulletMatcher.match(value.item)) {
        writer.remove(value.item);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }
} // Whether previous and current item belongs to the same list. It is determined based on `item.id`
// (extracted from `mso-list` style, see #getListItemData) and previous sibling of the current item.
//
// @param {Object} previousItem
// @param {Object} currentItem
// @returns {Boolean}


function isNewListNeeded(previousItem, currentItem) {
  if (!previousItem) {
    return true;
  }

  if (previousItem.id !== currentItem.id) {
    return true;
  }

  var previousSibling = currentItem.element.previousSibling;

  if (!previousSibling) {
    return true;
  } // Even with the same id the list does not have to be continuous (#43).


  return !list_isList(previousSibling);
}

function list_isList(element) {
  return element.is('ol') || element.is('ul');
} // Calculates the indentation difference between two given list items (based on indent attribute
// extracted from `mso-list` style, see #getListItemData).
//
// @param {Object} previousItem
// @param {Object} currentItem
// @returns {Number}


function getIndentationDifference(previousItem, currentItem) {
  return previousItem ? currentItem.indent - previousItem.indent : currentItem.indent - 1;
} // Finds parent list element (ul/ol) of a given list element with indentation level lower by a given value.
//
// @param {module:engine/view/element~Element} listElement List element from which to start looking for a parent list.
// @param {Number} indentationDifference Indentation difference between lists.
// @returns {module:engine/view/element~Element} Found list element with indentation level lower by a given value.


function findParentListAtLevel(listElement, indentationDifference) {
  var ancestors = listElement.getAncestors({
    parentFirst: true
  });
  var parentList = null;
  var levelChange = 0;

  var _iterator4 = _createForOfIteratorHelper(ancestors),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var ancestor = _step4.value;

      if (ancestor.name === 'ul' || ancestor.name === 'ol') {
        levelChange++;
      }

      if (levelChange === indentationDifference) {
        parentList = ancestor;
        break;
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return parentList;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-paste-from-office/src/normalizers/googledocsnormalizer.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module paste-from-office/normalizers/googledocsnormalizer
 */



var googleDocsMatch = /id=("|')docs-internal-guid-[-0-9a-f]+("|')/i;
/**
 * Normalizer for the content pasted from Google Docs.
 *
 * @implements module:paste-from-office/normalizer~Normalizer
 */

var googledocsnormalizer_GoogleDocsNormalizer = /*#__PURE__*/function () {
  /**
   * Creates a new `GoogleDocsNormalizer` instance.
   *
   * @param {module:engine/view/document~Document} document View document.
   */
  function GoogleDocsNormalizer(document) {
    Object(classCallCheck["a" /* default */])(this, GoogleDocsNormalizer);

    /**
     * @readonly
     * @type {module:engine/view/document~Document}
     */
    this.document = document;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(GoogleDocsNormalizer, [{
    key: "isActive",
    value: function isActive(htmlString) {
      return googleDocsMatch.test(htmlString);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "execute",
    value: function execute(data) {
      var writer = new upcastwriter_UpcastWriter(this.document);
      removeBoldWrapper(data.content, writer);
      unwrapParagraphInListItem(data.content, writer);
    }
  }]);

  return GoogleDocsNormalizer;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/space.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module paste-from-office/filters/space
 */

/**
 * Replaces last space preceding elements closing tag with `&nbsp;`. Such operation prevents spaces from being removed
 * during further DOM/View processing (see especially {@link module:engine/view/domconverter~DomConverter#_processDataFromDomText}).
 * This method also takes into account Word specific `<o:p></o:p>` empty tags.
 * Additionally multiline sequences of spaces and new lines between tags are removed (see #39 and #40).
 *
 * @param {String} htmlString HTML string in which spacing should be normalized.
 * @returns {String} Input HTML with spaces normalized.
 */
function normalizeSpacing(htmlString) {
  // Run normalizeSafariSpaceSpans() two times to cover nested spans.
  return normalizeSafariSpaceSpans(normalizeSafariSpaceSpans(htmlString)) // Remove all \r\n from "spacerun spans" so the last replace line doesn't strip all whitespaces.
  .replace(/(<span\s+style=['"]mso-spacerun:yes['"]>[\s]*?)[\r\n]+(\s*<\/span>)/g, '$1$2').replace(/<span\s+style=['"]mso-spacerun:yes['"]><\/span>/g, '').replace(/ <\//g, "\xA0</").replace(/ <o:p><\/o:p>/g, "\xA0<o:p></o:p>") // Remove <o:p> block filler from empty paragraph. Safari uses \u00A0 instead of &nbsp;.
  .replace(/<o:p>(&nbsp;|\u00A0)<\/o:p>/g, '') // Remove all whitespaces when they contain any \r or \n.
  .replace(/>(\s*[\r\n]\s*)</g, '><');
}
/**
 * Normalizes spacing in special Word `spacerun spans` (`<span style='mso-spacerun:yes'>\s+</span>`) by replacing
 * all spaces with `&nbsp; ` pairs. This prevents spaces from being removed during further DOM/View processing
 * (see especially {@link module:engine/view/domconverter~DomConverter#_processDataFromDomText}).
 *
 * @param {Document} htmlDocument Native `Document` object in which spacing should be normalized.
 */

function normalizeSpacerunSpans(htmlDocument) {
  htmlDocument.querySelectorAll('span[style*=spacerun]').forEach(function (el) {
    var innerTextLength = el.innerText.length || 0;
    el.innerHTML = Array(innerTextLength + 1).join("\xA0 ").substr(0, innerTextLength);
  });
} // Normalizes specific spacing generated by Safari when content pasted from Word (`<span class="Apple-converted-space"> </span>`)
// by replacing all spaces sequences longer than 1 space with `&nbsp; ` pairs. This prevents spaces from being removed during
// further DOM/View processing (see especially {@link module:engine/view/domconverter~DomConverter#_processDataFromDomText}).
//
// This function is similar to {@link module:clipboard/utils/normalizeclipboarddata normalizeClipboardData util} but uses
// regular spaces / &nbsp; sequence for replacement.
//
// @param {String} htmlString HTML string in which spacing should be normalized
// @returns {String} Input HTML with spaces normalized.

function normalizeSafariSpaceSpans(htmlString) {
  return htmlString.replace(/<span(?: class="Apple-converted-space"|)>(\s+)<\/span>/g, function (fullMatch, spaces) {
    return spaces.length === 1 ? ' ' : Array(spaces.length + 1).join("\xA0 ").substr(0, spaces.length);
  });
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/parse.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module paste-from-office/filters/parse
 */

/* globals DOMParser */



/**
 * Parses provided HTML extracting contents of `<body>` and `<style>` tags.
 *
 * @param {String} htmlString HTML string to be parsed.
 * @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor
 * @returns {Object} result
 * @returns {module:engine/view/documentfragment~DocumentFragment} result.body Parsed body
 * content as a traversable structure.
 * @returns {String} result.bodyString Entire body content as a string.
 * @returns {Array.<CSSStyleSheet>} result.styles Array of native `CSSStyleSheet` objects, each representing
 * separate `style` tag from the source HTML.
 * @returns {String} result.stylesString All `style` tags contents combined in the order of occurrence into one string.
 */

function parseHtml(htmlString, stylesProcessor) {
  var domParser = new DOMParser(); // Remove Word specific "if comments" so content inside is not omitted by the parser.

  htmlString = htmlString.replace(/<!--\[if gte vml 1]>/g, '');
  var normalizedHtml = normalizeSpacing(cleanContentAfterBody(htmlString)); // Parse htmlString as native Document object.

  var htmlDocument = domParser.parseFromString(normalizedHtml, 'text/html');
  normalizeSpacerunSpans(htmlDocument); // Get `innerHTML` first as transforming to View modifies the source document.

  var bodyString = htmlDocument.body.innerHTML; // Transform document.body to View.

  var bodyView = documentToView(htmlDocument, stylesProcessor); // Extract stylesheets.

  var stylesObject = extractStyles(htmlDocument);
  return {
    body: bodyView,
    bodyString: bodyString,
    styles: stylesObject.styles,
    stylesString: stylesObject.stylesString
  };
} // Transforms native `Document` object into {@link module:engine/view/documentfragment~DocumentFragment}.
//
// @param {Document} htmlDocument Native `Document` object to be transformed.
// @param {module:engine/view/stylesmap~StylesProcessor} stylesProcessor
// @returns {module:engine/view/documentfragment~DocumentFragment}

function documentToView(htmlDocument, stylesProcessor) {
  var viewDocument = new document_Document(stylesProcessor);
  var domConverter = new domconverter_DomConverter(viewDocument, {
    blockFillerMode: 'nbsp'
  });
  var fragment = htmlDocument.createDocumentFragment();
  var nodes = htmlDocument.body.childNodes;

  while (nodes.length > 0) {
    fragment.appendChild(nodes[0]);
  }

  return domConverter.domToView(fragment);
} // Extracts both `CSSStyleSheet` and string representation from all `style` elements available in a provided `htmlDocument`.
//
// @param {Document} htmlDocument Native `Document` object from which styles will be extracted.
// @returns {Object} result
// @returns {Array.<CSSStyleSheet>} result.styles Array of native `CSSStyleSheet` object, each representing
// separate `style` tag from the source object.
// @returns {String} result.stylesString All `style` tags contents combined in the order of occurrence as one string.


function extractStyles(htmlDocument) {
  var styles = [];
  var stylesString = [];
  var styleTags = Array.from(htmlDocument.getElementsByTagName('style'));

  for (var _i = 0, _styleTags = styleTags; _i < _styleTags.length; _i++) {
    var style = _styleTags[_i];

    if (style.sheet && style.sheet.cssRules && style.sheet.cssRules.length) {
      styles.push(style.sheet);
      stylesString.push(style.innerHTML);
    }
  }

  return {
    styles: styles,
    stylesString: stylesString.join(' ')
  };
} // Removes leftover content from between closing </body> and closing </html> tag:
//
// 		<html><body><p>Foo Bar</p></body><span>Fo</span></html> -> <html><body><p>Foo Bar</p></body></html>
//
// This function is used as specific browsers (Edge) add some random content after `body` tag when pasting from Word.
// @param {String} htmlString The HTML string to be cleaned.
// @returns {String} The HTML string with leftover content removed.


function cleanContentAfterBody(htmlString) {
  var regexp = /<\/body>(.*?)(<\/html>|$)/;
  var match = htmlString.match(regexp);

  if (match && match[1]) {
    htmlString = htmlString.slice(0, match.index) + htmlString.slice(match.index).replace(match[1], '');
  }

  return htmlString;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-paste-from-office/src/filters/image.js

















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module paste-from-office/filters/image
 */

/* globals btoa */


/**
 * Replaces source attribute of all `<img>` elements representing regular
 * images (not the Word shapes) with inlined base64 image representation extracted from RTF or Blob data.
 *
 * @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment on which transform images.
 * @param {String} rtfData The RTF data from which images representation will be used.
 */

function replaceImagesSourceWithBase64(documentFragment, rtfData) {
  if (!documentFragment.childCount) {
    return;
  }

  var upcastWriter = new upcastwriter_UpcastWriter();
  var shapesIds = findAllShapesIds(documentFragment, upcastWriter);
  removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, upcastWriter);
  removeAllShapeElements(documentFragment, upcastWriter);
  var images = findAllImageElementsWithLocalSource(documentFragment, upcastWriter);

  if (images.length) {
    replaceImagesFileSourceWithInlineRepresentation(images, extractImageDataFromRtf(rtfData), upcastWriter);
  }
}
/**
 * Converts given HEX string to base64 representation.
 *
 * @protected
 * @param {String} hexString The HEX string to be converted.
 * @returns {String} Base64 representation of a given HEX string.
 */

function _convertHexToBase64(hexString) {
  return btoa(hexString.match(/\w{2}/g).map(function (char) {
    return String.fromCharCode(parseInt(char, 16));
  }).join(''));
} // Finds all shapes (`<v:*>...</v:*>`) ids. Shapes can represent images (canvas)
// or Word shapes (which does not have RTF or Blob representation).
//
// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment
// from which to extract shape ids.
// @param {module:engine/view/upcastwriter~UpcastWriter} writer
// @returns {Array.<String>} Array of shape ids.

function findAllShapesIds(documentFragment, writer) {
  var range = writer.createRangeIn(documentFragment);
  var shapeElementsMatcher = new matcher_Matcher({
    name: /v:(.+)/
  });
  var shapesIds = [];

  var _iterator = _createForOfIteratorHelper(range),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var value = _step.value;
      var el = value.item;
      var prevSiblingName = el.previousSibling && el.previousSibling.name || null; // If shape element have 'o:gfxdata' attribute and is not directly before `<v:shapetype>` element it means it represent Word shape.

      if (shapeElementsMatcher.match(el) && el.getAttribute('o:gfxdata') && prevSiblingName !== 'v:shapetype') {
        shapesIds.push(value.item.getAttribute('id'));
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return shapesIds;
} // Removes all `<img>` elements which represents Word shapes and not regular images.
//
// @param {Array.<String>} shapesIds Shape ids which will be checked against `<img>` elements.
// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment from which to remove `<img>` elements.
// @param {module:engine/view/upcastwriter~UpcastWriter} writer


function removeAllImgElementsRepresentingShapes(shapesIds, documentFragment, writer) {
  var range = writer.createRangeIn(documentFragment);
  var imageElementsMatcher = new matcher_Matcher({
    name: 'img'
  });
  var imgs = [];

  var _iterator2 = _createForOfIteratorHelper(range),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var value = _step2.value;

      if (imageElementsMatcher.match(value.item)) {
        var el = value.item;
        var shapes = el.getAttribute('v:shapes') ? el.getAttribute('v:shapes').split(' ') : [];

        if (shapes.length && shapes.every(function (shape) {
          return shapesIds.indexOf(shape) > -1;
        })) {
          imgs.push(el); // Shapes may also have empty source while content is paste in some browsers (Safari).
        } else if (!el.getAttribute('src')) {
          imgs.push(el);
        }
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  for (var _i = 0, _imgs = imgs; _i < _imgs.length; _i++) {
    var img = _imgs[_i];
    writer.remove(img);
  }
} // Removes all shape elements (`<v:*>...</v:*>`) so they do not pollute the output structure.
//
// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment from which to remove shape elements.
// @param {module:engine/view/upcastwriter~UpcastWriter} writer


function removeAllShapeElements(documentFragment, writer) {
  var range = writer.createRangeIn(documentFragment);
  var shapeElementsMatcher = new matcher_Matcher({
    name: /v:(.+)/
  });
  var shapes = [];

  var _iterator3 = _createForOfIteratorHelper(range),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var value = _step3.value;

      if (shapeElementsMatcher.match(value.item)) {
        shapes.push(value.item);
      }
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  for (var _i2 = 0, _shapes = shapes; _i2 < _shapes.length; _i2++) {
    var shape = _shapes[_i2];
    writer.remove(shape);
  }
} // Finds all `<img>` elements in a given document fragment which have source pointing to local `file://` resource.
//
// @param {module:engine/view/documentfragment~DocumentFragment} documentFragment Document fragment in which to look for `<img>` elements.
// @param {module:engine/view/upcastwriter~UpcastWriter} writer
// @returns {Object} result All found images grouped by source type.
// @returns {Array.<module:engine/view/element~Element>} result.file Array of found `<img>` elements with `file://` source.
// @returns {Array.<module:engine/view/element~Element>} result.blob Array of found `<img>` elements with `blob:` source.


function findAllImageElementsWithLocalSource(documentFragment, writer) {
  var range = writer.createRangeIn(documentFragment);
  var imageElementsMatcher = new matcher_Matcher({
    name: 'img'
  });
  var imgs = [];

  var _iterator4 = _createForOfIteratorHelper(range),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var value = _step4.value;

      if (imageElementsMatcher.match(value.item)) {
        if (value.item.getAttribute('src').startsWith('file://')) {
          imgs.push(value.item);
        }
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return imgs;
} // Extracts all images HEX representations from a given RTF data.
//
// @param {String} rtfData The RTF data from which to extract images HEX representation.
// @returns {Array.<Object>} Array of found HEX representations. Each array item is an object containing:
//
// 		* {String} hex Image representation in HEX format.
// 		* {string} type Type of image, `image/png` or `image/jpeg`.


function extractImageDataFromRtf(rtfData) {
  if (!rtfData) {
    return [];
  }

  var regexPictureHeader = /{\\pict[\s\S]+?\\bliptag-?\d+(\\blipupi-?\d+)?({\\\*\\blipuid\s?[\da-fA-F]+)?[\s}]*?/;
  var regexPicture = new RegExp('(?:(' + regexPictureHeader.source + '))([\\da-fA-F\\s]+)\\}', 'g');
  var images = rtfData.match(regexPicture);
  var result = [];

  if (images) {
    var _iterator5 = _createForOfIteratorHelper(images),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var image = _step5.value;
        var imageType = false;

        if (image.includes('\\pngblip')) {
          imageType = 'image/png';
        } else if (image.includes('\\jpegblip')) {
          imageType = 'image/jpeg';
        }

        if (imageType) {
          result.push({
            hex: image.replace(regexPictureHeader, '').replace(/[^\da-fA-F]/g, ''),
            type: imageType
          });
        }
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }
  }

  return result;
} // Replaces `src` attribute value of all given images with the corresponding base64 image representation.
//
// @param {Array.<module:engine/view/element~Element>} imageElements Array of image elements which will have its source replaced.
// @param {Array.<Object>} imagesHexSources Array of images hex sources (usually the result of `extractImageDataFromRtf()` function).
// The array should be the same length as `imageElements` parameter.
// @param {module:engine/view/upcastwriter~UpcastWriter} writer


function replaceImagesFileSourceWithInlineRepresentation(imageElements, imagesHexSources, writer) {
  // Assume there is an equal amount of image elements and images HEX sources so they can be matched accordingly based on existing order.
  if (imageElements.length === imagesHexSources.length) {
    for (var i = 0; i < imageElements.length; i++) {
      var newSrc = "data:".concat(imagesHexSources[i].type, ";base64,").concat(_convertHexToBase64(imagesHexSources[i].hex));
      writer.setAttribute('src', newSrc, imageElements[i]);
    }
  }
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-paste-from-office/src/normalizers/mswordnormalizer.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module paste-from-office/normalizers/mswordnormalizer
 */



var msWordMatch1 = /<meta\s*name="?generator"?\s*content="?microsoft\s*word\s*\d+"?\/?>/i;
var msWordMatch2 = /xmlns:o="urn:schemas-microsoft-com/i;
/**
 * Normalizer for the content pasted from Microsoft Word.
 *
 * @implements module:paste-from-office/normalizer~Normalizer
 */

var mswordnormalizer_MSWordNormalizer = /*#__PURE__*/function () {
  /**
   * Creates a new `MSWordNormalizer` instance.
   *
   * @param {module:engine/view/document~Document} document View document.
   */
  function MSWordNormalizer(document) {
    Object(classCallCheck["a" /* default */])(this, MSWordNormalizer);

    /**
     * @readonly
     * @type {module:engine/view/document~Document}
     */
    this.document = document;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(MSWordNormalizer, [{
    key: "isActive",
    value: function isActive(htmlString) {
      return msWordMatch1.test(htmlString) || msWordMatch2.test(htmlString);
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "execute",
    value: function execute(data) {
      var _parseHtml = parseHtml(data.dataTransfer.getData('text/html'), this.document.stylesProcessor),
          body = _parseHtml.body,
          stylesString = _parseHtml.stylesString;

      transformListItemLikeElementsIntoLists(body, stylesString);
      replaceImagesSourceWithBase64(body, data.dataTransfer.getData('text/rtf'));
      data.content = body;
    }
  }]);

  return MSWordNormalizer;
}();


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-paste-from-office/src/pastefromoffice.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module paste-from-office/pastefromoffice
 */




/**
 * The Paste from Office plugin.
 *
 * This plugin handles content pasted from Office apps and transforms it (if necessary)
 * to a valid structure which can then be understood by the editor features.
 *
 * Transformation is made by a set of predefined {@link module:paste-from-office/normalizer~Normalizer normalizers}.
 * This plugin includes following normalizers:
 *   * {@link module:paste-from-office/normalizers/mswordnormalizer~MSWordNormalizer Microsoft Word normalizer}
 *   * {@link module:paste-from-office/normalizers/googledocsnormalizer~GoogleDocsNormalizer Google Docs normalizer}
 *
 * For more information about this feature check the {@glink api/paste-from-office package page}.
 *
 * @extends module:core/plugin~Plugin
 */

var pastefromoffice_PasteFromOffice = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(PasteFromOffice, _Plugin);

  var _super = Object(createSuper["a" /* default */])(PasteFromOffice);

  function PasteFromOffice() {
    Object(classCallCheck["a" /* default */])(this, PasteFromOffice);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(PasteFromOffice, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var editor = this.editor;
      var viewDocument = editor.editing.view.document;
      var normalizers = [];
      normalizers.push(new mswordnormalizer_MSWordNormalizer(viewDocument));
      normalizers.push(new googledocsnormalizer_GoogleDocsNormalizer(viewDocument));
      editor.plugins.get('Clipboard').on('inputTransformation', function (evt, data) {
        if (data.isTransformedWithPasteFromOffice) {
          return;
        }

        var htmlString = data.dataTransfer.getData('text/html');
        var activeNormalizer = normalizers.find(function (normalizer) {
          return normalizer.isActive(htmlString);
        });

        if (activeNormalizer) {
          activeNormalizer.execute(data);
          data.isTransformedWithPasteFromOffice = true;
        }
      }, {
        priority: 'high'
      });
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'PasteFromOffice';
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "requires",
    get: function get() {
      return [clipboard_Clipboard];
    }
  }]);

  return PasteFromOffice;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/utils/common.js


/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/utils/common
 */

/**
 * Returns the parent element of the given name. Returns undefined if the position or the element is not inside the desired parent.
 *
 * @param {String} parentName The name of the parent element to find.
 * @param {module:engine/model/position~Position|module:engine/model/position~Position} positionOrElement The position or
 * the parentElement to start searching.
 * @returns {module:engine/model/element~Element|module:engine/model/documentfragment~DocumentFragment}
 */
function common_findAncestor(parentName, positionOrElement) {
  var parent = positionOrElement.parent;

  while (parent) {
    if (parent.name === parentName) {
      return parent;
    }

    parent = parent.parent;
  }
}
/**
 * A common method to update the numeric value. If a value is the default one, it will be unset.
 *
 * @param {String} key An attribute key.
 * @param {*} value The new attribute value.
 * @param {module:engine/model/item~Item} item A model item on which the attribute will be set.
 * @param {module:engine/model/writer~Writer} writer
 * @param {*} defaultValue The default attribute value. If a value is lower or equal, it will be unset.
 */

function updateNumericAttribute(key, value, item, writer) {
  var defaultValue = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;

  if (value > defaultValue) {
    writer.setAttribute(key, value, item);
  } else {
    writer.removeAttribute(key, item);
  }
}
/**
 * A common method to create an empty table cell. It creates a proper model structure as a table cell must have at least one block inside.
 *
 * @param {module:engine/model/writer~Writer} writer The model writer.
 * @param {module:engine/model/position~Position} insertPosition The position at which the table cell should be inserted.
 * @param {Object} attributes The element attributes.
 */

function createEmptyTableCell(writer, insertPosition) {
  var attributes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var tableCell = writer.createElement('tableCell', attributes);
  writer.insertElement('paragraph', tableCell);
  writer.insert(tableCell, insertPosition);
}
/**
 * Checks if a table cell belongs to the heading column section.
 *
 * @param {module:table/tableutils~TableUtils} tableUtils
 * @param {module:engine/model/element~Element} tableCell
 * @returns {Boolean}
 */

function isHeadingColumnCell(tableUtils, tableCell) {
  var table = tableCell.parent.parent;
  var headingColumns = parseInt(table.getAttribute('headingColumns') || 0);

  var _tableUtils$getCellLo = tableUtils.getCellLocation(tableCell),
      column = _tableUtils$getCellLo.column;

  return !!headingColumns && column < headingColumns;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/converters/upcasttable.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/converters/upcasttable
 */

/**
 * View table element to model table element conversion helper.
 *
 * This conversion helper converts the table element as well as table rows.
 *
 * @returns {Function} Conversion helper.
 */

function upcastTable() {
  return function (dispatcher) {
    dispatcher.on('element:table', function (evt, data, conversionApi) {
      var viewTable = data.viewItem; // When element was already consumed then skip it.

      if (!conversionApi.consumable.test(viewTable, {
        name: true
      })) {
        return;
      }

      var _scanTable = scanTable(viewTable),
          rows = _scanTable.rows,
          headingRows = _scanTable.headingRows,
          headingColumns = _scanTable.headingColumns; // Only set attributes if values is greater then 0.


      var attributes = {};

      if (headingColumns) {
        attributes.headingColumns = headingColumns;
      }

      if (headingRows) {
        attributes.headingRows = headingRows;
      }

      var table = conversionApi.writer.createElement('table', attributes); // Insert element on allowed position.

      var splitResult = conversionApi.splitToAllowedParent(table, data.modelCursor); // When there is no split result it means that we can't insert element to model tree, so let's skip it.

      if (!splitResult) {
        return;
      }

      conversionApi.writer.insert(table, splitResult.position);
      conversionApi.consumable.consume(viewTable, {
        name: true
      }); // Upcast table rows in proper order (heading rows first).

      rows.forEach(function (row) {
        return conversionApi.convertItem(row, conversionApi.writer.createPositionAt(table, 'end'));
      }); // Create one row and one table cell for empty table.

      if (table.isEmpty) {
        var row = conversionApi.writer.createElement('tableRow');
        conversionApi.writer.insert(row, conversionApi.writer.createPositionAt(table, 'end'));
        createEmptyTableCell(conversionApi.writer, conversionApi.writer.createPositionAt(row, 'end'));
      } // Set conversion result range.


      data.modelRange = conversionApi.writer.createRange( // Range should start before inserted element
      conversionApi.writer.createPositionBefore(table), // Should end after but we need to take into consideration that children could split our
      // element, so we need to move range after parent of the last converted child.
      // before: <allowed>[]</allowed>
      // after: <allowed>[<converted><child></child></converted><child></child><converted>]</converted></allowed>
      conversionApi.writer.createPositionAfter(table)); // Now we need to check where the modelCursor should be.
      // If we had to split parent to insert our element then we want to continue conversion inside split parent.
      //
      // before: <allowed><notAllowed>[]</notAllowed></allowed>
      // after:  <allowed><notAllowed></notAllowed><converted></converted><notAllowed>[]</notAllowed></allowed>

      if (splitResult.cursorParent) {
        data.modelCursor = conversionApi.writer.createPositionAt(splitResult.cursorParent, 0); // Otherwise just continue after inserted element.
      } else {
        data.modelCursor = data.modelRange.end;
      }
    });
  };
}
/**
 * Conversion helper that skips empty <tr> from upcasting at the beginning of the table.
 *
 * Empty row is considered a table model error but when handling clipboard data there could be rows that contain only row-spanned cells
 * and empty TR-s are used to maintain table structure (also {@link module:table/tablewalker~TableWalker} assumes that there are only rows
 * that have related tableRow elements).
 *
 * *Note:* Only first empty rows are removed because those have no meaning and solves issue of improper table with all empty rows.
 *
 * @returns {Function} Conversion helper.
 */

function skipEmptyTableRow() {
  return function (dispatcher) {
    dispatcher.on('element:tr', function (evt, data) {
      if (data.viewItem.isEmpty && data.modelCursor.index == 0) {
        evt.stop();
      }
    }, {
      priority: 'high'
    });
  };
}
function upcastTableCell(elementName) {
  return function (dispatcher) {
    dispatcher.on("element:".concat(elementName), function (evt, data, conversionApi) {
      var viewTableCell = data.viewItem; // When element was already consumed then skip it.

      if (!conversionApi.consumable.test(viewTableCell, {
        name: true
      })) {
        return;
      }

      var tableCell = conversionApi.writer.createElement('tableCell'); // Insert element on allowed position.

      var splitResult = conversionApi.splitToAllowedParent(tableCell, data.modelCursor); // When there is no split result it means that we can't insert element to model tree, so let's skip it.

      if (!splitResult) {
        return;
      }

      conversionApi.writer.insert(tableCell, splitResult.position);
      conversionApi.consumable.consume(viewTableCell, {
        name: true
      });
      var modelCursor = conversionApi.writer.createPositionAt(tableCell, 0);
      conversionApi.convertChildren(viewTableCell, modelCursor); // Ensure a paragraph in the model for empty table cells.

      if (!tableCell.childCount) {
        conversionApi.writer.insertElement('paragraph', modelCursor);
      } // Set conversion result range.


      data.modelRange = conversionApi.writer.createRange( // Range should start before inserted element
      conversionApi.writer.createPositionBefore(tableCell), // Should end after but we need to take into consideration that children could split our
      // element, so we need to move range after parent of the last converted child.
      // before: <allowed>[]</allowed>
      // after: <allowed>[<converted><child></child></converted><child></child><converted>]</converted></allowed>
      conversionApi.writer.createPositionAfter(tableCell)); // Continue after inserted element.

      data.modelCursor = data.modelRange.end;
    });
  };
} // Scans table rows and extracts required metadata from the table:
//
// headingRows    - The number of rows that go as table headers.
// headingColumns - The maximum number of row headings.
// rows           - Sorted `<tr>` elements as they should go into the model - ie. if `<thead>` is inserted after `<tbody>` in the view.
//
// @param {module:engine/view/element~Element} viewTable
// @returns {{headingRows, headingColumns, rows}}

function scanTable(viewTable) {
  var tableMeta = {
    headingRows: 0,
    headingColumns: 0
  }; // The `<tbody>` and `<thead>` sections in the DOM do not have to be in order `<thead>` -> `<tbody>` and there might be more than one
  // of them.
  // As the model does not have these sections, rows from different sections must be sorted.
  // For example, below is a valid HTML table:
  //
  //		<table>
  //			<tbody><tr><td>2</td></tr></tbody>
  //			<thead><tr><td>1</td></tr></thead>
  //			<tbody><tr><td>3</td></tr></tbody>
  //		</table>
  //
  // But browsers will render rows in order as: 1 as heading and 2 and 3 as the body.

  var headRows = [];
  var bodyRows = []; // Currently the editor does not support more then one <thead> section.
  // Only the first <thead> from the view will be used as heading rows and others will be converted to body rows.

  var firstTheadElement;

  for (var _i = 0, _Array$from = Array.from(viewTable.getChildren()); _i < _Array$from.length; _i++) {
    var tableChild = _Array$from[_i];

    // Only <thead>, <tbody> & <tfoot> from allowed table children can have <tr>s.
    // The else is for future purposes (mainly <caption>).
    if (tableChild.name === 'tbody' || tableChild.name === 'thead' || tableChild.name === 'tfoot') {
      // Save the first <thead> in the table as table header - all other ones will be converted to table body rows.
      if (tableChild.name === 'thead' && !firstTheadElement) {
        firstTheadElement = tableChild;
      } // There might be some extra empty text nodes between the `tr`s.
      // Make sure further code operates on `tr`s only. (#145)


      var trs = Array.from(tableChild.getChildren()).filter(function (el) {
        return el.is('element', 'tr');
      });

      var _iterator = _createForOfIteratorHelper(trs),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var tr = _step.value;

          // This <tr> is a child of a first <thead> element.
          if (tr.parent.name === 'thead' && tr.parent === firstTheadElement) {
            tableMeta.headingRows++;
            headRows.push(tr);
          } else {
            bodyRows.push(tr); // For other rows check how many column headings this row has.

            var headingCols = scanRowForHeadingColumns(tr, tableMeta, firstTheadElement);

            if (headingCols > tableMeta.headingColumns) {
              tableMeta.headingColumns = headingCols;
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
  }

  tableMeta.rows = [].concat(headRows, bodyRows);
  return tableMeta;
} // Scans a `<tr>` element and its children for metadata:
// - For heading row:
//     - Adds this row to either the heading or the body rows.
//     - Updates the number of heading rows.
// - For body rows:
//     - Calculates the number of column headings.
//
// @param {module:engine/view/element~Element} tr
// @returns {Number}


function scanRowForHeadingColumns(tr) {
  var headingColumns = 0;
  var index = 0; // Filter out empty text nodes from tr children.

  var children = Array.from(tr.getChildren()).filter(function (child) {
    return child.name === 'th' || child.name === 'td';
  }); // Count starting adjacent <th> elements of a <tr>.

  while (index < children.length && children[index].name === 'th') {
    var th = children[index]; // Adjust columns calculation by the number of spanned columns.

    var colspan = parseInt(th.getAttribute('colspan') || 1);
    headingColumns = headingColumns + colspan;
    index++;
  }

  return headingColumns;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/tablewalker.js












/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/tablewalker
 */
// @if CK_DEBUG // import CKEditorError from '@ckeditor/ckeditor5-utils/src/ckeditorerror';

/**
 * The table iterator class. It allows to iterate over table cells. For each cell the iterator yields
 * {@link module:table/tablewalker~TableSlot} with proper table cell attributes.
 */
var tablewalker_TableWalker = /*#__PURE__*/function () {
  /**
   * Creates an instance of the table walker.
   *
   * The table walker iterates internally by traversing the table from row index = 0 and column index = 0.
   * It walks row by row and column by column in order to output values defined in the constructor.
   * By default it will output only the locations that are occupied by a cell. To include also spanned rows and columns,
   * pass the `includeAllSlots` option to the constructor.
   *
   * The most important values of the iterator are column and row indexes of a cell.
   *
   * See {@link module:table/tablewalker~TableSlot} what values are returned by the table walker.
   *
   * To iterate over a given row:
   *
   *		const tableWalker = new TableWalker( table, { startRow: 1, endRow: 2 } );
   *
   *		for ( const tableSlot of tableWalker ) {
   *			console.log( 'A cell at row', tableSlot.row, 'and column', tableSlot.column );
   *		}
   *
   * For instance the code above for the following table:
   *
   *		+----+----+----+----+----+----+
   *		| 00      | 02 | 03 | 04 | 05 |
   *		|         +----+----+----+----+
   *		|         | 12      | 14 | 15 |
   *		|         +----+----+----+    +
   *		|         | 22           |    |
   *		|----+----+----+----+----+    +
   *		| 30 | 31 | 32 | 33 | 34 |    |
   *		+----+----+----+----+----+----+
   *
   * will log in the console:
   *
   *		'A cell at row 1 and column 2'
   *		'A cell at row 1 and column 4'
   *		'A cell at row 1 and column 5'
   *		'A cell at row 2 and column 2'
   *
   * To also iterate over spanned cells:
   *
   *		const tableWalker = new TableWalker( table, { row: 1, includeAllSlots: true } );
   *
   *		for ( const tableSlot of tableWalker ) {
   *			console.log( 'Slot at', tableSlot.row, 'x', tableSlot.column, ':', tableSlot.isAnchor ? 'is anchored' : 'is spanned' );
   *		}
   *
   * will log in the console for the table from the previous example:
   *
   *		'Cell at 1 x 0 : is spanned'
   *		'Cell at 1 x 1 : is spanned'
   *		'Cell at 1 x 2 : is anchored'
   *		'Cell at 1 x 3 : is spanned'
   *		'Cell at 1 x 4 : is anchored'
   *		'Cell at 1 x 5 : is anchored'
   *
   * **Note**: Option `row` is a shortcut that sets both `startRow` and `endRow` to the same row.
   * (Use either `row` or `startRow` and `endRow` but never together). Similarly the `column` option sets both `startColumn`
   * and `endColumn` to the same column (Use either `column` or `startColumn` and `endColumn` but never together).
   *
   * @constructor
   * @param {module:engine/model/element~Element} table A table over which the walker iterates.
   * @param {Object} [options={}] An object with configuration.
   * @param {Number} [options.row] A row index for which this iterator will output cells.
   * Can't be used together with `startRow` and `endRow`.
   * @param {Number} [options.startRow=0] A row index from which this iterator should start. Can't be used together with `row`.
   * @param {Number} [options.endRow] A row index at which this iterator should end. Can't be used together with `row`.
   * @param {Number} [options.column] A column index for which this iterator will output cells.
   * Can't be used together with `startColumn` and `endColumn`.
   * @param {Number} [options.startColumn=0] A column index from which this iterator should start. Can't be used together with `column`.
   * @param {Number} [options.endColumn] A column index at which this iterator should end. Can't be used together with `column`.
   * @param {Boolean} [options.includeAllSlots=false] Also return values for spanned cells.
   */
  function TableWalker(table) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    Object(classCallCheck["a" /* default */])(this, TableWalker);

    /**
     * The walker's table element.
     *
     * @readonly
     * @member {module:engine/model/element~Element}
     * @protected
     */
    this._table = table;
    /**
     * A row index from which this iterator will start.
     *
     * @readonly
     * @member {Number}
     * @private
     */

    this._startRow = options.row !== undefined ? options.row : options.startRow || 0;
    /**
     * A row index at which this iterator will end.
     *
     * @readonly
     * @member {Number}
     * @private
     */

    this._endRow = options.row !== undefined ? options.row : options.endRow;
    /**
     * If set, the table walker will only output cells from a given column and following ones or cells that overlap them.
     *
     * @readonly
     * @member {Number}
     * @private
     */

    this._startColumn = options.column !== undefined ? options.column : options.startColumn || 0;
    /**
     * If set, the table walker will only output cells up to a given column.
     *
     * @readonly
     * @member {Number}
     * @private
     */

    this._endColumn = options.column !== undefined ? options.column : options.endColumn;
    /**
     * Enables output of spanned cells that are normally not yielded.
     *
     * @readonly
     * @member {Boolean}
     * @private
     */

    this._includeAllSlots = !!options.includeAllSlots;
    /**
     * Row indexes to skip from the iteration.
     *
     * @readonly
     * @member {Set<Number>}
     * @private
     */

    this._skipRows = new Set();
    /**
     * The current row index.
     *
     * @member {Number}
     * @protected
     */

    this._row = 0;
    /**
     * The current column index.
     *
     * @member {Number}
     * @protected
     */

    this._column = 0;
    /**
     * The cell index in a parent row. For spanned cells when {@link #_includeAllSlots} is set to `true`,
     * this represents the index of the next table cell.
     *
     * @member {Number}
     * @protected
     */

    this._cellIndex = 0;
    /**
     * Holds a map of spanned cells in a table.
     *
     * @readonly
     * @member {Map.<Number, Map.<Number, Object>>}
     * @private
     */

    this._spannedCells = new Map();
    /**
     * Index of the next column where a cell is anchored.
     *
     * @member {Number}
     * @private
     */

    this._nextCellAtColumn = -1;
  }
  /**
   * Iterable interface.
   *
   * @returns {Iterable.<module:table/tablewalker~TableSlot>}
   */


  Object(createClass["a" /* default */])(TableWalker, [{
    key: Symbol.iterator,
    value: function value() {
      return this;
    }
    /**
     * Gets the next table walker's value.
     *
     * @returns {module:table/tablewalker~TableSlot} The next table walker's value.
     */

  }, {
    key: "next",
    value: function next() {
      var row = this._table.getChild(this._row); // Iterator is done when there's no row (table ended) or the row is after `endRow` limit.


      if (!row || this._isOverEndRow()) {
        return {
          done: true
        };
      }

      if (this._isOverEndColumn()) {
        return this._advanceToNextRow();
      }

      var outValue = null;

      var spanData = this._getSpanned();

      if (spanData) {
        if (this._includeAllSlots && !this._shouldSkipSlot()) {
          outValue = this._formatOutValue(spanData.cell, spanData.row, spanData.column);
        }
      } else {
        var cell = row.getChild(this._cellIndex);

        if (!cell) {
          // If there are no more cells left in row advance to the next row.
          return this._advanceToNextRow();
        }

        var colspan = parseInt(cell.getAttribute('colspan') || 1);
        var rowspan = parseInt(cell.getAttribute('rowspan') || 1); // Record this cell spans if it's not 1x1 cell.

        if (colspan > 1 || rowspan > 1) {
          this._recordSpans(cell, rowspan, colspan);
        }

        if (!this._shouldSkipSlot()) {
          outValue = this._formatOutValue(cell);
        }

        this._nextCellAtColumn = this._column + colspan;
      } // Advance to the next column before returning value.


      this._column++;

      if (this._column == this._nextCellAtColumn) {
        this._cellIndex++;
      } // The current value will be returned only if current row and column are not skipped.


      return outValue || this.next();
    }
    /**
     * Marks a row to skip in the next iteration. It will also skip cells from the current row if there are any cells from the current row
     * to output.
     *
     * @param {Number} row The row index to skip.
     */

  }, {
    key: "skipRow",
    value: function skipRow(row) {
      this._skipRows.add(row);
    }
    /**
     * Advances internal cursor to the next row.
     *
     * @private
     * @returns {module:table/tablewalker~TableSlot}
     */

  }, {
    key: "_advanceToNextRow",
    value: function _advanceToNextRow() {
      this._row++;
      this._column = 0;
      this._cellIndex = 0;
      this._nextCellAtColumn = -1;
      return this.next();
    }
    /**
     * Checks if the current row is over {@link #_endRow}.
     *
     * @private
     * @returns {Boolean}
     */

  }, {
    key: "_isOverEndRow",
    value: function _isOverEndRow() {
      // If #_endRow is defined skip all rows after it.
      return this._endRow !== undefined && this._row > this._endRow;
    }
    /**
     * Checks if the current cell is over {@link #_endColumn}
     *
     * @private
     * @returns {Boolean}
     */

  }, {
    key: "_isOverEndColumn",
    value: function _isOverEndColumn() {
      // If #_endColumn is defined skip all cells after it.
      return this._endColumn !== undefined && this._column > this._endColumn;
    }
    /**
     * A common method for formatting the iterator's output value.
     *
     * @private
     * @param {module:engine/model/element~Element} cell The table cell to output.
     * @param {Number} [anchorRow] The row index of a cell anchor slot.
     * @param {Number} [anchorColumn] The column index of a cell anchor slot.
     * @returns {{done: Boolean, value: {cell: *, row: Number, column: *, rowspan: *, colspan: *, cellIndex: Number}}}
     */

  }, {
    key: "_formatOutValue",
    value: function _formatOutValue(cell) {
      var anchorRow = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._row;
      var anchorColumn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._column;
      return {
        done: false,
        value: new tablewalker_TableSlot(this, cell, anchorRow, anchorColumn)
      };
    }
    /**
     * Checks if the current slot should be skipped.
     *
     * @private
     * @returns {Boolean}
     */

  }, {
    key: "_shouldSkipSlot",
    value: function _shouldSkipSlot() {
      var rowIsMarkedAsSkipped = this._skipRows.has(this._row);

      var rowIsBeforeStartRow = this._row < this._startRow;
      var columnIsBeforeStartColumn = this._column < this._startColumn;
      var columnIsAfterEndColumn = this._endColumn !== undefined && this._column > this._endColumn;
      return rowIsMarkedAsSkipped || rowIsBeforeStartRow || columnIsBeforeStartColumn || columnIsAfterEndColumn;
    }
    /**
     * Returns the cell element that is spanned over the current cell location.
     *
     * @private
     * @returns {module:engine/model/element~Element}
     */

  }, {
    key: "_getSpanned",
    value: function _getSpanned() {
      var rowMap = this._spannedCells.get(this._row); // No spans for given row.


      if (!rowMap) {
        return null;
      } // If spans for given rows has entry for column it means that this location if spanned by other cell.


      return rowMap.get(this._column) || null;
    }
    /**
     * Updates spanned cells map relative to the current cell location and its span dimensions.
     *
     * @private
     * @param {module:engine/model/element~Element} cell A cell that is spanned.
     * @param {Number} rowspan Cell height.
     * @param {Number} colspan Cell width.
     */

  }, {
    key: "_recordSpans",
    value: function _recordSpans(cell, rowspan, colspan) {
      var data = {
        cell: cell,
        row: this._row,
        column: this._column
      };

      for (var rowToUpdate = this._row; rowToUpdate < this._row + rowspan; rowToUpdate++) {
        for (var columnToUpdate = this._column; columnToUpdate < this._column + colspan; columnToUpdate++) {
          if (rowToUpdate != this._row || columnToUpdate != this._column) {
            this._markSpannedCell(rowToUpdate, columnToUpdate, data);
          }
        }
      }
    }
    /**
     * Marks the cell location as spanned by another cell.
     *
     * @private
     * @param {Number} row The row index of the cell location.
     * @param {Number} column The column index of the cell location.
     * @param {Object} data A spanned cell details (cell element, anchor row and column).
     */

  }, {
    key: "_markSpannedCell",
    value: function _markSpannedCell(row, column, data) {
      if (!this._spannedCells.has(row)) {
        this._spannedCells.set(row, new Map());
      }

      var rowSpans = this._spannedCells.get(row);

      rowSpans.set(column, data);
    }
  }]);

  return TableWalker;
}();
/**
 * An object returned by {@link module:table/tablewalker~TableWalker} when traversing table cells.
 */




var tablewalker_TableSlot = /*#__PURE__*/function () {
  /**
   * Creates an instance of the table walker value.
   *
   * @protected
   * @param {module:table/tablewalker~TableWalker} tableWalker The table walker instance.
   * @param {module:engine/model/element~Element} cell The current table cell.
   * @param {Number} anchorRow The row index of a cell anchor slot.
   * @param {Number} anchorColumn The column index of a cell anchor slot.
   */
  function TableSlot(tableWalker, cell, anchorRow, anchorColumn) {
    Object(classCallCheck["a" /* default */])(this, TableSlot);

    /**
     * The current table cell.
     *
     * @readonly
     * @member {module:engine/model/element~Element}
     */
    this.cell = cell;
    /**
     * The row index of a table slot.
     *
     * @readonly
     * @member {Number}
     */

    this.row = tableWalker._row;
    /**
     * The column index of a table slot.
     *
     * @readonly
     * @member {Number}
     */

    this.column = tableWalker._column;
    /**
     * The row index of a cell anchor slot.
     *
     * @readonly
     * @member {Number}
     */

    this.cellAnchorRow = anchorRow;
    /**
     * The column index of a cell anchor slot.
     *
     * @readonly
     * @member {Number}
     */

    this.cellAnchorColumn = anchorColumn;
    /**
     * The index of the current cell in the parent row.
     *
     * @readonly
     * @member {Number}
     * @private
     */

    this._cellIndex = tableWalker._cellIndex;
    /**
     * The table element.
     *
     * @readonly
     * @member {module:engine/model/element~Element}
     * @private
     */

    this._table = tableWalker._table;
  }
  /**
   * Whether the cell is anchored in the current slot.
   *
   * @readonly
   * @returns {Boolean}
   */


  Object(createClass["a" /* default */])(TableSlot, [{
    key: "getPositionBefore",

    /**
     * Returns the {@link module:engine/model/position~Position} before the table slot.
     *
     * @returns {module:engine/model/position~Position}
     */
    value: function getPositionBefore() {
      var model = this._table.root.document.model;
      return model.createPositionAt(this._table.getChild(this.row), this._cellIndex);
    } // @if CK_DEBUG // get isSpanned() { throw new CKEditorError( 'tablewalker-improper-api-usage', this ); }
    // @if CK_DEBUG // get colspan() { throw new CKEditorError( 'tablewalker-improper-api-usage', this ); }
    // @if CK_DEBUG // get rowspan() { throw new CKEditorError( 'tablewalker-improper-api-usage', this ); }
    // @if CK_DEBUG // get cellIndex() { throw new CKEditorError( 'tablewalker-improper-api-usage', this ); }

  }, {
    key: "isAnchor",
    get: function get() {
      return this.row === this.cellAnchorRow && this.column === this.cellAnchorColumn;
    }
    /**
     * The width of a cell defined by a `colspan` attribute. If the model attribute is not present, it is set to `1`.
     *
     * @readonly
     * @returns {Number}
     */

  }, {
    key: "cellWidth",
    get: function get() {
      return parseInt(this.cell.getAttribute('colspan') || 1);
    }
    /**
     * The height of a cell defined by a `rowspan` attribute. If the model attribute is not present, it is set to `1`.
     *
     * @readonly
     * @returns {Number}
     */

  }, {
    key: "cellHeight",
    get: function get() {
      return parseInt(this.cell.getAttribute('rowspan') || 1);
    }
  }]);

  return TableSlot;
}();
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/converters/downcast.js











/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/converters/downcast
 */


/**
 * Model table element to view table element conversion helper.
 *
 * This conversion helper creates the whole table element with child elements.
 *
 * @param {Object} options
 * @param {Boolean} options.asWidget If set to `true`, the downcast conversion will produce a widget.
 * @returns {Function} Conversion helper.
 */

function downcastInsertTable() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  return function (dispatcher) {
    return dispatcher.on('insert:table', function (evt, data, conversionApi) {
      var table = data.item;

      if (!conversionApi.consumable.consume(table, 'insert')) {
        return;
      } // Consume attributes if present to not fire attribute change downcast


      conversionApi.consumable.consume(table, 'attribute:headingRows:table');
      conversionApi.consumable.consume(table, 'attribute:headingColumns:table');
      var asWidget = options && options.asWidget;
      var figureElement = conversionApi.writer.createContainerElement('figure', {
        class: 'table'
      });
      var tableElement = conversionApi.writer.createContainerElement('table');
      conversionApi.writer.insert(conversionApi.writer.createPositionAt(figureElement, 0), tableElement);
      var tableWidget;

      if (asWidget) {
        tableWidget = toTableWidget(figureElement, conversionApi.writer);
      }

      var tableWalker = new tablewalker_TableWalker(table);
      var tableAttributes = {
        headingRows: table.getAttribute('headingRows') || 0,
        headingColumns: table.getAttribute('headingColumns') || 0
      }; // Cache for created table rows.

      var viewRows = new Map();

      var _iterator = _createForOfIteratorHelper(tableWalker),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var tableSlot = _step.value;
          var row = tableSlot.row,
              cell = tableSlot.cell;
          var tableRow = table.getChild(row);
          var trElement = viewRows.get(row) || createTr(tableElement, tableRow, row, tableAttributes, conversionApi);
          viewRows.set(row, trElement); // Consume table cell - it will be always consumed as we convert whole table at once.

          conversionApi.consumable.consume(cell, 'insert');
          var insertPosition = conversionApi.writer.createPositionAt(trElement, 'end');
          createViewTableCellElement(tableSlot, tableAttributes, insertPosition, conversionApi, options);
        } // Insert empty TR elements if there are any rows without anchored cells. Since the model is always normalized
        // this can happen only in the document fragment that only part of the table is down-casted.

      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      var _iterator2 = _createForOfIteratorHelper(table.getChildren()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var _tableRow = _step2.value;
          var rowIndex = _tableRow.index;

          if (!viewRows.has(rowIndex)) {
            viewRows.set(rowIndex, createTr(tableElement, _tableRow, rowIndex, tableAttributes, conversionApi));
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      var viewPosition = conversionApi.mapper.toViewPosition(data.range.start);
      conversionApi.mapper.bindElements(table, asWidget ? tableWidget : figureElement);
      conversionApi.writer.insert(viewPosition, asWidget ? tableWidget : figureElement);
    });
  };
}
/**
 * Model row element to view `<tr>` element conversion helper.
 *
 * This conversion helper creates the whole `<tr>` element with child elements.
 *
 * @returns {Function} Conversion helper.
 */

function downcastInsertRow() {
  return function (dispatcher) {
    return dispatcher.on('insert:tableRow', function (evt, data, conversionApi) {
      var tableRow = data.item;

      if (!conversionApi.consumable.consume(tableRow, 'insert')) {
        return;
      }

      var table = tableRow.parent;
      var figureElement = conversionApi.mapper.toViewElement(table);
      var tableElement = getViewTable(figureElement);
      var row = table.getChildIndex(tableRow);
      var tableWalker = new tablewalker_TableWalker(table, {
        row: row
      });
      var tableAttributes = {
        headingRows: table.getAttribute('headingRows') || 0,
        headingColumns: table.getAttribute('headingColumns') || 0
      }; // Cache for created table rows.

      var viewRows = new Map();

      var _iterator3 = _createForOfIteratorHelper(tableWalker),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var tableSlot = _step3.value;
          var trElement = viewRows.get(row) || createTr(tableElement, tableRow, row, tableAttributes, conversionApi);
          viewRows.set(row, trElement); // Consume table cell - it will be always consumed as we convert whole row at once.

          conversionApi.consumable.consume(tableSlot.cell, 'insert');
          var insertPosition = conversionApi.writer.createPositionAt(trElement, 'end');
          createViewTableCellElement(tableSlot, tableAttributes, insertPosition, conversionApi, {
            asWidget: true
          });
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }
    });
  };
}
/**
 * Model table cell element to view `<td>` or `<th>` element conversion helper.
 *
 * This conversion helper will create proper `<th>` elements for table cells that are in the heading section (heading row or column)
 * and `<td>` otherwise.
 *
 * @returns {Function} Conversion helper.
 */

function downcastInsertCell() {
  return function (dispatcher) {
    return dispatcher.on('insert:tableCell', function (evt, data, conversionApi) {
      var tableCell = data.item;

      if (!conversionApi.consumable.consume(tableCell, 'insert')) {
        return;
      }

      var tableRow = tableCell.parent;
      var table = tableRow.parent;
      var rowIndex = table.getChildIndex(tableRow);
      var tableWalker = new tablewalker_TableWalker(table, {
        row: rowIndex
      });
      var tableAttributes = {
        headingRows: table.getAttribute('headingRows') || 0,
        headingColumns: table.getAttribute('headingColumns') || 0
      }; // We need to iterate over a table in order to get proper row & column values from a walker

      var _iterator4 = _createForOfIteratorHelper(tableWalker),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var tableSlot = _step4.value;

          if (tableSlot.cell === tableCell) {
            var trElement = conversionApi.mapper.toViewElement(tableRow);
            var insertPosition = conversionApi.writer.createPositionAt(trElement, tableRow.getChildIndex(tableCell));
            createViewTableCellElement(tableSlot, tableAttributes, insertPosition, conversionApi, {
              asWidget: true
            }); // No need to iterate further.

            return;
          }
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }
    });
  };
}
/**
 * Conversion helper that acts on heading row table attribute change.
 *
 * This converter will:
 *
 * * Rename `<td>` to `<th>` elements or vice versa depending on headings.
 * * Create `<thead>` or `<tbody>` elements if needed.
 * * Remove empty `<thead>` or `<tbody>` if needed.
 *
 * @returns {Function} Conversion helper.
 */

function downcastTableHeadingRowsChange() {
  return function (dispatcher) {
    return dispatcher.on('attribute:headingRows:table', function (evt, data, conversionApi) {
      var table = data.item;

      if (!conversionApi.consumable.consume(data.item, evt.name)) {
        return;
      }

      var figureElement = conversionApi.mapper.toViewElement(table);
      var viewTable = getViewTable(figureElement);
      var oldRows = data.attributeOldValue;
      var newRows = data.attributeNewValue; // The head section has grown so move rows from <tbody> to <thead>.

      if (newRows > oldRows) {
        // Filter out only those rows that are in wrong section.
        var rowsToMove = Array.from(table.getChildren()).filter(function (_ref) {
          var index = _ref.index;
          return isBetween(index, oldRows - 1, newRows);
        });
        var viewTableHead = getOrCreateTableSection('thead', viewTable, conversionApi);
        moveViewRowsToTableSection(rowsToMove, viewTableHead, conversionApi, 'end'); // Rename all table cells from moved rows to 'th' as they lands in <thead>.

        var _iterator5 = _createForOfIteratorHelper(rowsToMove),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var tableRow = _step5.value;

            var _iterator6 = _createForOfIteratorHelper(tableRow.getChildren()),
                _step6;

            try {
              for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
                var tableCell = _step6.value;
                renameViewTableCell(tableCell, 'th', conversionApi);
              }
            } catch (err) {
              _iterator6.e(err);
            } finally {
              _iterator6.f();
            }
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      } // The head section has shrunk so move rows from <thead> to <tbody>.
      else {
          // Filter out only those rows that are in wrong section.
          var _rowsToMove = Array.from(table.getChildren()).filter(function (_ref2) {
            var index = _ref2.index;
            return isBetween(index, newRows - 1, oldRows);
          }).reverse(); // The rows will be moved from <thead> to <tbody> in reverse order at the beginning of a <tbody>.


          var viewTableBody = getOrCreateTableSection('tbody', viewTable, conversionApi);
          moveViewRowsToTableSection(_rowsToMove, viewTableBody, conversionApi, 0); // Check if cells moved from <thead> to <tbody> requires renaming to <td> as this depends on current heading columns attribute.

          var tableWalker = new tablewalker_TableWalker(table, {
            startRow: newRows ? newRows - 1 : newRows,
            endRow: oldRows - 1
          });
          var tableAttributes = {
            headingRows: table.getAttribute('headingRows') || 0,
            headingColumns: table.getAttribute('headingColumns') || 0
          };

          var _iterator7 = _createForOfIteratorHelper(tableWalker),
              _step7;

          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var tableSlot = _step7.value;
              renameViewTableCellIfRequired(tableSlot, tableAttributes, conversionApi);
            }
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }
        } // Cleanup: Ensure that thead & tbody sections are removed if left empty after moving rows. See #6437, #6391.


      removeTableSectionIfEmpty('thead', viewTable, conversionApi);
      removeTableSectionIfEmpty('tbody', viewTable, conversionApi);

      function isBetween(index, lower, upper) {
        return index > lower && index < upper;
      }
    });
  };
}
/**
 * Conversion helper that acts on heading column table attribute change.
 *
 * Depending on changed attributes this converter will rename `<td` to `<th>` elements or vice versa depending on the cell column index.
 *
 * @returns {Function} Conversion helper.
 */

function downcastTableHeadingColumnsChange() {
  return function (dispatcher) {
    return dispatcher.on('attribute:headingColumns:table', function (evt, data, conversionApi) {
      var table = data.item;

      if (!conversionApi.consumable.consume(data.item, evt.name)) {
        return;
      }

      var tableAttributes = {
        headingRows: table.getAttribute('headingRows') || 0,
        headingColumns: table.getAttribute('headingColumns') || 0
      };
      var oldColumns = data.attributeOldValue;
      var newColumns = data.attributeNewValue;
      var lastColumnToCheck = (oldColumns > newColumns ? oldColumns : newColumns) - 1;

      var _iterator8 = _createForOfIteratorHelper(new tablewalker_TableWalker(table, {
        endColumn: lastColumnToCheck
      })),
          _step8;

      try {
        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
          var tableSlot = _step8.value;
          renameViewTableCellIfRequired(tableSlot, tableAttributes, conversionApi);
        }
      } catch (err) {
        _iterator8.e(err);
      } finally {
        _iterator8.f();
      }
    });
  };
}
/**
 * Conversion helper that acts on a removed row.
 *
 * @returns {Function} Conversion helper.
 */

function downcastRemoveRow() {
  return function (dispatcher) {
    return dispatcher.on('remove:tableRow', function (evt, data, conversionApi) {
      // Prevent default remove converter.
      evt.stop();
      var viewWriter = conversionApi.writer;
      var mapper = conversionApi.mapper;
      var viewStart = mapper.toViewPosition(data.position).getLastMatchingPosition(function (value) {
        return !value.item.is('tr');
      });
      var viewItem = viewStart.nodeAfter;
      var tableSection = viewItem.parent;
      var viewTable = tableSection.parent; // Remove associated <tr> from the view.

      var removeRange = viewWriter.createRangeOn(viewItem);
      var removed = viewWriter.remove(removeRange);

      var _iterator9 = _createForOfIteratorHelper(viewWriter.createRangeIn(removed).getItems()),
          _step9;

      try {
        for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
          var child = _step9.value;
          mapper.unbindViewElement(child);
        } // Cleanup: Ensure that thead & tbody sections are removed if left empty after removing rows. See #6437, #6391.

      } catch (err) {
        _iterator9.e(err);
      } finally {
        _iterator9.f();
      }

      removeTableSectionIfEmpty('thead', viewTable, conversionApi);
      removeTableSectionIfEmpty('tbody', viewTable, conversionApi);
    }, {
      priority: 'higher'
    });
  };
} // Converts a given {@link module:engine/view/element~Element} to a table widget:
// * Adds a {@link module:engine/view/element~Element#_setCustomProperty custom property} allowing to recognize the table widget element.
// * Calls the {@link module:widget/utils~toWidget} function with the proper element's label creator.
//
// @param {module:engine/view/element~Element} viewElement
// @param {module:engine/view/downcastwriter~DowncastWriter} writer An instance of the view writer.
// @param {String} label The element's label. It will be concatenated with the table `alt` attribute if one is present.
// @returns {module:engine/view/element~Element}

function toTableWidget(viewElement, writer) {
  writer.setCustomProperty('table', true, viewElement);
  return toWidget(viewElement, writer, {
    hasSelectionHandle: true
  });
} // Renames an existing table cell in the view to a given element name.
//
// **Note** This method will not do anything if a view table cell has not been converted yet.
//
// @param {module:engine/model/element~Element} tableCell
// @param {String} desiredCellElementName
// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi


function renameViewTableCell(tableCell, desiredCellElementName, conversionApi) {
  var viewWriter = conversionApi.writer;
  var viewCell = conversionApi.mapper.toViewElement(tableCell); // View cell might be not yet converted - skip it as it will be properly created by cell converter later on.

  if (!viewCell) {
    return;
  }

  var editable = viewWriter.createEditableElement(desiredCellElementName, viewCell.getAttributes());
  var renamedCell = toWidgetEditable(editable, viewWriter);
  setHighlightHandling(renamedCell, viewWriter, function (element, descriptor, writer) {
    return writer.addClass(normalizeToArray(descriptor.classes), element);
  }, function (element, descriptor, writer) {
    return writer.removeClass(normalizeToArray(descriptor.classes), element);
  });
  viewWriter.insert(viewWriter.createPositionAfter(viewCell), renamedCell);
  viewWriter.move(viewWriter.createRangeIn(viewCell), viewWriter.createPositionAt(renamedCell, 0));
  viewWriter.remove(viewWriter.createRangeOn(viewCell));
  conversionApi.mapper.unbindViewElement(viewCell);
  conversionApi.mapper.bindElements(tableCell, renamedCell);
} // Renames a table cell element in the view according to its location in the table.
//
// @param {module:table/tablewalker~TableSlot} tableSlot
// @param {{headingColumns, headingRows}} tableAttributes
// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi


function renameViewTableCellIfRequired(tableSlot, tableAttributes, conversionApi) {
  var cell = tableSlot.cell; // Check whether current columnIndex is overlapped by table cells from previous rows.

  var desiredCellElementName = getCellElementName(tableSlot, tableAttributes);
  var viewCell = conversionApi.mapper.toViewElement(cell); // If in single change we're converting attribute changes and inserting cell the table cell might not be inserted into view
  // because of child conversion is done after parent.

  if (viewCell && viewCell.name !== desiredCellElementName) {
    renameViewTableCell(cell, desiredCellElementName, conversionApi);
  }
} // Creates a table cell element in the view.
//
// @param {module:table/tablewalker~TableSlot} tableSlot
// @param {module:engine/view/position~Position} insertPosition
// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi


function createViewTableCellElement(tableSlot, tableAttributes, insertPosition, conversionApi, options) {
  var asWidget = options && options.asWidget;
  var cellElementName = getCellElementName(tableSlot, tableAttributes);
  var cellElement = asWidget ? toWidgetEditable(conversionApi.writer.createEditableElement(cellElementName), conversionApi.writer) : conversionApi.writer.createContainerElement(cellElementName);

  if (asWidget) {
    setHighlightHandling(cellElement, conversionApi.writer, function (element, descriptor, writer) {
      return writer.addClass(normalizeToArray(descriptor.classes), element);
    }, function (element, descriptor, writer) {
      return writer.removeClass(normalizeToArray(descriptor.classes), element);
    });
  }

  var tableCell = tableSlot.cell;
  var firstChild = tableCell.getChild(0);
  var isSingleParagraph = tableCell.childCount === 1 && firstChild.name === 'paragraph';
  conversionApi.writer.insert(insertPosition, cellElement);

  if (isSingleParagraph && !hasAnyAttribute(firstChild)) {
    var innerParagraph = tableCell.getChild(0);
    var paragraphInsertPosition = conversionApi.writer.createPositionAt(cellElement, 'end');
    conversionApi.consumable.consume(innerParagraph, 'insert');

    if (asWidget) {
      // Use display:inline-block to force Chrome/Safari to limit text mutations to this element.
      // See #6062.
      var fakeParagraph = conversionApi.writer.createContainerElement('span', {
        style: 'display:inline-block'
      });
      conversionApi.mapper.bindElements(innerParagraph, fakeParagraph);
      conversionApi.writer.insert(paragraphInsertPosition, fakeParagraph);
      conversionApi.mapper.bindElements(tableCell, cellElement);
    } else {
      conversionApi.mapper.bindElements(tableCell, cellElement);
      conversionApi.mapper.bindElements(innerParagraph, cellElement);
    }
  } else {
    conversionApi.mapper.bindElements(tableCell, cellElement);
  }
} // Creates a `<tr>` view element.
//
// @param {module:engine/view/element~Element} tableElement
// @param {module:engine/model/element~Element} tableRow
// @param {Number} rowIndex
// @param {{headingColumns, headingRows}} tableAttributes
// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi
// @returns {module:engine/view/element~Element}


function createTr(tableElement, tableRow, rowIndex, tableAttributes, conversionApi) {
  // Will always consume since we're converting <tableRow> element from a parent <table>.
  conversionApi.consumable.consume(tableRow, 'insert');
  var trElement = tableRow.isEmpty ? conversionApi.writer.createEmptyElement('tr') : conversionApi.writer.createContainerElement('tr');
  conversionApi.mapper.bindElements(tableRow, trElement);
  var headingRows = tableAttributes.headingRows;
  var tableSection = getOrCreateTableSection(getSectionName(rowIndex, tableAttributes), tableElement, conversionApi);
  var offset = headingRows > 0 && rowIndex >= headingRows ? rowIndex - headingRows : rowIndex;
  var position = conversionApi.writer.createPositionAt(tableSection, offset);
  conversionApi.writer.insert(position, trElement);
  return trElement;
} // Returns `th` for heading cells and `td` for other cells for the current table walker value.
//
// @param {module:table/tablewalker~TableSlot} tableSlot
// @param {{headingColumns, headingRows}} tableAttributes
// @returns {String}


function getCellElementName(tableSlot, tableAttributes) {
  var row = tableSlot.row,
      column = tableSlot.column;
  var headingColumns = tableAttributes.headingColumns,
      headingRows = tableAttributes.headingRows; // Column heading are all tableCells in the first `columnHeading` rows.

  var isColumnHeading = headingRows && headingRows > row; // So a whole row gets <th> element.

  if (isColumnHeading) {
    return 'th';
  } // Row heading are tableCells which columnIndex is lower then headingColumns.


  var isRowHeading = headingColumns && headingColumns > column;
  return isRowHeading ? 'th' : 'td';
} // Returns the table section name for the current table walker value.
//
// @param {Number} row
// @param {{headingColumns, headingRows}} tableAttributes
// @returns {String}


function getSectionName(row, tableAttributes) {
  return row < tableAttributes.headingRows ? 'thead' : 'tbody';
} // Creates or returns an existing `<tbody>` or `<thead>` element with caching.
//
// @param {String} sectionName
// @param {module:engine/view/element~Element} viewTable
// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi
// @param {Object} cachedTableSection An object that stores cached elements.
// @returns {module:engine/view/containerelement~ContainerElement}


function getOrCreateTableSection(sectionName, viewTable, conversionApi) {
  var viewTableSection = getExistingTableSectionElement(sectionName, viewTable);
  return viewTableSection ? viewTableSection : createTableSection(sectionName, viewTable, conversionApi);
} // Finds an existing `<tbody>` or `<thead>` element or returns undefined.
//
// @param {String} sectionName
// @param {module:engine/view/element~Element} tableElement
// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi


function getExistingTableSectionElement(sectionName, tableElement) {
  var _iterator10 = _createForOfIteratorHelper(tableElement.getChildren()),
      _step10;

  try {
    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
      var tableSection = _step10.value;

      if (tableSection.name == sectionName) {
        return tableSection;
      }
    }
  } catch (err) {
    _iterator10.e(err);
  } finally {
    _iterator10.f();
  }
} // Creates a table section at the end of the table.
//
// @param {String} sectionName
// @param {module:engine/view/element~Element} tableElement
// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi
// @returns {module:engine/view/containerelement~ContainerElement}


function createTableSection(sectionName, tableElement, conversionApi) {
  var tableChildElement = conversionApi.writer.createContainerElement(sectionName);
  var insertPosition = conversionApi.writer.createPositionAt(tableElement, sectionName == 'tbody' ? 'end' : 0);
  conversionApi.writer.insert(insertPosition, tableChildElement);
  return tableChildElement;
} // Removes an existing `<tbody>` or `<thead>` element if it is empty.
//
// @param {String} sectionName
// @param {module:engine/view/element~Element} tableElement
// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi


function removeTableSectionIfEmpty(sectionName, tableElement, conversionApi) {
  var tableSection = getExistingTableSectionElement(sectionName, tableElement);

  if (tableSection && tableSection.childCount === 0) {
    conversionApi.writer.remove(conversionApi.writer.createRangeOn(tableSection));
  }
} // Moves view table rows associated with passed model rows to the provided table section element.
//
// **Note**: This method will skip not converted table rows.
//
// @param {Array.<module:engine/model/element~Element>} rowsToMove
// @param {module:engine/view/element~Element} viewTableSection
// @param {module:engine/conversion/downcastdispatcher~DowncastConversionApi} conversionApi
// @param {Number|'end'|'before'|'after'} offset Offset or one of the flags.


function moveViewRowsToTableSection(rowsToMove, viewTableSection, conversionApi, offset) {
  var _iterator11 = _createForOfIteratorHelper(rowsToMove),
      _step11;

  try {
    for (_iterator11.s(); !(_step11 = _iterator11.n()).done;) {
      var tableRow = _step11.value;
      var viewTableRow = conversionApi.mapper.toViewElement(tableRow); // View table row might be not yet converted - skip it as it will be properly created by cell converter later on.

      if (viewTableRow) {
        conversionApi.writer.move(conversionApi.writer.createRangeOn(viewTableRow), conversionApi.writer.createPositionAt(viewTableSection, offset));
      }
    }
  } catch (err) {
    _iterator11.e(err);
  } finally {
    _iterator11.f();
  }
} // Finds a '<table>' element inside the `<figure>` widget.
//
// @param {module:engine/view/element~Element} viewFigure


function getViewTable(viewFigure) {
  var _iterator12 = _createForOfIteratorHelper(viewFigure.getChildren()),
      _step12;

  try {
    for (_iterator12.s(); !(_step12 = _iterator12.n()).done;) {
      var child = _step12.value;

      if (child.name === 'table') {
        return child;
      }
    }
  } catch (err) {
    _iterator12.e(err);
  } finally {
    _iterator12.f();
  }
} // Checks if an element has any attributes set.
//
// @param {module:engine/model/element~Element element
// @returns {Boolean}


function hasAnyAttribute(element) {
  return !!_toConsumableArray(element.getAttributeKeys()).length;
}

function normalizeToArray(classes) {
  return Array.isArray(classes) ? classes : [classes];
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/commands/inserttablecommand.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/commands/inserttablecommand
 */


/**
 * The insert table command.
 *
 * The command is registered by {@link module:table/tableediting~TableEditing} as the `'insertTable'` editor command.
 *
 * To insert a table at the current selection, execute the command and specify the dimensions:
 *
 *		editor.execute( 'insertTable', { rows: 20, columns: 5 } );
 *
 * @extends module:core/command~Command
 */

var inserttablecommand_InsertTableCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(InsertTableCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(InsertTableCommand);

  function InsertTableCommand() {
    Object(classCallCheck["a" /* default */])(this, InsertTableCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(InsertTableCommand, [{
    key: "refresh",

    /**
     * @inheritDoc
     */
    value: function refresh() {
      var model = this.editor.model;
      var selection = model.document.selection;
      var schema = model.schema;
      var validParent = getInsertTableParent(selection.getFirstPosition());
      this.isEnabled = schema.checkChild(validParent, 'table');
    }
    /**
     * Executes the command.
     *
     * Inserts a table with the given number of rows and columns into the editor.
     *
     * @param {Object} options
     * @param {Number} [options.rows=2] The number of rows to create in the inserted table.
     * @param {Number} [options.columns=2] The number of columns to create in the inserted table.
     * @fires execute
     */

  }, {
    key: "execute",
    value: function execute() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var model = this.editor.model;
      var selection = model.document.selection;
      var tableUtils = this.editor.plugins.get('TableUtils');
      var rows = parseInt(options.rows) || 2;
      var columns = parseInt(options.columns) || 2;
      var insertPosition = findOptimalInsertionPosition(selection, model);
      model.change(function (writer) {
        var table = tableUtils.createTable(writer, rows, columns);
        model.insertContent(table, insertPosition);
        writer.setSelection(writer.createPositionAt(table.getNodeByPath([0, 0, 0]), 0));
      });
    }
  }]);

  return InsertTableCommand;
}(command_Command); // Returns valid parent to insert table
//
// @param {module:engine/model/position} position




function getInsertTableParent(position) {
  var parent = position.parent;
  return parent === parent.root ? parent : parent.parent;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/utils/selection.js













/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/utils/selection
 */


/**
 * Returns all model table cells that are fully selected (from the outside)
 * within the provided model selection's ranges.
 *
 * To obtain the cells selected from the inside, use
 * {@link module:table/utils/selection~getTableCellsContainingSelection}.
 *
 * @param {module:engine/model/selection~Selection} selection
 * @returns {Array.<module:engine/model/element~Element>}
 */

function selection_getSelectedTableCells(selection) {
  var cells = [];

  var _iterator = _createForOfIteratorHelper(sortRanges(selection.getRanges())),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var range = _step.value;
      var element = range.getContainedElement();

      if (element && element.is('tableCell')) {
        cells.push(element);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return cells;
}
/**
 * Returns all model table cells that the provided model selection's ranges
 * {@link module:engine/model/range~Range#start} inside.
 *
 * To obtain the cells selected from the outside, use
 * {@link module:table/utils/selection~getSelectedTableCells}.
 *
 * @param {module:engine/model/selection~Selection} selection
 * @returns {Array.<module:engine/model/element~Element>}
 */

function getTableCellsContainingSelection(selection) {
  var cells = [];

  var _iterator2 = _createForOfIteratorHelper(selection.getRanges()),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var range = _step2.value;
      var cellWithSelection = common_findAncestor('tableCell', range.start);

      if (cellWithSelection) {
        cells.push(cellWithSelection);
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return cells;
}
/**
 * Returns all model table cells that are either completely selected
 * by selection ranges or host selection range
 * {@link module:engine/model/range~Range#start start positions} inside them.
 *
 * Combines {@link module:table/utils/selection~getTableCellsContainingSelection} and
 * {@link module:table/utils/selection~getSelectedTableCells}.
 *
 * @param {module:engine/model/selection~Selection} selection
 * @returns {Array.<module:engine/model/element~Element>}
 */

function getSelectionAffectedTableCells(selection) {
  var selectedCells = selection_getSelectedTableCells(selection);

  if (selectedCells.length) {
    return selectedCells;
  }

  return getTableCellsContainingSelection(selection);
}
/**
 * Returns an object with the `first` and `last` row index contained in the given `tableCells`.
 *
 *		const selectedTableCells = getSelectedTableCells( editor.model.document.selection );
 *
 *		const { first, last } = getRowIndexes( selectedTableCells );
 *
 *		console.log( `Selected rows: ${ first } to ${ last }` );
 *
 * @param {Array.<module:engine/model/element~Element>} tableCells
 * @returns {Object} Returns an object with the `first` and `last` table row indexes.
 */

function getRowIndexes(tableCells) {
  var indexes = tableCells.map(function (cell) {
    return cell.parent.index;
  });
  return getFirstLastIndexesObject(indexes);
}
/**
 * Returns an object with the `first` and `last` column index contained in the given `tableCells`.
 *
 *		const selectedTableCells = getSelectedTableCells( editor.model.document.selection );
 *
 *		const { first, last } = getColumnIndexes( selectedTableCells );
 *
 *		console.log( `Selected columns: ${ first } to ${ last }` );
 *
 * @param {Array.<module:engine/model/element~Element>} tableCells
 * @returns {Object} Returns an object with the `first` and `last` table column indexes.
 */

function getColumnIndexes(tableCells) {
  var table = common_findAncestor('table', tableCells[0]);

  var tableMap = _toConsumableArray(new tablewalker_TableWalker(table));

  var indexes = tableMap.filter(function (entry) {
    return tableCells.includes(entry.cell);
  }).map(function (entry) {
    return entry.column;
  });
  return getFirstLastIndexesObject(indexes);
}
/**
 * Checks if the selection contains cells that do not exceed rectangular selection.
 *
 * In a table below:
 *
 *		┌───┬───┬───┬───┐
 *		│ a │ b │ c │ d │
 *		├───┴───┼───┤   │
 *		│ e     │ f │   │
 *		│       ├───┼───┤
 *		│       │ g │ h │
 *		└───────┴───┴───┘
 *
 * Valid selections are these which create a solid rectangle (without gaps), such as:
 *   - a, b (two horizontal cells)
 *   - c, f (two vertical cells)
 *   - a, b, e (cell "e" spans over four cells)
 *   - c, d, f (cell d spans over a cell in the row below)
 *
 * While an invalid selection would be:
 *   - a, c (the unselected cell "b" creates a gap)
 *   - f, g, h (cell "d" spans over a cell from the row of "f" cell - thus creates a gap)
 *
 * @param {Array.<module:engine/model/element~Element>} selectedTableCells
 * @param {module:table/tableutils~TableUtils} tableUtils
 * @returns {Boolean}
 */

function isSelectionRectangular(selectedTableCells, tableUtils) {
  if (selectedTableCells.length < 2 || !areCellInTheSameTableSection(selectedTableCells)) {
    return false;
  } // A valid selection is a fully occupied rectangle composed of table cells.
  // Below we will calculate the area of a selected table cells and the area of valid selection.
  // The area of a valid selection is defined by top-left and bottom-right cells.


  var rows = new Set();
  var columns = new Set();
  var areaOfSelectedCells = 0;

  var _iterator3 = _createForOfIteratorHelper(selectedTableCells),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var tableCell = _step3.value;

      var _tableUtils$getCellLo = tableUtils.getCellLocation(tableCell),
          row = _tableUtils$getCellLo.row,
          column = _tableUtils$getCellLo.column;

      var rowspan = parseInt(tableCell.getAttribute('rowspan') || 1);
      var colspan = parseInt(tableCell.getAttribute('colspan') || 1); // Record row & column indexes of current cell.

      rows.add(row);
      columns.add(column); // For cells that spans over multiple rows add also the last row that this cell spans over.

      if (rowspan > 1) {
        rows.add(row + rowspan - 1);
      } // For cells that spans over multiple columns add also the last column that this cell spans over.


      if (colspan > 1) {
        columns.add(column + colspan - 1);
      }

      areaOfSelectedCells += rowspan * colspan;
    } // We can only merge table cells that are in adjacent rows...

  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  var areaOfValidSelection = getBiggestRectangleArea(rows, columns);
  return areaOfValidSelection == areaOfSelectedCells;
} // Helper method to get an object with `first` and `last` indexes from an unsorted array of indexes.

function getFirstLastIndexesObject(indexes) {
  var allIndexesSorted = indexes.sort(function (indexA, indexB) {
    return indexA - indexB;
  });
  var first = allIndexesSorted[0];
  var last = allIndexesSorted[allIndexesSorted.length - 1];
  return {
    first: first,
    last: last
  };
}

function sortRanges(rangesIterator) {
  return Array.from(rangesIterator).sort(compareRangeOrder);
}

function compareRangeOrder(rangeA, rangeB) {
  // Since table cell ranges are disjoint, it's enough to check their start positions.
  var posA = rangeA.start;
  var posB = rangeB.start; // Checking for equal position (returning 0) is not needed because this would be either:
  // a. Intersecting range (not allowed by model)
  // b. Collapsed range on the same position (allowed by model but should not happen).

  return posA.isBefore(posB) ? -1 : 1;
} // Calculates the area of a maximum rectangle that can span over the provided row & column indexes.
//
// @param {Array.<Number>} rows
// @param {Array.<Number>} columns
// @returns {Number}


function getBiggestRectangleArea(rows, columns) {
  var rowsIndexes = Array.from(rows.values());
  var columnIndexes = Array.from(columns.values());
  var lastRow = Math.max.apply(Math, _toConsumableArray(rowsIndexes));
  var firstRow = Math.min.apply(Math, _toConsumableArray(rowsIndexes));
  var lastColumn = Math.max.apply(Math, _toConsumableArray(columnIndexes));
  var firstColumn = Math.min.apply(Math, _toConsumableArray(columnIndexes));
  return (lastRow - firstRow + 1) * (lastColumn - firstColumn + 1);
} // Checks if the selection does not mix a header (column or row) with other cells.
//
// For instance, in the table below valid selections consist of cells with the same letter only.
// So, a-a (same heading row and column) or d-d (body cells) are valid while c-d or a-b are not.
//
//		 header columns
//		  ↓   ↓
//		┌───┬───┬───┬───┐
//		│ a │ a │ b │ b │  ← header row
//		├───┼───┼───┼───┤
//		│ c │ c │ d │ d │
//		├───┼───┼───┼───┤
//		│ c │ c │ d │ d │
//		└───┴───┴───┴───┘


function areCellInTheSameTableSection(tableCells) {
  var table = common_findAncestor('table', tableCells[0]);
  var rowIndexes = getRowIndexes(tableCells);
  var headingRows = parseInt(table.getAttribute('headingRows') || 0); // Calculating row indexes is a bit cheaper so if this check fails we can't merge.

  if (!areIndexesInSameSection(rowIndexes, headingRows)) {
    return false;
  }

  var headingColumns = parseInt(table.getAttribute('headingColumns') || 0);
  var columnIndexes = getColumnIndexes(tableCells); // Similarly cells must be in same column section.

  return areIndexesInSameSection(columnIndexes, headingColumns);
} // Unified check if table rows/columns indexes are in the same heading/body section.


function areIndexesInSameSection(_ref, headingSectionSize) {
  var first = _ref.first,
      last = _ref.last;
  var firstCellIsInHeading = first < headingSectionSize;
  var lastCellIsInHeading = last < headingSectionSize;
  return firstCellIsInHeading === lastCellIsInHeading;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/commands/insertrowcommand.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/commands/insertrowcommand
 */



/**
 * The insert row command.
 *
 * The command is registered by {@link module:table/tableediting~TableEditing} as the `'insertTableRowBelow'` and
 * `'insertTableRowAbove'` editor commands.
 *
 * To insert a row below the selected cell, execute the following command:
 *
 *		editor.execute( 'insertTableRowBelow' );
 *
 * To insert a row above the selected cell, execute the following command:
 *
 *		editor.execute( 'insertTableRowAbove' );
 *
 * @extends module:core/command~Command
 */

var insertrowcommand_InsertRowCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(InsertRowCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(InsertRowCommand);

  /**
   * Creates a new `InsertRowCommand` instance.
   *
   * @param {module:core/editor/editor~Editor} editor The editor on which this command will be used.
   * @param {Object} options
   * @param {String} [options.order="below"] The order of insertion relative to the row in which the caret is located.
   * Possible values: `"above"` and `"below"`.
   */
  function InsertRowCommand(editor) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    Object(classCallCheck["a" /* default */])(this, InsertRowCommand);

    _this = _super.call(this, editor);
    /**
     * The order of insertion relative to the row in which the caret is located.
     *
     * @readonly
     * @member {String} module:table/commands/insertrowcommand~InsertRowCommand#order
     */

    _this.order = options.order || 'below';
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(InsertRowCommand, [{
    key: "refresh",
    value: function refresh() {
      var selection = this.editor.model.document.selection;
      var tableParent = common_findAncestor('table', selection.getFirstPosition());
      this.isEnabled = !!tableParent;
    }
    /**
     * Executes the command.
     *
     * Depending on the command's {@link #order} value, it inserts a row `'below'` or `'above'` the row in which selection is set.
     *
     * @fires execute
     */

  }, {
    key: "execute",
    value: function execute() {
      var editor = this.editor;
      var selection = editor.model.document.selection;
      var tableUtils = editor.plugins.get('TableUtils');
      var insertAbove = this.order === 'above';
      var affectedTableCells = getSelectionAffectedTableCells(selection);
      var rowIndexes = getRowIndexes(affectedTableCells);
      var row = insertAbove ? rowIndexes.first : rowIndexes.last;
      var table = common_findAncestor('table', affectedTableCells[0]);
      tableUtils.insertRows(table, {
        at: insertAbove ? row : row + 1,
        copyStructureFromAbove: !insertAbove
      });
    }
  }]);

  return InsertRowCommand;
}(command_Command);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/commands/insertcolumncommand.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/commands/insertcolumncommand
 */



/**
 * The insert column command.
 *
 * The command is registered by {@link module:table/tableediting~TableEditing} as the `'insertTableColumnLeft'` and
 * `'insertTableColumnRight'` editor commands.
 *
 * To insert a column to the left of the selected cell, execute the following command:
 *
 *		editor.execute( 'insertTableColumnLeft' );
 *
 * To insert a column to the right of the selected cell, execute the following command:
 *
 *		editor.execute( 'insertTableColumnRight' );
 *
 * @extends module:core/command~Command
 */

var insertcolumncommand_InsertColumnCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(InsertColumnCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(InsertColumnCommand);

  /**
   * Creates a new `InsertColumnCommand` instance.
   *
   * @param {module:core/editor/editor~Editor} editor An editor on which this command will be used.
   * @param {Object} options
   * @param {String} [options.order="right"] The order of insertion relative to the column in which the caret is located.
   * Possible values: `"left"` and `"right"`.
   */
  function InsertColumnCommand(editor) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    Object(classCallCheck["a" /* default */])(this, InsertColumnCommand);

    _this = _super.call(this, editor);
    /**
     * The order of insertion relative to the column in which the caret is located.
     *
     * @readonly
     * @member {String} module:table/commands/insertcolumncommand~InsertColumnCommand#order
     */

    _this.order = options.order || 'right';
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(InsertColumnCommand, [{
    key: "refresh",
    value: function refresh() {
      var selection = this.editor.model.document.selection;
      var tableParent = common_findAncestor('table', selection.getFirstPosition());
      this.isEnabled = !!tableParent;
    }
    /**
     * Executes the command.
     *
     * Depending on the command's {@link #order} value, it inserts a column to the `'left'` or `'right'` of the column
     * in which the selection is set.
     *
     * @fires execute
     */

  }, {
    key: "execute",
    value: function execute() {
      var editor = this.editor;
      var selection = editor.model.document.selection;
      var tableUtils = editor.plugins.get('TableUtils');
      var insertBefore = this.order === 'left';
      var affectedTableCells = getSelectionAffectedTableCells(selection);
      var columnIndexes = getColumnIndexes(affectedTableCells);
      var column = insertBefore ? columnIndexes.first : columnIndexes.last;
      var table = common_findAncestor('table', affectedTableCells[0]);
      tableUtils.insertColumns(table, {
        columns: 1,
        at: insertBefore ? column : column + 1
      });
    }
  }]);

  return InsertColumnCommand;
}(command_Command);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/commands/splitcellcommand.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/commands/splitcellcommand
 */


/**
 * The split cell command.
 *
 * The command is registered by {@link module:table/tableediting~TableEditing} as the `'splitTableCellVertically'`
 * and `'splitTableCellHorizontally'`  editor commands.
 *
 * You can split any cell vertically or horizontally by executing this command. For example, to split the selected table cell vertically:
 *
 *		editor.execute( 'splitTableCellVertically' );
 *
 * @extends module:core/command~Command
 */

var splitcellcommand_SplitCellCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(SplitCellCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(SplitCellCommand);

  /**
   * Creates a new `SplitCellCommand` instance.
   *
   * @param {module:core/editor/editor~Editor} editor The editor on which this command will be used.
   * @param {Object} options
   * @param {String} options.direction Indicates whether the command should split cells `'horizontally'` or `'vertically'`.
   */
  function SplitCellCommand(editor) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    Object(classCallCheck["a" /* default */])(this, SplitCellCommand);

    _this = _super.call(this, editor);
    /**
     * The direction that indicates which cell will be split.
     *
     * @readonly
     * @member {String} #direction
     */

    _this.direction = options.direction || 'horizontally';
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(SplitCellCommand, [{
    key: "refresh",
    value: function refresh() {
      var selectedCells = getSelectionAffectedTableCells(this.editor.model.document.selection);
      this.isEnabled = selectedCells.length === 1;
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "execute",
    value: function execute() {
      var tableCell = getSelectionAffectedTableCells(this.editor.model.document.selection)[0];
      var isHorizontal = this.direction === 'horizontally';
      var tableUtils = this.editor.plugins.get('TableUtils');

      if (isHorizontal) {
        tableUtils.splitCellHorizontally(tableCell, 2);
      } else {
        tableUtils.splitCellVertically(tableCell, 2);
      }
    }
  }]);

  return SplitCellCommand;
}(command_Command);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/utils/structure.js











/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/utils/structure
 */


/**
 * Returns a cropped table according to given dimensions.

 * To return a cropped table that starts at first row and first column and end in third row and column:
 *
 *		const croppedTable = cropTableToDimensions( table, {
 *			startRow: 1,
 *			endRow: 1,
 *			startColumn: 3,
 *			endColumn: 3
 *		}, writer );
 *
 * Calling the code above for the table below:
 *
 *		      0   1   2   3   4                      0   1   2
 *		    ┌───┬───┬───┬───┬───┐
 *		 0  │ a │ b │ c │ d │ e │
 *		    ├───┴───┤   ├───┴───┤                  ┌───┬───┬───┐
 *		 1  │ f     │   │ g     │                  │   │   │ g │  0
 *		    ├───┬───┴───┼───┬───┤   will return:   ├───┴───┼───┤
 *		 2  │ h │ i     │ j │ k │                  │ i     │ j │  1
 *		    ├───┤       ├───┤   │                  │       ├───┤
 *		 3  │ l │       │ m │   │                  │       │ m │  2
 *		    ├───┼───┬───┤   ├───┤                  └───────┴───┘
 *		 4  │ n │ o │ p │   │ q │
 *		    └───┴───┴───┴───┴───┘
 *
 * @param {module:engine/model/element~Element} sourceTable
 * @param {Object} cropDimensions
 * @param {Number} cropDimensions.startRow
 * @param {Number} cropDimensions.startColumn
 * @param {Number} cropDimensions.endRow
 * @param {Number} cropDimensions.endColumn
 * @param {module:engine/model/writer~Writer} writer
 * @returns {module:engine/model/element~Element}
 */

function cropTableToDimensions(sourceTable, cropDimensions, writer) {
  var startRow = cropDimensions.startRow,
      startColumn = cropDimensions.startColumn,
      endRow = cropDimensions.endRow,
      endColumn = cropDimensions.endColumn; // Create empty table with empty rows equal to crop height.

  var croppedTable = writer.createElement('table');
  var cropHeight = endRow - startRow + 1;

  for (var i = 0; i < cropHeight; i++) {
    writer.insertElement('tableRow', croppedTable, 'end');
  }

  var tableMap = _toConsumableArray(new tablewalker_TableWalker(sourceTable, {
    startRow: startRow,
    endRow: endRow,
    startColumn: startColumn,
    endColumn: endColumn,
    includeAllSlots: true
  })); // Iterate over source table slots (including empty - spanned - ones).


  var _iterator = _createForOfIteratorHelper(tableMap),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _step$value = _step.value,
          sourceRow = _step$value.row,
          sourceColumn = _step$value.column,
          tableCell = _step$value.cell,
          isAnchor = _step$value.isAnchor,
          cellAnchorRow = _step$value.cellAnchorRow,
          cellAnchorColumn = _step$value.cellAnchorColumn;
      // Row index in cropped table.
      var rowInCroppedTable = sourceRow - startRow;
      var row = croppedTable.getChild(rowInCroppedTable); // For empty slots: fill the gap with empty table cell.

      if (!isAnchor) {
        // But fill the gap only if the spanning cell is anchored outside cropped area.
        // In the table from method jsdoc those cells are: "c" & "f".
        if (cellAnchorRow < startRow || cellAnchorColumn < startColumn) {
          createEmptyTableCell(writer, writer.createPositionAt(row, 'end'));
        }
      } // Otherwise clone the cell with all children and trim if it exceeds cropped area.
      else {
          var tableCellCopy = writer.cloneElement(tableCell);
          writer.append(tableCellCopy, row); // Trim table if it exceeds cropped area.
          // In the table from method jsdoc those cells are: "g" & "m".

          trimTableCellIfNeeded(tableCellCopy, sourceRow, sourceColumn, endRow, endColumn, writer);
        }
    } // Adjust heading rows & columns in cropped table if crop selection includes headings parts.

  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  addHeadingsToCroppedTable(croppedTable, sourceTable, startRow, startColumn, writer);
  return croppedTable;
}
/**
 * Returns slot info of cells that starts above and overlaps a given row.
 *
 * In a table below, passing `overlapRow = 3`
 *
 *		   ┌───┬───┬───┬───┬───┐
 *		0  │ a │ b │ c │ d │ e │
 *		   │   ├───┼───┼───┼───┤
 *		1  │   │ f │ g │ h │ i │
 *		   ├───┤   ├───┼───┤   │
 *		2  │ j │   │ k │ l │   │
 *		   │   │   │   ├───┼───┤
 *		3  │   │   │   │ m │ n │  <- overlap row to check
 *		   ├───┼───┤   │   ├───│
 *		4  │ o │ p │   │   │ q │
 *		   └───┴───┴───┴───┴───┘
 *
 * will return slot info for cells: "j", "f", "k".
 *
 * @param {module:engine/model/element~Element} table The table to check.
 * @param {Number} overlapRow The index of the row to check.
 * @param {Number} [startRow=0] A row to start analysis. Use it when it is known that the cells above that row will not overlap.
 * @returns {Array.<module:table/tablewalker~TableSlot>}
 */

function getVerticallyOverlappingCells(table, overlapRow) {
  var startRow = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  var cells = [];
  var tableWalker = new tablewalker_TableWalker(table, {
    startRow: startRow,
    endRow: overlapRow - 1
  });

  var _iterator2 = _createForOfIteratorHelper(tableWalker),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var slotInfo = _step2.value;
      var row = slotInfo.row,
          cellHeight = slotInfo.cellHeight;
      var cellEndRow = row + cellHeight - 1;

      if (row < overlapRow && overlapRow <= cellEndRow) {
        cells.push(slotInfo);
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return cells;
}
/**
 * Splits the table cell horizontally.
 *
 * @param {module:engine/model/element~Element} tableCell
 * @param {Number} splitRow
 * @param {module:engine/model/writer~Writer} writer
 */

function splitHorizontally(tableCell, splitRow, writer) {
  var tableRow = tableCell.parent;
  var table = tableRow.parent;
  var rowIndex = tableRow.index;
  var rowspan = parseInt(tableCell.getAttribute('rowspan'));
  var newRowspan = splitRow - rowIndex;
  var newCellAttributes = {};
  var newCellRowSpan = rowspan - newRowspan;

  if (newCellRowSpan > 1) {
    newCellAttributes.rowspan = newCellRowSpan;
  }

  var colspan = parseInt(tableCell.getAttribute('colspan') || 1);

  if (colspan > 1) {
    newCellAttributes.colspan = colspan;
  }

  var startRow = rowIndex;
  var endRow = startRow + newRowspan;

  var tableMap = _toConsumableArray(new tablewalker_TableWalker(table, {
    startRow: startRow,
    endRow: endRow,
    includeAllSlots: true
  }));

  var columnIndex;

  var _iterator3 = _createForOfIteratorHelper(tableMap),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var tableSlot = _step3.value;
      var row = tableSlot.row,
          column = tableSlot.column,
          cell = tableSlot.cell;

      if (cell === tableCell && columnIndex === undefined) {
        columnIndex = column;
      }

      if (columnIndex !== undefined && columnIndex === column && row === endRow) {
        createEmptyTableCell(writer, tableSlot.getPositionBefore(), newCellAttributes);
      }
    } // Update the rowspan attribute after updating table.

  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  updateNumericAttribute('rowspan', newRowspan, tableCell, writer);
}
/**
 * Returns slot info of cells that starts before and overlaps a given column.
 *
 * In a table below, passing `overlapColumn = 3`
 *
 *		  0   1   2   3   4
 *		┌───────┬───────┬───┐
 *		│ a     │ b     │ c │
 *		│───┬───┴───────┼───┤
 *		│ d │ e         │ f │
 *		├───┼───┬───────┴───┤
 *		│ g │ h │ i         │
 *		├───┼───┼───┬───────┤
 *		│ j │ k │ l │ m     │
 *		├───┼───┴───┼───┬───┤
 *		│ n │ o     │ p │ q │
 *		└───┴───────┴───┴───┘
 *		              ^
 *		              Overlap column to check
 *
 * will return slot info for cells: "b", "e", "i".
 *
 * @param {module:engine/model/element~Element} table The table to check.
 * @param {Number} overlapColumn The index of the column to check.
 * @returns {Array.<module:table/tablewalker~TableSlot>}
 */

function getHorizontallyOverlappingCells(table, overlapColumn) {
  var cellsToSplit = [];
  var tableWalker = new tablewalker_TableWalker(table);

  var _iterator4 = _createForOfIteratorHelper(tableWalker),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var slotInfo = _step4.value;
      var column = slotInfo.column,
          cellWidth = slotInfo.cellWidth;
      var cellEndColumn = column + cellWidth - 1;

      if (column < overlapColumn && overlapColumn <= cellEndColumn) {
        cellsToSplit.push(slotInfo);
      }
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return cellsToSplit;
}
/**
 * Splits the table cell vertically.
 *
 * @param {module:engine/model/element~Element} tableCell
 * @param {Number} columnIndex The table cell column index.
 * @param {Number} splitColumn The index of column to split cell on.
 * @param {module:engine/model/writer~Writer} writer
 */

function splitVertically(tableCell, columnIndex, splitColumn, writer) {
  var colspan = parseInt(tableCell.getAttribute('colspan'));
  var newColspan = splitColumn - columnIndex;
  var newCellAttributes = {};
  var newCellColSpan = colspan - newColspan;

  if (newCellColSpan > 1) {
    newCellAttributes.colspan = newCellColSpan;
  }

  var rowspan = parseInt(tableCell.getAttribute('rowspan') || 1);

  if (rowspan > 1) {
    newCellAttributes.rowspan = rowspan;
  }

  createEmptyTableCell(writer, writer.createPositionAfter(tableCell), newCellAttributes); // Update the colspan attribute after updating table.

  updateNumericAttribute('colspan', newColspan, tableCell, writer);
}
/**
 * Adjusts table cell dimensions to not exceed limit row and column.
 *
 * If table cell width (or height) covers a column (or row) that is after a limit column (or row)
 * this method will trim "colspan" (or "rowspan") attribute so the table cell will fit in a defined limits.
 *
 * @param {module:engine/model/element~Element} tableCell
 * @param {Number} cellRow
 * @param {Number} cellColumn
 * @param {Number} limitRow
 * @param {Number} limitColumn
 * @param {module:engine/model/writer~Writer} writer
 */

function trimTableCellIfNeeded(tableCell, cellRow, cellColumn, limitRow, limitColumn, writer) {
  var colspan = parseInt(tableCell.getAttribute('colspan') || 1);
  var rowspan = parseInt(tableCell.getAttribute('rowspan') || 1);
  var endColumn = cellColumn + colspan - 1;

  if (endColumn > limitColumn) {
    var trimmedSpan = limitColumn - cellColumn + 1;
    updateNumericAttribute('colspan', trimmedSpan, tableCell, writer, 1);
  }

  var endRow = cellRow + rowspan - 1;

  if (endRow > limitRow) {
    var _trimmedSpan = limitRow - cellRow + 1;

    updateNumericAttribute('rowspan', _trimmedSpan, tableCell, writer, 1);
  }
} // Sets proper heading attributes to a cropped table.

function addHeadingsToCroppedTable(croppedTable, sourceTable, startRow, startColumn, writer) {
  var headingRows = parseInt(sourceTable.getAttribute('headingRows') || 0);

  if (headingRows > 0) {
    var headingRowsInCrop = headingRows - startRow;
    updateNumericAttribute('headingRows', headingRowsInCrop, croppedTable, writer, 0);
  }

  var headingColumns = parseInt(sourceTable.getAttribute('headingColumns') || 0);

  if (headingColumns > 0) {
    var headingColumnsInCrop = headingColumns - startColumn;
    updateNumericAttribute('headingColumns', headingColumnsInCrop, croppedTable, writer, 0);
  }
}
/**
 * Removes columns that have no cells anchored.
 *
 * In table below:
 *
 *     +----+----+----+----+----+----+----+
 *     | 00 | 01      | 03 | 04      | 06 |
 *     +----+----+----+----+         +----+
 *     | 10 | 11      | 13 |         | 16 |
 *     +----+----+----+----+----+----+----+
 *     | 20 | 21      | 23 | 24      | 26 |
 *     +----+----+----+----+----+----+----+
 *                  ^--- empty ---^
 *
 * Will remove columns 2 and 5.
 *
 * **Note:** This is a low-level helper method for clearing invalid model state when doing table modifications.
 * To remove a column from a table use {@link module:table/tableutils~TableUtils#removeColumns `TableUtils.removeColumns()`}.
 *
 * @protected
 * @param {module:engine/model/element~Element} table
 * @param {module:table/tableutils~TableUtils} tableUtils
 * @returns {Boolean} True if removed some columns.
 */


function removeEmptyColumns(table, tableUtils) {
  var width = tableUtils.getColumns(table);
  var columnsMap = new Array(width).fill(0);

  var _iterator5 = _createForOfIteratorHelper(new tablewalker_TableWalker(table)),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var column = _step5.value.column;
      columnsMap[column]++;
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }

  var emptyColumns = columnsMap.reduce(function (result, cellsCount, column) {
    return cellsCount ? result : [].concat(_toConsumableArray(result), [column]);
  }, []); // @if CK_DEBUG_TABLE // emptyColumns.length > 0 && console.log( `Removing empty columns: ${ emptyColumns.join( ', ' ) }.` );

  emptyColumns.reverse().forEach(function (column) {
    tableUtils.removeColumns(table, {
      at: column
    });
  });
  return emptyColumns.length > 0;
}
/**
 * Removes rows that have no cells anchored.
 *
 * In table below:
 *
 *     +----+----+----+
 *     | 00 | 01 | 02 |
 *     +----+----+----+
 *     | 10 | 11 | 12 |
 *     +    +    +    +
 *     |    |    |    | <-- empty
 *     +----+----+----+
 *     | 30 | 31 | 32 |
 *     +----+----+----+
 *     | 40      | 42 |
 *     +         +    +
 *     |         |    | <-- empty
 *     +----+----+----+
 *     | 60 | 61 | 62 |
 *     +----+----+----+
 *
 * Will remove rows 2 and 5.
 *
 * **Note:** This is a low-level helper method for clearing invalid model state when doing table modifications.
 * To remove a row from a table use {@link module:table/tableutils~TableUtils#removeRows `TableUtils.removeRows()`}.
 *
 * @protected
 * @param {module:engine/model/element~Element} table
 * @param {module:table/tableutils~TableUtils} tableUtils
 * @param {module:engine/model/batch~Batch|null} [batch] Batch that should be used for removing empty rows.
 * @returns {Boolean} True if removed some rows.
 */

function removeEmptyRows(table, tableUtils, batch) {
  var emptyRows = [];

  for (var rowIndex = 0; rowIndex < table.childCount; rowIndex++) {
    var tableRow = table.getChild(rowIndex);

    if (tableRow.isEmpty) {
      emptyRows.push(rowIndex);
    }
  } // @if CK_DEBUG_TABLE // emptyRows.length > 0 && console.log( `Removing empty rows: ${ emptyRows.join( ', ' ) }.` );


  emptyRows.reverse().forEach(function (row) {
    tableUtils.removeRows(table, {
      at: row,
      batch: batch
    });
  });
  return emptyRows.length > 0;
}
/**
 * Removes rows and columns that have no cells anchored.
 *
 * In table below:
 *
 *     +----+----+----+----+
 *     | 00      | 02      |
 *     +----+----+         +
 *     | 10      |         |
 *     +----+----+----+----+
 *     | 20      | 22 | 23 |
 *     +         +    +    +
 *     |         |    |    | <-- empty row
 *     +----+----+----+----+
 *             ^--- empty column
 *
 * Will remove row 3 and column 1.
 *
 * **Note:** This is a low-level helper method for clearing invalid model state when doing table modifications.
 * To remove a rows from a table use {@link module:table/tableutils~TableUtils#removeRows `TableUtils.removeRows()`} and
 * {@link module:table/tableutils~TableUtils#removeColumns `TableUtils.removeColumns()`} to remove a column.
 *
 * @protected
 * @param {module:engine/model/element~Element} table
 * @param {module:table/tableutils~TableUtils} tableUtils
 * @param {module:engine/model/batch~Batch|null} [batch] Batch that should be used for removing empty rows.
 */

function removeEmptyRowsColumns(table, tableUtils, batch) {
  var removedColumns = removeEmptyColumns(table, tableUtils); // If there was some columns removed then cleaning empty rows was already triggered.

  if (!removedColumns) {
    removeEmptyRows(table, tableUtils, batch);
  }
}
/**
 * Returns adjusted last row index if selection covers part of a row with empty slots (spanned by other cells).
 * The `dimensions.lastRow` is equal to last row index but selection might be bigger.
 *
 * This happens *only* on rectangular selection so we analyze a case like this:
 *
 *        +---+---+---+---+
 *      0 | a | b | c | d |
 *        +   +   +---+---+
 *      1 |   | e | f | g |
 *        +   +---+   +---+
 *      2 |   | h |   | i | <- last row, each cell has rowspan = 2,
 *        +   +   +   +   +    so we need to return 3, not 2
 *      3 |   |   |   |   |
 *        +---+---+---+---+
 *
 * @param {module:engine/model/element~Element} table
 * @param {Object} dimensions
 * @param {Number} dimensions.firstRow
 * @param {Number} dimensions.firstColumn
 * @param {Number} dimensions.lastRow
 * @param {Number} dimensions.lastColumn
 * @returns {Number} Adjusted last row index.
 */

function adjustLastRowIndex(table, dimensions) {
  var lastRowMap = Array.from(new tablewalker_TableWalker(table, {
    startColumn: dimensions.firstColumn,
    endColumn: dimensions.lastColumn,
    row: dimensions.lastRow
  }));
  var everyCellHasSingleRowspan = lastRowMap.every(function (_ref) {
    var cellHeight = _ref.cellHeight;
    return cellHeight === 1;
  }); // It is a "flat" row, so the last row index is OK.

  if (everyCellHasSingleRowspan) {
    return dimensions.lastRow;
  } // Otherwise get any cell's rowspan and adjust the last row index.


  var rowspanAdjustment = lastRowMap[0].cellHeight - 1;
  return dimensions.lastRow + rowspanAdjustment;
}
/**
 * Returns adjusted last column index if selection covers part of a column with empty slots (spanned by other cells).
 * The `dimensions.lastColumn` is equal to last column index but selection might be bigger.
 *
 * This happens *only* on rectangular selection so we analyze a case like this:
 *
 *       0   1   2   3
 *     +---+---+---+---+
 *     | a             |
 *     +---+---+---+---+
 *     | b | c | d     |
 *     +---+---+---+---+
 *     | e     | f     |
 *     +---+---+---+---+
 *     | g | h         |
 *     +---+---+---+---+
 *               ^
 *              last column, each cell has colspan = 2, so we need to return 3, not 2
 *
 * @param {module:engine/model/element~Element} table
 * @param {Object} dimensions
 * @param {Number} dimensions.firstRow
 * @param {Number} dimensions.firstColumn
 * @param {Number} dimensions.lastRow
 * @param {Number} dimensions.lastColumn
 * @returns {Number} Adjusted last column index.
 */

function adjustLastColumnIndex(table, dimensions) {
  var lastColumnMap = Array.from(new tablewalker_TableWalker(table, {
    startRow: dimensions.firstRow,
    endRow: dimensions.lastRow,
    column: dimensions.lastColumn
  }));
  var everyCellHasSingleColspan = lastColumnMap.every(function (_ref2) {
    var cellWidth = _ref2.cellWidth;
    return cellWidth === 1;
  }); // It is a "flat" column, so the last column index is OK.

  if (everyCellHasSingleColspan) {
    return dimensions.lastColumn;
  } // Otherwise get any cell's colspan and adjust the last column index.


  var colspanAdjustment = lastColumnMap[0].cellWidth - 1;
  return dimensions.lastColumn + colspanAdjustment;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/commands/mergecellcommand.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/commands/mergecellcommand
 */





/**
 * The merge cell command.
 *
 * The command is registered by {@link module:table/tableediting~TableEditing} as the `'mergeTableCellRight'`, `'mergeTableCellLeft'`,
 * `'mergeTableCellUp'` and `'mergeTableCellDown'` editor commands.
 *
 * To merge a table cell at the current selection with another cell, execute the command corresponding with the preferred direction.
 *
 * For example, to merge with a cell to the right:
 *
 *		editor.execute( 'mergeTableCellRight' );
 *
 * **Note**: If a table cell has a different [`rowspan`](https://www.w3.org/TR/html50/tabular-data.html#attr-tdth-rowspan)
 * (for `'mergeTableCellRight'` and `'mergeTableCellLeft'`) or [`colspan`](https://www.w3.org/TR/html50/tabular-data.html#attr-tdth-colspan)
 * (for `'mergeTableCellUp'` and `'mergeTableCellDown'`), the command will be disabled.
 *
 * @extends module:core/command~Command
 */

var mergecellcommand_MergeCellCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(MergeCellCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(MergeCellCommand);

  /**
   * Creates a new `MergeCellCommand` instance.
   *
   * @param {module:core/editor/editor~Editor} editor The editor on which this command will be used.
   * @param {Object} options
   * @param {String} options.direction Indicates which cell to merge with the currently selected one.
   * Possible values are: `'left'`, `'right'`, `'up'` and `'down'`.
   */
  function MergeCellCommand(editor, options) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, MergeCellCommand);

    _this = _super.call(this, editor);
    /**
     * The direction that indicates which cell will be merged with the currently selected one.
     *
     * @readonly
     * @member {String} #direction
     */

    _this.direction = options.direction;
    /**
     * Whether the merge is horizontal (left/right) or vertical (up/down).
     *
     * @readonly
     * @member {Boolean} #isHorizontal
     */

    _this.isHorizontal = _this.direction == 'right' || _this.direction == 'left';
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(MergeCellCommand, [{
    key: "refresh",
    value: function refresh() {
      var cellToMerge = this._getMergeableCell();

      this.value = cellToMerge;
      this.isEnabled = !!cellToMerge;
    }
    /**
     * Executes the command.
     *
     * Depending on the command's {@link #direction} value, it will merge the cell that is to the `'left'`, `'right'`, `'up'` or `'down'`.
     *
     * @fires execute
     */

  }, {
    key: "execute",
    value: function execute() {
      var _this2 = this;

      var model = this.editor.model;
      var doc = model.document;
      var tableCell = getTableCellsContainingSelection(doc.selection)[0];
      var cellToMerge = this.value;
      var direction = this.direction;
      model.change(function (writer) {
        var isMergeNext = direction == 'right' || direction == 'down'; // The merge mechanism is always the same so sort cells to be merged.

        var cellToExpand = isMergeNext ? tableCell : cellToMerge;
        var cellToRemove = isMergeNext ? cellToMerge : tableCell; // Cache the parent of cell to remove for later check.

        var removedTableCellRow = cellToRemove.parent;
        mergeTableCells(cellToRemove, cellToExpand, writer);
        var spanAttribute = _this2.isHorizontal ? 'colspan' : 'rowspan';
        var cellSpan = parseInt(tableCell.getAttribute(spanAttribute) || 1);
        var cellToMergeSpan = parseInt(cellToMerge.getAttribute(spanAttribute) || 1); // Update table cell span attribute and merge set selection on merged contents.

        writer.setAttribute(spanAttribute, cellSpan + cellToMergeSpan, cellToExpand);
        writer.setSelection(writer.createRangeIn(cellToExpand));

        var tableUtils = _this2.editor.plugins.get('TableUtils');

        var table = common_findAncestor('table', removedTableCellRow); // Remove empty rows and columns after merging.

        removeEmptyRowsColumns(table, tableUtils, writer.batch);
      });
    }
    /**
     * Returns a cell that can be merged with the current cell depending on the command's direction.
     *
     * @returns {module:engine/model/element~Element|undefined}
     * @private
     */

  }, {
    key: "_getMergeableCell",
    value: function _getMergeableCell() {
      var model = this.editor.model;
      var doc = model.document;
      var tableCell = getTableCellsContainingSelection(doc.selection)[0];

      if (!tableCell) {
        return;
      }

      var tableUtils = this.editor.plugins.get('TableUtils'); // First get the cell on proper direction.

      var cellToMerge = this.isHorizontal ? getHorizontalCell(tableCell, this.direction, tableUtils) : getVerticalCell(tableCell, this.direction);

      if (!cellToMerge) {
        return;
      } // If found check if the span perpendicular to merge direction is equal on both cells.


      var spanAttribute = this.isHorizontal ? 'rowspan' : 'colspan';
      var span = parseInt(tableCell.getAttribute(spanAttribute) || 1);
      var cellToMergeSpan = parseInt(cellToMerge.getAttribute(spanAttribute) || 1);

      if (cellToMergeSpan === span) {
        return cellToMerge;
      }
    }
  }]);

  return MergeCellCommand;
}(command_Command); // Returns the cell that can be merged horizontally.
//
// @param {module:engine/model/element~Element} tableCell
// @param {String} direction
// @returns {module:engine/model/node~Node|null}




function getHorizontalCell(tableCell, direction, tableUtils) {
  var tableRow = tableCell.parent;
  var table = tableRow.parent;
  var horizontalCell = direction == 'right' ? tableCell.nextSibling : tableCell.previousSibling;
  var hasHeadingColumns = (table.getAttribute('headingColumns') || 0) > 0;

  if (!horizontalCell) {
    return;
  } // Sort cells:


  var cellOnLeft = direction == 'right' ? tableCell : horizontalCell;
  var cellOnRight = direction == 'right' ? horizontalCell : tableCell; // Get their column indexes:

  var _tableUtils$getCellLo = tableUtils.getCellLocation(cellOnLeft),
      leftCellColumn = _tableUtils$getCellLo.column;

  var _tableUtils$getCellLo2 = tableUtils.getCellLocation(cellOnRight),
      rightCellColumn = _tableUtils$getCellLo2.column;

  var leftCellSpan = parseInt(cellOnLeft.getAttribute('colspan') || 1);
  var isCellOnLeftInHeadingColumn = isHeadingColumnCell(tableUtils, cellOnLeft, table);
  var isCellOnRightInHeadingColumn = isHeadingColumnCell(tableUtils, cellOnRight, table); // We cannot merge heading columns cells with regular cells.

  if (hasHeadingColumns && isCellOnLeftInHeadingColumn != isCellOnRightInHeadingColumn) {
    return;
  } // The cell on the right must have index that is distant to the cell on the left by the left cell's width (colspan).


  var cellsAreTouching = leftCellColumn + leftCellSpan === rightCellColumn; // If the right cell's column index is different it means that there are rowspanned cells between them.

  return cellsAreTouching ? horizontalCell : undefined;
} // Returns the cell that can be merged vertically.
//
// @param {module:engine/model/element~Element} tableCell
// @param {String} direction
// @returns {module:engine/model/node~Node|null}


function getVerticalCell(tableCell, direction) {
  var tableRow = tableCell.parent;
  var table = tableRow.parent;
  var rowIndex = table.getChildIndex(tableRow); // Don't search for mergeable cell if direction points out of the table.

  if (direction == 'down' && rowIndex === table.childCount - 1 || direction == 'up' && rowIndex === 0) {
    return;
  }

  var rowspan = parseInt(tableCell.getAttribute('rowspan') || 1);
  var headingRows = table.getAttribute('headingRows') || 0;
  var isMergeWithBodyCell = direction == 'down' && rowIndex + rowspan === headingRows;
  var isMergeWithHeadCell = direction == 'up' && rowIndex === headingRows; // Don't search for mergeable cell if direction points out of the current table section.

  if (headingRows && (isMergeWithBodyCell || isMergeWithHeadCell)) {
    return;
  }

  var currentCellRowSpan = parseInt(tableCell.getAttribute('rowspan') || 1);
  var rowOfCellToMerge = direction == 'down' ? rowIndex + currentCellRowSpan : rowIndex;

  var tableMap = _toConsumableArray(new tablewalker_TableWalker(table, {
    endRow: rowOfCellToMerge
  }));

  var currentCellData = tableMap.find(function (value) {
    return value.cell === tableCell;
  });
  var mergeColumn = currentCellData.column;
  var cellToMergeData = tableMap.find(function (_ref) {
    var row = _ref.row,
        cellHeight = _ref.cellHeight,
        column = _ref.column;

    if (column !== mergeColumn) {
      return false;
    }

    if (direction == 'down') {
      // If merging a cell below the mergeRow is already calculated.
      return row === rowOfCellToMerge;
    } else {
      // If merging a cell above calculate if it spans to mergeRow.
      return rowOfCellToMerge === row + cellHeight;
    }
  });
  return cellToMergeData && cellToMergeData.cell;
} // Merges two table cells. It will ensure that after merging cells with an empty paragraph, the resulting table cell will only have one
// paragraph. If one of the merged table cells is empty, the merged table cell will have the contents of the non-empty table cell.
// If both are empty, the merged table cell will have only one empty paragraph.
//
// @param {module:engine/model/element~Element} cellToRemove
// @param {module:engine/model/element~Element} cellToExpand
// @param {module:engine/model/writer~Writer} writer


function mergeTableCells(cellToRemove, cellToExpand, writer) {
  if (!mergecellcommand_isEmpty(cellToRemove)) {
    if (mergecellcommand_isEmpty(cellToExpand)) {
      writer.remove(writer.createRangeIn(cellToExpand));
    }

    writer.move(writer.createRangeIn(cellToRemove), writer.createPositionAt(cellToExpand, 'end'));
  } // Remove merged table cell.


  writer.remove(cellToRemove);
} // Checks if the passed table cell contains an empty paragraph.
//
// @param {module:engine/model/element~Element} tableCell
// @returns {Boolean}


function mergecellcommand_isEmpty(tableCell) {
  return tableCell.childCount == 1 && tableCell.getChild(0).is('paragraph') && tableCell.getChild(0).isEmpty;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/commands/removerowcommand.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/commands/removerowcommand
 */



/**
 * The remove row command.
 *
 * The command is registered by {@link module:table/tableediting~TableEditing} as the `'removeTableRow'` editor command.
 *
 * To remove the row containing the selected cell, execute the command:
 *
 *		editor.execute( 'removeTableRow' );
 *
 * @extends module:core/command~Command
 */

var removerowcommand_RemoveRowCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(RemoveRowCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(RemoveRowCommand);

  function RemoveRowCommand() {
    Object(classCallCheck["a" /* default */])(this, RemoveRowCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(RemoveRowCommand, [{
    key: "refresh",

    /**
     * @inheritDoc
     */
    value: function refresh() {
      var selectedCells = getSelectionAffectedTableCells(this.editor.model.document.selection);
      var firstCell = selectedCells[0];

      if (firstCell) {
        var table = common_findAncestor('table', firstCell);
        var tableRowCount = this.editor.plugins.get('TableUtils').getRows(table);
        var lastRowIndex = tableRowCount - 1;
        var selectedRowIndexes = getRowIndexes(selectedCells);
        var areAllRowsSelected = selectedRowIndexes.first === 0 && selectedRowIndexes.last === lastRowIndex; // Disallow selecting whole table -> delete whole table should be used instead.

        this.isEnabled = !areAllRowsSelected;
      } else {
        this.isEnabled = false;
      }
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "execute",
    value: function execute() {
      var _this = this;

      var model = this.editor.model;
      var referenceCells = getSelectionAffectedTableCells(model.document.selection);
      var removedRowIndexes = getRowIndexes(referenceCells);
      var firstCell = referenceCells[0];
      var table = common_findAncestor('table', firstCell);
      var columnIndexToFocus = this.editor.plugins.get('TableUtils').getCellLocation(firstCell).column; // Use single batch to modify table in steps but in one undo step.

      var batch = model.createBatch();
      model.enqueueChange(batch, function (writer) {
        // This prevents the "model-selection-range-intersects" error, caused by removing row selected cells.
        writer.setSelection(writer.createSelection(table, 'on'));
        var rowsToRemove = removedRowIndexes.last - removedRowIndexes.first + 1;

        _this.editor.plugins.get('TableUtils').removeRows(table, {
          at: removedRowIndexes.first,
          rows: rowsToRemove,
          batch: batch
        });
      });
      model.enqueueChange(batch, function (writer) {
        var cellToFocus = getCellToFocus(table, removedRowIndexes.first, columnIndexToFocus);
        writer.setSelection(writer.createPositionAt(cellToFocus, 0));
      });
    }
  }]);

  return RemoveRowCommand;
}(command_Command); // Returns a cell that should be focused before removing the row, belonging to the same column as the currently focused cell.
// * If the row was not the last one, the cell to focus will be in the row that followed it (before removal).
// * If the row was the last one, the cell to focus will be in the row that preceded it (before removal).




function getCellToFocus(table, removedRowIndex, columnToFocus) {
  var row = table.getChild(removedRowIndex) || table.getChild(table.childCount - 1); // Default to first table cell.

  var cellToFocus = row.getChild(0);
  var column = 0;

  var _iterator = _createForOfIteratorHelper(row.getChildren()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var tableCell = _step.value;

      if (column > columnToFocus) {
        return cellToFocus;
      }

      cellToFocus = tableCell;
      column += parseInt(tableCell.getAttribute('colspan') || 1);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return cellToFocus;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/commands/removecolumncommand.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/commands/removecolumncommand
 */




/**
 * The remove column command.
 *
 * The command is registered by {@link module:table/tableediting~TableEditing} as the `'removeTableColumn'` editor command.
 *
 * To remove the column containing the selected cell, execute the command:
 *
 *		editor.execute( 'removeTableColumn' );
 *
 * @extends module:core/command~Command
 */

var removecolumncommand_RemoveColumnCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(RemoveColumnCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(RemoveColumnCommand);

  function RemoveColumnCommand() {
    Object(classCallCheck["a" /* default */])(this, RemoveColumnCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(RemoveColumnCommand, [{
    key: "refresh",

    /**
     * @inheritDoc
     */
    value: function refresh() {
      var selectedCells = getSelectionAffectedTableCells(this.editor.model.document.selection);
      var firstCell = selectedCells[0];

      if (firstCell) {
        var table = common_findAncestor('table', firstCell);
        var tableColumnCount = this.editor.plugins.get('TableUtils').getColumns(table);

        var _getColumnIndexes = getColumnIndexes(selectedCells),
            first = _getColumnIndexes.first,
            last = _getColumnIndexes.last;

        this.isEnabled = last - first < tableColumnCount - 1;
      } else {
        this.isEnabled = false;
      }
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "execute",
    value: function execute() {
      var _this = this;

      var _getBoundaryCells = getBoundaryCells(this.editor.model.document.selection),
          _getBoundaryCells2 = _slicedToArray(_getBoundaryCells, 2),
          firstCell = _getBoundaryCells2[0],
          lastCell = _getBoundaryCells2[1];

      var table = firstCell.parent.parent; // Cache the table before removing or updating colspans.

      var tableMap = _toConsumableArray(new tablewalker_TableWalker(table)); // Store column indexes of removed columns.


      var removedColumnIndexes = {
        first: tableMap.find(function (value) {
          return value.cell === firstCell;
        }).column,
        last: tableMap.find(function (value) {
          return value.cell === lastCell;
        }).column
      };
      var cellToFocus = removecolumncommand_getCellToFocus(tableMap, firstCell, lastCell, removedColumnIndexes);
      this.editor.model.change(function (writer) {
        var columnsToRemove = removedColumnIndexes.last - removedColumnIndexes.first + 1;

        _this.editor.plugins.get('TableUtils').removeColumns(table, {
          at: removedColumnIndexes.first,
          columns: columnsToRemove
        });

        writer.setSelection(writer.createPositionAt(cellToFocus, 0));
      });
    }
  }]);

  return RemoveColumnCommand;
}(command_Command); // Returns a proper table cell to focus after removing a column.
// - selection is on last table cell it will return previous cell.




function removecolumncommand_getCellToFocus(tableMap, firstCell, lastCell, removedColumnIndexes) {
  var colspan = parseInt(lastCell.getAttribute('colspan') || 1); // If the table cell is spanned over 2+ columns - it will be truncated so the selection should
  // stay in that cell.

  if (colspan > 1) {
    return lastCell;
  } // Normally, look for the cell in the same row that precedes the first cell to put selection there ("column on the left").
  // If the deleted column is the first column of the table, there will be no predecessor: use the cell
  // from the column that follows then (also in the same row).
  else if (firstCell.previousSibling || lastCell.nextSibling) {
      return lastCell.nextSibling || firstCell.previousSibling;
    } // It can happen that table cells have no siblings in a row, for instance, when there are row spans
    // in the table (in the previous row). Then just look for the closest cell that is in a column
    // that will not be removed to put the selection there.
    else {
        // Look for any cell in a column that precedes the first removed column.
        if (removedColumnIndexes.first) {
          return tableMap.reverse().find(function (_ref) {
            var column = _ref.column;
            return column < removedColumnIndexes.first;
          }).cell;
        } // If the first removed column is the first column of the table, then
        // look for any cell that is in a column that follows the last removed column.
        else {
            return tableMap.reverse().find(function (_ref2) {
              var column = _ref2.column;
              return column > removedColumnIndexes.last;
            }).cell;
          }
      }
} // Returns helper object returning the first and the last cell contained in given selection, based on DOM order.


function getBoundaryCells(selection) {
  var referenceCells = getSelectionAffectedTableCells(selection);
  var firstCell = referenceCells[0];
  var lastCell = referenceCells.pop();
  var returnValue = [firstCell, lastCell];
  return firstCell.isBefore(lastCell) ? returnValue : returnValue.reverse();
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/commands/setheaderrowcommand.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/commands/setheaderrowcommand
 */




/**
 * The header row command.
 *
 * The command is registered by {@link module:table/tableediting~TableEditing} as the `'setTableColumnHeader'` editor command.
 *
 * You can make the row containing the selected cell a [header](https://www.w3.org/TR/html50/tabular-data.html#the-th-element) by executing:
 *
 *		editor.execute( 'setTableRowHeader' );
 *
 * **Note:** All preceding rows will also become headers. If the current row is already a header, executing this command
 * will make it a regular row back again (including the following rows).
 *
 * @extends module:core/command~Command
 */

var setheaderrowcommand_SetHeaderRowCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(SetHeaderRowCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(SetHeaderRowCommand);

  function SetHeaderRowCommand() {
    Object(classCallCheck["a" /* default */])(this, SetHeaderRowCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(SetHeaderRowCommand, [{
    key: "refresh",

    /**
     * @inheritDoc
     */
    value: function refresh() {
      var _this = this;

      var model = this.editor.model;
      var selectedCells = getSelectionAffectedTableCells(model.document.selection);
      var isInTable = selectedCells.length > 0;
      this.isEnabled = isInTable;
      /**
       * Flag indicating whether the command is active. The command is active when the
       * {@link module:engine/model/selection~Selection} is in a header row.
       *
       * @observable
       * @readonly
       * @member {Boolean} #value
       */

      this.value = isInTable && selectedCells.every(function (cell) {
        return _this._isInHeading(cell, cell.parent.parent);
      });
    }
    /**
     * Executes the command.
     *
     * When the selection is in a non-header row, the command will set the `headingRows` table attribute to cover that row.
     *
     * When the selection is already in a header row, it will set `headingRows` so the heading section will end before that row.
     *
     * @fires execute
     * @param {Object} options
     * @param {Boolean} [options.forceValue] If set, the command will set (`true`) or unset (`false`) the header rows according to
     * the `forceValue` parameter instead of the current model state.
     */

  }, {
    key: "execute",
    value: function execute() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.forceValue === this.value) {
        return;
      }

      var model = this.editor.model;
      var selectedCells = getSelectionAffectedTableCells(model.document.selection);
      var table = common_findAncestor('table', selectedCells[0]);

      var _getRowIndexes = getRowIndexes(selectedCells),
          first = _getRowIndexes.first,
          last = _getRowIndexes.last;

      var headingRowsToSet = this.value ? first : last + 1;
      var currentHeadingRows = table.getAttribute('headingRows') || 0;
      model.change(function (writer) {
        if (headingRowsToSet) {
          // Changing heading rows requires to check if any of a heading cell is overlapping vertically the table head.
          // Any table cell that has a rowspan attribute > 1 will not exceed the table head so we need to fix it in rows below.
          var startRow = headingRowsToSet > currentHeadingRows ? currentHeadingRows : 0;
          var overlappingCells = getVerticallyOverlappingCells(table, headingRowsToSet, startRow);

          var _iterator = _createForOfIteratorHelper(overlappingCells),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var cell = _step.value.cell;
              splitHorizontally(cell, headingRowsToSet, writer);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        updateNumericAttribute('headingRows', headingRowsToSet, table, writer, 0);
      });
    }
    /**
     * Checks if a table cell is in the heading section.
     *
     * @param {module:engine/model/element~Element} tableCell
     * @param {module:engine/model/element~Element} table
     * @returns {Boolean}
     * @private
     */

  }, {
    key: "_isInHeading",
    value: function _isInHeading(tableCell, table) {
      var headingRows = parseInt(table.getAttribute('headingRows') || 0);
      return !!headingRows && tableCell.parent.index < headingRows;
    }
  }]);

  return SetHeaderRowCommand;
}(command_Command);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/commands/setheadercolumncommand.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/commands/setheadercolumncommand
 */




/**
 * The header column command.
 *
 * The command is registered by {@link module:table/tableediting~TableEditing} as the `'setTableColumnHeader'` editor command.
 *
 * You can make the column containing the selected cell a [header](https://www.w3.org/TR/html50/tabular-data.html#the-th-element)
 * by executing:
 *
 *		editor.execute( 'setTableColumnHeader' );
 *
 * **Note:** All preceding columns will also become headers. If the current column is already a header, executing this command
 * will make it a regular column back again (including the following columns).
 *
 * @extends module:core/command~Command
 */

var setheadercolumncommand_SetHeaderColumnCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(SetHeaderColumnCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(SetHeaderColumnCommand);

  function SetHeaderColumnCommand() {
    Object(classCallCheck["a" /* default */])(this, SetHeaderColumnCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(SetHeaderColumnCommand, [{
    key: "refresh",

    /**
     * @inheritDoc
     */
    value: function refresh() {
      var model = this.editor.model;
      var selectedCells = getSelectionAffectedTableCells(model.document.selection);
      var tableUtils = this.editor.plugins.get('TableUtils');
      var isInTable = selectedCells.length > 0;
      this.isEnabled = isInTable;
      /**
       * Flag indicating whether the command is active. The command is active when the
       * {@link module:engine/model/selection~Selection} is in a header column.
       *
       * @observable
       * @readonly
       * @member {Boolean} #value
       */

      this.value = isInTable && selectedCells.every(function (cell) {
        return isHeadingColumnCell(tableUtils, cell);
      });
    }
    /**
     * Executes the command.
     *
     * When the selection is in a non-header column, the command will set the `headingColumns` table attribute to cover that column.
     *
     * When the selection is already in a header column, it will set `headingColumns` so the heading section will end before that column.
     *
     * @fires execute
     * @param {Object} [options]
     * @param {Boolean} [options.forceValue] If set, the command will set (`true`) or unset (`false`) the header columns according to
     * the `forceValue` parameter instead of the current model state.
     */

  }, {
    key: "execute",
    value: function execute() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      if (options.forceValue === this.value) {
        return;
      }

      var model = this.editor.model;
      var selectedCells = getSelectionAffectedTableCells(model.document.selection);
      var table = common_findAncestor('table', selectedCells[0]);

      var _getColumnIndexes = getColumnIndexes(selectedCells),
          first = _getColumnIndexes.first,
          last = _getColumnIndexes.last;

      var headingColumnsToSet = this.value ? first : last + 1;
      model.change(function (writer) {
        if (headingColumnsToSet) {
          // Changing heading columns requires to check if any of a heading cell is overlapping horizontally the table head.
          // Any table cell that has a colspan attribute > 1 will not exceed the table head so we need to fix it in columns before.
          var overlappingCells = getHorizontallyOverlappingCells(table, headingColumnsToSet);

          var _iterator = _createForOfIteratorHelper(overlappingCells),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var _step$value = _step.value,
                  cell = _step$value.cell,
                  column = _step$value.column;
              splitVertically(cell, column, headingColumnsToSet, writer);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }

        updateNumericAttribute('headingColumns', headingColumnsToSet, table, writer, 0);
      });
    }
  }]);

  return SetHeaderColumnCommand;
}(command_Command);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/tableutils.js
















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/tableutils
 */




/**
 * The table utilities plugin.
 *
 * @extends module:core/plugin~Plugin
 */

var tableutils_TableUtils = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(TableUtils, _Plugin);

  var _super = Object(createSuper["a" /* default */])(TableUtils);

  function TableUtils() {
    Object(classCallCheck["a" /* default */])(this, TableUtils);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(TableUtils, [{
    key: "getCellLocation",

    /**
     * Returns the table cell location as an object with table row and table column indexes.
     *
     * For instance, in the table below:
     *
     *		    0   1   2   3
     *		  +---+---+---+---+
     *		0 | a     | b | c |
     *		  +       +   +---+
     *		1 |       |   | d |
     *		  +---+---+   +---+
     *		2 | e     |   | f |
     *		  +---+---+---+---+
     *
     * the method will return:
     *
     *		const cellA = table.getNodeByPath( [ 0, 0 ] );
     *		editor.plugins.get( 'TableUtils' ).getCellLocation( cellA );
     *		// will return { row: 0, column: 0 }
     *
     *		const cellD = table.getNodeByPath( [ 1, 0 ] );
     *		editor.plugins.get( 'TableUtils' ).getCellLocation( cellD );
     *		// will return { row: 1, column: 3 }
     *
     * @param {module:engine/model/element~Element} tableCell
     * @returns {Object} Returns a `{row, column}` object.
     */
    value: function getCellLocation(tableCell) {
      var tableRow = tableCell.parent;
      var table = tableRow.parent;
      var rowIndex = table.getChildIndex(tableRow);
      var tableWalker = new tablewalker_TableWalker(table, {
        row: rowIndex
      });

      var _iterator = _createForOfIteratorHelper(tableWalker),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _step.value,
              cell = _step$value.cell,
              row = _step$value.row,
              column = _step$value.column;

          if (cell === tableCell) {
            return {
              row: row,
              column: column
            };
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Creates an empty table with a proper structure. The table needs to be inserted into the model,
     * for example, by using the {@link module:engine/model/model~Model#insertContent} function.
     *
     *		model.change( ( writer ) => {
     *			// Create a table of 2 rows and 7 columns:
     *			const table = tableUtils.createTable( writer, 2, 7);
     *
     *			// Insert a table to the model at the best position taking the current selection:
     *			model.insertContent( table );
     *		}
     *
     * @param {module:engine/model/writer~Writer} writer The model writer.
     * @param {Number} rows The number of rows to create.
     * @param {Number} columns The number of columns to create.
     * @returns {module:engine/model/element~Element} The created table element.
     */

  }, {
    key: "createTable",
    value: function createTable(writer, rows, columns) {
      var table = writer.createElement('table');
      createEmptyRows(writer, table, 0, rows, columns);
      return table;
    }
    /**
     * Inserts rows into a table.
     *
     *		editor.plugins.get( 'TableUtils' ).insertRows( table, { at: 1, rows: 2 } );
     *
     * Assuming the table on the left, the above code will transform it to the table on the right:
     *
     *		row index
     *		  0 +---+---+---+       `at` = 1,      +---+---+---+ 0
     *		    | a | b | c |       `rows` = 2,    | a | b | c |
     *		  1 +   +---+---+   <-- insert here    +   +---+---+ 1
     *		    |   | d | e |                      |   |   |   |
     *		  2 +   +---+---+       will give:     +   +---+---+ 2
     *		    |   | f | g |                      |   |   |   |
     *		  3 +---+---+---+                      +   +---+---+ 3
     *		                                       |   | d | e |
     *		                                       +   +---+---+ 4
     *		                                       +   + f | g |
     *		                                       +---+---+---+ 5
     *
     * @param {module:engine/model/element~Element} table The table model element where the rows will be inserted.
     * @param {Object} options
     * @param {Number} [options.at=0] The row index at which the rows will be inserted.
     * @param {Number} [options.rows=1] The number of rows to insert.
     * @param {Boolean|undefined} [options.copyStructureFromAbove] The flag for copying row structure. Note that
     * the row structure will not be copied if this option is not provided.
     */

  }, {
    key: "insertRows",
    value: function insertRows(table) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var model = this.editor.model;
      var insertAt = options.at || 0;
      var rowsToInsert = options.rows || 1;
      var isCopyStructure = options.copyStructureFromAbove !== undefined;
      var copyStructureFrom = options.copyStructureFromAbove ? insertAt - 1 : insertAt;
      var rows = this.getRows(table);
      var columns = this.getColumns(table);
      model.change(function (writer) {
        var headingRows = table.getAttribute('headingRows') || 0; // Inserting rows inside heading section requires to update `headingRows` attribute as the heading section will grow.

        if (headingRows > insertAt) {
          writer.setAttribute('headingRows', headingRows + rowsToInsert, table);
        } // Inserting at the end or at the beginning of a table doesn't require to calculate anything special.


        if (!isCopyStructure && (insertAt === 0 || insertAt === rows)) {
          createEmptyRows(writer, table, insertAt, rowsToInsert, columns);
          return;
        } // Iterate over all the rows above the inserted rows in order to check for the row-spanned cells.


        var walkerEndRow = isCopyStructure ? Math.max(insertAt, copyStructureFrom) : insertAt;
        var tableIterator = new tablewalker_TableWalker(table, {
          endRow: walkerEndRow
        }); // Store spans of the reference row to reproduce it's structure. This array is column number indexed.

        var rowColSpansMap = new Array(columns).fill(1);

        var _iterator2 = _createForOfIteratorHelper(tableIterator),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var _step2$value = _step2.value,
                row = _step2$value.row,
                column = _step2$value.column,
                cellHeight = _step2$value.cellHeight,
                cellWidth = _step2$value.cellWidth,
                cell = _step2$value.cell;
            var lastCellRow = row + cellHeight - 1;
            var isOverlappingInsertedRow = row < insertAt && insertAt <= lastCellRow;
            var isReferenceRow = row <= copyStructureFrom && copyStructureFrom <= lastCellRow; // If the cell is row-spanned and overlaps the inserted row, then reserve space for it in the row map.

            if (isOverlappingInsertedRow) {
              // This cell overlaps the inserted rows so we need to expand it further.
              writer.setAttribute('rowspan', cellHeight + rowsToInsert, cell); // Mark this cell with negative number to indicate how many cells should be skipped when adding the new cells.

              rowColSpansMap[column] = -cellWidth;
            } // Store the colspan from reference row.
            else if (isCopyStructure && isReferenceRow) {
                rowColSpansMap[column] = cellWidth;
              }
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        for (var rowIndex = 0; rowIndex < rowsToInsert; rowIndex++) {
          var tableRow = writer.createElement('tableRow');
          writer.insert(tableRow, table, insertAt);

          for (var cellIndex = 0; cellIndex < rowColSpansMap.length; cellIndex++) {
            var colspan = rowColSpansMap[cellIndex];
            var insertPosition = writer.createPositionAt(tableRow, 'end'); // Insert the empty cell only if this slot is not row-spanned from any other cell.

            if (colspan > 0) {
              createEmptyTableCell(writer, insertPosition, colspan > 1 ? {
                colspan: colspan
              } : null);
            } // Skip the col-spanned slots, there won't be any cells.


            cellIndex += Math.abs(colspan) - 1;
          }
        }
      });
    }
    /**
     * Inserts columns into a table.
     *
     *		editor.plugins.get( 'TableUtils' ).insertColumns( table, { at: 1, columns: 2 } );
     *
     * Assuming the table on the left, the above code will transform it to the table on the right:
     *
     *		0   1   2   3                   0   1   2   3   4   5
     *		+---+---+---+                   +---+---+---+---+---+
     *		| a     | b |                   | a             | b |
     *		+       +---+                   +               +---+
     *		|       | c |                   |               | c |
     *		+---+---+---+     will give:    +---+---+---+---+---+
     *		| d | e | f |                   | d |   |   | e | f |
     *		+---+   +---+                   +---+---+---+   +---+
     *		| g |   | h |                   | g |   |   |   | h |
     *		+---+---+---+                   +---+---+---+---+---+
     *		| i         |                   | i                 |
     *		+---+---+---+                   +---+---+---+---+---+
     *		    ^---- insert here, `at` = 1, `columns` = 2
     *
     * @param {module:engine/model/element~Element} table The table model element where the columns will be inserted.
     * @param {Object} options
     * @param {Number} [options.at=0] The column index at which the columns will be inserted.
     * @param {Number} [options.columns=1] The number of columns to insert.
     */

  }, {
    key: "insertColumns",
    value: function insertColumns(table) {
      var _this = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var model = this.editor.model;
      var insertAt = options.at || 0;
      var columnsToInsert = options.columns || 1;
      model.change(function (writer) {
        var headingColumns = table.getAttribute('headingColumns'); // Inserting columns inside heading section requires to update `headingColumns` attribute as the heading section will grow.

        if (insertAt < headingColumns) {
          writer.setAttribute('headingColumns', headingColumns + columnsToInsert, table);
        }

        var tableColumns = _this.getColumns(table); // Inserting at the end and at the beginning of a table doesn't require to calculate anything special.


        if (insertAt === 0 || tableColumns === insertAt) {
          var _iterator3 = _createForOfIteratorHelper(table.getChildren()),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var tableRow = _step3.value;
              createCells(columnsToInsert, writer, writer.createPositionAt(tableRow, insertAt ? 'end' : 0));
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }

          return;
        }

        var tableWalker = new tablewalker_TableWalker(table, {
          column: insertAt,
          includeAllSlots: true
        });

        var _iterator4 = _createForOfIteratorHelper(tableWalker),
            _step4;

        try {
          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
            var tableSlot = _step4.value;
            var row = tableSlot.row,
                cell = tableSlot.cell,
                cellAnchorColumn = tableSlot.cellAnchorColumn,
                cellAnchorRow = tableSlot.cellAnchorRow,
                cellWidth = tableSlot.cellWidth,
                cellHeight = tableSlot.cellHeight; // When iterating over column the table walker outputs either:
            // - cells at given column index (cell "e" from method docs),
            // - spanned columns (spanned cell from row between cells "g" and "h" - spanned by "e", only if `includeAllSlots: true`),
            // - or a cell from the same row which spans over this column (cell "a").

            if (cellAnchorColumn < insertAt) {
              // If cell is anchored in previous column, it is a cell that spans over an inserted column (cell "a" & "i").
              // For such cells expand them by a number of columns inserted.
              writer.setAttribute('colspan', cellWidth + columnsToInsert, cell); // This cell will overlap cells in rows below so skip them (because of `includeAllSlots` option) - (cell "a")

              var lastCellRow = cellAnchorRow + cellHeight - 1;

              for (var i = row; i <= lastCellRow; i++) {
                tableWalker.skipRow(i);
              }
            } else {
              // It's either cell at this column index or spanned cell by a row-spanned cell from row above.
              // In table above it's cell "e" and a spanned position from row below (empty cell between cells "g" and "h")
              createCells(columnsToInsert, writer, tableSlot.getPositionBefore());
            }
          }
        } catch (err) {
          _iterator4.e(err);
        } finally {
          _iterator4.f();
        }
      });
    }
    /**
     * Removes rows from the given `table`.
     *
     * This method re-calculates the table geometry including `rowspan` attribute of table cells overlapping removed rows
     * and table headings values.
     *
     *		editor.plugins.get( 'TableUtils' ).removeRows( table, { at: 1, rows: 2 } );
     *
     * Executing the above code in the context of the table on the left will transform its structure as presented on the right:
     *
     *		row index
     *		    ┌───┬───┬───┐        `at` = 1        ┌───┬───┬───┐
     *		  0 │ a │ b │ c │        `rows` = 2      │ a │ b │ c │ 0
     *		    │   ├───┼───┤                        │   ├───┼───┤
     *		  1 │   │ d │ e │  <-- remove from here  │   │ d │ g │ 1
     *		    │   │   ├───┤        will give:      ├───┼───┼───┤
     *		  2 │   │   │ f │                        │ h │ i │ j │ 2
     *		    │   │   ├───┤                        └───┴───┴───┘
     *		  3 │   │   │ g │
     *		    ├───┼───┼───┤
     *		  4 │ h │ i │ j │
     *		    └───┴───┴───┘
     *
     * @param {module:engine/model/element~Element} table
     * @param {Object} options
     * @param {Number} options.at The row index at which the removing rows will start.
     * @param {Number} [options.rows=1] The number of rows to remove.
     */

  }, {
    key: "removeRows",
    value: function removeRows(table, options) {
      var _this2 = this;

      var model = this.editor.model;
      var rowsToRemove = options.rows || 1;
      var first = options.at;
      var last = first + rowsToRemove - 1;
      var batch = options.batch || 'default';
      model.enqueueChange(batch, function (writer) {
        // Removing rows from the table require that most calculations to be done prior to changing table structure.
        // Preparations must be done in the same enqueueChange callback to use the current table structure.
        // 1. Preparation - get row-spanned cells that have to be modified after removing rows.
        var _getCellsToMoveAndTri = getCellsToMoveAndTrimOnRemoveRow(table, first, last),
            cellsToMove = _getCellsToMoveAndTri.cellsToMove,
            cellsToTrim = _getCellsToMoveAndTri.cellsToTrim; // 2. Execution
        // 2a. Move cells from removed rows that extends over a removed section - must be done before removing rows.
        // This will fill any gaps in a rows below that previously were empty because of row-spanned cells.


        if (cellsToMove.size) {
          var rowAfterRemovedSection = last + 1;
          moveCellsToRow(table, rowAfterRemovedSection, cellsToMove, writer);
        } // 2b. Remove all required rows.


        for (var i = last; i >= first; i--) {
          writer.remove(table.getChild(i));
        } // 2c. Update cells from rows above that overlap removed section. Similar to step 2 but does not involve moving cells.


        var _iterator5 = _createForOfIteratorHelper(cellsToTrim),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _step5$value = _step5.value,
                rowspan = _step5$value.rowspan,
                cell = _step5$value.cell;
            updateNumericAttribute('rowspan', rowspan, cell, writer);
          } // 2d. Remove empty columns (without anchored cells) if there are any.

        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }

        removeEmptyColumns(table, _this2); // 2e. Adjust heading rows if removed rows were in a heading section.

        updateHeadingRows(table, first, last, model, batch);
      });
    }
    /**
     * Removes columns from the given `table`.
     *
     * This method re-calculates the table geometry including the `colspan` attribute of table cells overlapping removed columns
     * and table headings values.
     *
     *		editor.plugins.get( 'TableUtils' ).removeColumns( table, { at: 1, columns: 2 } );
     *
     * Executing the above code in the context of the table on the left will transform its structure as presented on the right:
     *
     *		  0   1   2   3   4                       0   1   2
     *		┌───────────────┬───┐                   ┌───────┬───┐
     *		│ a             │ b │                   │ a     │ b │
     *		│               ├───┤                   │       ├───┤
     *		│               │ c │                   │       │ c │
     *		├───┬───┬───┬───┼───┤     will give:    ├───┬───┼───┤
     *		│ d │ e │ f │ g │ h │                   │ d │ g │ h │
     *		├───┼───┼───┤   ├───┤                   ├───┤   ├───┤
     *		│ i │ j │ k │   │ l │                   │ i │   │ l │
     *		├───┴───┴───┴───┴───┤                   ├───┴───┴───┤
     *		│ m                 │                   │ m         │
     *		└───────────────────┘                   └───────────┘
     *		      ^---- remove from here, `at` = 1, `columns` = 2
     *
     * @param {module:engine/model/element~Element} table
     * @param {Object} options
     * @param {Number} options.at The row index at which the removing columns will start.
     * @param {Number} [options.columns=1] The number of columns to remove.
     */

  }, {
    key: "removeColumns",
    value: function removeColumns(table, options) {
      var _this3 = this;

      var model = this.editor.model;
      var first = options.at;
      var columnsToRemove = options.columns || 1;
      var last = options.at + columnsToRemove - 1;
      model.change(function (writer) {
        adjustHeadingColumns(table, {
          first: first,
          last: last
        }, writer);

        for (var removedColumnIndex = last; removedColumnIndex >= first; removedColumnIndex--) {
          for (var _i = 0, _arr = _toConsumableArray(new tablewalker_TableWalker(table)); _i < _arr.length; _i++) {
            var _arr$_i = _arr[_i],
                cell = _arr$_i.cell,
                column = _arr$_i.column,
                cellWidth = _arr$_i.cellWidth;

            // If colspaned cell overlaps removed column decrease its span.
            if (column <= removedColumnIndex && cellWidth > 1 && column + cellWidth > removedColumnIndex) {
              updateNumericAttribute('colspan', cellWidth - 1, cell, writer);
            } else if (column === removedColumnIndex) {
              // The cell in removed column has colspan of 1.
              writer.remove(cell);
            }
          }
        } // Remove empty rows that could appear after removing columns.


        removeEmptyRows(table, _this3, writer.batch);
      });
    }
    /**
     * Divides a table cell vertically into several ones.
     *
     * The cell will be visually split into more cells by updating colspans of other cells in a column
     * and inserting cells (columns) after that cell.
     *
     * In the table below, if cell "a" is split into 3 cells:
     *
     *		+---+---+---+
     *		| a | b | c |
     *		+---+---+---+
     *		| d | e | f |
     *		+---+---+---+
     *
     * it will result in the table below:
     *
     *		+---+---+---+---+---+
     *		| a |   |   | b | c |
     *		+---+---+---+---+---+
     *		| d         | e | f |
     *		+---+---+---+---+---+
     *
     * So cell "d" will get its `colspan` updated to `3` and 2 cells will be added (2 columns will be created).
     *
     * Splitting a cell that already has a `colspan` attribute set will distribute the cell `colspan` evenly and the remainder
     * will be left to the original cell:
     *
     *		+---+---+---+
     *		| a         |
     *		+---+---+---+
     *		| b | c | d |
     *		+---+---+---+
     *
     * Splitting cell "a" with `colspan=3` into 2 cells will create 1 cell with a `colspan=a` and cell "a" that will have `colspan=2`:
     *
     *		+---+---+---+
     *		| a     |   |
     *		+---+---+---+
     *		| b | c | d |
     *		+---+---+---+
     *
     * @param {module:engine/model/element~Element} tableCell
     * @param {Number} numberOfCells
     */

  }, {
    key: "splitCellVertically",
    value: function splitCellVertically(tableCell) {
      var numberOfCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
      var model = this.editor.model;
      var tableRow = tableCell.parent;
      var table = tableRow.parent;
      var rowspan = parseInt(tableCell.getAttribute('rowspan') || 1);
      var colspan = parseInt(tableCell.getAttribute('colspan') || 1);
      model.change(function (writer) {
        // First check - the cell spans over multiple rows so before doing anything else just split this cell.
        if (colspan > 1) {
          // Get spans of new (inserted) cells and span to update of split cell.
          var _breakSpanEvenly = breakSpanEvenly(colspan, numberOfCells),
              newCellsSpan = _breakSpanEvenly.newCellsSpan,
              updatedSpan = _breakSpanEvenly.updatedSpan;

          updateNumericAttribute('colspan', updatedSpan, tableCell, writer); // Each inserted cell will have the same attributes:

          var newCellsAttributes = {}; // Do not store default value in the model.

          if (newCellsSpan > 1) {
            newCellsAttributes.colspan = newCellsSpan;
          } // Copy rowspan of split cell.


          if (rowspan > 1) {
            newCellsAttributes.rowspan = rowspan;
          }

          var cellsToInsert = colspan > numberOfCells ? numberOfCells - 1 : colspan - 1;
          createCells(cellsToInsert, writer, writer.createPositionAfter(tableCell), newCellsAttributes);
        } // Second check - the cell has colspan of 1 or we need to create more cells then the currently one spans over.


        if (colspan < numberOfCells) {
          var _cellsToInsert = numberOfCells - colspan; // First step: expand cells on the same column as split cell.


          var tableMap = _toConsumableArray(new tablewalker_TableWalker(table)); // Get the column index of split cell.


          var _tableMap$find = tableMap.find(function (_ref) {
            var cell = _ref.cell;
            return cell === tableCell;
          }),
              splitCellColumn = _tableMap$find.column; // Find cells which needs to be expanded vertically - those on the same column or those that spans over split cell's column.


          var cellsToUpdate = tableMap.filter(function (_ref2) {
            var cell = _ref2.cell,
                cellWidth = _ref2.cellWidth,
                column = _ref2.column;
            var isOnSameColumn = cell !== tableCell && column === splitCellColumn;
            var spansOverColumn = column < splitCellColumn && column + cellWidth > splitCellColumn;
            return isOnSameColumn || spansOverColumn;
          }); // Expand cells vertically.

          var _iterator6 = _createForOfIteratorHelper(cellsToUpdate),
              _step6;

          try {
            for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
              var _step6$value = _step6.value,
                  cell = _step6$value.cell,
                  cellWidth = _step6$value.cellWidth;
              writer.setAttribute('colspan', cellWidth + _cellsToInsert, cell);
            } // Second step: create columns after split cell.
            // Each inserted cell will have the same attributes:

          } catch (err) {
            _iterator6.e(err);
          } finally {
            _iterator6.f();
          }

          var _newCellsAttributes = {}; // Do not store default value in the model.
          // Copy rowspan of split cell.

          if (rowspan > 1) {
            _newCellsAttributes.rowspan = rowspan;
          }

          createCells(_cellsToInsert, writer, writer.createPositionAfter(tableCell), _newCellsAttributes);
          var headingColumns = table.getAttribute('headingColumns') || 0; // Update heading section if split cell is in heading section.

          if (headingColumns > splitCellColumn) {
            updateNumericAttribute('headingColumns', headingColumns + _cellsToInsert, table, writer);
          }
        }
      });
    }
    /**
     * Divides a table cell horizontally into several ones.
     *
     * The cell will be visually split into more cells by updating rowspans of other cells in the row and inserting rows with a single cell
     * below.
     *
     * If in the table below cell "b" is split into 3 cells:
     *
     *		+---+---+---+
     *		| a | b | c |
     *		+---+---+---+
     *		| d | e | f |
     *		+---+---+---+
     *
     * It will result in the table below:
     *
     *		+---+---+---+
     *		| a | b | c |
     *		+   +---+   +
     *		|   |   |   |
     *		+   +---+   +
     *		|   |   |   |
     *		+---+---+---+
     *		| d | e | f |
     *		+---+---+---+
     *
     * So cells "a" and "b" will get their `rowspan` updated to `3` and 2 rows with a single cell will be added.
     *
     * Splitting a cell that already has a `rowspan` attribute set will distribute the cell `rowspan` evenly and the remainder
     * will be left to the original cell:
     *
     *		+---+---+---+
     *		| a | b | c |
     *		+   +---+---+
     *		|   | d | e |
     *		+   +---+---+
     *		|   | f | g |
     *		+   +---+---+
     *		|   | h | i |
     *		+---+---+---+
     *
     * Splitting cell "a" with `rowspan=4` into 3 cells will create 2 cells with a `rowspan=1` and cell "a" will have `rowspan=2`:
     *
     *		+---+---+---+
     *		| a | b | c |
     *		+   +---+---+
     *		|   | d | e |
     *		+---+---+---+
     *		|   | f | g |
     *		+---+---+---+
     *		|   | h | i |
     *		+---+---+---+
     *
     * @param {module:engine/model/element~Element} tableCell
     * @param {Number} numberOfCells
     */

  }, {
    key: "splitCellHorizontally",
    value: function splitCellHorizontally(tableCell) {
      var numberOfCells = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
      var model = this.editor.model;
      var tableRow = tableCell.parent;
      var table = tableRow.parent;
      var splitCellRow = table.getChildIndex(tableRow);
      var rowspan = parseInt(tableCell.getAttribute('rowspan') || 1);
      var colspan = parseInt(tableCell.getAttribute('colspan') || 1);
      model.change(function (writer) {
        // First check - the cell spans over multiple rows so before doing anything else just split this cell.
        if (rowspan > 1) {
          // Cache table map before updating table.
          var tableMap = _toConsumableArray(new tablewalker_TableWalker(table, {
            startRow: splitCellRow,
            endRow: splitCellRow + rowspan - 1,
            includeAllSlots: true
          })); // Get spans of new (inserted) cells and span to update of split cell.


          var _breakSpanEvenly2 = breakSpanEvenly(rowspan, numberOfCells),
              newCellsSpan = _breakSpanEvenly2.newCellsSpan,
              updatedSpan = _breakSpanEvenly2.updatedSpan;

          updateNumericAttribute('rowspan', updatedSpan, tableCell, writer);

          var _tableMap$find2 = tableMap.find(function (_ref3) {
            var cell = _ref3.cell;
            return cell === tableCell;
          }),
              cellColumn = _tableMap$find2.column; // Each inserted cell will have the same attributes:


          var newCellsAttributes = {}; // Do not store default value in the model.

          if (newCellsSpan > 1) {
            newCellsAttributes.rowspan = newCellsSpan;
          } // Copy colspan of split cell.


          if (colspan > 1) {
            newCellsAttributes.colspan = colspan;
          }

          var _iterator7 = _createForOfIteratorHelper(tableMap),
              _step7;

          try {
            for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
              var tableSlot = _step7.value;
              var column = tableSlot.column,
                  row = tableSlot.row; // As both newly created cells and the split cell might have rowspan,
              // the insertion of new cells must go to appropriate rows:
              //
              // 1. It's a row after split cell + it's height.

              var isAfterSplitCell = row >= splitCellRow + updatedSpan; // 2. Is on the same column.

              var isOnSameColumn = column === cellColumn; // 3. And it's row index is after previous cell height.

              var isInEvenlySplitRow = (row + splitCellRow + updatedSpan) % newCellsSpan === 0;

              if (isAfterSplitCell && isOnSameColumn && isInEvenlySplitRow) {
                createCells(1, writer, tableSlot.getPositionBefore(), newCellsAttributes);
              }
            }
          } catch (err) {
            _iterator7.e(err);
          } finally {
            _iterator7.f();
          }
        } // Second check - the cell has rowspan of 1 or we need to create more cells than the current cell spans over.


        if (rowspan < numberOfCells) {
          // We already split the cell in check one so here we split to the remaining number of cells only.
          var cellsToInsert = numberOfCells - rowspan; // This check is needed since we need to check if there are any cells from previous rows than spans over this cell's row.

          var _tableMap = _toConsumableArray(new tablewalker_TableWalker(table, {
            startRow: 0,
            endRow: splitCellRow
          })); // First step: expand cells.


          var _iterator8 = _createForOfIteratorHelper(_tableMap),
              _step8;

          try {
            for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {
              var _step8$value = _step8.value,
                  cell = _step8$value.cell,
                  cellHeight = _step8$value.cellHeight,
                  _row = _step8$value.row;

              // Expand rowspan of cells that are either:
              // - on the same row as current cell,
              // - or are below split cell row and overlaps that row.
              if (cell !== tableCell && _row + cellHeight > splitCellRow) {
                var rowspanToSet = cellHeight + cellsToInsert;
                writer.setAttribute('rowspan', rowspanToSet, cell);
              }
            } // Second step: create rows with single cell below split cell.

          } catch (err) {
            _iterator8.e(err);
          } finally {
            _iterator8.f();
          }

          var _newCellsAttributes2 = {}; // Copy colspan of split cell.

          if (colspan > 1) {
            _newCellsAttributes2.colspan = colspan;
          }

          createEmptyRows(writer, table, splitCellRow + 1, cellsToInsert, 1, _newCellsAttributes2); // Update heading section if split cell is in heading section.

          var headingRows = table.getAttribute('headingRows') || 0;

          if (headingRows > splitCellRow) {
            updateNumericAttribute('headingRows', headingRows + cellsToInsert, table, writer);
          }
        }
      });
    }
    /**
     * Returns the number of columns for a given table.
     *
     *		editor.plugins.get( 'TableUtils' ).getColumns( table );
     *
     * @param {module:engine/model/element~Element} table The table to analyze.
     * @returns {Number}
     */

  }, {
    key: "getColumns",
    value: function getColumns(table) {
      // Analyze first row only as all the rows should have the same width.
      var row = table.getChild(0);
      return _toConsumableArray(row.getChildren()).reduce(function (columns, row) {
        var columnWidth = parseInt(row.getAttribute('colspan') || 1);
        return columns + columnWidth;
      }, 0);
    }
    /**
     * Returns the number of rows for a given table.
     *
     *		editor.plugins.get( 'TableUtils' ).getRows( table );
     *
     * @param {module:engine/model/element~Element} table The table to analyze.
     * @returns {Number}
     */

  }, {
    key: "getRows",
    value: function getRows(table) {
      // Simple row counting, not including rowspan due to #6427.
      return table.childCount;
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'TableUtils';
    }
  }]);

  return TableUtils;
}(plugin_Plugin); // Creates empty rows at the given index in an existing table.
//
// @param {module:engine/model/writer~Writer} writer
// @param {module:engine/model/element~Element} table
// @param {Number} insertAt The row index of row insertion.
// @param {Number} rows The number of rows to create.
// @param {Number} tableCellToInsert The number of cells to insert in each row.




function createEmptyRows(writer, table, insertAt, rows, tableCellToInsert) {
  var attributes = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : {};

  for (var i = 0; i < rows; i++) {
    var tableRow = writer.createElement('tableRow');
    writer.insert(tableRow, table, insertAt);
    createCells(tableCellToInsert, writer, writer.createPositionAt(tableRow, 'end'), attributes);
  }
} // Creates cells at a given position.
//
// @param {Number} columns The number of columns to create
// @param {module:engine/model/writer~Writer} writer
// @param {module:engine/model/position~Position} insertPosition


function createCells(cells, writer, insertPosition) {
  var attributes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

  for (var i = 0; i < cells; i++) {
    createEmptyTableCell(writer, insertPosition, attributes);
  }
} // Evenly distributes the span of a cell to a number of provided cells.
// The resulting spans will always be integer values.
//
// For instance breaking a span of 7 into 3 cells will return:
//
//		{ newCellsSpan: 2, updatedSpan: 3 }
//
// as two cells will have a span of 2 and the remainder will go the first cell so its span will change to 3.
//
// @param {Number} span The span value do break.
// @param {Number} numberOfCells The number of resulting spans.
// @returns {{newCellsSpan: Number, updatedSpan: Number}}


function breakSpanEvenly(span, numberOfCells) {
  if (span < numberOfCells) {
    return {
      newCellsSpan: 1,
      updatedSpan: 1
    };
  }

  var newCellsSpan = Math.floor(span / numberOfCells);
  var updatedSpan = span - newCellsSpan * numberOfCells + newCellsSpan;
  return {
    newCellsSpan: newCellsSpan,
    updatedSpan: updatedSpan
  };
} // Updates heading columns attribute if removing a row from head section.


function adjustHeadingColumns(table, removedColumnIndexes, writer) {
  var headingColumns = table.getAttribute('headingColumns') || 0;

  if (headingColumns && removedColumnIndexes.first < headingColumns) {
    var headingsRemoved = Math.min(headingColumns - 1
    /* Other numbers are 0-based */
    , removedColumnIndexes.last) - removedColumnIndexes.first + 1;
    writer.setAttribute('headingColumns', headingColumns - headingsRemoved, table);
  }
} // Calculates a new heading rows value for removing rows from heading section.


function updateHeadingRows(table, first, last, model, batch) {
  // Must be done after the changes in table structure (removing rows).
  // Otherwise the downcast converter for headingRows attribute will fail.
  // See https://github.com/ckeditor/ckeditor5/issues/6391.
  //
  // Must be completely wrapped in enqueueChange to get the current table state (after applying other enqueued changes).
  model.enqueueChange(batch, function (writer) {
    var headingRows = table.getAttribute('headingRows') || 0;

    if (first < headingRows) {
      var newRows = last < headingRows ? headingRows - (last - first + 1) : first;
      updateNumericAttribute('headingRows', newRows, table, writer, 0);
    }
  });
} // Finds cells that will be:
// - trimmed - Cells that are "above" removed rows sections and overlap the removed section - their rowspan must be trimmed.
// - moved - Cells from removed rows section might stick out of. These cells are moved to the next row after a removed section.
//
// Sample table with overlapping & sticking out cells:
//
//      +----+----+----+----+----+
//      | 00 | 01 | 02 | 03 | 04 |
//      +----+    +    +    +    +
//      | 10 |    |    |    |    |
//      +----+----+    +    +    +
//      | 20 | 21 |    |    |    | <-- removed row
//      +    +    +----+    +    +
//      |    |    | 32 |    |    | <-- removed row
//      +----+    +    +----+    +
//      | 40 |    |    | 43 |    |
//      +----+----+----+----+----+
//
// In a table above:
// - cells to trim: '02', '03' & '04'.
// - cells to move: '21' & '32'.


function getCellsToMoveAndTrimOnRemoveRow(table, first, last) {
  var cellsToMove = new Map();
  var cellsToTrim = [];

  var _iterator9 = _createForOfIteratorHelper(new tablewalker_TableWalker(table, {
    endRow: last
  })),
      _step9;

  try {
    for (_iterator9.s(); !(_step9 = _iterator9.n()).done;) {
      var _step9$value = _step9.value,
          row = _step9$value.row,
          column = _step9$value.column,
          cellHeight = _step9$value.cellHeight,
          cell = _step9$value.cell;
      var lastRowOfCell = row + cellHeight - 1;
      var isCellStickingOutFromRemovedRows = row >= first && row <= last && lastRowOfCell > last;

      if (isCellStickingOutFromRemovedRows) {
        var rowspanInRemovedSection = last - row + 1;
        var rowSpanToSet = cellHeight - rowspanInRemovedSection;
        cellsToMove.set(column, {
          cell: cell,
          rowspan: rowSpanToSet
        });
      }

      var isCellOverlappingRemovedRows = row < first && lastRowOfCell >= first;

      if (isCellOverlappingRemovedRows) {
        var rowspanAdjustment = void 0; // Cell fully covers removed section - trim it by removed rows count.

        if (lastRowOfCell >= last) {
          rowspanAdjustment = last - first + 1;
        } // Cell partially overlaps removed section - calculate cell's span that is in removed section.
        else {
            rowspanAdjustment = lastRowOfCell - first + 1;
          }

        cellsToTrim.push({
          cell: cell,
          rowspan: cellHeight - rowspanAdjustment
        });
      }
    }
  } catch (err) {
    _iterator9.e(err);
  } finally {
    _iterator9.f();
  }

  return {
    cellsToMove: cellsToMove,
    cellsToTrim: cellsToTrim
  };
}

function moveCellsToRow(table, targetRowIndex, cellsToMove, writer) {
  var tableWalker = new tablewalker_TableWalker(table, {
    includeAllSlots: true,
    row: targetRowIndex
  });

  var tableRowMap = _toConsumableArray(tableWalker);

  var row = table.getChild(targetRowIndex);
  var previousCell;

  var _iterator10 = _createForOfIteratorHelper(tableRowMap),
      _step10;

  try {
    for (_iterator10.s(); !(_step10 = _iterator10.n()).done;) {
      var _step10$value = _step10.value,
          column = _step10$value.column,
          cell = _step10$value.cell,
          isAnchor = _step10$value.isAnchor;

      if (cellsToMove.has(column)) {
        var _cellsToMove$get = cellsToMove.get(column),
            cellToMove = _cellsToMove$get.cell,
            rowspan = _cellsToMove$get.rowspan;

        var targetPosition = previousCell ? writer.createPositionAfter(previousCell) : writer.createPositionAt(row, 0);
        writer.move(writer.createRangeOn(cellToMove), targetPosition);
        updateNumericAttribute('rowspan', rowspan, cellToMove, writer);
        previousCell = cellToMove;
      } else if (isAnchor) {
        // If cell is spanned then `cell` holds reference to overlapping cell. See ckeditor/ckeditor5#6502.
        previousCell = cell;
      }
    }
  } catch (err) {
    _iterator10.e(err);
  } finally {
    _iterator10.f();
  }
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/commands/mergecellscommand.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/commands/mergecellscommand
 */





/**
 * The merge cells command.
 *
 * The command is registered by {@link module:table/tableediting~TableEditing} as the `'mergeTableCells'` editor command.
 *
 * For example, to merge selected table cells:
 *
 *		editor.execute( 'mergeTableCells' );
 *
 * @extends module:core/command~Command
 */

var mergecellscommand_MergeCellsCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(MergeCellsCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(MergeCellsCommand);

  function MergeCellsCommand() {
    Object(classCallCheck["a" /* default */])(this, MergeCellsCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(MergeCellsCommand, [{
    key: "refresh",

    /**
     * @inheritDoc
     */
    value: function refresh() {
      var selectedTableCells = selection_getSelectedTableCells(this.editor.model.document.selection);
      this.isEnabled = isSelectionRectangular(selectedTableCells, this.editor.plugins.get(tableutils_TableUtils));
    }
    /**
     * Executes the command.
     *
     * @fires execute
     */

  }, {
    key: "execute",
    value: function execute() {
      var model = this.editor.model;
      var tableUtils = this.editor.plugins.get(tableutils_TableUtils);
      model.change(function (writer) {
        var selectedTableCells = selection_getSelectedTableCells(model.document.selection); // All cells will be merged into the first one.

        var firstTableCell = selectedTableCells.shift(); // Set the selection in cell that other cells are being merged to prevent model-selection-range-intersects error in undo.
        // See https://github.com/ckeditor/ckeditor5/issues/6634.
        // May be fixed by: https://github.com/ckeditor/ckeditor5/issues/6639.

        writer.setSelection(firstTableCell, 0); // Update target cell dimensions.

        var _getMergeDimensions = getMergeDimensions(firstTableCell, selectedTableCells, tableUtils),
            mergeWidth = _getMergeDimensions.mergeWidth,
            mergeHeight = _getMergeDimensions.mergeHeight;

        updateNumericAttribute('colspan', mergeWidth, firstTableCell, writer);
        updateNumericAttribute('rowspan', mergeHeight, firstTableCell, writer);

        var _iterator = _createForOfIteratorHelper(selectedTableCells),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var tableCell = _step.value;
            mergecellscommand_mergeTableCells(tableCell, firstTableCell, writer);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }

        var table = common_findAncestor('table', firstTableCell); // Remove rows and columns that become empty (have no anchored cells).

        removeEmptyRowsColumns(table, tableUtils, writer.batch);
        writer.setSelection(firstTableCell, 'in');
      });
    }
  }]);

  return MergeCellsCommand;
}(command_Command); // Merges two table cells. It will ensure that after merging cells with empty paragraphs the resulting table cell will only have one
// paragraph. If one of the merged table cells is empty, the merged table cell will have contents of the non-empty table cell.
// If both are empty, the merged table cell will have only one empty paragraph.
//
// @param {module:engine/model/element~Element} cellBeingMerged
// @param {module:engine/model/element~Element} targetCell
// @param {module:engine/model/writer~Writer} writer




function mergecellscommand_mergeTableCells(cellBeingMerged, targetCell, writer) {
  if (!mergecellscommand_isEmpty(cellBeingMerged)) {
    if (mergecellscommand_isEmpty(targetCell)) {
      writer.remove(writer.createRangeIn(targetCell));
    }

    writer.move(writer.createRangeIn(cellBeingMerged), writer.createPositionAt(targetCell, 'end'));
  } // Remove merged table cell.


  writer.remove(cellBeingMerged);
} // Checks if the passed table cell contains an empty paragraph.
//
// @param {module:engine/model/element~Element} tableCell
// @returns {Boolean}


function mergecellscommand_isEmpty(tableCell) {
  return tableCell.childCount == 1 && tableCell.getChild(0).is('paragraph') && tableCell.getChild(0).isEmpty;
}

function getMergeDimensions(firstTableCell, selectedTableCells, tableUtils) {
  var maxWidthOffset = 0;
  var maxHeightOffset = 0;

  var _iterator2 = _createForOfIteratorHelper(selectedTableCells),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var tableCell = _step2.value;

      var _tableUtils$getCellLo2 = tableUtils.getCellLocation(tableCell),
          row = _tableUtils$getCellLo2.row,
          column = _tableUtils$getCellLo2.column;

      maxWidthOffset = getMaxOffset(tableCell, column, maxWidthOffset, 'colspan');
      maxHeightOffset = getMaxOffset(tableCell, row, maxHeightOffset, 'rowspan');
    } // Update table cell span attribute and merge set selection on a merged contents.

  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  var _tableUtils$getCellLo = tableUtils.getCellLocation(firstTableCell),
      firstCellRow = _tableUtils$getCellLo.row,
      firstCellColumn = _tableUtils$getCellLo.column;

  var mergeWidth = maxWidthOffset - firstCellColumn;
  var mergeHeight = maxHeightOffset - firstCellRow;
  return {
    mergeWidth: mergeWidth,
    mergeHeight: mergeHeight
  };
}

function getMaxOffset(tableCell, start, currentMaxOffset, which) {
  var dimensionValue = parseInt(tableCell.getAttribute(which) || 1);
  return Math.max(currentMaxOffset, start + dimensionValue);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/commands/selectrowcommand.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/commands/selectrowcommand
 */



/**
 * The select row command.
 *
 * The command is registered by {@link module:table/tableediting~TableEditing} as the `'selectTableRow'` editor command.
 *
 * To select the rows containing the selected cells, execute the command:
 *
 *		editor.execute( 'selectTableRow' );
 *
 * @extends module:core/command~Command
 */

var selectrowcommand_SelectRowCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(SelectRowCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(SelectRowCommand);

  function SelectRowCommand() {
    Object(classCallCheck["a" /* default */])(this, SelectRowCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(SelectRowCommand, [{
    key: "refresh",

    /**
     * @inheritDoc
     */
    value: function refresh() {
      var selectedCells = getSelectionAffectedTableCells(this.editor.model.document.selection);
      this.isEnabled = selectedCells.length > 0;
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "execute",
    value: function execute() {
      var model = this.editor.model;
      var referenceCells = getSelectionAffectedTableCells(model.document.selection);
      var rowIndexes = getRowIndexes(referenceCells);
      var table = common_findAncestor('table', referenceCells[0]);
      var rangesToSelect = [];

      for (var rowIndex = rowIndexes.first; rowIndex <= rowIndexes.last; rowIndex++) {
        var _iterator = _createForOfIteratorHelper(table.getChild(rowIndex).getChildren()),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var cell = _step.value;
            rangesToSelect.push(model.createRangeOn(cell));
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      model.change(function (writer) {
        writer.setSelection(rangesToSelect);
      });
    }
  }]);

  return SelectRowCommand;
}(command_Command);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/commands/selectcolumncommand.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/commands/selectcolumncommand
 */




/**
 * The select column command.
 *
 * The command is registered by {@link module:table/tableediting~TableEditing} as the `'selectTableColumn'` editor command.
 *
 * To select the columns containing the selected cells, execute the command:
 *
 *		editor.execute( 'selectTableColumn' );
 *
 * @extends module:core/command~Command
 */

var selectcolumncommand_SelectColumnCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(SelectColumnCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(SelectColumnCommand);

  function SelectColumnCommand() {
    Object(classCallCheck["a" /* default */])(this, SelectColumnCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(SelectColumnCommand, [{
    key: "refresh",

    /**
     * @inheritDoc
     */
    value: function refresh() {
      var selectedCells = getSelectionAffectedTableCells(this.editor.model.document.selection);
      this.isEnabled = selectedCells.length > 0;
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "execute",
    value: function execute() {
      var model = this.editor.model;
      var referenceCells = getSelectionAffectedTableCells(model.document.selection);
      var firstCell = referenceCells[0];
      var lastCell = referenceCells.pop();
      var table = common_findAncestor('table', firstCell);
      var tableUtils = this.editor.plugins.get('TableUtils');
      var startLocation = tableUtils.getCellLocation(firstCell);
      var endLocation = tableUtils.getCellLocation(lastCell);
      var startColumn = Math.min(startLocation.column, endLocation.column);
      var endColumn = Math.max(startLocation.column, endLocation.column);
      var rangesToSelect = [];

      var _iterator = _createForOfIteratorHelper(new tablewalker_TableWalker(table, {
        startColumn: startColumn,
        endColumn: endColumn
      })),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var cellInfo = _step.value;
          rangesToSelect.push(model.createRangeOn(cellInfo.cell));
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      model.change(function (writer) {
        writer.setSelection(rangesToSelect);
      });
    }
  }]);

  return SelectColumnCommand;
}(command_Command);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/converters/table-layout-post-fixer.js













/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/converters/table-layout-post-fixer
 */


/**
 * Injects a table layout post-fixer into the model.
 *
 * The role of the table layout post-fixer is to ensure that the table rows have the correct structure
 * after a {@link module:engine/model/model~Model#change `change()`} block was executed.
 *
 * The correct structure means that:
 *
 * * All table rows have the same size.
 * * None of the table cells extend vertically beyond their section (either header or body).
 * * A table cell has always at least one element as a child.
 *
 * If the table structure is not correct, the post-fixer will automatically correct it in two steps:
 *
 * 1. It will clip table cells that extend beyond their section.
 * 2. It will add empty table cells to the rows that are narrower than the widest table row.
 *
 * ## Clipping overlapping table cells
 *
 * Such situation may occur when pasting a table (or a part of a table) to the editor from external sources.
 *
 * For example, see the following table which has a cell (FOO) with the rowspan attribute (2):
 *
 *		<table headingRows="1">
 *			<tableRow>
 *				<tableCell rowspan="2"><paragraph>FOO</paragraph></tableCell>
 *				<tableCell colspan="2"><paragraph>BAR</paragraph></tableCell>
 *			</tableRow>
 *			<tableRow>
 *				<tableCell><paragraph>BAZ</paragraph></tableCell>
 *				<tableCell><paragraph>XYZ</paragraph></tableCell>
 *			</tableRow>
 *		</table>
 *
 * It will be rendered in the view as:
 *
 *		<table>
 *			<thead>
 *				<tr>
 *					<td rowspan="2">FOO</td>
 *					<td colspan="2">BAR</td>
 *				</tr>
 *			</thead>
 *			<tbody>
 *				<tr>
 *					<td>BAZ</td>
 *					<td>XYZ</td>
 *				</tr>
 *			</tbody>
 *		</table>
 *
 * In the above example the table will be rendered as a table with two rows: one in the header and second one in the body.
 * The table cell (FOO) cannot span over multiple rows as it would extend from the header to the body section.
 * The `rowspan` attribute must be changed to (1). The value (1) is the default value of the `rowspan` attribute
 * so the `rowspan` attribute will be removed from the model.
 *
 * The table cell with BAZ in the content will be in the first column of the table.
 *
 * ## Adding missing table cells
 *
 * The table post-fixer will insert empty table cells to equalize table row sizes (the number of columns).
 * The size of a table row is calculated by counting column spans of table cells, both horizontal (from the same row) and
 * vertical (from the rows above).
 *
 * In the above example, the table row in the body section of the table is narrower then the row from the header: it has two cells
 * with the default colspan (1). The header row has one cell with colspan (1) and the second with colspan (2).
 * The table cell (FOO) does not extend beyond the head section (and as such will be fixed in the first step of this post-fixer).
 * The post-fixer will add a missing table cell to the row in the body section of the table.
 *
 * The table from the above example will be fixed and rendered to the view as below:
 *
 *		<table>
 *			<thead>
 *				<tr>
 *					<td rowspan="2">FOO</td>
 *					<td colspan="2">BAR</td>
 *				</tr>
 *			</thead>
 *			<tbody>
 *				<tr>
 *					<td>BAZ</td>
 *					<td>XYZ</td>
 *				</tr>
 *			</tbody>
 *		</table>
 *
 * ## Collaboration and undo - Expectations vs post-fixer results
 *
 * The table post-fixer only ensures proper structure without a deeper analysis of the nature of the change. As such, it might lead
 * to a structure which was not intended by the user. In particular, it will also fix undo steps (in conjunction with collaboration)
 * in which the editor content might not return to the original state.
 *
 * This will usually happen when one or more users change the size of the table.
 *
 * As an example see the table below:
 *
 *		<table>
 *			<tbody>
 *				<tr>
 *					<td>11</td>
 *					<td>12</td>
 *				</tr>
 *				<tr>
 *					<td>21</td>
 *					<td>22</td>
 *				</tr>
 *			</tbody>
 *		</table>
 *
 * and the user actions:
 *
 * 1. Both users have a table with two rows and two columns.
 * 2. User A adds a column at the end of the table. This will insert empty table cells to two rows.
 * 3. User B adds a row at the end of the table. This will insert a row with two empty table cells.
 * 4. Both users will have a table as below:
 *
 *
 *		<table>
 *			<tbody>
 *				<tr>
 *					<td>11</td>
 *					<td>12</td>
 *					<td>(empty, inserted by A)</td>
 *				</tr>
 *				<tr>
 *					<td>21</td>
 *					<td>22</td>
 *					<td>(empty, inserted by A)</td>
 *				</tr>
 *				<tr>
 *					<td>(empty, inserted by B)</td>
 *					<td>(empty, inserted by B)</td>
 *				</tr>
 *			</tbody>
 *		</table>
 *
 * The last row is shorter then others so the table post-fixer will add an empty row to the last row:
 *
 *		<table>
 *			<tbody>
 *				<tr>
 *					<td>11</td>
 *					<td>12</td>
 *					<td>(empty, inserted by A)</td>
 *				</tr>
 *				<tr>
 *					<td>21</td>
 *					<td>22</td>
 *					<td>(empty, inserted by A)</td>
 *				</tr>
 *				<tr>
 *					<td>(empty, inserted by B)</td>
 *					<td>(empty, inserted by B)</td>
 *					<td>(empty, inserted by the post-fixer)</td>
 *				</tr>
 *			</tbody>
 *		</table>
 *
 * Unfortunately undo does not know the nature of the changes and depending on which user applies the post-fixer changes, undoing them
 * might lead to a broken table. If User B undoes inserting the column to the table, the undo engine will undo only the operations of
 * inserting empty cells to rows from the initial table state (row 1 and 2) but the cell in the post-fixed row will remain:
 *
 *		<table>
 *			<tbody>
 *				<tr>
 *					<td>11</td>
 *					<td>12</td>
 *				</tr>
 *				<tr>
 *					<td>21</td>
 *					<td>22</td>
 *				</tr>
 *				<tr>
 *					<td>(empty, inserted by B)</td>
 *					<td>(empty, inserted by B)</td>
 *					<td>(empty, inserted by a post-fixer)</td>
 *				</tr>
 *			</tbody>
 *		</table>
 *
 * After undo, the table post-fixer will detect that two rows are shorter than others and will fix the table to:
 *
 *		<table>
 *			<tbody>
 *				<tr>
 *					<td>11</td>
 *					<td>12</td>
 *					<td>(empty, inserted by a post-fixer after undo)</td>
 *				</tr>
 *				<tr>
 *					<td>21</td>
 *					<td>22</td>
 *					<td>(empty, inserted by a post-fixer after undo)</td>
 *				</tr>
 *				<tr>
 *					<td>(empty, inserted by B)</td>
 *					<td>(empty, inserted by B)</td>
 *					<td>(empty, inserted by a post-fixer)</td>
 *				</tr>
 *			</tbody>
 *		</table>
 * @param {module:engine/model/model~Model} model
 */

function injectTableLayoutPostFixer(model) {
  model.document.registerPostFixer(function (writer) {
    return tableLayoutPostFixer(writer, model);
  });
} // The table layout post-fixer.
//
// @param {module:engine/model/writer~Writer} writer
// @param {module:engine/model/model~Model} model

function tableLayoutPostFixer(writer, model) {
  var changes = model.document.differ.getChanges();
  var wasFixed = false; // Do not analyze the same table more then once - may happen for multiple changes in the same table.

  var analyzedTables = new Set();

  var _iterator = _createForOfIteratorHelper(changes),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var entry = _step.value;
      var table = void 0;

      if (entry.name == 'table' && entry.type == 'insert') {
        table = entry.position.nodeAfter;
      } // Fix table on adding/removing table cells and rows.


      if (entry.name == 'tableRow' || entry.name == 'tableCell') {
        table = common_findAncestor('table', entry.position);
      } // Fix table on any table's attribute change - including attributes of table cells.


      if (isTableAttributeEntry(entry)) {
        table = common_findAncestor('table', entry.range.start);
      }

      if (table && !analyzedTables.has(table)) {
        // Step 1: correct rowspans of table cells if necessary.
        // The wasFixed flag should be true if any of tables in batch was fixed - might be more then one.
        wasFixed = fixTableCellsRowspan(table, writer) || wasFixed; // Step 2: fix table rows sizes.

        wasFixed = fixTableRowsSizes(table, writer) || wasFixed;
        analyzedTables.add(table);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return wasFixed;
} // Fixes the invalid value of the `rowspan` attribute because a table cell cannot vertically extend beyond the table section it belongs to.
//
// @param {module:engine/model/element~Element} table
// @param {module:engine/model/writer~Writer} writer
// @returns {Boolean} Returns `true` if the table was fixed.


function fixTableCellsRowspan(table, writer) {
  var wasFixed = false;
  var cellsToTrim = findCellsToTrim(table);

  if (cellsToTrim.length) {
    // @if CK_DEBUG_TABLE // console.log( `Post-fixing table: trimming cells row-spans (${ cellsToTrim.length }).` );
    wasFixed = true;

    var _iterator2 = _createForOfIteratorHelper(cellsToTrim),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var data = _step2.value;
        updateNumericAttribute('rowspan', data.rowspan, data.cell, writer, 1);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }
  }

  return wasFixed;
} // Makes all table rows in a table the same size.
//
// @param {module:engine/model/element~Element} table
// @param {module:engine/model/writer~Writer} writer
// @returns {Boolean} Returns `true` if the table was fixed.


function fixTableRowsSizes(table, writer) {
  var wasFixed = false;
  var rowsLengths = getRowsLengths(table);
  var rowsToRemove = []; // Find empty rows.

  var _iterator3 = _createForOfIteratorHelper(rowsLengths.entries()),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _step3$value = _slicedToArray(_step3.value, 2),
          _rowIndex2 = _step3$value[0],
          _size = _step3$value[1];

      if (!_size) {
        rowsToRemove.push(_rowIndex2);
      }
    } // Remove empty rows.

  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  if (rowsToRemove.length) {
    // @if CK_DEBUG_TABLE // console.log( `Post-fixing table: remove empty rows (${ rowsToRemove.length }).` );
    wasFixed = true;

    var _iterator4 = _createForOfIteratorHelper(rowsToRemove.reverse()),
        _step4;

    try {
      for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
        var rowIndex = _step4.value;
        writer.remove(table.getChild(rowIndex));
        rowsLengths.splice(rowIndex, 1);
      }
    } catch (err) {
      _iterator4.e(err);
    } finally {
      _iterator4.f();
    }
  } // Verify if all the rows have the same number of columns.


  var tableSize = rowsLengths[0];
  var isValid = rowsLengths.every(function (length) {
    return length === tableSize;
  });

  if (!isValid) {
    // @if CK_DEBUG_TABLE // console.log( 'Post-fixing table: adding missing cells.' );
    // Find the maximum number of columns.
    var maxColumns = rowsLengths.reduce(function (prev, current) {
      return current > prev ? current : prev;
    }, 0);

    var _iterator5 = _createForOfIteratorHelper(rowsLengths.entries()),
        _step5;

    try {
      for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
        var _step5$value = _slicedToArray(_step5.value, 2),
            _rowIndex = _step5$value[0],
            size = _step5$value[1];

        var columnsToInsert = maxColumns - size;

        if (columnsToInsert) {
          for (var i = 0; i < columnsToInsert; i++) {
            createEmptyTableCell(writer, writer.createPositionAt(table.getChild(_rowIndex), 'end'));
          }

          wasFixed = true;
        }
      }
    } catch (err) {
      _iterator5.e(err);
    } finally {
      _iterator5.f();
    }
  }

  return wasFixed;
} // Searches for table cells that extend beyond the table section to which they belong to. It will return an array of objects
// that stores table cells to be trimmed and the correct value of the `rowspan` attribute to set.
//
// @param {module:engine/model/element~Element} table
// @returns {Array.<{{cell, rowspan}}>}


function findCellsToTrim(table) {
  var headingRows = parseInt(table.getAttribute('headingRows') || 0);
  var maxRows = table.childCount;
  var cellsToTrim = [];

  var _iterator6 = _createForOfIteratorHelper(new tablewalker_TableWalker(table)),
      _step6;

  try {
    for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
      var _step6$value = _step6.value,
          row = _step6$value.row,
          cell = _step6$value.cell,
          cellHeight = _step6$value.cellHeight;

      // Skip cells that do not expand over its row.
      if (cellHeight < 2) {
        continue;
      }

      var isInHeader = row < headingRows; // Row limit is either end of header section or whole table as table body is after the header.

      var rowLimit = isInHeader ? headingRows : maxRows; // If table cell expands over its limit reduce it height to proper value.

      if (row + cellHeight > rowLimit) {
        var newRowspan = rowLimit - row;
        cellsToTrim.push({
          cell: cell,
          rowspan: newRowspan
        });
      }
    }
  } catch (err) {
    _iterator6.e(err);
  } finally {
    _iterator6.f();
  }

  return cellsToTrim;
} // Returns an array with lengths of rows assigned to the corresponding row index.
//
// @param {module:engine/model/element~Element} table
// @returns {Array.<Number>}


function getRowsLengths(table) {
  // TableWalker will not provide items for the empty rows, we need to pre-fill this array.
  var lengths = new Array(table.childCount).fill(0);

  var _iterator7 = _createForOfIteratorHelper(new tablewalker_TableWalker(table, {
    includeAllSlots: true
  })),
      _step7;

  try {
    for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {
      var row = _step7.value.row;
      lengths[row]++;
    }
  } catch (err) {
    _iterator7.e(err);
  } finally {
    _iterator7.f();
  }

  return lengths;
} // Checks if the differ entry for an attribute change is one of the table's attributes.
//
// @param entry
// @returns {Boolean}


function isTableAttributeEntry(entry) {
  var isAttributeType = entry.type === 'attribute';
  var key = entry.attributeKey;
  return isAttributeType && (key === 'headingRows' || key === 'colspan' || key === 'rowspan');
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/converters/table-cell-paragraph-post-fixer.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/converters/table-cell-paragraph-post-fixer
 */

/**
 * Injects a table cell post-fixer into the model which inserts a `paragraph` element into empty table cells.
 *
 * A table cell must contain at least one block element as a child. An empty table cell will have an empty `paragraph` as a child.
 *
 *		<table>
 *			<tableRow>
 *				<tableCell></tableCell>
 *			</tableRow>
 *		</table>
 *
 * Will be fixed to:
 *
 *		<table>
 *			<tableRow>
 *				<tableCell><paragraph></paragraph></tableCell>
 *			</tableRow>
 *		</table>
 *
 * @param {module:engine/model/model~Model} model
 */
function injectTableCellParagraphPostFixer(model) {
  model.document.registerPostFixer(function (writer) {
    return tableCellContentsPostFixer(writer, model);
  });
} // The table cell contents post-fixer.
//
// @param {module:engine/model/writer~Writer} writer
// @param {module:engine/model/model~Model} model

function tableCellContentsPostFixer(writer, model) {
  var changes = model.document.differ.getChanges();
  var wasFixed = false;

  var _iterator = _createForOfIteratorHelper(changes),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var entry = _step.value;

      if (entry.type == 'insert' && entry.name == 'table') {
        wasFixed = fixTable(entry.position.nodeAfter, writer) || wasFixed;
      }

      if (entry.type == 'insert' && entry.name == 'tableRow') {
        wasFixed = fixTableRow(entry.position.nodeAfter, writer) || wasFixed;
      }

      if (entry.type == 'insert' && entry.name == 'tableCell') {
        wasFixed = fixTableCellContent(entry.position.nodeAfter, writer) || wasFixed;
      }

      if (checkTableCellChange(entry)) {
        wasFixed = fixTableCellContent(entry.position.parent, writer) || wasFixed;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return wasFixed;
} // Fixes all table cells in a table.
//
// @param {module:engine/model/element~Element} table
// @param {module:engine/model/writer~Writer} writer


function fixTable(table, writer) {
  var wasFixed = false;

  var _iterator2 = _createForOfIteratorHelper(table.getChildren()),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var row = _step2.value;
      wasFixed = fixTableRow(row, writer) || wasFixed;
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return wasFixed;
} // Fixes all table cells in a table row.
//
// @param {module:engine/model/element~Element} tableRow
// @param {module:engine/model/writer~Writer} writer


function fixTableRow(tableRow, writer) {
  var wasFixed = false;

  var _iterator3 = _createForOfIteratorHelper(tableRow.getChildren()),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var tableCell = _step3.value;
      wasFixed = fixTableCellContent(tableCell, writer) || wasFixed;
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return wasFixed;
} // Fixes all table cell content by:
// - Adding a paragraph to a table cell without any child.
// - Wrapping direct $text in a `<paragraph>`.
//
// @param {module:engine/model/element~Element} table
// @param {module:engine/model/writer~Writer} writer
// @returns {Boolean}


function fixTableCellContent(tableCell, writer) {
  // Insert paragraph to an empty table cell.
  if (tableCell.childCount == 0) {
    // @if CK_DEBUG_TABLE // console.log( 'Post-fixing table: insert paragraph in empty cell.' );
    writer.insertElement('paragraph', tableCell);
    return true;
  } // Check table cell children for directly placed text nodes.
  // Temporary solution. See https://github.com/ckeditor/ckeditor5/issues/1464.


  var textNodes = Array.from(tableCell.getChildren()).filter(function (child) {
    return child.is('text');
  }); // @if CK_DEBUG_TABLE // textNodes.length && console.log( 'Post-fixing table: wrap cell content with paragraph.' );

  var _iterator4 = _createForOfIteratorHelper(textNodes),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var child = _step4.value;
      writer.wrap(writer.createRangeOn(child), 'paragraph');
    } // Return true when there were text nodes to fix.

  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }

  return !!textNodes.length;
} // Checks if a differ change should fix the table cell. This happens on:
// - Removing content from the table cell (i.e. `tableCell` can be left empty).
// - Adding a text node directly into a table cell.
//
// @param {Object} differ change entry
// @returns {Boolean}


function checkTableCellChange(entry) {
  if (!entry.position || !entry.position.parent.is('tableCell')) {
    return false;
  }

  return entry.type == 'insert' && entry.name == '$text' || entry.type == 'remove';
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/converters/table-cell-refresh-post-fixer.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/converters/table-cell-refresh-post-fixer
 */

/**
 * Injects a table cell post-fixer into the model which marks the table cell in the differ to have it re-rendered.
 *
 * Model `paragraph` inside a table cell can be rendered as `<span>` or `<p>`. It is rendered as `<span>` if this is the only block
 * element in that table cell and it does not have any attributes. It is rendered as `<p>` otherwise.
 *
 * When table cell content changes, for example a second `paragraph` element is added, we need to ensure that the first `paragraph` is
 * re-rendered so it changes from `<span>` to `<p>`. The easiest way to do it is to re-render the entire table cell.
 *
 * @param {module:engine/model/model~Model} model
 */
function injectTableCellRefreshPostFixer(model) {
  model.document.registerPostFixer(function () {
    return tableCellRefreshPostFixer(model);
  });
}

function tableCellRefreshPostFixer(model) {
  var differ = model.document.differ; // Stores cells to be refreshed so the table cell will be refreshed once for multiple changes.

  var cellsToRefresh = new Set(); // Counting the paragraph inserts to verify if it increased to more than one paragraph in the current differ.

  var insertCount = 0;

  var _iterator = _createForOfIteratorHelper(differ.getChanges()),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var change = _step.value;
      var parent = change.type == 'insert' || change.type == 'remove' ? change.position.parent : change.range.start.parent;

      if (!parent.is('tableCell')) {
        continue;
      }

      if (change.type == 'insert') {
        insertCount++;
      }

      if (checkRefresh(parent, change.type, insertCount)) {
        cellsToRefresh.add(parent);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  if (cellsToRefresh.size) {
    // @if CK_DEBUG_TABLE // console.log( `Post-fixing table: refreshing cells (${ cellsToRefresh.size }).` );
    var _iterator2 = _createForOfIteratorHelper(cellsToRefresh.values()),
        _step2;

    try {
      for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
        var tableCell = _step2.value;
        differ.refreshItem(tableCell);
      }
    } catch (err) {
      _iterator2.e(err);
    } finally {
      _iterator2.f();
    }

    return true;
  }

  return false;
} // Checks if the model table cell requires refreshing to be re-rendered to a proper state in the view.
//
// This method detects changes that will require renaming `<span>` to `<p>` (or vice versa) in the view.
//
// This method is a simple heuristic that checks only a single change and will sometimes give a false positive result when multiple changes
// will result in a state that does not require renaming in the view (but will be seen as requiring a refresh).
//
// For instance: A `<span>` should be renamed to `<p>` when adding an attribute to a `<paragraph>`.
// But adding one attribute and removing another one will result in a false positive: the check for an added attribute will see one
// attribute on a paragraph and will falsely qualify such change as adding an attribute to a paragraph without any attribute.
//
// @param {module:engine/model/element~Element} tableCell The table cell to check.
// @param {String} type Type of change.
// @param {Number} insertCount The number of inserts in differ.


function checkRefresh(tableCell, type, insertCount) {
  var hasInnerParagraph = Array.from(tableCell.getChildren()).some(function (child) {
    return child.is('paragraph');
  }); // If there is no paragraph in table cell then the view doesn't require refreshing.
  //
  // Why? What we really want to achieve is to make all the old paragraphs (which weren't added in this batch) to be
  // converted once again, so that the paragraph-in-table-cell converter can correctly create a `<p>` or a `<span>` element.
  // If there are no paragraphs in the table cell, we don't care.

  if (!hasInnerParagraph) {
    return false;
  } // For attribute change we only refresh if there is a single paragraph as in this case we may want to change existing `<span>` to `<p>`.


  if (type == 'attribute') {
    var attributesCount = Array.from(tableCell.getChild(0).getAttributeKeys()).length;
    return tableCell.childCount === 1 && attributesCount < 2;
  } // For other changes (insert, remove) the `<span>` to `<p>` change is needed when:
  //
  // - another element is added to a single paragraph (childCount becomes >= 2)
  // - another element is removed and a single paragraph is left (childCount == 1)
  //
  // Change is not needed if there were multiple blocks before change.


  return tableCell.childCount <= (type == 'insert' ? insertCount + 1 : 1);
}
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-table/theme/tableediting.css
var tableediting = __webpack_require__("4230");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/tableediting.js










/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/tableediting
 */




















/**
 * The table editing feature.
 *
 * @extends module:core/plugin~Plugin
 */

var tableediting_TableEditing = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(TableEditing, _Plugin);

  var _super = Object(createSuper["a" /* default */])(TableEditing);

  function TableEditing() {
    Object(classCallCheck["a" /* default */])(this, TableEditing);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(TableEditing, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var editor = this.editor;
      var model = editor.model;
      var schema = model.schema;
      var conversion = editor.conversion;
      schema.register('table', {
        allowWhere: '$block',
        allowAttributes: ['headingRows', 'headingColumns'],
        isLimit: true,
        isObject: true,
        isBlock: true
      });
      schema.register('tableRow', {
        allowIn: 'table',
        isLimit: true
      });
      schema.register('tableCell', {
        allowIn: 'tableRow',
        allowAttributes: ['colspan', 'rowspan'],
        isObject: true
      }); // Allow all $block content inside table cell.

      schema.extend('$block', {
        allowIn: 'tableCell'
      }); // Disallow table in table.

      schema.addChildCheck(function (context, childDefinition) {
        if (childDefinition.name == 'table' && Array.from(context.getNames()).includes('table')) {
          return false;
        }
      }); // Table conversion.

      conversion.for('upcast').add(upcastTable());
      conversion.for('editingDowncast').add(downcastInsertTable({
        asWidget: true
      }));
      conversion.for('dataDowncast').add(downcastInsertTable()); // Table row conversion.

      conversion.for('upcast').elementToElement({
        model: 'tableRow',
        view: 'tr'
      });
      conversion.for('upcast').add(skipEmptyTableRow());
      conversion.for('editingDowncast').add(downcastInsertRow());
      conversion.for('editingDowncast').add(downcastRemoveRow()); // Table cell conversion.

      conversion.for('upcast').add(upcastTableCell('td'));
      conversion.for('upcast').add(upcastTableCell('th'));
      conversion.for('editingDowncast').add(downcastInsertCell()); // Table attributes conversion.

      conversion.attributeToAttribute({
        model: 'colspan',
        view: 'colspan'
      });
      conversion.attributeToAttribute({
        model: 'rowspan',
        view: 'rowspan'
      }); // Table heading rows and columns conversion.

      conversion.for('editingDowncast').add(downcastTableHeadingColumnsChange());
      conversion.for('editingDowncast').add(downcastTableHeadingRowsChange()); // Define all the commands.

      editor.commands.add('insertTable', new inserttablecommand_InsertTableCommand(editor));
      editor.commands.add('insertTableRowAbove', new insertrowcommand_InsertRowCommand(editor, {
        order: 'above'
      }));
      editor.commands.add('insertTableRowBelow', new insertrowcommand_InsertRowCommand(editor, {
        order: 'below'
      }));
      editor.commands.add('insertTableColumnLeft', new insertcolumncommand_InsertColumnCommand(editor, {
        order: 'left'
      }));
      editor.commands.add('insertTableColumnRight', new insertcolumncommand_InsertColumnCommand(editor, {
        order: 'right'
      }));
      editor.commands.add('removeTableRow', new removerowcommand_RemoveRowCommand(editor));
      editor.commands.add('removeTableColumn', new removecolumncommand_RemoveColumnCommand(editor));
      editor.commands.add('splitTableCellVertically', new splitcellcommand_SplitCellCommand(editor, {
        direction: 'vertically'
      }));
      editor.commands.add('splitTableCellHorizontally', new splitcellcommand_SplitCellCommand(editor, {
        direction: 'horizontally'
      }));
      editor.commands.add('mergeTableCells', new mergecellscommand_MergeCellsCommand(editor));
      editor.commands.add('mergeTableCellRight', new mergecellcommand_MergeCellCommand(editor, {
        direction: 'right'
      }));
      editor.commands.add('mergeTableCellLeft', new mergecellcommand_MergeCellCommand(editor, {
        direction: 'left'
      }));
      editor.commands.add('mergeTableCellDown', new mergecellcommand_MergeCellCommand(editor, {
        direction: 'down'
      }));
      editor.commands.add('mergeTableCellUp', new mergecellcommand_MergeCellCommand(editor, {
        direction: 'up'
      }));
      editor.commands.add('setTableColumnHeader', new setheadercolumncommand_SetHeaderColumnCommand(editor));
      editor.commands.add('setTableRowHeader', new setheaderrowcommand_SetHeaderRowCommand(editor));
      editor.commands.add('selectTableRow', new selectrowcommand_SelectRowCommand(editor));
      editor.commands.add('selectTableColumn', new selectcolumncommand_SelectColumnCommand(editor));
      injectTableLayoutPostFixer(model);
      injectTableCellRefreshPostFixer(model);
      injectTableCellParagraphPostFixer(model);
    }
    /**
     * @inheritDoc
     */

  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'TableEditing';
    }
  }, {
    key: "requires",
    get: function get() {
      return [tableutils_TableUtils];
    }
  }]);

  return TableEditing;
}(plugin_Plugin);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/components/dropdown/splitbutton.css
var splitbutton = __webpack_require__("74fe");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/dropdown/button/splitbuttonview.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/dropdown/button/splitbuttonview
 */






/**
 * The split button view class.
 *
 *		const view = new SplitButtonView();
 *
 *		view.set( {
 *			label: 'A button',
 *			keystroke: 'Ctrl+B',
 *			tooltip: true
 *		} );
 *
 *		view.render();
 *
 *		document.body.append( view.element );
 *
 * Also see the {@link module:ui/dropdown/utils~createDropdown `createDropdown()` util}.
 *
 * @implements module:ui/dropdown/button/dropdownbutton~DropdownButton
 * @extends module:ui/view~View
 */

var splitbuttonview_SplitButtonView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(SplitButtonView, _View);

  var _super = Object(createSuper["a" /* default */])(SplitButtonView);

  /**
   * @inheritDoc
   */
  function SplitButtonView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, SplitButtonView);

    _this = _super.call(this, locale);
    var bind = _this.bindTemplate; // Implement the Button interface.

    _this.set('icon');

    _this.set('isEnabled', true);

    _this.set('isOn', false);

    _this.set('isToggleable', false);

    _this.set('isVisible', true);

    _this.set('keystroke');

    _this.set('label');

    _this.set('tabindex', -1);

    _this.set('tooltip');

    _this.set('tooltipPosition', 's');

    _this.set('type', 'button');

    _this.set('withText', false);
    /**
     * Collection of the child views inside of the split button {@link #element}.
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */


    _this.children = _this.createCollection();
    /**
     * A main button of split button.
     *
     * @readonly
     * @member {module:ui/button/buttonview~ButtonView}
     */

    _this.actionView = _this._createActionView();
    /**
     * A secondary button of split button that opens dropdown.
     *
     * @readonly
     * @member {module:ui/button/buttonview~ButtonView}
     */

    _this.arrowView = _this._createArrowView();
    /**
     * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}. It manages
     * keystrokes of the split button:
     *
     * * <kbd>▶</kbd> moves focus to arrow view when action view is focused,
     * * <kbd>◀</kbd> moves focus to action view when arrow view is focused.
     *
     * @readonly
     * @member {module:utils/keystrokehandler~KeystrokeHandler}
     */

    _this.keystrokes = new keystrokehandler_KeystrokeHandler();
    /**
     * Tracks information about DOM focus in the dropdown.
     *
     * @readonly
     * @member {module:utils/focustracker~FocusTracker}
     */

    _this.focusTracker = new focustracker_FocusTracker();

    _this.setTemplate({
      tag: 'div',
      attributes: {
        class: ['ck', 'ck-splitbutton', bind.if('isVisible', 'ck-hidden', function (value) {
          return !value;
        }), _this.arrowView.bindTemplate.if('isOn', 'ck-splitbutton_open')]
      },
      children: _this.children
    });

    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(SplitButtonView, [{
    key: "render",
    value: function render() {
      var _this2 = this;

      get_get(Object(getPrototypeOf["a" /* default */])(SplitButtonView.prototype), "render", this).call(this);

      this.children.add(this.actionView);
      this.children.add(this.arrowView);
      this.focusTracker.add(this.actionView.element);
      this.focusTracker.add(this.arrowView.element);
      this.keystrokes.listenTo(this.element); // Overrides toolbar focus cycling behavior.

      this.keystrokes.set('arrowright', function (evt, cancel) {
        if (_this2.focusTracker.focusedElement === _this2.actionView.element) {
          _this2.arrowView.focus();

          cancel();
        }
      }); // Overrides toolbar focus cycling behavior.

      this.keystrokes.set('arrowleft', function (evt, cancel) {
        if (_this2.focusTracker.focusedElement === _this2.arrowView.element) {
          _this2.actionView.focus();

          cancel();
        }
      });
    }
    /**
     * Focuses the {@link #actionView#element} of the action part of split button.
     */

  }, {
    key: "focus",
    value: function focus() {
      this.actionView.focus();
    }
    /**
     * Creates a {@link module:ui/button/buttonview~ButtonView} instance as {@link #actionView} and binds it with main split button
     * attributes.
     *
     * @private
     * @returns {module:ui/button/buttonview~ButtonView}
     */

  }, {
    key: "_createActionView",
    value: function _createActionView() {
      var actionView = new buttonview_ButtonView();
      actionView.bind('icon', 'isEnabled', 'isOn', 'isToggleable', 'keystroke', 'label', 'tabindex', 'tooltip', 'tooltipPosition', 'type', 'withText').to(this);
      actionView.extendTemplate({
        attributes: {
          class: 'ck-splitbutton__action'
        }
      });
      actionView.delegate('execute').to(this);
      return actionView;
    }
    /**
     * Creates a {@link module:ui/button/buttonview~ButtonView} instance as {@link #arrowView} and binds it with main split button
     * attributes.
     *
     * @private
     * @returns {module:ui/button/buttonview~ButtonView}
     */

  }, {
    key: "_createArrowView",
    value: function _createArrowView() {
      var arrowView = new buttonview_ButtonView();
      var bind = arrowView.bindTemplate;
      arrowView.icon = dropdown_arrow_default.a;
      arrowView.extendTemplate({
        attributes: {
          class: 'ck-splitbutton__arrow',
          'aria-haspopup': true,
          'aria-expanded': bind.to('isOn', function (value) {
            return String(value);
          })
        }
      });
      arrowView.bind('isEnabled').to(this);
      arrowView.delegate('execute').to(this, 'open');
      return arrowView;
    }
  }]);

  return SplitButtonView;
}(src_view_View);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-table/theme/inserttable.css
var inserttable = __webpack_require__("aeed");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/ui/inserttableview.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/ui/inserttableview
 */


/**
 * The table size view.
 *
 * It renders a 10x10 grid to choose the inserted table size.
 *
 * @extends module:ui/view~View
 * @implements module:ui/dropdown/dropdownpanelfocusable~DropdownPanelFocusable
 */

var inserttableview_InsertTableView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(InsertTableView, _View);

  var _super = Object(createSuper["a" /* default */])(InsertTableView);

  /**
   * @inheritDoc
   */
  function InsertTableView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, InsertTableView);

    _this = _super.call(this, locale);
    var bind = _this.bindTemplate;
    /**
     * A collection of table size box items.
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */

    _this.items = _this._createGridCollection();
    /**
     * The currently selected number of rows of the new table.
     *
     * @observable
     * @member {Number} #rows
     */

    _this.set('rows', 0);
    /**
     * The currently selected number of columns of the new table.
     *
     * @observable
     * @member {Number} #columns
     */


    _this.set('columns', 0);
    /**
     * The label text displayed under the boxes.
     *
     * @observable
     * @member {String} #label
     */


    _this.bind('label').to(Object(assertThisInitialized["a" /* default */])(_this), 'columns', Object(assertThisInitialized["a" /* default */])(_this), 'rows', function (columns, rows) {
      return "".concat(rows, " \xD7 ").concat(columns);
    });

    _this.setTemplate({
      tag: 'div',
      attributes: {
        class: ['ck']
      },
      children: [{
        tag: 'div',
        attributes: {
          class: ['ck-insert-table-dropdown__grid']
        },
        on: {
          'mouseover@.ck-insert-table-dropdown-grid-box': bind.to('boxover')
        },
        children: _this.items
      }, {
        tag: 'div',
        attributes: {
          class: ['ck-insert-table-dropdown__label']
        },
        children: [{
          text: bind.to('label')
        }]
      }],
      on: {
        mousedown: bind.to(function (evt) {
          evt.preventDefault();
        }),
        click: bind.to(function () {
          _this.fire('execute');
        })
      }
    });

    _this.on('boxover', function (evt, domEvt) {
      var _domEvt$target$datase = domEvt.target.dataset,
          row = _domEvt$target$datase.row,
          column = _domEvt$target$datase.column; // As row & column indexes are zero-based transform it to number of selected rows & columns.

      _this.set({
        rows: parseInt(row),
        columns: parseInt(column)
      });
    });

    _this.on('change:columns', function () {
      _this._highlightGridBoxes();
    });

    _this.on('change:rows', function () {
      _this._highlightGridBoxes();
    });

    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(InsertTableView, [{
    key: "focus",
    value: function focus() {// The dropdown panel expects DropdownPanelFocusable interface on views passed to dropdown panel. See #30.
      // The method should be implemented while working on keyboard support for this view. See #22.
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "focusLast",
    value: function focusLast() {// The dropdown panel expects DropdownPanelFocusable interface on views passed to dropdown panel. See #30.
      // The method should be implemented while working on keyboard support for this view. See #22.
    }
    /**
     * Highlights grid boxes depending on rows and columns selected.
     *
     * @private
     */

  }, {
    key: "_highlightGridBoxes",
    value: function _highlightGridBoxes() {
      var rows = this.rows;
      var columns = this.columns;
      this.items.map(function (boxView, index) {
        // Translate box index to the row & column index.
        var itemRow = Math.floor(index / 10);
        var itemColumn = index % 10; // Grid box is highlighted when its row & column index belongs to selected number of rows & columns.

        var isOn = itemRow < rows && itemColumn < columns;
        boxView.set('isOn', isOn);
      });
    }
    /**
     * @private
     * @returns {module:ui/viewcollection~ViewCollection} A view collection containing boxes to be placed in a table grid.
     */

  }, {
    key: "_createGridCollection",
    value: function _createGridCollection() {
      var boxes = []; // Add grid boxes to table selection view.

      for (var index = 0; index < 100; index++) {
        var row = Math.floor(index / 10);
        var column = index % 10;
        boxes.push(new inserttableview_TableSizeGridBoxView(this.locale, row + 1, column + 1));
      }

      return this.createCollection(boxes);
    }
    /**
     * Fired when the mouse hover over one of the {@link #items child grid boxes}.
     *
     * @event boxover
     */

  }]);

  return InsertTableView;
}(src_view_View);
/**
 * A single grid box view element.
 *
 * This class is used to render the table size selection grid in {@link module:table/ui/inserttableview~InsertTableView}.
 *
 * @private
 */




var inserttableview_TableSizeGridBoxView = /*#__PURE__*/function (_View2) {
  Object(inherits["a" /* default */])(TableSizeGridBoxView, _View2);

  var _super2 = Object(createSuper["a" /* default */])(TableSizeGridBoxView);

  /**
   * @inheritDoc
   */
  function TableSizeGridBoxView(locale, row, column) {
    var _this2;

    Object(classCallCheck["a" /* default */])(this, TableSizeGridBoxView);

    _this2 = _super2.call(this, locale);
    var bind = _this2.bindTemplate;
    /**
     * Controls whether the grid box view is "on".
     *
     * @observable
     * @member {Boolean} #isOn
     */

    _this2.set('isOn', false);

    _this2.setTemplate({
      tag: 'div',
      attributes: {
        class: ['ck-insert-table-dropdown-grid-box', bind.if('isOn', 'ck-on')],
        'data-row': row,
        'data-column': column
      }
    });

    return _this2;
  }

  return TableSizeGridBoxView;
}(src_view_View);
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-table/theme/icons/table.svg
var icons_table = __webpack_require__("4928");
var table_default = /*#__PURE__*/__webpack_require__.n(icons_table);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-table/theme/icons/table-column.svg
var table_column = __webpack_require__("2787");
var table_column_default = /*#__PURE__*/__webpack_require__.n(table_column);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-table/theme/icons/table-row.svg
var table_row = __webpack_require__("536c");
var table_row_default = /*#__PURE__*/__webpack_require__.n(table_row);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-table/theme/icons/table-merge-cell.svg
var table_merge_cell = __webpack_require__("f67e");
var table_merge_cell_default = /*#__PURE__*/__webpack_require__.n(table_merge_cell);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/tableui.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/tableui
 */










/**
 * The table UI plugin. It introduces:
 *
 * * The `'insertTable'` dropdown,
 * * The `'tableColumn'` dropdown,
 * * The `'tableRow'` dropdown,
 * * The `'mergeTableCells'` split button.
 *
 * The `'tableColumn'`, `'tableRow'` and `'mergeTableCells'` dropdowns work best with {@link module:table/tabletoolbar~TableToolbar}.
 *
 * @extends module:core/plugin~Plugin
 */

var tableui_TableUI = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(TableUI, _Plugin);

  var _super = Object(createSuper["a" /* default */])(TableUI);

  function TableUI() {
    Object(classCallCheck["a" /* default */])(this, TableUI);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(TableUI, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this = this;

      var editor = this.editor;
      var t = this.editor.t;
      var contentLanguageDirection = editor.locale.contentLanguageDirection;
      var isContentLtr = contentLanguageDirection === 'ltr';
      editor.ui.componentFactory.add('insertTable', function (locale) {
        var command = editor.commands.get('insertTable');
        var dropdownView = createDropdown(locale);
        dropdownView.bind('isEnabled').to(command); // Decorate dropdown's button.

        dropdownView.buttonView.set({
          icon: table_default.a,
          label: t('Insert table'),
          tooltip: true
        });
        var insertTableView;
        dropdownView.on('change:isOpen', function () {
          if (insertTableView) {
            return;
          } // Prepare custom view for dropdown's panel.


          insertTableView = new inserttableview_InsertTableView(locale);
          dropdownView.panelView.children.add(insertTableView);
          insertTableView.delegate('execute').to(dropdownView);
          dropdownView.buttonView.on('open', function () {
            // Reset the chooser before showing it to the user.
            insertTableView.rows = 0;
            insertTableView.columns = 0;
          });
          dropdownView.on('execute', function () {
            editor.execute('insertTable', {
              rows: insertTableView.rows,
              columns: insertTableView.columns
            });
            editor.editing.view.focus();
          });
        });
        return dropdownView;
      });
      editor.ui.componentFactory.add('tableColumn', function (locale) {
        var options = [{
          type: 'switchbutton',
          model: {
            commandName: 'setTableColumnHeader',
            label: t('Header column'),
            bindIsOn: true
          }
        }, {
          type: 'separator'
        }, {
          type: 'button',
          model: {
            commandName: isContentLtr ? 'insertTableColumnLeft' : 'insertTableColumnRight',
            label: t('Insert column left')
          }
        }, {
          type: 'button',
          model: {
            commandName: isContentLtr ? 'insertTableColumnRight' : 'insertTableColumnLeft',
            label: t('Insert column right')
          }
        }, {
          type: 'button',
          model: {
            commandName: 'removeTableColumn',
            label: t('Delete column')
          }
        }, {
          type: 'button',
          model: {
            commandName: 'selectTableColumn',
            label: t('Select column')
          }
        }];
        return _this._prepareDropdown(t('Column'), table_column_default.a, options, locale);
      });
      editor.ui.componentFactory.add('tableRow', function (locale) {
        var options = [{
          type: 'switchbutton',
          model: {
            commandName: 'setTableRowHeader',
            label: t('Header row'),
            bindIsOn: true
          }
        }, {
          type: 'separator'
        }, {
          type: 'button',
          model: {
            commandName: 'insertTableRowAbove',
            label: t('Insert row above')
          }
        }, {
          type: 'button',
          model: {
            commandName: 'insertTableRowBelow',
            label: t('Insert row below')
          }
        }, {
          type: 'button',
          model: {
            commandName: 'removeTableRow',
            label: t('Delete row')
          }
        }, {
          type: 'button',
          model: {
            commandName: 'selectTableRow',
            label: t('Select row')
          }
        }];
        return _this._prepareDropdown(t('Row'), table_row_default.a, options, locale);
      });
      editor.ui.componentFactory.add('mergeTableCells', function (locale) {
        var options = [{
          type: 'button',
          model: {
            commandName: 'mergeTableCellUp',
            label: t('Merge cell up')
          }
        }, {
          type: 'button',
          model: {
            commandName: isContentLtr ? 'mergeTableCellRight' : 'mergeTableCellLeft',
            label: t('Merge cell right')
          }
        }, {
          type: 'button',
          model: {
            commandName: 'mergeTableCellDown',
            label: t('Merge cell down')
          }
        }, {
          type: 'button',
          model: {
            commandName: isContentLtr ? 'mergeTableCellLeft' : 'mergeTableCellRight',
            label: t('Merge cell left')
          }
        }, {
          type: 'separator'
        }, {
          type: 'button',
          model: {
            commandName: 'splitTableCellVertically',
            label: t('Split cell vertically')
          }
        }, {
          type: 'button',
          model: {
            commandName: 'splitTableCellHorizontally',
            label: t('Split cell horizontally')
          }
        }];
        return _this._prepareMergeSplitButtonDropdown(t('Merge cells'), table_merge_cell_default.a, options, locale);
      });
    }
    /**
     * Creates a dropdown view from a set of options.
     *
     * @private
     * @param {String} label The dropdown button label.
     * @param {String} icon An icon for the dropdown button.
     * @param {Array.<module:ui/dropdown/utils~ListDropdownItemDefinition>} options The list of options for the dropdown.
     * @param {module:utils/locale~Locale} locale
     * @returns {module:ui/dropdown/dropdownview~DropdownView}
     */

  }, {
    key: "_prepareDropdown",
    value: function _prepareDropdown(label, icon, options, locale) {
      var editor = this.editor;
      var dropdownView = createDropdown(locale);

      var commands = this._fillDropdownWithListOptions(dropdownView, options); // Decorate dropdown's button.


      dropdownView.buttonView.set({
        label: label,
        icon: icon,
        tooltip: true
      }); // Make dropdown button disabled when all options are disabled.

      dropdownView.bind('isEnabled').toMany(commands, 'isEnabled', function () {
        for (var _len = arguments.length, areEnabled = new Array(_len), _key = 0; _key < _len; _key++) {
          areEnabled[_key] = arguments[_key];
        }

        return areEnabled.some(function (isEnabled) {
          return isEnabled;
        });
      });
      this.listenTo(dropdownView, 'execute', function (evt) {
        editor.execute(evt.source.commandName);
        editor.editing.view.focus();
      });
      return dropdownView;
    }
    /**
     * Creates a dropdown view with a {@link module:ui/dropdown/button/splitbuttonview~SplitButtonView} for
     * merge (and split)–related commands.
     *
     * @private
     * @param {String} label The dropdown button label.
     * @param {String} icon An icon for the dropdown button.
     * @param {Array.<module:ui/dropdown/utils~ListDropdownItemDefinition>} options The list of options for the dropdown.
     * @param {module:utils/locale~Locale} locale
     * @returns {module:ui/dropdown/dropdownview~DropdownView}
     */

  }, {
    key: "_prepareMergeSplitButtonDropdown",
    value: function _prepareMergeSplitButtonDropdown(label, icon, options, locale) {
      var editor = this.editor;
      var dropdownView = createDropdown(locale, splitbuttonview_SplitButtonView);
      var mergeCommandName = 'mergeTableCells';

      this._fillDropdownWithListOptions(dropdownView, options);

      dropdownView.buttonView.set({
        label: label,
        icon: icon,
        tooltip: true,
        isEnabled: true
      }); // Merge selected table cells when the main part of the split button is clicked.

      this.listenTo(dropdownView.buttonView, 'execute', function () {
        editor.execute(mergeCommandName);
        editor.editing.view.focus();
      }); // Execute commands for events coming from the list in the dropdown panel.

      this.listenTo(dropdownView, 'execute', function (evt) {
        editor.execute(evt.source.commandName);
        editor.editing.view.focus();
      });
      return dropdownView;
    }
    /**
     * Injects a {@link module:ui/list/listview~ListView} into the passed dropdown with buttons
     * which execute editor commands as configured in passed options.
     *
     * @private
     * @param {module:ui/dropdown/dropdownview~DropdownView} dropdownView
     * @param {Array.<module:ui/dropdown/utils~ListDropdownItemDefinition>} options The list of options for the dropdown.
     * @returns {Array.<module:core/command~Command>} Commands the list options are interacting with.
     */

  }, {
    key: "_fillDropdownWithListOptions",
    value: function _fillDropdownWithListOptions(dropdownView, options) {
      var editor = this.editor;
      var commands = [];
      var itemDefinitions = new collection_Collection();

      var _iterator = _createForOfIteratorHelper(options),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var option = _step.value;
          addListOption(option, editor, commands, itemDefinitions);
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      addListToDropdown(dropdownView, itemDefinitions, editor.ui.componentFactory);
      return commands;
    }
  }]);

  return TableUI;
}(plugin_Plugin); // Adds an option to a list view.
//
// @param {module:table/tableui~DropdownOption} option A configuration option.
// @param {module:core/editor/editor~Editor} editor
// @param {Array.<module:core/command~Command>} commands The list of commands to update.
// @param {Iterable.<module:ui/dropdown/utils~ListDropdownItemDefinition>} itemDefinitions
// A collection of dropdown items to update with the given option.




function addListOption(option, editor, commands, itemDefinitions) {
  var model = option.model = new src_model_Model(option.model);
  var _option$model = option.model,
      commandName = _option$model.commandName,
      bindIsOn = _option$model.bindIsOn;

  if (option.type === 'button' || option.type === 'switchbutton') {
    var command = editor.commands.get(commandName);
    commands.push(command);
    model.set({
      commandName: commandName
    });
    model.bind('isEnabled').to(command);

    if (bindIsOn) {
      model.bind('isOn').to(command, 'value');
    }
  }

  model.set({
    withText: true
  });
  itemDefinitions.add(option);
}
// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.flat.js
var es_array_flat = __webpack_require__("0481");

// EXTERNAL MODULE: ./node_modules/core-js/modules/es.array.unscopables.flat.js
var es_array_unscopables_flat = __webpack_require__("4069");

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-table/theme/tableselection.css
var tableselection = __webpack_require__("2c4a");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/tableselection.js



















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/tableselection
 */








/**
 * This plugin enables the advanced table cells, rows and columns selection.
 * It is loaded automatically by the {@link module:table/table~Table} plugin.
 *
 * @extends module:core/plugin~Plugin
 */

var tableselection_TableSelection = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(TableSelection, _Plugin);

  var _super = Object(createSuper["a" /* default */])(TableSelection);

  function TableSelection() {
    Object(classCallCheck["a" /* default */])(this, TableSelection);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(TableSelection, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this = this;

      var editor = this.editor;
      var model = editor.model;
      this.listenTo(model, 'deleteContent', function (evt, args) {
        return _this._handleDeleteContent(evt, args);
      }, {
        priority: 'high'
      });

      this._defineSelectionConverter();

      this._enablePluginDisabling(); // sic!

    }
    /**
     * Returns the currently selected table cells or `null` if it is not a table cells selection.
     *
     * @returns {Array.<module:engine/model/element~Element>|null}
     */

  }, {
    key: "getSelectedTableCells",
    value: function getSelectedTableCells() {
      var selection = this.editor.model.document.selection;

      var selectedCells = selection_getSelectedTableCells(selection);

      if (selectedCells.length == 0) {
        return null;
      } // This should never happen, but let's know if it ever happens.
      // @if CK_DEBUG //	/* istanbul ignore next */
      // @if CK_DEBUG //	if ( selectedCells.length != selection.rangeCount ) {
      // @if CK_DEBUG //		console.warn( 'Mixed selection warning. The selection contains table cells and some other ranges.' );
      // @if CK_DEBUG //	}


      return selectedCells;
    }
    /**
     * Returns the selected table fragment as a document fragment.
     *
     * @returns {module:engine/model/documentfragment~DocumentFragment|null}
     */

  }, {
    key: "getSelectionAsFragment",
    value: function getSelectionAsFragment() {
      var _this2 = this;

      var selectedCells = this.getSelectedTableCells();

      if (!selectedCells) {
        return null;
      }

      return this.editor.model.change(function (writer) {
        var documentFragment = writer.createDocumentFragment();

        var tableUtils = _this2.editor.plugins.get('TableUtils');

        var _getColumnIndexes = getColumnIndexes(selectedCells),
            firstColumn = _getColumnIndexes.first,
            lastColumn = _getColumnIndexes.last;

        var _getRowIndexes = getRowIndexes(selectedCells),
            firstRow = _getRowIndexes.first,
            lastRow = _getRowIndexes.last;

        var sourceTable = common_findAncestor('table', selectedCells[0]);
        var adjustedLastRow = lastRow;
        var adjustedLastColumn = lastColumn; // If the selection is rectangular there could be a case of all cells in the last row/column spanned over
        // next row/column so the real lastRow/lastColumn should be updated.

        if (isSelectionRectangular(selectedCells, tableUtils)) {
          var dimensions = {
            firstColumn: firstColumn,
            lastColumn: lastColumn,
            firstRow: firstRow,
            lastRow: lastRow
          };
          adjustedLastRow = adjustLastRowIndex(sourceTable, dimensions);
          adjustedLastColumn = adjustLastColumnIndex(sourceTable, dimensions);
        }

        var cropDimensions = {
          startRow: firstRow,
          startColumn: firstColumn,
          endRow: adjustedLastRow,
          endColumn: adjustedLastColumn
        };
        var table = cropTableToDimensions(sourceTable, cropDimensions, writer);
        writer.insert(table, documentFragment, 0);
        return documentFragment;
      });
    }
    /**
     * Sets the model selection based on given anchor and target cells (can be the same cell).
     * Takes care of setting the backward flag.
     *
     *		const modelRoot = editor.model.document.getRoot();
     *		const firstCell = modelRoot.getNodeByPath( [ 0, 0, 0 ] );
     *		const lastCell = modelRoot.getNodeByPath( [ 0, 0, 1 ] );
     *
     *		const tableSelection = editor.plugins.get( 'TableSelection' );
     *		tableSelection.setCellSelection( firstCell, lastCell );
     *
     * @param {module:engine/model/element~Element} anchorCell
     * @param {module:engine/model/element~Element} targetCell
     */

  }, {
    key: "setCellSelection",
    value: function setCellSelection(anchorCell, targetCell) {
      var cellsToSelect = this._getCellsToSelect(anchorCell, targetCell);

      this.editor.model.change(function (writer) {
        writer.setSelection(cellsToSelect.cells.map(function (cell) {
          return writer.createRangeOn(cell);
        }), {
          backward: cellsToSelect.backward
        });
      });
    }
    /**
     * Returns the focus cell from the current selection.
     *
     * @returns {module:engine/model/element~Element}
     */

  }, {
    key: "getFocusCell",
    value: function getFocusCell() {
      var selection = this.editor.model.document.selection;

      var focusCellRange = _toConsumableArray(selection.getRanges()).pop();

      var element = focusCellRange.getContainedElement();

      if (element && element.is('tableCell')) {
        return element;
      }

      return null;
    }
    /**
     * Returns the anchor cell from the current selection.
     *
     * @returns {module:engine/model/element~Element} anchorCell
     */

  }, {
    key: "getAnchorCell",
    value: function getAnchorCell() {
      var selection = this.editor.model.document.selection;
      var anchorCellRange = first_first(selection.getRanges());
      var element = anchorCellRange.getContainedElement();

      if (element && element.is('tableCell')) {
        return element;
      }

      return null;
    }
    /**
     * Defines a selection converter which marks the selected cells with a specific class.
     *
     * The real DOM selection is put in the last cell. Since the order of ranges is dependent on whether the
     * selection is backward or not, the last cell will usually be close to the "focus" end of the selection
     * (a selection has anchor and focus).
     *
     * The real DOM selection is then hidden with CSS.
     *
     * @private
     */

  }, {
    key: "_defineSelectionConverter",
    value: function _defineSelectionConverter() {
      var _this3 = this;

      var editor = this.editor;
      var highlighted = new Set();
      editor.conversion.for('editingDowncast').add(function (dispatcher) {
        return dispatcher.on('selection', function (evt, data, conversionApi) {
          var viewWriter = conversionApi.writer;
          clearHighlightedTableCells(viewWriter);

          var selectedCells = _this3.getSelectedTableCells();

          if (!selectedCells) {
            return;
          }

          var _iterator = _createForOfIteratorHelper(selectedCells),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var tableCell = _step.value;
              var viewElement = conversionApi.mapper.toViewElement(tableCell);
              viewWriter.addClass('ck-editor__editable_selected', viewElement);
              highlighted.add(viewElement);
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }

          var lastViewCell = conversionApi.mapper.toViewElement(selectedCells[selectedCells.length - 1]);
          viewWriter.setSelection(lastViewCell, 0);
        }, {
          priority: 'lowest'
        });
      });

      function clearHighlightedTableCells(writer) {
        var _iterator2 = _createForOfIteratorHelper(highlighted),
            _step2;

        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var previouslyHighlighted = _step2.value;
            writer.removeClass('ck-editor__editable_selected', previouslyHighlighted);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }

        highlighted.clear();
      }
    }
    /**
     * Creates a listener that reacts to changes in {@link #isEnabled} and, if the plugin was disabled,
     * it collapses the multi-cell selection to a regular selection placed inside a table cell.
     *
     * This listener helps features that disable the table selection plugin bring the selection
     * to a clear state they can work with (for instance, because they don't support multiple cell selection).
     */

  }, {
    key: "_enablePluginDisabling",
    value: function _enablePluginDisabling() {
      var _this4 = this;

      var editor = this.editor;
      this.on('change:isEnabled', function () {
        if (!_this4.isEnabled) {
          var selectedCells = _this4.getSelectedTableCells();

          if (!selectedCells) {
            return;
          }

          editor.model.change(function (writer) {
            var position = writer.createPositionAt(selectedCells[0], 0);
            var range = editor.model.schema.getNearestSelectionRange(position);
            writer.setSelection(range);
          });
        }
      });
    }
    /**
     * Overrides the default `model.deleteContent()` behavior over a selected table fragment.
     *
     * @private
     * @param {module:utils/eventinfo~EventInfo} event
     * @param {Array.<*>} args Delete content method arguments.
     */

  }, {
    key: "_handleDeleteContent",
    value: function _handleDeleteContent(event, args) {
      var _args = _slicedToArray(args, 2),
          selection = _args[0],
          options = _args[1];

      var model = this.editor.model;
      var isBackward = !options || options.direction == 'backward';

      var selectedTableCells = selection_getSelectedTableCells(selection);

      if (!selectedTableCells.length) {
        return;
      }

      event.stop();
      model.change(function (writer) {
        var tableCellToSelect = selectedTableCells[isBackward ? selectedTableCells.length - 1 : 0];
        model.change(function (writer) {
          var _iterator3 = _createForOfIteratorHelper(selectedTableCells),
              _step3;

          try {
            for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
              var tableCell = _step3.value;
              model.deleteContent(writer.createSelection(tableCell, 'in'));
            }
          } catch (err) {
            _iterator3.e(err);
          } finally {
            _iterator3.f();
          }
        });
        var rangeToSelect = model.schema.getNearestSelectionRange(writer.createPositionAt(tableCellToSelect, 0)); // Note: we ignore the case where rangeToSelect may be null because deleteContent() will always (unless someone broke it)
        // create an empty paragraph to accommodate the selection.

        if (selection.is('documentSelection')) {
          writer.setSelection(rangeToSelect);
        } else {
          selection.setTo(rangeToSelect);
        }
      });
    }
    /**
     * Returns an array of table cells that should be selected based on the
     * given anchor cell and target (focus) cell.
     *
     * The cells are returned in a reverse direction if the selection is backward.
     *
     * @private
     * @param {module:engine/model/element~Element} anchorCell
     * @param {module:engine/model/element~Element} targetCell
     * @returns {Array.<module:engine/model/element~Element>}
     */

  }, {
    key: "_getCellsToSelect",
    value: function _getCellsToSelect(anchorCell, targetCell) {
      var tableUtils = this.editor.plugins.get('TableUtils');
      var startLocation = tableUtils.getCellLocation(anchorCell);
      var endLocation = tableUtils.getCellLocation(targetCell);
      var startRow = Math.min(startLocation.row, endLocation.row);
      var endRow = Math.max(startLocation.row, endLocation.row);
      var startColumn = Math.min(startLocation.column, endLocation.column);
      var endColumn = Math.max(startLocation.column, endLocation.column); // 2-dimensional array of the selected cells to ease flipping the order of cells for backward selections.

      var selectionMap = new Array(endRow - startRow + 1).fill(null).map(function () {
        return [];
      });
      var walkerOptions = {
        startRow: startRow,
        endRow: endRow,
        startColumn: startColumn,
        endColumn: endColumn
      };

      var _iterator4 = _createForOfIteratorHelper(new tablewalker_TableWalker(common_findAncestor('table', anchorCell), walkerOptions)),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var _step4$value = _step4.value,
              row = _step4$value.row,
              cell = _step4$value.cell;
          selectionMap[row - startRow].push(cell);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      var flipVertically = endLocation.row < startLocation.row;
      var flipHorizontally = endLocation.column < startLocation.column;

      if (flipVertically) {
        selectionMap.reverse();
      }

      if (flipHorizontally) {
        selectionMap.forEach(function (row) {
          return row.reverse();
        });
      }

      return {
        cells: selectionMap.flat(),
        backward: flipVertically || flipHorizontally
      };
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'TableSelection';
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "requires",
    get: function get() {
      return [tableutils_TableUtils];
    }
  }]);

  return TableSelection;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/tableclipboard.js












/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/tableclipboard
 */







/**
 * This plugin adds support for copying/cutting/pasting fragments of tables.
 * It is loaded automatically by the {@link module:table/table~Table} plugin.
 *
 * @extends module:core/plugin~Plugin
 */

var tableclipboard_TableClipboard = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(TableClipboard, _Plugin);

  var _super = Object(createSuper["a" /* default */])(TableClipboard);

  function TableClipboard() {
    Object(classCallCheck["a" /* default */])(this, TableClipboard);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(TableClipboard, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this = this;

      var editor = this.editor;
      var viewDocument = editor.editing.view.document;
      this.listenTo(viewDocument, 'copy', function (evt, data) {
        return _this._onCopyCut(evt, data);
      });
      this.listenTo(viewDocument, 'cut', function (evt, data) {
        return _this._onCopyCut(evt, data);
      });
      this.listenTo(editor.model, 'insertContent', function (evt, args) {
        return _this._onInsertContent.apply(_this, [evt].concat(_toConsumableArray(args)));
      }, {
        priority: 'high'
      });
    }
    /**
     * Copies table content to a clipboard on "copy" & "cut" events.
     *
     * @private
     * @param {module:utils/eventinfo~EventInfo} evt An object containing information about the handled event.
     * @param {Object} data Clipboard event data.
     */

  }, {
    key: "_onCopyCut",
    value: function _onCopyCut(evt, data) {
      var tableSelection = this.editor.plugins.get(tableselection_TableSelection);

      if (!tableSelection.getSelectedTableCells()) {
        return;
      }

      if (evt.name == 'cut' && this.editor.isReadOnly) {
        return;
      }

      data.preventDefault();
      evt.stop();
      var dataController = this.editor.data;
      var viewDocument = this.editor.editing.view.document;
      var content = dataController.toView(tableSelection.getSelectionAsFragment());
      viewDocument.fire('clipboardOutput', {
        dataTransfer: data.dataTransfer,
        content: content,
        method: evt.name
      });
    }
    /**
     * Overrides default {@link module:engine/model/model~Model#insertContent `model.insertContent()`} method to handle pasting table inside
     * selected table fragment.
     *
     * Depending on selected table fragment:
     * - If a selected table fragment is smaller than paste table it will crop pasted table to match dimensions.
     * - If dimensions are equal it will replace selected table fragment with a pasted table contents.
     *
     * @private
     * @param evt
     * @param {module:engine/model/documentfragment~DocumentFragment|module:engine/model/item~Item} content The content to insert.
     * @param {module:engine/model/selection~Selectable} [selectable=model.document.selection]
     * The selection into which the content should be inserted. If not provided the current model document selection will be used.
     */

  }, {
    key: "_onInsertContent",
    value: function _onInsertContent(evt, content, selectable) {
      if (selectable && !selectable.is('documentSelection')) {
        return;
      }

      var model = this.editor.model;
      var tableUtils = this.editor.plugins.get(tableutils_TableUtils); // We might need to crop table before inserting so reference might change.

      var pastedTable = getTableIfOnlyTableInContent(content, model);

      if (!pastedTable) {
        return;
      }

      var selectedTableCells = getSelectionAffectedTableCells(model.document.selection);

      if (!selectedTableCells.length) {
        removeEmptyRowsColumns(pastedTable, tableUtils);
        return;
      } // Override default model.insertContent() handling at this point.


      evt.stop();
      model.change(function (writer) {
        var pastedDimensions = {
          width: tableUtils.getColumns(pastedTable),
          height: tableUtils.getRows(pastedTable)
        }; // Prepare the table for pasting.

        var selection = prepareTableForPasting(selectedTableCells, pastedDimensions, writer, tableUtils); // Beyond this point we operate on a fixed content table with rectangular selection and proper last row/column values.

        var selectionHeight = selection.lastRow - selection.firstRow + 1;
        var selectionWidth = selection.lastColumn - selection.firstColumn + 1; // Crop pasted table if:
        // - Pasted table dimensions exceeds selection area.
        // - Pasted table has broken layout (ie some cells sticks out by the table dimensions established by the first and last row).
        //
        // Note: The table dimensions are established by the width of the first row and the total number of rows.
        // It is possible to programmatically create a table that has rows which would have cells anchored beyond first row width but
        // such table will not be created by other editing solutions.

        var cropDimensions = {
          startRow: 0,
          startColumn: 0,
          endRow: Math.min(selectionHeight, pastedDimensions.height) - 1,
          endColumn: Math.min(selectionWidth, pastedDimensions.width) - 1
        };
        pastedTable = cropTableToDimensions(pastedTable, cropDimensions, writer); // Content table to which we insert a pasted table.

        var selectedTable = common_findAncestor('table', selectedTableCells[0]);
        replaceSelectedCellsWithPasted(pastedTable, pastedDimensions, selectedTable, selection, writer);
      });
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'TableClipboard';
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "requires",
    get: function get() {
      return [tableselection_TableSelection, tableutils_TableUtils];
    }
  }]);

  return TableClipboard;
}(plugin_Plugin); // Prepares a table for pasting and returns adjusted selection dimensions.
//
// @param {Array.<module:engine/model/element~Element>} selectedTableCells
// @param {Object} pastedDimensions
// @param {Number} pastedDimensions.height
// @param {Number} pastedDimensions.width
// @param {module:engine/model/writer~Writer} writer
// @param {module:table/tableutils~TableUtils} tableUtils
// @returns {Object} selection
// @returns {Number} selection.firstColumn
// @returns {Number} selection.firstRow
// @returns {Number} selection.lastColumn
// @returns {Number} selection.lastRow




function prepareTableForPasting(selectedTableCells, pastedDimensions, writer, tableUtils) {
  var selectedTable = common_findAncestor('table', selectedTableCells[0]);
  var columnIndexes = getColumnIndexes(selectedTableCells);
  var rowIndexes = getRowIndexes(selectedTableCells);
  var selection = {
    firstColumn: columnIndexes.first,
    lastColumn: columnIndexes.last,
    firstRow: rowIndexes.first,
    lastRow: rowIndexes.last
  }; // Single cell selected - expand selection to pasted table dimensions.

  var shouldExpandSelection = selectedTableCells.length === 1;

  if (shouldExpandSelection) {
    selection.lastRow += pastedDimensions.height - 1;
    selection.lastColumn += pastedDimensions.width - 1;
    expandTableSize(selectedTable, selection.lastRow + 1, selection.lastColumn + 1, writer, tableUtils);
  } // In case of expanding selection we do not reset the selection so in this case we will always try to fix selection
  // like in the case of a non-rectangular area. This might be fixed by re-setting selected cells array but this shortcut is safe.


  if (shouldExpandSelection || !isSelectionRectangular(selectedTableCells, tableUtils)) {
    // For a non-rectangular selection (ie in which some cells sticks out from a virtual selection rectangle) we need to create
    // a table layout that has a rectangular selection. This will split cells so the selection become rectangular.
    // Beyond this point we will operate on fixed content table.
    splitCellsToRectangularSelection(selectedTable, selection, writer);
  } // However a selected table fragment might be invalid if examined alone. Ie such table fragment:
  //
  //    +---+---+---+---+
  //  0 | a | b | c | d |
  //    +   +   +---+---+
  //  1 |   | e | f | g |
  //    +   +---+   +---+
  //  2 |   | h |   | i | <- last row, each cell has rowspan = 2,
  //    +   +   +   +   +    so we need to return 3, not 2
  //  3 |   |   |   |   |
  //    +---+---+---+---+
  //
  // is invalid as the cells "h" and "i" have rowspans.
  // This case needs only adjusting the selection dimension as the rest of the algorithm operates on empty slots also.
  else {
      selection.lastRow = adjustLastRowIndex(selectedTable, selection);
      selection.lastColumn = adjustLastColumnIndex(selectedTable, selection);
    }

  return selection;
} // Replaces the part of selectedTable with pastedTable.
//
// @param {module:engine/model/element~Element} pastedTable
// @param {Object} pastedDimensions
// @param {Number} pastedDimensions.height
// @param {Number} pastedDimensions.width
// @param {module:engine/model/element~Element} selectedTable
// @param {Object} selection
// @param {Number} selection.firstColumn
// @param {Number} selection.firstRow
// @param {Number} selection.lastColumn
// @param {Number} selection.lastRow
// @param {module:engine/model/writer~Writer} writer


function replaceSelectedCellsWithPasted(pastedTable, pastedDimensions, selectedTable, selection, writer) {
  var pastedWidth = pastedDimensions.width,
      pastedHeight = pastedDimensions.height; // Holds two-dimensional array that is addressed by [ row ][ column ] that stores cells anchored at given location.

  var pastedTableLocationMap = createLocationMap(pastedTable, pastedWidth, pastedHeight);

  var selectedTableMap = _toConsumableArray(new tablewalker_TableWalker(selectedTable, {
    startRow: selection.firstRow,
    endRow: selection.lastRow,
    startColumn: selection.firstColumn,
    endColumn: selection.lastColumn,
    includeAllSlots: true
  })); // Selection must be set to pasted cells (some might be removed or new created).


  var cellsToSelect = []; // Store next cell insert position.

  var insertPosition; // Content table replace cells algorithm iterates over a selected table fragment and:
  //
  // - Removes existing table cells at current slot (location).
  // - Inserts cell from a pasted table for a matched slots.
  //
  // This ensures proper table geometry after the paste

  var _iterator = _createForOfIteratorHelper(selectedTableMap),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var tableSlot = _step.value;
      var row = tableSlot.row,
          column = tableSlot.column,
          cell = tableSlot.cell,
          isAnchor = tableSlot.isAnchor; // Save the insert position for current row start.

      if (column === selection.firstColumn) {
        insertPosition = tableSlot.getPositionBefore();
      } // If the slot is occupied by a cell in a selected table - remove it.
      // The slot of this cell will be either:
      // - Replaced by a pasted table cell.
      // - Spanned by a previously pasted table cell.


      if (isAnchor) {
        writer.remove(cell);
      } // Map current table slot location to an pasted table slot location.


      var pastedRow = row - selection.firstRow;
      var pastedColumn = column - selection.firstColumn;
      var pastedCell = pastedTableLocationMap[pastedRow % pastedHeight][pastedColumn % pastedWidth]; // There is no cell to insert (might be spanned by other cell in a pasted table) - advance to the next content table slot.

      if (!pastedCell) {
        continue;
      } // Clone cell to insert (to duplicate its attributes and children).
      // Cloning is required to support repeating pasted table content when inserting to a bigger selection.


      var cellToInsert = writer.cloneElement(pastedCell); // Trim the cell if it's row/col-spans would exceed selection area.

      trimTableCellIfNeeded(cellToInsert, row, column, selection.lastRow, selection.lastColumn, writer);
      writer.insert(cellToInsert, insertPosition);
      cellsToSelect.push(cellToInsert);
      insertPosition = writer.createPositionAfter(cellToInsert);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  writer.setSelection(cellsToSelect.map(function (cell) {
    return writer.createRangeOn(cell);
  }));
} // Expand table (in place) to expected size.


function expandTableSize(table, expectedHeight, expectedWidth, writer, tableUtils) {
  var tableWidth = tableUtils.getColumns(table);
  var tableHeight = tableUtils.getRows(table);

  if (expectedWidth > tableWidth) {
    tableUtils.insertColumns(table, {
      batch: writer.batch,
      at: tableWidth,
      columns: expectedWidth - tableWidth
    });
  }

  if (expectedHeight > tableHeight) {
    tableUtils.insertRows(table, {
      batch: writer.batch,
      at: tableHeight,
      rows: expectedHeight - tableHeight
    });
  }
}

function getTableIfOnlyTableInContent(content, model) {
  if (!content.is('documentFragment') && !content.is('element')) {
    return null;
  } // Table passed directly.


  if (content.is('table')) {
    return content;
  } // We do not support mixed content when pasting table into table.
  // See: https://github.com/ckeditor/ckeditor5/issues/6817.


  if (content.childCount == 1 && content.getChild(0).is('table')) {
    return content.getChild(0);
  } // If there are only whitespaces around a table then use that table for pasting.


  var contentRange = model.createRangeIn(content);

  var _iterator2 = _createForOfIteratorHelper(contentRange.getItems()),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var element = _step2.value;

      if (element.is('table')) {
        // Stop checking if there is some content before table.
        var rangeBefore = model.createRange(contentRange.start, model.createPositionBefore(element));

        if (model.hasContent(rangeBefore, {
          ignoreWhitespaces: true
        })) {
          return null;
        } // Stop checking if there is some content after table.


        var rangeAfter = model.createRange(model.createPositionAfter(element), contentRange.end);

        if (model.hasContent(rangeAfter, {
          ignoreWhitespaces: true
        })) {
          return null;
        } // There wasn't any content neither before nor after.


        return element;
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return null;
} // Returns two-dimensional array that is addressed by [ row ][ column ] that stores cells anchored at given location.
//
// At given row & column location it might be one of:
//
// * cell - cell from pasted table anchored at this location.
// * null - if no cell is anchored at this location.
//
// For instance, from a table below:
//
//		+----+----+----+----+
//		| 00 | 01 | 02 | 03 |
//		+    +----+----+----+
//		|    | 11      | 13 |
//		+----+         +----+
//		| 20 |         | 23 |
//		+----+----+----+----+
//
// The method will return an array (numbers represents cell element):
//
//	const map = [
//		[ '00', '01', '02', '03' ],
//		[ null, '11', null, '13' ],
//		[ '20', null, null, '23' ]
//	]
//
// This allows for a quick access to table at give row & column. For instance to access table cell "13" from pasted table call:
//
//		const cell = map[ 1 ][ 3 ]
//


function createLocationMap(table, width, height) {
  // Create height x width (row x column) two-dimensional table to store cells.
  var map = new Array(height).fill(null).map(function () {
    return new Array(width).fill(null);
  });

  var _iterator3 = _createForOfIteratorHelper(new tablewalker_TableWalker(table)),
      _step3;

  try {
    for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
      var _step3$value = _step3.value,
          column = _step3$value.column,
          row = _step3$value.row,
          cell = _step3$value.cell;
      map[row][column] = cell;
    }
  } catch (err) {
    _iterator3.e(err);
  } finally {
    _iterator3.f();
  }

  return map;
} // Make selected cells rectangular by splitting the cells that stand out from a rectangular selection.
//
// In the table below a selection is shown with "::" and slots with anchor cells are named.
//
// +----+----+----+----+----+                    +----+----+----+----+----+
// | 00 | 01 | 02 | 03      |                    | 00 | 01 | 02 | 03      |
// +    +----+    +----+----+                    |    ::::::::::::::::----+
// |    | 11 |    | 13 | 14 |                    |    ::11 |    | 13:: 14 |    <- first row
// +----+----+    +    +----+                    +----::---|    |   ::----+
// | 20 | 21 |    |    | 24 |   select cells:    | 20 ::21 |    |   :: 24 |
// +----+----+    +----+----+     11 -> 33       +----::---|    |---::----+
// | 30      |    | 33 | 34 |                    | 30 ::   |    | 33:: 34 |    <- last row
// +         +    +----+    +                    |    ::::::::::::::::    +
// |         |    | 43 |    |                    |         |    | 43 |    |
// +----+----+----+----+----+                    +----+----+----+----+----+
//                                                      ^          ^
//                                                     first & last columns
//
// Will update table to:
//
//                       +----+----+----+----+----+
//                       | 00 | 01 | 02 | 03      |
//                       +    +----+----+----+----+
//                       |    | 11 |    | 13 | 14 |
//                       +----+----+    +    +----+
//                       | 20 | 21 |    |    | 24 |
//                       +----+----+    +----+----+
//                       | 30 |    |    | 33 | 34 |
//                       +    +----+----+----+    +
//                       |    |    |    | 43 |    |
//                       +----+----+----+----+----+
//
// In th example above:
// - Cell "02" which have `rowspan = 4` must be trimmed at first and at after last row.
// - Cell "03" which have `rowspan = 2` and `colspan = 2` must be trimmed at first column and after last row.
// - Cells "00", "03" & "30" which cannot be cut by this algorithm as they are outside the trimmed area.
// - Cell "13" cannot be cut as it is inside the trimmed area.


function splitCellsToRectangularSelection(table, dimensions, writer) {
  var firstRow = dimensions.firstRow,
      lastRow = dimensions.lastRow,
      firstColumn = dimensions.firstColumn,
      lastColumn = dimensions.lastColumn;
  var rowIndexes = {
    first: firstRow,
    last: lastRow
  };
  var columnIndexes = {
    first: firstColumn,
    last: lastColumn
  }; // 1. Split cells vertically in two steps as first step might create cells that needs to split again.

  doVerticalSplit(table, firstColumn, rowIndexes, writer);
  doVerticalSplit(table, lastColumn + 1, rowIndexes, writer); // 2. Split cells horizontally in two steps as first step might create cells that needs to split again.

  doHorizontalSplit(table, firstRow, columnIndexes, writer);
  doHorizontalSplit(table, lastRow + 1, columnIndexes, writer, firstRow);
}

function doHorizontalSplit(table, splitRow, limitColumns, writer) {
  var startRow = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;

  // If selection starts at first row then no split is needed.
  if (splitRow < 1) {
    return;
  }

  var overlappingCells = getVerticallyOverlappingCells(table, splitRow, startRow); // Filter out cells that are not touching insides of the rectangular selection.

  var cellsToSplit = overlappingCells.filter(function (_ref) {
    var column = _ref.column,
        cellWidth = _ref.cellWidth;
    return isAffectedBySelection(column, cellWidth, limitColumns);
  });

  var _iterator4 = _createForOfIteratorHelper(cellsToSplit),
      _step4;

  try {
    for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
      var cell = _step4.value.cell;
      splitHorizontally(cell, splitRow, writer);
    }
  } catch (err) {
    _iterator4.e(err);
  } finally {
    _iterator4.f();
  }
}

function doVerticalSplit(table, splitColumn, limitRows, writer) {
  // If selection starts at first column then no split is needed.
  if (splitColumn < 1) {
    return;
  }

  var overlappingCells = getHorizontallyOverlappingCells(table, splitColumn); // Filter out cells that are not touching insides of the rectangular selection.

  var cellsToSplit = overlappingCells.filter(function (_ref2) {
    var row = _ref2.row,
        cellHeight = _ref2.cellHeight;
    return isAffectedBySelection(row, cellHeight, limitRows);
  });

  var _iterator5 = _createForOfIteratorHelper(cellsToSplit),
      _step5;

  try {
    for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
      var _step5$value = _step5.value,
          cell = _step5$value.cell,
          column = _step5$value.column;
      splitVertically(cell, column, splitColumn, writer);
    }
  } catch (err) {
    _iterator5.e(err);
  } finally {
    _iterator5.f();
  }
} // Checks if cell at given row (column) is affected by a rectangular selection defined by first/last column (row).
//
// The same check is used for row as for column.


function isAffectedBySelection(index, span, limit) {
  var endIndex = index + span - 1;
  var first = limit.first,
      last = limit.last;
  var isInsideSelection = index >= first && index <= last;
  var overlapsSelectionFromOutside = index < first && endIndex >= first;
  return isInsideSelection || overlapsSelectionFromOutside;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/tablekeyboard.js










/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/tablekeyboard
 */








/**
 * This plugin enables keyboard navigation for tables.
 * It is loaded automatically by the {@link module:table/table~Table} plugin.
 *
 * @extends module:core/plugin~Plugin
 */

var tablekeyboard_TableKeyboard = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(TableKeyboard, _Plugin);

  var _super = Object(createSuper["a" /* default */])(TableKeyboard);

  function TableKeyboard() {
    Object(classCallCheck["a" /* default */])(this, TableKeyboard);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(TableKeyboard, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this = this;

      var view = this.editor.editing.view;
      var viewDocument = view.document; // Handle Tab key navigation.

      this.editor.keystrokes.set('Tab', function () {
        return _this._handleTabOnSelectedTable.apply(_this, arguments);
      }, {
        priority: 'low'
      });
      this.editor.keystrokes.set('Tab', this._getTabHandler(true), {
        priority: 'low'
      });
      this.editor.keystrokes.set('Shift+Tab', this._getTabHandler(false), {
        priority: 'low'
      }); // Note: This listener has the "high-10" priority because it should allow the Widget plugin to handle the default
      // behavior first ("high") but it should not be "prevent–defaulted" by the Widget plugin ("high-20") because of
      // the fake selection retention on the fully selected widget.

      this.listenTo(viewDocument, 'keydown', function () {
        return _this._onKeydown.apply(_this, arguments);
      }, {
        priority: src_priorities.get('high') - 10
      });
    }
    /**
     * Handles {@link module:engine/view/document~Document#event:keydown keydown} events for the <kbd>Tab</kbd> key executed
     * when the table widget is selected.
     *
     * @private
     * @param {module:engine/view/observer/keyobserver~KeyEventData} data Key event data.
     * @param {Function} cancel The stop/stopPropagation/preventDefault function.
     */

  }, {
    key: "_handleTabOnSelectedTable",
    value: function _handleTabOnSelectedTable(data, cancel) {
      var editor = this.editor;
      var selection = editor.model.document.selection;

      if (!selection.isCollapsed && selection.rangeCount === 1 && selection.getFirstRange().isFlat) {
        var selectedElement = selection.getSelectedElement();

        if (!selectedElement || !selectedElement.is('table')) {
          return;
        }

        cancel();
        editor.model.change(function (writer) {
          writer.setSelection(writer.createRangeIn(selectedElement.getChild(0).getChild(0)));
        });
      }
    }
    /**
     * Returns a handler for {@link module:engine/view/document~Document#event:keydown keydown} events for the <kbd>Tab</kbd> key executed
     * inside table cells.
     *
     * @private
     * @param {Boolean} isForward Whether this handler will move the selection to the next or the previous cell.
     */

  }, {
    key: "_getTabHandler",
    value: function _getTabHandler(isForward) {
      var editor = this.editor;
      return function (domEventData, cancel) {
        var selection = editor.model.document.selection;
        var tableCell = getTableCellsContainingSelection(selection)[0];

        if (!tableCell) {
          return;
        }

        cancel();
        var tableRow = tableCell.parent;
        var table = tableRow.parent;
        var currentRowIndex = table.getChildIndex(tableRow);
        var currentCellIndex = tableRow.getChildIndex(tableCell);
        var isFirstCellInRow = currentCellIndex === 0;

        if (!isForward && isFirstCellInRow && currentRowIndex === 0) {
          // It's the first cell of the table - don't do anything (stay in the current position).
          return;
        }

        var isLastCellInRow = currentCellIndex === tableRow.childCount - 1;
        var isLastRow = currentRowIndex === table.childCount - 1;

        if (isForward && isLastRow && isLastCellInRow) {
          editor.execute('insertTableRowBelow'); // Check if the command actually added a row. If `insertTableRowBelow` execution didn't add a row (because it was disabled
          // or it got overwritten) do not change the selection.

          if (currentRowIndex === table.childCount - 1) {
            return;
          }
        }

        var cellToFocus; // Move to the first cell in the next row.

        if (isForward && isLastCellInRow) {
          var nextRow = table.getChild(currentRowIndex + 1);
          cellToFocus = nextRow.getChild(0);
        } // Move to the last cell in the previous row.
        else if (!isForward && isFirstCellInRow) {
            var previousRow = table.getChild(currentRowIndex - 1);
            cellToFocus = previousRow.getChild(previousRow.childCount - 1);
          } // Move to the next/previous cell.
          else {
              cellToFocus = tableRow.getChild(currentCellIndex + (isForward ? 1 : -1));
            }

        editor.model.change(function (writer) {
          writer.setSelection(writer.createRangeIn(cellToFocus));
        });
      };
    }
    /**
     * Handles {@link module:engine/view/document~Document#event:keydown keydown} events.
     *
     * @private
     * @param {module:utils/eventinfo~EventInfo} eventInfo
     * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData
     */

  }, {
    key: "_onKeydown",
    value: function _onKeydown(eventInfo, domEventData) {
      var editor = this.editor;
      var keyCode = domEventData.keyCode;

      if (!isArrowKeyCode(keyCode)) {
        return;
      }

      var direction = getLocalizedArrowKeyCodeDirection(keyCode, editor.locale.contentLanguageDirection);

      var wasHandled = this._handleArrowKeys(direction, domEventData.shiftKey);

      if (wasHandled) {
        domEventData.preventDefault();
        domEventData.stopPropagation();
        eventInfo.stop();
      }
    }
    /**
     * Handles arrow keys to move the selection around the table.
     *
     * @private
     * @param {'left'|'up'|'right'|'down'} direction The direction of the arrow key.
     * @param {Boolean} expandSelection If the current selection should be expanded.
     * @returns {Boolean} Returns `true` if key was handled.
     */

  }, {
    key: "_handleArrowKeys",
    value: function _handleArrowKeys(direction, expandSelection) {
      var model = this.editor.model;
      var selection = model.document.selection;
      var isForward = ['right', 'down'].includes(direction); // In case one or more table cells are selected (from outside),
      // move the selection to a cell adjacent to the selected table fragment.

      var selectedCells = selection_getSelectedTableCells(selection);

      if (selectedCells.length) {
        var focusCell;

        if (expandSelection) {
          focusCell = this.editor.plugins.get('TableSelection').getFocusCell();
        } else {
          focusCell = isForward ? selectedCells[selectedCells.length - 1] : selectedCells[0];
        }

        this._navigateFromCellInDirection(focusCell, direction, expandSelection);

        return true;
      } // Abort if we're not in a table cell.


      var tableCell = common_findAncestor('tableCell', selection.focus);

      if (!tableCell) {
        return false;
      }

      var cellRange = model.createRangeIn(tableCell); // Let's check if the selection is at the beginning/end of the cell.

      if (this._isSelectionAtCellEdge(selection, isForward)) {
        this._navigateFromCellInDirection(tableCell, direction, expandSelection);

        return true;
      } // If there isn't any $text position between cell edge and selection then we shall move the selection to next cell.


      var textRange = this._findTextRangeFromSelection(cellRange, selection, isForward);

      if (!textRange) {
        this._navigateFromCellInDirection(tableCell, direction, expandSelection);

        return true;
      } // If the navigation is horizontal then we have no more custom cases.


      if (['left', 'right'].includes(direction)) {
        return false;
      } // If the range is a single line then move the selection to the beginning/end of a cell content.
      //
      // We can't move the selection directly to the another cell because of dual position at the end/beginning
      // of wrapped line (it's at the same time at the end of one line and at the start of the next line).


      if (this._isSingleLineRange(textRange, isForward)) {
        model.change(function (writer) {
          var newPosition = isForward ? cellRange.end : cellRange.start;

          if (expandSelection) {
            var newSelection = model.createSelection(selection.anchor);
            newSelection.setFocus(newPosition);
            writer.setSelection(newSelection);
          } else {
            writer.setSelection(newPosition);
          }
        });
        return true;
      }
    }
    /**
     * Returns `true` if the selection is at the boundary of a table cell according to the navigation direction.
     *
     * @private
     * @param {module:engine/model/selection~Selection} selection The current selection.
     * @param {Boolean} isForward The expected navigation direction.
     * @returns {Boolean}
     */

  }, {
    key: "_isSelectionAtCellEdge",
    value: function _isSelectionAtCellEdge(selection, isForward) {
      var model = this.editor.model;
      var schema = this.editor.model.schema;
      var focus = isForward ? selection.getLastPosition() : selection.getFirstPosition(); // If the current limit element is not table cell we are for sure not at the cell edge.
      // Also `modifySelection` will not let us out of it.

      if (!schema.getLimitElement(focus).is('tableCell')) {
        return false;
      }

      var probe = model.createSelection(focus);
      model.modifySelection(probe, {
        direction: isForward ? 'forward' : 'backward'
      }); // If there was no change in the focus position, then it's not possible to move the selection there.

      return focus.isEqual(probe.focus);
    }
    /**
     * Truncates the range so that it spans from the last selection position
     * to the last allowed `$text` position (mirrored if `isForward` is false).
     *
     * Returns `null` if, according to the schema, the resulting range cannot contain a `$text` element.
     *
     * @private
     * @param {module:engine/model/range~Range} range The current table cell content range.
     * @param {module:engine/model/selection~Selection} selection The current selection.
     * @param {Boolean} isForward The expected navigation direction.
     * @returns {module:engine/model/range~Range|null}
     */

  }, {
    key: "_findTextRangeFromSelection",
    value: function _findTextRangeFromSelection(range, selection, isForward) {
      var model = this.editor.model;

      if (isForward) {
        var position = selection.getLastPosition();

        var lastRangePosition = this._getNearestVisibleTextPosition(range, 'backward');

        if (lastRangePosition && position.isBefore(lastRangePosition)) {
          return model.createRange(position, lastRangePosition);
        }

        return null;
      } else {
        var _position = selection.getFirstPosition();

        var firstRangePosition = this._getNearestVisibleTextPosition(range, 'forward');

        if (firstRangePosition && _position.isAfter(firstRangePosition)) {
          return model.createRange(firstRangePosition, _position);
        }

        return null;
      }
    }
    /**
     * Basing on the provided range, finds the first or last (depending on `direction`) position inside the range
     * that can contain `$text` (according to schema) and is visible in the view.
     *
     * @private
     * @param {module:engine/model/range~Range} range The range to find the position in.
     * @param {'forward'|'backward'} direction Search direction.
     * @returns {module:engine/model/position~Position} The nearest selection range.
     */

  }, {
    key: "_getNearestVisibleTextPosition",
    value: function _getNearestVisibleTextPosition(range, direction) {
      var schema = this.editor.model.schema;
      var mapper = this.editor.editing.mapper;

      var _iterator = _createForOfIteratorHelper(range.getWalker({
        direction: direction
      })),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _step$value = _step.value,
              nextPosition = _step$value.nextPosition,
              item = _step$value.item;

          if (schema.checkChild(nextPosition, '$text')) {
            var viewElement = mapper.toViewElement(item);

            if (viewElement && !viewElement.hasClass('ck-hidden')) {
              return nextPosition;
            }
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Checks if the DOM range corresponding to the provided model range renders as a single line by analyzing DOMRects
     * (verifying if they visually wrap content to the next line).
     *
     * @private
     * @param {module:engine/model/range~Range} modelRange The current table cell content range.
     * @param {Boolean} isForward The expected navigation direction.
     * @returns {Boolean}
     */

  }, {
    key: "_isSingleLineRange",
    value: function _isSingleLineRange(modelRange, isForward) {
      var model = this.editor.model;
      var editing = this.editor.editing;
      var domConverter = editing.view.domConverter; // Wrapped lines contain exactly the same position at the end of current line
      // and at the beginning of next line. That position's client rect is at the end
      // of current line. In case of caret at first position of the last line that 'dual'
      // position would be detected as it's not the last line.

      if (isForward) {
        var probe = model.createSelection(modelRange.start);
        model.modifySelection(probe); // If the new position is at the end of the container then we can't use this position
        // because it would provide incorrect result for eg caption of image and selection
        // just before end of it. Also in this case there is no "dual" position.

        if (!probe.focus.isAtEnd && !modelRange.start.isEqual(probe.focus)) {
          modelRange = model.createRange(probe.focus, modelRange.end);
        }
      }

      var viewRange = editing.mapper.toViewRange(modelRange);
      var domRange = domConverter.viewRangeToDom(viewRange);
      var rects = rect_Rect.getDomRangeRects(domRange);
      var boundaryVerticalPosition;

      var _iterator2 = _createForOfIteratorHelper(rects),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var rect = _step2.value;

          if (boundaryVerticalPosition === undefined) {
            boundaryVerticalPosition = Math.round(rect.bottom);
            continue;
          } // Let's check if this rect is in new line.


          if (Math.round(rect.top) >= boundaryVerticalPosition) {
            return false;
          }

          boundaryVerticalPosition = Math.max(boundaryVerticalPosition, Math.round(rect.bottom));
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      return true;
    }
    /**
     * Moves the selection from the given table cell in the specified direction.
     *
     * @protected
     * @param {module:engine/model/element~Element} focusCell The table cell that is current multi-cell selection focus.
     * @param {'left'|'up'|'right'|'down'} direction Direction in which selection should move.
     * @param {Boolean} [expandSelection=false] If the current selection should be expanded.
     */

  }, {
    key: "_navigateFromCellInDirection",
    value: function _navigateFromCellInDirection(focusCell, direction) {
      var expandSelection = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var model = this.editor.model;
      var table = common_findAncestor('table', focusCell);

      var tableMap = _toConsumableArray(new tablewalker_TableWalker(table, {
        includeAllSlots: true
      }));

      var _tableMap = tableMap[tableMap.length - 1],
          lastRow = _tableMap.row,
          lastColumn = _tableMap.column;
      var currentCellInfo = tableMap.find(function (_ref) {
        var cell = _ref.cell;
        return cell == focusCell;
      });
      var row = currentCellInfo.row,
          column = currentCellInfo.column;

      switch (direction) {
        case 'left':
          column--;
          break;

        case 'up':
          row--;
          break;

        case 'right':
          column += currentCellInfo.cellWidth;
          break;

        case 'down':
          row += currentCellInfo.cellHeight;
          break;
      }

      var isOutsideVertically = row < 0 || row > lastRow;
      var isBeforeFirstCell = column < 0 && row <= 0;
      var isAfterLastCell = column > lastColumn && row >= lastRow; // Note that if the table cell at the end of a row is row-spanned then isAfterLastCell will never be true.
      // However, we don't know if user was navigating on the last row or not, so let's stay in the table.

      if (isOutsideVertically || isBeforeFirstCell || isAfterLastCell) {
        model.change(function (writer) {
          writer.setSelection(writer.createRangeOn(table));
        });
        return;
      }

      if (column < 0) {
        column = expandSelection ? 0 : lastColumn;
        row--;
      } else if (column > lastColumn) {
        column = expandSelection ? lastColumn : 0;
        row++;
      }

      var cellToSelect = tableMap.find(function (cellInfo) {
        return cellInfo.row == row && cellInfo.column == column;
      }).cell;
      var isForward = ['right', 'down'].includes(direction);
      var tableSelection = this.editor.plugins.get('TableSelection');

      if (expandSelection && tableSelection.isEnabled) {
        var anchorCell = tableSelection.getAnchorCell() || focusCell;
        tableSelection.setCellSelection(anchorCell, cellToSelect);
      } else {
        var positionToSelect = model.createPositionAt(cellToSelect, isForward ? 0 : 'end');
        model.change(function (writer) {
          writer.setSelection(positionToSelect);
        });
      }
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'TableKeyboard';
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "requires",
    get: function get() {
      return [tableselection_TableSelection];
    }
  }]);

  return TableKeyboard;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/tablemouse/mouseeventsobserver.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/tableselection/mouseeventsobserver
 */

/**
 * The mouse selection event observer.
 *
 * It registers listeners for the following DOM events:
 *
 * - `'mousemove'`
 * - `'mouseup'`
 * - `'mouseleave'`
 *
 * Note that this observer is disabled by default. To enable this observer, it needs to be added to
 * {@link module:engine/view/view~View} using the {@link module:engine/view/view~View#addObserver} method.
 *
 * The observer is registered by the {@link module:table/tableselection~TableSelection} plugin.
 *
 * @extends module:engine/view/observer/domeventobserver~DomEventObserver
 */

var mouseeventsobserver_MouseEventsObserver = /*#__PURE__*/function (_DomEventObserver) {
  Object(inherits["a" /* default */])(MouseEventsObserver, _DomEventObserver);

  var _super = Object(createSuper["a" /* default */])(MouseEventsObserver);

  /**
   * @inheritDoc
   */
  function MouseEventsObserver(view) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, MouseEventsObserver);

    _this = _super.call(this, view);
    _this.domEventType = ['mousemove', 'mouseup', 'mouseleave'];
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(MouseEventsObserver, [{
    key: "onDomEvent",
    value: function onDomEvent(domEvent) {
      this.fire(domEvent.type, domEvent);
    }
  }]);

  return MouseEventsObserver;
}(domeventobserver_DomEventObserver);
/**
 * Fired when the mouse button is released over one of the editables.
 *
 * Introduced by {@link module:table/tableselection/mouseeventsobserver~MouseEventsObserver}.
 *
 * Note that this event is not available by default. To make it available,
 * {@link module:table/tableselection/mouseeventsobserver~MouseEventsObserver} needs to be added
 * to {@link module:engine/view/view~View} using the {@link module:engine/view/view~View#addObserver} method.
 *
 * @see module:table/tableselection/mouseeventsobserver~MouseEventsObserver
 * @event module:engine/view/document~Document#event:mouseup
 * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.
 */

/**
 * Fired when the mouse is moved over one of the editables.
 *
 * Introduced by {@link module:table/tableselection/mouseeventsobserver~MouseEventsObserver}.
 *
 * Note that this event is not available by default. To make it available,
 * {@link module:table/tableselection/mouseeventsobserver~MouseEventsObserver} needs to be added
 * to {@link module:engine/view/view~View} using the {@link module:engine/view/view~View#addObserver} method.
 *
 * @see module:table/tableselection/mouseeventsobserver~MouseEventsObserver
 * @event module:engine/view/document~Document#event:mousemove
 * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.
 */

/**
 * Fired when the mouse is moved out of one of the editables.
 *
 * Introduced by {@link module:table/tableselection/mouseeventsobserver~MouseEventsObserver}.
 *
 * Note that this event is not available by default. To make it available,
 * {@link module:table/tableselection/mouseeventsobserver~MouseEventsObserver} needs to be added
 * to {@link module:engine/view/view~View} using the {@link module:engine/view/view~View#addObserver} method.
 *
 * @see module:table/tableselection/mouseeventsobserver~MouseEventsObserver
 * @event module:engine/view/document~Document#event:mouseleave
 * @param {module:engine/view/observer/domeventdata~DomEventData} data Event data.
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/tablemouse.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/tablemouse
 */





/**
 * This plugin enables a table cells' selection with the mouse.
 * It is loaded automatically by the {@link module:table/table~Table} plugin.
 *
 * @extends module:core/plugin~Plugin
 */

var tablemouse_TableMouse = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(TableMouse, _Plugin);

  var _super = Object(createSuper["a" /* default */])(TableMouse);

  function TableMouse() {
    Object(classCallCheck["a" /* default */])(this, TableMouse);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(TableMouse, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var editor = this.editor; // Currently the MouseObserver only handles `mouseup` events.
      // TODO move to the engine?

      editor.editing.view.addObserver(mouseeventsobserver_MouseEventsObserver);

      this._enableShiftClickSelection();

      this._enableMouseDragSelection();
    }
    /**
     * Enables making cells selection by <kbd>Shift</kbd>+click. Creates a selection from the cell which previously held
     * the selection to the cell which was clicked. It can be the same cell, in which case it selects a single cell.
     *
     * @private
     */

  }, {
    key: "_enableShiftClickSelection",
    value: function _enableShiftClickSelection() {
      var _this = this;

      var editor = this.editor;
      var blockSelectionChange = false;
      var tableSelection = editor.plugins.get(tableselection_TableSelection);
      this.listenTo(editor.editing.view.document, 'mousedown', function (evt, domEventData) {
        if (!_this.isEnabled || !tableSelection.isEnabled) {
          return;
        }

        if (!domEventData.domEvent.shiftKey) {
          return;
        }

        var anchorCell = tableSelection.getAnchorCell() || getTableCellsContainingSelection(editor.model.document.selection)[0];

        if (!anchorCell) {
          return;
        }

        var targetCell = _this._getModelTableCellFromDomEvent(domEventData);

        if (targetCell && haveSameTableParent(anchorCell, targetCell)) {
          blockSelectionChange = true;
          tableSelection.setCellSelection(anchorCell, targetCell);
          domEventData.preventDefault();
        }
      });
      this.listenTo(editor.editing.view.document, 'mouseup', function () {
        blockSelectionChange = false;
      }); // We need to ignore a `selectionChange` event that is fired after we render our new table cells selection.
      // When downcasting table cells selection to the view, we put the view selection in the last selected cell
      // in a place that may not be natively a "correct" location. This is – we put it directly in the `<td>` element.
      // All browsers fire the native `selectionchange` event.
      // However, all browsers except Safari return the selection in the exact place where we put it
      // (even though it's visually normalized). Safari returns `<td><p>^foo` that makes our selection observer
      // fire our `selectionChange` event (because the view selection that we set in the first step differs from the DOM selection).
      // Since `selectionChange` is fired, we automatically update the model selection that moves it that paragraph.
      // This breaks our dear cells selection.
      //
      // Theoretically this issue concerns only Safari that is the only browser that do normalize the selection.
      // However, to avoid code branching and to have a good coverage for this event blocker, I enabled it for all browsers.
      //
      // Note: I'm keeping the `blockSelectionChange` state separately for shift+click and mouse drag (exact same logic)
      // so I don't have to try to analyze whether they don't overlap in some weird cases. Probably they don't.
      // But I have other things to do, like writing this comment.

      this.listenTo(editor.editing.view.document, 'selectionChange', function (evt) {
        if (blockSelectionChange) {
          // @if CK_DEBUG // console.log( 'Blocked selectionChange to avoid breaking table cells selection.' );
          evt.stop();
        }
      }, {
        priority: 'highest'
      });
    }
    /**
     * Enables making cells selection by dragging.
     *
     * The selection is made only on mousemove. Mouse tracking is started on mousedown.
     * However, the cells selection is enabled only after the mouse cursor left the anchor cell.
     * Thanks to that normal text selection within one cell works just fine. However, you can still select
     * just one cell by leaving the anchor cell and moving back to it.
     *
     * @private
     */

  }, {
    key: "_enableMouseDragSelection",
    value: function _enableMouseDragSelection() {
      var _this2 = this;

      var editor = this.editor;
      var anchorCell, targetCell;
      var beganCellSelection = false;
      var blockSelectionChange = false;
      var tableSelection = editor.plugins.get(tableselection_TableSelection);
      this.listenTo(editor.editing.view.document, 'mousedown', function (evt, domEventData) {
        if (!_this2.isEnabled || !tableSelection.isEnabled) {
          return;
        } // Make sure to not conflict with the shift+click listener and any other possible handler.


        if (domEventData.domEvent.shiftKey || domEventData.domEvent.ctrlKey || domEventData.domEvent.altKey) {
          return;
        }

        anchorCell = _this2._getModelTableCellFromDomEvent(domEventData);
      });
      this.listenTo(editor.editing.view.document, 'mousemove', function (evt, domEventData) {
        if (!domEventData.domEvent.buttons) {
          return;
        }

        if (!anchorCell) {
          return;
        }

        var newTargetCell = _this2._getModelTableCellFromDomEvent(domEventData);

        if (newTargetCell && haveSameTableParent(anchorCell, newTargetCell)) {
          targetCell = newTargetCell; // Switch to the cell selection mode after the mouse cursor left the anchor cell.
          // Switch off only on mouseup (makes selecting a single cell possible).

          if (!beganCellSelection && targetCell != anchorCell) {
            beganCellSelection = true;
          }
        } // Yep, not making a cell selection yet. See method docs.


        if (!beganCellSelection) {
          return;
        }

        blockSelectionChange = true;
        tableSelection.setCellSelection(anchorCell, targetCell);
        domEventData.preventDefault();
      });
      this.listenTo(editor.editing.view.document, 'mouseup', function () {
        beganCellSelection = false;
        blockSelectionChange = false;
        anchorCell = null;
        targetCell = null;
      }); // See the explanation in `_enableShiftClickSelection()`.

      this.listenTo(editor.editing.view.document, 'selectionChange', function (evt) {
        if (blockSelectionChange) {
          // @if CK_DEBUG // console.log( 'Blocked selectionChange to avoid breaking table cells selection.' );
          evt.stop();
        }
      }, {
        priority: 'highest'
      });
    }
    /**
     * Returns the model table cell element based on the target element of the passed DOM event.
     *
     * @private
     * @param {module:engine/view/observer/domeventdata~DomEventData} domEventData
     * @returns {module:engine/model/element~Element|undefined} Returns the table cell or `undefined`.
     */

  }, {
    key: "_getModelTableCellFromDomEvent",
    value: function _getModelTableCellFromDomEvent(domEventData) {
      // Note: Work with positions (not element mapping) because the target element can be an attribute or other non-mapped element.
      var viewTargetElement = domEventData.target;
      var viewPosition = this.editor.editing.view.createPositionAt(viewTargetElement, 0);
      var modelPosition = this.editor.editing.mapper.toModelPosition(viewPosition);
      var modelElement = modelPosition.parent;

      if (modelElement.is('tableCell')) {
        return modelElement;
      }

      return common_findAncestor('tableCell', modelElement);
    }
  }], [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'TableMouse';
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "requires",
    get: function get() {
      return [tableselection_TableSelection];
    }
  }]);

  return TableMouse;
}(plugin_Plugin);



function haveSameTableParent(cellA, cellB) {
  return cellA.parent.parent == cellB.parent.parent;
}
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-table/theme/table.css
var theme_table = __webpack_require__("6aed");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/table.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/table
 */









/**
 * The table plugin.
 *
 * For a detailed overview, check the {@glink features/table Table feature documentation}.
 *
 * This is a "glue" plugin that loads the following table features:
 *
 * * {@link module:table/tableediting~TableEditing editing feature},
 * * {@link module:table/tableselection~TableSelection selection feature},
 * * {@link module:table/tablekeyboard~TableKeyboard keyboard navigation feature},
 * * {@link module:table/tablemouse~TableMouse mouse selection feature},
 * * {@link module:table/tableclipboard~TableClipboard clipboard feature},
 * * {@link module:table/tableui~TableUI UI feature}.
 *
 * @extends module:core/plugin~Plugin
 */

var table_Table = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(Table, _Plugin);

  var _super = Object(createSuper["a" /* default */])(Table);

  function Table() {
    Object(classCallCheck["a" /* default */])(this, Table);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Table, null, [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [tableediting_TableEditing, tableui_TableUI, tableselection_TableSelection, tablemouse_TableMouse, tablekeyboard_TableKeyboard, tableclipboard_TableClipboard, widget_Widget];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'Table';
    }
  }]);

  return Table;
}(plugin_Plugin);
/**
 * The configuration of the table feature. Used by the table feature in the `@ckeditor/ckeditor5-table` package.
 *
 *		ClassicEditor
 *			.create( editorElement, {
 * 				table: ... // Table feature options.
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * See {@link module:core/editor/editorconfig~EditorConfig all editor options}.
 *
 * @interface TableConfig
 */

/**
 * The configuration of the {@link module:table/table~Table} feature.
 *
 * Read more in {@link module:table/table~TableConfig}.
 *
 * @member {module:table/table~TableConfig} module:core/editor/editorconfig~EditorConfig#table
 */

/**
 * An array of color definitions (either strings or objects).
 *
 *		const colors = [
 *			{
 *				color: 'hsl(0, 0%, 60%)',
 *				label: 'Grey'
 *			},
 *			'hsl(0, 0%, 80%)',
 *			{
 *				color: 'hsl(0, 0%, 90%)',
 *				label: 'Light grey'
 *			},
 *			{
 *				color: 'hsl(0, 0%, 100%)',
 *				label: 'White',
 *				hasBorder: true
 *			},
 *			'#FF0000'
 *		]
 *
 * Usually used as a configuration parameter, for instance in
 * {@link module:table/table~TableConfig#tableProperties `config.table.tableProperties`}
 * or {@link module:table/table~TableConfig#tableCellProperties `config.table.tableCellProperties`}.
 *
 * @typedef {Array.<String|Object>} module:table/table~TableColorConfig
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/utils/ui/widget.js
/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/utils/ui/widget
 */


/**
 * Returns a table widget editing view element if one is selected.
 *
 * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} selection
 * @returns {module:engine/view/element~Element|null}
 */

function getSelectedTableWidget(selection) {
  var viewElement = selection.getSelectedElement();

  if (viewElement && isTableWidget(viewElement)) {
    return viewElement;
  }

  return null;
}
/**
 * Returns a table widget editing view element if one is among the selection's ancestors.
 *
 * @param {module:engine/view/selection~Selection|module:engine/view/documentselection~DocumentSelection} selection
 * @returns {module:engine/view/element~Element|null}
 */

function getTableWidgetAncestor(selection) {
  var parentTable = common_findAncestor('table', selection.getFirstPosition());

  if (parentTable && isTableWidget(parentTable.parent)) {
    return parentTable.parent;
  }

  return null;
} // Checks if a given view element is a table widget.
//
// @param {module:engine/view/element~Element} viewElement
// @returns {Boolean}

function isTableWidget(viewElement) {
  return !!viewElement.getCustomProperty('table') && isWidget(viewElement);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-table/src/tabletoolbar.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module table/tabletoolbar
 */



/**
 * The table toolbar class. It creates toolbars for the table feature and its content (for now only for the table cell content).
 *
 * The table toolbar shows up when a table widget is selected. Its components (e.g. buttons) are created based on the
 * {@link module:table/table~TableConfig#tableToolbar `table.tableToolbar` configuration option}.
 *
 * Table content toolbar shows up when the selection is inside the content of a table. It creates its component based on the
 * {@link module:table/table~TableConfig#contentToolbar `table.contentToolbar` configuration option}.
 *
 * @extends module:core/plugin~Plugin
 */

var tabletoolbar_TableToolbar = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(TableToolbar, _Plugin);

  var _super = Object(createSuper["a" /* default */])(TableToolbar);

  function TableToolbar() {
    Object(classCallCheck["a" /* default */])(this, TableToolbar);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(TableToolbar, [{
    key: "afterInit",

    /**
     * @inheritDoc
     */
    value: function afterInit() {
      var editor = this.editor;
      var t = editor.t;
      var widgetToolbarRepository = editor.plugins.get(widgettoolbarrepository_WidgetToolbarRepository);
      var tableContentToolbarItems = editor.config.get('table.contentToolbar');
      var tableToolbarItems = editor.config.get('table.tableToolbar');

      if (tableContentToolbarItems) {
        widgetToolbarRepository.register('tableContent', {
          ariaLabel: t('Table toolbar'),
          items: tableContentToolbarItems,
          getRelatedElement: getTableWidgetAncestor
        });
      }

      if (tableToolbarItems) {
        widgetToolbarRepository.register('table', {
          ariaLabel: t('Table toolbar'),
          items: tableToolbarItems,
          getRelatedElement: getSelectedTableWidget
        });
      }
    }
  }], [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [widgettoolbarrepository_WidgetToolbarRepository];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'TableToolbar';
    }
  }]);

  return TableToolbar;
}(plugin_Plugin);
/**
 * Items to be placed in the table content toolbar.
 * The {@link module:table/tabletoolbar~TableToolbar} plugin is required to make this toolbar work.
 *
 * Assuming that you use the {@link module:table/tableui~TableUI} feature, the following toolbar items will be available
 * in {@link module:ui/componentfactory~ComponentFactory}:
 *
 * * `'tableRow'`,
 * * `'tableColumn'`,
 * * `'mergeTableCells'`.
 *
 * You can thus configure the toolbar like this:
 *
 *		const tableConfig = {
 *			contentToolbar: [ 'tableRow', 'tableColumn', 'mergeTableCells' ]
 *		};
 *
 * Of course, the same buttons can also be used in the
 * {@link module:core/editor/editorconfig~EditorConfig#toolbar main editor toolbar}.
 *
 * Read more about configuring the toolbar in {@link module:core/editor/editorconfig~EditorConfig#toolbar}.
 *
 * @member {Array.<String>} module:table/table~TableConfig#contentToolbar
 */

/**
 * Items to be placed in the table toolbar.
 * The {@link module:table/tabletoolbar~TableToolbar} plugin is required to make this toolbar work.
 *
 * You can thus configure the toolbar like this:
 *
 *		const tableConfig = {
 *			tableToolbar: [ 'blockQuote' ]
 *		};
 *
 * Of course, the same buttons can also be used in the
 * {@link module:core/editor/editorconfig~EditorConfig#toolbar main editor toolbar}.
 *
 * Read more about configuring the toolbar in {@link module:core/editor/editorconfig~EditorConfig#toolbar}.
 *
 * @member {Array.<String>} module:table/table~TableConfig#tableToolbar
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-typing/src/utils/getlasttextline.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module typing/utils/getlasttextline
 */

/**
 * Returns the last text line from the given range.
 *
 * "The last text line" is understood as text (from one or more text nodes) which is limited either by a parent block
 * or by inline elements (e.g. `<softBreak>`).
 *
 *		const rangeToCheck = model.createRange(
 *			model.createPositionAt( paragraph, 0 ),
 *			model.createPositionAt( paragraph, 'end' )
 *		);
 *
 *		const { text, range } = getLastTextLine( rangeToCheck, model );
 *
 * For model below, the returned `text` will be "Foo bar baz" and `range` will be set on whole `<paragraph>` content:
 *
 *		<paragraph>Foo bar baz<paragraph>
 *
 * However, in below case, `text` will be set to "baz" and `range` will be set only on "baz".
 *
 *		<paragraph>Foo<softBreak></softBreak>bar<softBreak></softBreak>baz<paragraph>
 *
 * @protected
 * @param {module:engine/model/range~Range} range
 * @param {module:engine/model/model~Model} model
 * @returns {module:typing/utils/getlasttextline~LastTextLineData}
 */
function getLastTextLine(range, model) {
  var start = range.start;
  var text = Array.from(range.getItems()).reduce(function (rangeText, node) {
    // Trim text to a last occurrence of an inline element and update range start.
    if (!(node.is('text') || node.is('textProxy'))) {
      start = model.createPositionAfter(node);
      return '';
    }

    return rangeText + node.data;
  }, '');
  return {
    text: text,
    range: model.createRange(start, range.end)
  };
}
/**
 * The value returned by {@link module:typing/utils/getlasttextline~getLastTextLine}.
 *
 * @typedef {Object} module:typing/utils/getlasttextline~LastTextLineData
 *
 * @property {String} text The text from the text nodes in the last text line.
 * @property {module:engine/model/range~Range} range The range set on the text nodes in the last text line.
 */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-typing/src/textwatcher.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module typing/textwatcher
 */



/**
 * The text watcher feature.
 *
 * Fires the {@link module:typing/textwatcher~TextWatcher#event:matched:data `matched:data`},
 * {@link module:typing/textwatcher~TextWatcher#event:matched:selection `matched:selection`} and
 * {@link module:typing/textwatcher~TextWatcher#event:unmatched `unmatched`} events on typing or selection changes.
 *
 * @private
 * @mixes module:utils/observablemixin~ObservableMixin
 */

var textwatcher_TextWatcher = /*#__PURE__*/function () {
  /**
   * Creates a text watcher instance.
   *
   * @param {module:engine/model/model~Model} model
   * @param {Function} testCallback See {@link module:typing/textwatcher~TextWatcher#testCallback}.
   */
  function TextWatcher(model, testCallback) {
    var _this = this;

    Object(classCallCheck["a" /* default */])(this, TextWatcher);

    /**
     * The editor's model.
     *
     * @readonly
     * @member {module:engine/model/model~Model}
     */
    this.model = model;
    /**
     * The function used to match the text.
     *
     * The test callback can return 3 values:
     *
     * * `false` if there is no match,
     * * `true` if there is a match,
     * * an object if there is a match and we want to pass some additional information to the {@link #event:matched:data} event.
     *
     * @member {Function} #testCallback
     * @returns {Object} testResult
     */

    this.testCallback = testCallback;
    /**
     * Whether there is a match currently.
     *
     * @readonly
     * @member {Boolean}
     */

    this.hasMatch = false;
    /**
     * Flag indicating whether the `TextWatcher` instance is enabled or disabled.
     * A disabled TextWatcher will not evaluate text.
     *
     * To disable TextWatcher:
     *
     *		const watcher = new TextWatcher( editor.model, testCallback );
     *
     *		// After this a testCallback will not be called.
     *		watcher.isEnabled = false;
     *
     * @observable
     * @member {Boolean} #isEnabled
     */

    this.set('isEnabled', true); // Toggle text watching on isEnabled state change.

    this.on('change:isEnabled', function () {
      if (_this.isEnabled) {
        _this._startListening();
      } else {
        _this.stopListening(model.document.selection);

        _this.stopListening(model.document);
      }
    });

    this._startListening();
  }
  /**
   * Starts listening to the editor for typing and selection events.
   *
   * @private
   */


  Object(createClass["a" /* default */])(TextWatcher, [{
    key: "_startListening",
    value: function _startListening() {
      var _this2 = this;

      var model = this.model;
      var document = model.document;
      this.listenTo(document.selection, 'change:range', function (evt, _ref) {
        var directChange = _ref.directChange;

        // Indirect changes (i.e. when the user types or external changes are applied) are handled in the document's change event.
        if (!directChange) {
          return;
        } // Act only on collapsed selection.


        if (!document.selection.isCollapsed) {
          if (_this2.hasMatch) {
            _this2.fire('unmatched');

            _this2.hasMatch = false;
          }

          return;
        }

        _this2._evaluateTextBeforeSelection('selection');
      });
      this.listenTo(document, 'change:data', function (evt, batch) {
        if (batch.type == 'transparent') {
          return;
        }

        _this2._evaluateTextBeforeSelection('data', {
          batch: batch
        });
      });
    }
    /**
     * Checks the editor content for matched text.
     *
     * @fires matched:data
     * @fires matched:selection
     * @fires unmatched
     *
     * @private
     * @param {'data'|'selection'} suffix A suffix used for generating the event name.
     * @param {Object} data Data object for event.
     */

  }, {
    key: "_evaluateTextBeforeSelection",
    value: function _evaluateTextBeforeSelection(suffix) {
      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var model = this.model;
      var document = model.document;
      var selection = document.selection;
      var rangeBeforeSelection = model.createRange(model.createPositionAt(selection.focus.parent, 0), selection.focus);

      var _getLastTextLine = getLastTextLine(rangeBeforeSelection, model),
          text = _getLastTextLine.text,
          range = _getLastTextLine.range;

      var testResult = this.testCallback(text);

      if (!testResult && this.hasMatch) {
        this.fire('unmatched');
      }

      this.hasMatch = !!testResult;

      if (testResult) {
        var eventData = Object.assign(data, {
          text: text,
          range: range
        }); // If the test callback returns an object with additional data, assign the data as well.

        if (Object(esm_typeof["a" /* default */])(testResult) == 'object') {
          Object.assign(eventData, testResult);
        }

        this.fire("matched:".concat(suffix), eventData);
      }
    }
  }]);

  return TextWatcher;
}();


mix(textwatcher_TextWatcher, observablemixin);
/**
 * Fired whenever the text watcher found a match for data changes.
 *
 * @event matched:data
 * @param {Object} data Event data.
 * @param {String} data.text The full text before selection to which the regexp was applied.
 * @param {module:engine/model/range~Range} data.range The range representing the position of the `data.text`.
 * @param {Object} [data.testResult] The additional data returned from the {@link module:typing/textwatcher~TextWatcher#testCallback}.
 */

/**
 * Fired whenever the text watcher found a match for selection changes.
 *
 * @event matched:selection
 * @param {Object} data Event data.
 * @param {String} data.text The full text before selection.
 * @param {module:engine/model/range~Range} data.range The range representing the position of the `data.text`.
 * @param {Object} [data.testResult] The additional data returned from the {@link module:typing/textwatcher~TextWatcher#testCallback}.
 */

/**
 * Fired whenever the text does not match anymore. Fired only when the text watcher found a match.
 *
 * @event unmatched
 */
// CONCATENATED MODULE: ./node_modules/lodash-es/escapeRegExp.js


/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var escapeRegExp_reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
    reHasRegExpChar = RegExp(escapeRegExp_reRegExpChar.source);

/**
 * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
 * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category String
 * @param {string} [string=''] The string to escape.
 * @returns {string} Returns the escaped string.
 * @example
 *
 * _.escapeRegExp('[lodash](https://lodash.com/)');
 * // => '\[lodash\]\(https://lodash\.com/\)'
 */
function escapeRegExp(string) {
  string = lodash_es_toString(string);
  return (string && reHasRegExpChar.test(string))
    ? string.replace(escapeRegExp_reRegExpChar, '\\$&')
    : string;
}

/* harmony default export */ var lodash_es_escapeRegExp = (escapeRegExp);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-typing/src/texttransformation.js






















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module typing/texttransformation
 */


 // All named transformations.

var TRANSFORMATIONS = {
  // Common symbols:
  copyright: {
    from: '(c)',
    to: '©'
  },
  registeredTrademark: {
    from: '(r)',
    to: '®'
  },
  trademark: {
    from: '(tm)',
    to: '™'
  },
  // Mathematical:
  oneHalf: {
    from: '1/2',
    to: '½'
  },
  oneThird: {
    from: '1/3',
    to: '⅓'
  },
  twoThirds: {
    from: '2/3',
    to: '⅔'
  },
  oneForth: {
    from: '1/4',
    to: '¼'
  },
  threeQuarters: {
    from: '3/4',
    to: '¾'
  },
  lessThanOrEqual: {
    from: '<=',
    to: '≤'
  },
  greaterThanOrEqual: {
    from: '>=',
    to: '≥'
  },
  notEqual: {
    from: '!=',
    to: '≠'
  },
  arrowLeft: {
    from: '<-',
    to: '←'
  },
  arrowRight: {
    from: '->',
    to: '→'
  },
  // Typography:
  horizontalEllipsis: {
    from: '...',
    to: '…'
  },
  enDash: {
    from: /(^| )(--)( )$/,
    to: [null, '–', null]
  },
  emDash: {
    from: /(^| )(---)( )$/,
    to: [null, '—', null]
  },
  // Quotations:
  // English, US
  quotesPrimary: {
    from: buildQuotesRegExp('"'),
    to: [null, '“', null, '”']
  },
  quotesSecondary: {
    from: buildQuotesRegExp('\''),
    to: [null, '‘', null, '’']
  },
  // English, UK
  quotesPrimaryEnGb: {
    from: buildQuotesRegExp('\''),
    to: [null, '‘', null, '’']
  },
  quotesSecondaryEnGb: {
    from: buildQuotesRegExp('"'),
    to: [null, '“', null, '”']
  },
  // Polish
  quotesPrimaryPl: {
    from: buildQuotesRegExp('"'),
    to: [null, '„', null, '”']
  },
  quotesSecondaryPl: {
    from: buildQuotesRegExp('\''),
    to: [null, '‚', null, '’']
  }
}; // Transformation groups.

var TRANSFORMATION_GROUPS = {
  symbols: ['copyright', 'registeredTrademark', 'trademark'],
  mathematical: ['oneHalf', 'oneThird', 'twoThirds', 'oneForth', 'threeQuarters', 'lessThanOrEqual', 'greaterThanOrEqual', 'notEqual', 'arrowLeft', 'arrowRight'],
  typography: ['horizontalEllipsis', 'enDash', 'emDash'],
  quotes: ['quotesPrimary', 'quotesSecondary']
}; // A set of default transformations provided by the feature.

var DEFAULT_TRANSFORMATIONS = ['symbols', 'mathematical', 'typography', 'quotes'];
/**
 * The text transformation plugin.
 *
 * @extends module:core/plugin~Plugin
 */

var texttransformation_TextTransformation = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(TextTransformation, _Plugin);

  var _super = Object(createSuper["a" /* default */])(TextTransformation);

  Object(createClass["a" /* default */])(TextTransformation, null, [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'TextTransformation';
    }
    /**
     * @inheritDoc
     */

  }]);

  function TextTransformation(editor) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, TextTransformation);

    _this = _super.call(this, editor);
    editor.config.define('typing', {
      transformations: {
        include: DEFAULT_TRANSFORMATIONS
      }
    });
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(TextTransformation, [{
    key: "init",
    value: function init() {
      var _this2 = this;

      var model = this.editor.model;
      var modelSelection = model.document.selection;
      modelSelection.on('change:range', function () {
        // Disable plugin when selection is inside a code block.
        _this2.isEnabled = !modelSelection.anchor.parent.is('codeBlock');
      });

      this._enableTransformationWatchers();
    }
    /**
     * Create new TextWatcher listening to the editor for typing and selection events.
     *
     * @private
     */

  }, {
    key: "_enableTransformationWatchers",
    value: function _enableTransformationWatchers() {
      var editor = this.editor;
      var model = editor.model;
      var input = editor.plugins.get('Input');
      var normalizedTransformations = normalizeTransformations(editor.config.get('typing.transformations'));

      var testCallback = function testCallback(text) {
        var _iterator = _createForOfIteratorHelper(normalizedTransformations),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var normalizedTransformation = _step.value;
            var from = normalizedTransformation.from;
            var match = from.test(text);

            if (match) {
              return {
                normalizedTransformation: normalizedTransformation
              };
            }
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      };

      var watcherCallback = function watcherCallback(evt, data) {
        if (!input.isInput(data.batch)) {
          return;
        }

        var _data$normalizedTrans = data.normalizedTransformation,
            from = _data$normalizedTrans.from,
            to = _data$normalizedTrans.to;
        var matches = from.exec(data.text);
        var replaces = to(matches.slice(1));
        var matchedRange = data.range;
        var changeIndex = matches.index;
        model.enqueueChange(function (writer) {
          for (var i = 1; i < matches.length; i++) {
            var match = matches[i];
            var replaceWith = replaces[i - 1];

            if (replaceWith == null) {
              changeIndex += match.length;
              continue;
            }

            var replacePosition = matchedRange.start.getShiftedBy(changeIndex);
            var replaceRange = model.createRange(replacePosition, replacePosition.getShiftedBy(match.length));
            var attributes = getTextAttributesAfterPosition(replacePosition);
            model.insertContent(writer.createText(replaceWith, attributes), replaceRange);
            changeIndex += replaceWith.length;
          }
        });
      };

      var watcher = new textwatcher_TextWatcher(editor.model, testCallback);
      watcher.on('matched:data', watcherCallback);
      watcher.bind('isEnabled').to(this);
    }
  }]);

  return TextTransformation;
}(plugin_Plugin); // Normalizes the configuration `from` parameter value.
// The normalized value for the `from` parameter is a RegExp instance. If the passed `from` is already a RegExp instance,
// it is returned unchanged.
//
// @param {String|RegExp} from
// @returns {RegExp}




function normalizeFrom(from) {
  if (typeof from == 'string') {
    return new RegExp("(".concat(lodash_es_escapeRegExp(from), ")$"));
  } // `from` is already a regular expression.


  return from;
} // Normalizes the configuration `to` parameter value.
// The normalized value for the `to` parameter is a function that takes an array and returns an array. See more in the
// configuration description. If the passed `to` is already a function, it is returned unchanged.
//
// @param {String|Array.<null|String>|Function} to
// @returns {Function}


function normalizeTo(to) {
  if (typeof to == 'string') {
    return function () {
      return [to];
    };
  } else if (to instanceof Array) {
    return function () {
      return to;
    };
  } // `to` is already a function.


  return to;
} // For given `position` returns attributes for the text that is after that position.
// The text can be in the same text node as the position (`foo[]bar`) or in the next text node (`foo[]<$text bold="true">bar</$text>`).
//
// @param {module:engine/model/position~Position} position
// @returns {Iterable.<*>}


function getTextAttributesAfterPosition(position) {
  var textNode = position.textNode ? position.textNode : position.nodeAfter;
  return textNode.getAttributes();
} // Returns a RegExp pattern string that detects a sentence inside a quote.
//
// @param {String} quoteCharacter The character to create a pattern for.
// @returns {String}


function buildQuotesRegExp(quoteCharacter) {
  return new RegExp("(^|\\s)(".concat(quoteCharacter, ")([^").concat(quoteCharacter, "]*)(").concat(quoteCharacter, ")$"));
} // Reads text transformation config and returns normalized array of transformations objects.
//
// @param {module:typing/texttransformation~TextTransformationDescription} config
// @returns {Array.<{from:String,to:Function}>}


function normalizeTransformations(config) {
  var extra = config.extra || [];
  var remove = config.remove || [];

  var isNotRemoved = function isNotRemoved(transformation) {
    return !remove.includes(transformation);
  };

  var configured = config.include.concat(extra).filter(isNotRemoved);
  return expandGroupsAndRemoveDuplicates(configured).filter(isNotRemoved) // Filter out 'remove' transformations as they might be set in group
  .map(function (transformation) {
    return TRANSFORMATIONS[transformation] || transformation;
  }).map(function (transformation) {
    return {
      from: normalizeFrom(transformation.from),
      to: normalizeTo(transformation.to)
    };
  });
} // Reads definitions and expands named groups if needed to transformation names.
// This method also removes duplicated named transformations if any.
//
// @param {Array.<String|Object>} definitions
// @returns {Array.<String|Object>}


function expandGroupsAndRemoveDuplicates(definitions) {
  // Set is using to make sure that transformation names are not duplicated.
  var definedTransformations = new Set();

  var _iterator2 = _createForOfIteratorHelper(definitions),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var transformationOrGroup = _step2.value;

      if (TRANSFORMATION_GROUPS[transformationOrGroup]) {
        var _iterator3 = _createForOfIteratorHelper(TRANSFORMATION_GROUPS[transformationOrGroup]),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var transformation = _step3.value;
            definedTransformations.add(transformation);
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      } else {
        definedTransformations.add(transformationOrGroup);
      }
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }

  return Array.from(definedTransformations);
}
/**
 * The text transformation definition object. It describes what should be replaced with what.
 *
 * The input value (`from`) can be passed either as a string or as a regular expression.
 *
 * * If a string is passed, it will be simply checked if the end of the input matches it.
 * * If a regular expression is passed, its entire length must be covered with capturing groups (e.g. `/(foo)(bar)$/`).
 * Also, since it is compared against the end of the input, it has to end with  `$` to be correctly matched.
 * See examples below.
 *
 * The output value (`to`) can be passed as a string, as an array or as a function.
 *
 * * If a string is passed, it will be used as a replacement value as-is. Note that a string output value can be used only if
 * the input value is a string, too.
 * * If an array is passed, it has to have the same number of elements as there are capturing groups in the input value regular expression.
 * Each capture group will be replaced with a corresponding string from the passed array. If a given capturing group should not be replaced,
 * use `null` instead of passing a string.
 * * If a function is used, it should return an array as described above. The function is passed one parameter &mdash; an array with matches
 * by the regular expression. See the examples below.
 *
 * A simple string-to-string replacement:
 *
 *		{ from: '(c)', to: '©' }
 *
 * Change quote styles using a regular expression. Note how all the parts are in separate capturing groups and the space at the beginning
 * and the text inside quotes are not replaced (`null` passed as the first and the third value in the `to` parameter):
 *
 *		{
 *			from: /(^|\s)(")([^"]*)(")$/,
 *			to: [ null, '“', null, '”' ]
 *		}
 *
 * Automatic uppercase after a dot using a callback:
 *
 *		{
 *			from: /(\. )([a-z])$/,
 *			to: matches => [ null, matches[ 1 ].toUpperCase() ]
 *		}
 *
 * @typedef {Object} module:typing/texttransformation~TextTransformationDescription
 * @property {String|RegExp} from The string or regular expression to transform.
 * @property {String} to The text to transform compatible with `String.replace()`.
 */

/**
 * The configuration of the {@link module:typing/texttransformation~TextTransformation} feature.
 *
 * Read more in {@link module:typing/texttransformation~TextTransformationConfig}.
 *
 * @member {module:typing/texttransformation~TextTransformationConfig} module:typing/typing~TypingConfig#transformations
 */

/**
 * The configuration of the text transformation feature.
 *
 *		ClassicEditor
 *			.create( editorElement, {
 *				typing: {
 *					transformations: ... // Text transformation feature options.
 *				}
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * By default, the feature comes pre-configured
 * (via {@link module:typing/texttransformation~TextTransformationConfig#include `config.typing.transformations.include`}) with the
 * following groups of transformations:
 *
 * * Typography (group name: `typography`)
 *   - `ellipsis`: transforms `...` to `…`
 *   - `enDash`: transforms ` -- ` to ` – `
 *   - `emDash`: transforms ` --- ` to ` — `
 * * Quotations (group name: `quotes`)
 *   - `quotesPrimary`: transforms `"Foo bar"` to `“Foo bar”`
 *   - `quotesSecondary`: transforms `'Foo bar'` to `‘Foo bar’`
 * * Symbols (group name: `symbols`)
 *   - `trademark`: transforms `(tm)` to `™`
 *   - `registeredTrademark`: transforms `(r)` to `®`
 *   - `copyright`: transforms `(c)` to `©`
 * * Mathematical (group name: `mathematical`)
 *   - `oneHalf`: transforms `1/2` to: `½`
 *   - `oneThird`: transforms `1/3` to: `⅓`
 *   - `twoThirds`: transforms `2/3` to: `⅔`
 *   - `oneForth`: transforms `1/4` to: `¼`
 *   - `threeQuarters`: transforms `3/4` to: `¾`
 *   - `lessThanOrEqual`: transforms `<=` to: `≤`
 *   - `greaterThanOrEqual`: transforms `>=` to: `≥`
 *   - `notEqual`: transforms `!=` to: `≠`
 *   - `arrowLeft`: transforms `<-` to: `←`
 *   - `arrowRight`: transforms `->` to: `→`
 * * Misc:
 *   - `quotesPrimaryEnGb`: transforms `'Foo bar'` to `‘Foo bar’`
 *   - `quotesSecondaryEnGb`: transforms `"Foo bar"` to `“Foo bar”`
 *   - `quotesPrimaryPl`: transforms `"Foo bar"` to `„Foo bar”`
 *   - `quotesSecondaryPl`:  transforms `'Foo bar'` to `‚Foo bar’`
 *
 * In order to load additional transformations, use the
 * {@link module:typing/texttransformation~TextTransformationConfig#extra `transformations.extra` option}.
 *
 * In order to narrow down the list of transformations, use the
 * {@link module:typing/texttransformation~TextTransformationConfig#remove `transformations.remove` option}.
 *
 * In order to completely override the supported transformations, use the
 * {@link module:typing/texttransformation~TextTransformationConfig#include `transformations.include` option}.
 *
 * Examples:
 *
 *		const transformationsConfig = {
 *			include: [
 *				// Use only the 'quotes' and 'typography' groups.
 *				'quotes',
 *				'typography',
 *
 *				// Plus, some custom transformation.
 *				{ from: 'CKE', to: 'CKEditor' }
 *			]
 *		};
 *
 *		const transformationsConfig = {
 *			// Remove the 'ellipsis' transformation loaded by the 'typography' group.
 *			remove: [ 'ellipsis' ]
 *		}
 *
 * @interface TextTransformationConfig
 */

/* eslint-disable max-len */

/**
 * The standard list of text transformations supported by the editor. By default it comes pre-configured with a couple dozen of them
 * (see {@link module:typing/texttransformation~TextTransformationConfig} for the full list). You can override this list completely
 * by setting this option or use the other two options
 * ({@link module:typing/texttransformation~TextTransformationConfig#extra `transformations.extra`},
 * {@link module:typing/texttransformation~TextTransformationConfig#remove `transformations.remove`}) to fine-tune the default list.
 *
 * @member {Array.<module:typing/texttransformation~TextTransformationDescription>} module:typing/texttransformation~TextTransformationConfig#include
 */

/**
 * Additional text transformations that are added to the transformations defined in
 * {@link module:typing/texttransformation~TextTransformationConfig#include `transformations.include`}.
 *
 *		const transformationsConfig = {
 *			extra: [
 *				{ from: 'CKE', to: 'CKEditor' }
 *			]
 *		};
 *
 * @member {Array.<module:typing/texttransformation~TextTransformationDescription>} module:typing/texttransformation~TextTransformationConfig#extra
 */

/**
 * The text transformation names that are removed from transformations defined in
 * {@link module:typing/texttransformation~TextTransformationConfig#include `transformations.include`} or
 * {@link module:typing/texttransformation~TextTransformationConfig#extra `transformations.extra`}.
 *
 *		const transformationsConfig = {
 *			remove: [
 *				'ellipsis',    // Remove only 'ellipsis' from the 'typography' group.
 *				'mathematical' // Remove all transformations from the 'mathematical' group.
 *			]
 *		}
 *
 * @member {Array.<module:typing/texttransformation~TextTransformationDescription>} module:typing/texttransformation~TextTransformationConfig#remove
 */

/* eslint-enable max-len */
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-font/src/fontcommand.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module font/fontcommand
 */

/**
 * The base font command.
 *
 * @extends module:core/command~Command
 */

var fontcommand_FontCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(FontCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(FontCommand);

  /**
   * Creates an instance of the command.
   *
   * @param {module:core/editor/editor~Editor} editor Editor instance.
   * @param {String} attributeKey The name of a model attribute on which this command operates.
   */
  function FontCommand(editor, attributeKey) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, FontCommand);

    _this = _super.call(this, editor);
    /**
     * When set, it reflects the {@link #attributeKey} value of the selection.
     *
     * @observable
     * @readonly
     * @member {String} module:font/fontcommand~FontCommand#value
     */

    /**
     * A model attribute on which this command operates.
     *
     * @readonly
     * @member {Boolean} module:font/fontcommand~FontCommand#attributeKey
     */

    _this.attributeKey = attributeKey;
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(FontCommand, [{
    key: "refresh",
    value: function refresh() {
      var model = this.editor.model;
      var doc = model.document;
      this.value = doc.selection.getAttribute(this.attributeKey);
      this.isEnabled = model.schema.checkAttributeInSelection(doc.selection, this.attributeKey);
    }
    /**
     * Executes the command. Applies the `value` of the {@link #attributeKey} to the selection.
     * If no `value` is passed, it removes the attribute from the selection.
     *
     * @protected
     * @param {Object} [options] Options for the executed command.
     * @param {String} [options.value] The value to apply.
     * @fires execute
     */

  }, {
    key: "execute",
    value: function execute() {
      var _this2 = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var model = this.editor.model;
      var document = model.document;
      var selection = document.selection;
      var value = options.value;
      model.change(function (writer) {
        if (selection.isCollapsed) {
          if (value) {
            writer.setSelectionAttribute(_this2.attributeKey, value);
          } else {
            writer.removeSelectionAttribute(_this2.attributeKey);
          }
        } else {
          var ranges = model.schema.getValidRanges(selection.getRanges(), _this2.attributeKey);

          var _iterator = _createForOfIteratorHelper(ranges),
              _step;

          try {
            for (_iterator.s(); !(_step = _iterator.n()).done;) {
              var range = _step.value;

              if (value) {
                writer.setAttribute(_this2.attributeKey, value, range);
              } else {
                writer.removeAttribute(_this2.attributeKey, range);
              }
            }
          } catch (err) {
            _iterator.e(err);
          } finally {
            _iterator.f();
          }
        }
      });
    }
  }]);

  return FontCommand;
}(command_Command);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/icons/color-tile-check.svg
var color_tile_check = __webpack_require__("8de7");
var color_tile_check_default = /*#__PURE__*/__webpack_require__.n(color_tile_check);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/colorgrid/colortileview.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/colorgrid/colortile
 */


/**
 * This class represents a single color tile in the {@link module:ui/colorgrid/colorgrid~ColorGridView}.
 *
 * @extends module:ui/button/buttonview~ButtonView
 */

var colortileview_ColorTileView = /*#__PURE__*/function (_ButtonView) {
  Object(inherits["a" /* default */])(ColorTileView, _ButtonView);

  var _super = Object(createSuper["a" /* default */])(ColorTileView);

  function ColorTileView(locale) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, ColorTileView);

    _this = _super.call(this, locale);
    var bind = _this.bindTemplate;
    /**
     * String representing a color shown as tile's background.
     *
     * @type {String}
     */

    _this.set('color');
    /**
     * A flag that toggles a special CSS class responsible for displaying
     * a border around the button.
     *
     * @type {Boolean}
     */


    _this.set('hasBorder');

    _this.icon = color_tile_check_default.a;

    _this.extendTemplate({
      attributes: {
        style: {
          backgroundColor: bind.to('color')
        },
        class: ['ck', 'ck-color-grid__tile', bind.if('hasBorder', 'ck-color-table__color-tile_bordered')]
      }
    });

    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(ColorTileView, [{
    key: "render",
    value: function render() {
      get_get(Object(getPrototypeOf["a" /* default */])(ColorTileView.prototype), "render", this).call(this);

      this.iconView.fillColor = 'hsl(0, 0%, 100%)';
    }
  }]);

  return ColorTileView;
}(buttonview_ButtonView);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-ui/theme/components/colorgrid/colorgrid.css
var colorgrid = __webpack_require__("6cdf");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/colorgrid/colorgridview.js










/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/colorgrid/colorgrid
 */






/**
 * A grid of {@link module:ui/colorgrid/colortile~ColorTileView color tiles}.
 *
 * @extends module:ui/view~View
 */

var colorgridview_ColorGridView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(ColorGridView, _View);

  var _super = Object(createSuper["a" /* default */])(ColorGridView);

  /**
   * Creates an instance of a color grid containing {@link module:ui/colorgrid/colortile~ColorTileView tiles}.
   *
   * @param {module:utils/locale~Locale} [locale] The localization services instance.
   * @param {Object} options Component configuration
   * @param {Array.<module:ui/colorgrid/colorgrid~ColorDefinition>} [options.colorDefinitions] Array with definitions
   * required to create the {@link module:ui/colorgrid/colortile~ColorTileView tiles}.
   * @param {Number} options.columns A number of columns to display the tiles.
   */
  function ColorGridView(locale, options) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, ColorGridView);

    _this = _super.call(this, locale);
    var colorDefinitions = options && options.colorDefinitions || [];
    var viewStyleAttribute = {};

    if (options && options.columns) {
      viewStyleAttribute.gridTemplateColumns = "repeat( ".concat(options.columns, ", 1fr)");
    }
    /**
     * The color of the currently selected color tile in {@link #items}.
     *
     * @observable
     * @type {String}
     */


    _this.set('selectedColor');
    /**
     * Collection of the child tile views.
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */


    _this.items = _this.createCollection();
    /**
     * Tracks information about DOM focus in the grid.
     *
     * @readonly
     * @member {module:utils/focustracker~FocusTracker}
     */

    _this.focusTracker = new focustracker_FocusTracker();
    /**
     * Instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
     *
     * @readonly
     * @member {module:utils/keystrokehandler~KeystrokeHandler}
     */

    _this.keystrokes = new keystrokehandler_KeystrokeHandler();
    /**
     * Helps cycling over focusable {@link #items} in the grid.
     *
     * @readonly
     * @protected
     * @member {module:ui/focuscycler~FocusCycler}
     */

    _this._focusCycler = new focuscycler_FocusCycler({
      focusables: _this.items,
      focusTracker: _this.focusTracker,
      keystrokeHandler: _this.keystrokes,
      actions: {
        // Navigate grid items backwards using the arrowup key.
        focusPrevious: 'arrowleft',
        // Navigate grid items forwards using the arrowdown key.
        focusNext: 'arrowright'
      }
    });

    _this.items.on('add', function (evt, colorTile) {
      colorTile.isOn = colorTile.color === _this.selectedColor;
    });

    colorDefinitions.forEach(function (color) {
      var colorTile = new colortileview_ColorTileView();
      colorTile.set({
        color: color.color,
        label: color.label,
        tooltip: true,
        hasBorder: color.options.hasBorder
      });
      colorTile.on('execute', function () {
        _this.fire('execute', {
          value: color.color,
          hasBorder: color.options.hasBorder,
          label: color.label
        });
      });

      _this.items.add(colorTile);
    });

    _this.setTemplate({
      tag: 'div',
      children: _this.items,
      attributes: {
        class: ['ck', 'ck-color-grid'],
        style: viewStyleAttribute
      }
    });

    _this.on('change:selectedColor', function (evt, name, selectedColor) {
      var _iterator = _createForOfIteratorHelper(_this.items),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var item = _step.value;
          item.isOn = item.color === selectedColor;
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    });

    return _this;
  }
  /**
   * Focuses the first focusable in {@link #items}.
   */


  Object(createClass["a" /* default */])(ColorGridView, [{
    key: "focus",
    value: function focus() {
      if (this.items.length) {
        this.items.first.focus();
      }
    }
    /**
     * Focuses the last focusable in {@link #items}.
     */

  }, {
    key: "focusLast",
    value: function focusLast() {
      if (this.items.length) {
        this.items.last.focus();
      }
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "render",
    value: function render() {
      var _this2 = this;

      get_get(Object(getPrototypeOf["a" /* default */])(ColorGridView.prototype), "render", this).call(this); // Items added before rendering should be known to the #focusTracker.


      var _iterator2 = _createForOfIteratorHelper(this.items),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var item = _step2.value;
          this.focusTracker.add(item.element);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      this.items.on('add', function (evt, item) {
        _this2.focusTracker.add(item.element);
      });
      this.items.on('remove', function (evt, item) {
        _this2.focusTracker.remove(item.element);
      }); // Start listening for the keystrokes coming from #element.

      this.keystrokes.listenTo(this.element);
    }
    /**
     * Fired when the `ColorTileView` for the picked item is executed.
     *
     * @event execute
     * @param {Object} data Additional information about the event.
     * @param {String} data.value The value of the selected color
     * ({@link module:ui/colorgrid/colorgrid~ColorDefinition#color `color.color`}).
     * @param {Boolean} data.hasBorder The `hasBorder` property of the selected color
     * ({@link module:ui/colorgrid/colorgrid~ColorDefinition#options `color.options.hasBorder`}).
     * @param {String} data.Label The label of the selected color
     * ({@link module:ui/colorgrid/colorgrid~ColorDefinition#label `color.label`})
     */

  }]);

  return ColorGridView;
}(src_view_View);
/**
 * A color definition used to create a {@link module:ui/colorgrid/colortile~ColorTileView}.
 *
 *		{
 *			color: 'hsl(0, 0%, 75%)',
 *			label: 'Light Grey',
 *			options: {
 *				hasBorder: true
 *			}
 *		}
 *
 * @typedef {Object} module:ui/colorgrid/colorgrid~ColorDefinition
 * @type Object
 *
 * @property {String} color String representing a color.
 * It is used as value of background-color style in {@link module:ui/colorgrid/colortile~ColorTileView}.
 * @property {String} label String used as label for {@link module:ui/colorgrid/colortile~ColorTileView}.
 * @property {Object} options Additional options passed to create a {@link module:ui/colorgrid/colortile~ColorTileView}.
 * @property {Boolean} options.hasBorder A flag that indicates if special a CSS class should be added
 * to {@link module:ui/colorgrid/colortile~ColorTileView}, which renders a border around it.
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-font/src/documentcolorcollection.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module font/documentcolorcollection
 */



/**
 * A collection to store document colors. It enforces colors to be unique.
 *
 * @mixes module:utils/observablemixin~ObservableMixin
 * @extends module:utils/collection~Collection
 */

var documentcolorcollection_DocumentColorCollection = /*#__PURE__*/function (_Collection) {
  Object(inherits["a" /* default */])(DocumentColorCollection, _Collection);

  var _super = Object(createSuper["a" /* default */])(DocumentColorCollection);

  function DocumentColorCollection(options) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, DocumentColorCollection);

    _this = _super.call(this, options);
    /**
     * Indicates whether the document color collection is empty.
     *
     * @observable
     * @readonly
     * @member {Boolean} #isEmpty
     */

    _this.set('isEmpty', true);

    return _this;
  }
  /**
   * Adds a color to the document color collection.
   *
   * This method ensures that no color duplicates are inserted (compared using
   * the color value of the {@link module:ui/colorgrid/colorgrid~ColorDefinition}).
   *
   * If the item does not have an ID, it will be automatically generated and set on the item.
   *
   * @chainable
   * @param {module:ui/colorgrid/colorgrid~ColorDefinition} item
   * @param {Number} [index] The position of the item in the collection. The item
   * is pushed to the collection when `index` is not specified.
   * @fires add
   */


  Object(createClass["a" /* default */])(DocumentColorCollection, [{
    key: "add",
    value: function add(item, index) {
      if (this.find(function (element) {
        return element.color === item.color;
      })) {
        // No duplicates are allowed.
        return;
      }

      get_get(Object(getPrototypeOf["a" /* default */])(DocumentColorCollection.prototype), "add", this).call(this, item, index);

      this.set('isEmpty', false);
    }
    /**
     * @inheritdoc
     */

  }, {
    key: "remove",
    value: function remove(subject) {
      var ret = get_get(Object(getPrototypeOf["a" /* default */])(DocumentColorCollection.prototype), "remove", this).call(this, subject);

      if (this.length === 0) {
        this.set('isEmpty', true);
      }

      return ret;
    }
    /**
     * Checks if an object with given colors is present in the document color collection.
     *
     * @param {String} color
     * @returns {Boolean}
     */

  }, {
    key: "hasColor",
    value: function hasColor(color) {
      return !!this.find(function (item) {
        return item.color === color;
      });
    }
  }]);

  return DocumentColorCollection;
}(collection_Collection);


mix(documentcolorcollection_DocumentColorCollection, observablemixin);
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-core/theme/icons/eraser.svg
var eraser = __webpack_require__("875d");
var eraser_default = /*#__PURE__*/__webpack_require__.n(eraser);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-font/theme/fontcolor.css
var fontcolor = __webpack_require__("b3ce");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-font/src/ui/colortableview.js










/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module font/ui/colortableview
 */












/**
 * A class which represents a view with the following sub–components:
 *
 * * A remove color button,
 * * A static {@link module:ui/colorgrid/colorgrid~ColorGridView} of colors defined in the configuration,
 * * A dynamic {@link module:ui/colorgrid/colorgrid~ColorGridView} of colors used in the document.
 *
 * @extends module:ui/view~View
 */

var colortableview_ColorTableView = /*#__PURE__*/function (_View) {
  Object(inherits["a" /* default */])(ColorTableView, _View);

  var _super = Object(createSuper["a" /* default */])(ColorTableView);

  /**
   * Creates a view to be inserted as a child of {@link module:ui/dropdown/dropdownview~DropdownView}.
   *
   * @param {module:utils/locale~Locale} [locale] The localization services instance.
   * @param {Object} config The configuration object.
   * @param {Array.<module:ui/colorgrid/colorgrid~ColorDefinition>} config.colors An array with definitions of colors to
   * be displayed in the table.
   * @param {Number} config.columns The number of columns in the color grid.
   * @param {String} config.removeButtonLabel The label of the button responsible for removing the color.
   * @param {String} config.documentColorsLabel The label for the section with the document colors.
   * @param {String} config.documentColorsCount The number of colors in the document colors section inside the color dropdown.
   */
  function ColorTableView(locale, _ref) {
    var _this;

    var colors = _ref.colors,
        columns = _ref.columns,
        removeButtonLabel = _ref.removeButtonLabel,
        documentColorsLabel = _ref.documentColorsLabel,
        documentColorsCount = _ref.documentColorsCount;

    Object(classCallCheck["a" /* default */])(this, ColorTableView);

    _this = _super.call(this, locale);
    /**
     * A collection of the children of the table.
     *
     * @readonly
     * @member {module:ui/viewcollection~ViewCollection}
     */

    _this.items = _this.createCollection();
    /**
     * An array with objects representing colors to be displayed in the grid.
     *
     * @type {Arrray.<module:ui/colorgrid/colorgrid~ColorDefinition>}
     */

    _this.colorDefinitions = colors;
    /**
     * Tracks information about the DOM focus in the list.
     *
     * @readonly
     * @member {module:utils/focustracker~FocusTracker}
     */

    _this.focusTracker = new focustracker_FocusTracker();
    /**
     * An instance of the {@link module:utils/keystrokehandler~KeystrokeHandler}.
     *
     * @readonly
     * @member {module:utils/keystrokehandler~KeystrokeHandler}
     */

    _this.keystrokes = new keystrokehandler_KeystrokeHandler();
    /**
     * Keeps the value of the command associated with the table for the current selection.
     *
     * @type {String}
     */

    _this.set('selectedColor');
    /**
     * The label of the button responsible for removing color attributes.
     *
     * @type {String}
     */


    _this.removeButtonLabel = removeButtonLabel;
    /**
     * The number of columns in the color grid.
     *
     * @type {Number}
     */

    _this.columns = columns;
    /**
     * A collection of definitions that store the document colors.
     *
     * @readonly
     * @member {module:font/documentcolorcollection~DocumentColorCollection}
     */

    _this.documentColors = new documentcolorcollection_DocumentColorCollection();
    /**
     * The maximum number of colors in the document colors section.
     * If it equals 0, the document colors section is not added.
     *
     * @readonly
     * @type {Number}
     */

    _this.documentColorsCount = documentColorsCount;
    /**
     * Preserves the reference to {@link module:ui/colorgrid/colorgrid~ColorGridView} used to create
     * the default (static) color set.
     *
     * The property is loaded once the the parent dropdown is opened the first time.
     *
     * @readonly
     * @member {module:ui/colorgrid/colorgrid~ColorGridView|undefined} #staticColorsGrid
     */

    /**
     * Preserves the reference to {@link module:ui/colorgrid/colorgrid~ColorGridView} used to create
     * the document colors. It remains undefined if the document colors feature is disabled.
     *
     * The property is loaded once the the parent dropdown is opened the first time.
     *
     * @readonly
     * @member {module:ui/colorgrid/colorgrid~ColorGridView|undefined} #documentColorsGrid
     */

    /**
     * Helps cycling over focusable {@link #items} in the list.
     *
     * @readonly
     * @protected
     * @member {module:ui/focuscycler~FocusCycler}
     */

    _this._focusCycler = new focuscycler_FocusCycler({
      focusables: _this.items,
      focusTracker: _this.focusTracker,
      keystrokeHandler: _this.keystrokes,
      actions: {
        // Navigate list items backwards using the Arrow Up key.
        focusPrevious: 'arrowup',
        // Navigate list items forwards using the Arrow Down key.
        focusNext: 'arrowdown'
      }
    });
    /**
     * Document color section's label.
     *
     * @private
     * @readonly
     * @type {String}
     */

    _this._documentColorsLabel = documentColorsLabel;

    _this.setTemplate({
      tag: 'div',
      attributes: {
        class: ['ck', 'ck-color-table']
      },
      children: _this.items
    });

    _this.items.add(_this._removeColorButton());

    return _this;
  }
  /**
   * Scans through the editor model and searches for text node attributes with the given attribute name.
   * Found entries are set as document colors.
   *
   * All the previously stored document colors will be lost in the process.
   *
   * @param {module:engine/model/model~Model} model The model used as a source to obtain the document colors.
   * @param {String} attributeName Determines the name of the related model's attribute for a given dropdown.
   */


  Object(createClass["a" /* default */])(ColorTableView, [{
    key: "updateDocumentColors",
    value: function updateDocumentColors(model, attributeName) {
      var document = model.document;
      var maxCount = this.documentColorsCount;
      this.documentColors.clear();

      var _iterator = _createForOfIteratorHelper(document.getRootNames()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var rootName = _step.value;
          var root = document.getRoot(rootName);
          var range = model.createRangeIn(root);

          var _iterator2 = _createForOfIteratorHelper(range.getItems()),
              _step2;

          try {
            for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
              var node = _step2.value;

              if (node.is('textProxy') && node.hasAttribute(attributeName)) {
                this._addColorToDocumentColors(node.getAttribute(attributeName));

                if (this.documentColors.length >= maxCount) {
                  return;
                }
              }
            }
          } catch (err) {
            _iterator2.e(err);
          } finally {
            _iterator2.f();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Refreshes the state of the selected color in one or both {@link module:ui/colorgrid/colorgrid~ColorGridView}s
     * available in the {@link module:font/ui/colortableview~ColorTableView}. It guarantees that the selection will occur only in one
     * of them.
     */

  }, {
    key: "updateSelectedColors",
    value: function updateSelectedColors() {
      var documentColorsGrid = this.documentColorsGrid;
      var staticColorsGrid = this.staticColorsGrid;
      var selectedColor = this.selectedColor;
      staticColorsGrid.selectedColor = selectedColor;

      if (documentColorsGrid) {
        documentColorsGrid.selectedColor = selectedColor;
      }
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "render",
    value: function render() {
      get_get(Object(getPrototypeOf["a" /* default */])(ColorTableView.prototype), "render", this).call(this); // Items added before rendering should be known to the #focusTracker.


      var _iterator3 = _createForOfIteratorHelper(this.items),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var item = _step3.value;
          this.focusTracker.add(item.element);
        } // Start listening for the keystrokes coming from #element.

      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this.keystrokes.listenTo(this.element);
    }
    /**
     * Appends {@link #staticColorsGrid} and {@link #documentColorsGrid} views.
     */

  }, {
    key: "appendGrids",
    value: function appendGrids() {
      if (this.staticColorsGrid) {
        return;
      }

      this.staticColorsGrid = this._createStaticColorsGrid();
      this.items.add(this.staticColorsGrid);

      if (this.documentColorsCount) {
        // Create a label for document colors.
        var bind = template_Template.bind(this.documentColors, this.documentColors);
        var label = new labelview_LabelView(this.locale);
        label.text = this._documentColorsLabel;
        label.extendTemplate({
          attributes: {
            class: ['ck', 'ck-color-grid__label', bind.if('isEmpty', 'ck-hidden')]
          }
        });
        this.items.add(label);
        this.documentColorsGrid = this._createDocumentColorsGrid();
        this.items.add(this.documentColorsGrid);
      }
    }
    /**
     * Focuses the first focusable element in {@link #items}.
     */

  }, {
    key: "focus",
    value: function focus() {
      this._focusCycler.focusFirst();
    }
    /**
     * Focuses the last focusable element in {@link #items}.
     */

  }, {
    key: "focusLast",
    value: function focusLast() {
      this._focusCycler.focusLast();
    }
    /**
     * Adds the remove color button as a child of the current view.
     *
     * @private
     * @returns {module:ui/button/buttonview~ButtonView}
     */

  }, {
    key: "_removeColorButton",
    value: function _removeColorButton() {
      var _this2 = this;

      var buttonView = new buttonview_ButtonView();
      buttonView.set({
        withText: true,
        icon: eraser_default.a,
        tooltip: true,
        label: this.removeButtonLabel
      });
      buttonView.class = 'ck-color-table__remove-color';
      buttonView.on('execute', function () {
        _this2.fire('execute', {
          value: null
        });
      });
      return buttonView;
    }
    /**
     * Creates a static color table grid based on the editor configuration.
     *
     * @private
     * @returns {module:ui/colorgrid/colorgrid~ColorGridView}
     */

  }, {
    key: "_createStaticColorsGrid",
    value: function _createStaticColorsGrid() {
      var colorGrid = new colorgridview_ColorGridView(this.locale, {
        colorDefinitions: this.colorDefinitions,
        columns: this.columns
      });
      colorGrid.delegate('execute').to(this);
      return colorGrid;
    }
    /**
     * Creates the document colors section view and binds it to {@link #documentColors}.
     *
     * @private
     * @returns {module:ui/colorgrid/colorgrid~ColorGridView}
     */

  }, {
    key: "_createDocumentColorsGrid",
    value: function _createDocumentColorsGrid() {
      var _this3 = this;

      var bind = template_Template.bind(this.documentColors, this.documentColors);
      var documentColorsGrid = new colorgridview_ColorGridView(this.locale, {
        columns: this.columns
      });
      documentColorsGrid.delegate('execute').to(this);
      documentColorsGrid.extendTemplate({
        attributes: {
          class: bind.if('isEmpty', 'ck-hidden')
        }
      });
      documentColorsGrid.items.bindTo(this.documentColors).using(function (colorObj) {
        var colorTile = new colortileview_ColorTileView();
        colorTile.set({
          color: colorObj.color,
          hasBorder: colorObj.options && colorObj.options.hasBorder
        });

        if (colorObj.label) {
          colorTile.set({
            label: colorObj.label,
            tooltip: true
          });
        }

        colorTile.on('execute', function () {
          _this3.fire('execute', {
            value: colorObj.color
          });
        });
        return colorTile;
      }); // Selected color should be cleared when document colors became empty.

      this.documentColors.on('change:isEmpty', function (evt, name, val) {
        if (val) {
          documentColorsGrid.selectedColor = null;
        }
      });
      return documentColorsGrid;
    }
    /**
     * Adds a given color to the document colors list. If possible, the method will attempt to use
     * data from the {@link #colorDefinitions} (label, color options).
     *
     * @private
     * @param {String} color A string that stores the value of the recently applied color.
     */

  }, {
    key: "_addColorToDocumentColors",
    value: function _addColorToDocumentColors(color) {
      var predefinedColor = this.colorDefinitions.find(function (definition) {
        return definition.color === color;
      });

      if (!predefinedColor) {
        this.documentColors.add({
          color: color,
          label: color,
          options: {
            hasBorder: false
          }
        });
      } else {
        this.documentColors.add(Object.assign({}, predefinedColor));
      }
    }
  }]);

  return ColorTableView;
}(src_view_View);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-font/src/utils.js








/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module font/utils
 */

/**
 * The name of the font size plugin.
 */

var FONT_SIZE = 'fontSize';
/**
 * The name of the font family plugin.
 */

var FONT_FAMILY = 'fontFamily';
/**
 * The name of the font color plugin.
 */

var FONT_COLOR = 'fontColor';
/**
 * The name of the font background color plugin.
 */

var FONT_BACKGROUND_COLOR = 'fontBackgroundColor';
/**
 * Builds a proper {@link module:engine/conversion/conversion~ConverterDefinition converter definition} out of input data.
 *
 * @param {String} modelAttributeKey Key
 * @param {Array.<module:font/fontfamily~FontFamilyOption>|Array.<module:font/fontsize~FontSizeOption>} options
 * @returns {module:engine/conversion/conversion~ConverterDefinition}
 */

function buildDefinition(modelAttributeKey, options) {
  var definition = {
    model: {
      key: modelAttributeKey,
      values: []
    },
    view: {},
    upcastAlso: {}
  };

  var _iterator = _createForOfIteratorHelper(options),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var option = _step.value;
      definition.model.values.push(option.model);
      definition.view[option.model] = option.view;

      if (option.upcastAlso) {
        definition.upcastAlso[option.model] = option.upcastAlso;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return definition;
}
/**
 * A {@link module:font/fontcolor~FontColor font color} and
 * {@link module:font/fontbackgroundcolor~FontBackgroundColor font background color} helper
 * responsible for upcasting data to the model.
 *
 * **Note**: The `styleAttr` parameter should be either `'color'` or `'background-color'`.
 *
 * @param {String} styleAttr
 * @return {String}
 */

function renderUpcastAttribute(styleAttr) {
  return function (viewElement) {
    return normalizeColorCode(viewElement.getStyle(styleAttr));
  };
}
/**
 * A {@link module:font/fontcolor~FontColor font color} and
 * {@link module:font/fontbackgroundcolor~FontBackgroundColor font background color} helper
 * responsible for downcasting a color attribute to a `<span>` element.
 *
 * **Note**: The `styleAttr` parameter should be either `'color'` or `'background-color'`.
 *
 * @param {String} styleAttr
 */

function renderDowncastElement(styleAttr) {
  return function (modelAttributeValue, viewWriter) {
    return viewWriter.createAttributeElement('span', {
      style: "".concat(styleAttr, ":").concat(modelAttributeValue)
    }, {
      priority: 7
    });
  };
}
/**
 * A helper that adds {@link module:font/ui/colortableview~ColorTableView} to the color dropdown with proper initial values.
 *
 * @param {Object} config The configuration object.
 * @param {module:ui/dropdown/dropdownview~DropdownView} config.dropdownView The dropdown view to which
 * a {@link module:font/ui/colortableview~ColorTableView} will be added.
 * @param {Array.<module:ui/colorgrid/colorgrid~ColorDefinition>} config.colors An array with definitions
 * representing colors to be displayed in the color table.
 * @param {String} config.removeButtonLabel The label for the button responsible for removing the color.
 * @param {String} config.documentColorsLabel The label for the section with document colors.
 * @param {String} config.documentColorsCount The number of document colors inside the dropdown.
 * @returns {module:font/ui/colortableview~ColorTableView} The new color table view.
 */

function addColorTableToDropdown(_ref) {
  var dropdownView = _ref.dropdownView,
      colors = _ref.colors,
      columns = _ref.columns,
      removeButtonLabel = _ref.removeButtonLabel,
      documentColorsLabel = _ref.documentColorsLabel,
      documentColorsCount = _ref.documentColorsCount;
  var locale = dropdownView.locale;
  var colorTableView = new colortableview_ColorTableView(locale, {
    colors: colors,
    columns: columns,
    removeButtonLabel: removeButtonLabel,
    documentColorsLabel: documentColorsLabel,
    documentColorsCount: documentColorsCount
  });
  dropdownView.colorTableView = colorTableView;
  dropdownView.panelView.children.add(colorTableView);
  colorTableView.delegate('execute').to(dropdownView, 'execute');
  return colorTableView;
} // Fixes the color value string.
//
// @param {String} value
// @returns {String}

function normalizeColorCode(value) {
  return value.replace(/\s/g, '');
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-font/src/fontcolor/fontcolorcommand.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module font/fontcolor/fontcolorcommand
 */


/**
 * The font color command. It is used by {@link module:font/fontcolor/fontcolorediting~FontColorEditing}
 * to apply the font color.
 *
 *		editor.execute( 'fontColor', { value: 'rgb(250, 20, 20)' } );
 *
 * **Note**: Executing the command with the `null` value removes the attribute from the model.
 *
 * @extends module:font/fontcommand~FontCommand
 */

var fontcolorcommand_FontColorCommand = /*#__PURE__*/function (_FontCommand) {
  Object(inherits["a" /* default */])(FontColorCommand, _FontCommand);

  var _super = Object(createSuper["a" /* default */])(FontColorCommand);

  /**
   * @inheritDoc
   */
  function FontColorCommand(editor) {
    Object(classCallCheck["a" /* default */])(this, FontColorCommand);

    return _super.call(this, editor, FONT_COLOR);
  }

  return FontColorCommand;
}(fontcommand_FontCommand);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-font/src/fontcolor/fontcolorediting.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module font/fontcolor/fontcolorediting
 */



/**
 * The font color editing feature.
 *
 * It introduces the {@link module:font/fontcolor/fontcolorcommand~FontColorCommand command} and
 * the `fontColor` attribute in the {@link module:engine/model/model~Model model} which renders
 * in the {@link module:engine/view/view view} as a `<span>` element (`<span style="color: ...">`),
 * depending on the {@link module:font/fontcolor~FontColorConfig configuration}.
 *
 * @extends module:core/plugin~Plugin
 */

var fontcolorediting_FontColorEditing = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(FontColorEditing, _Plugin);

  var _super = Object(createSuper["a" /* default */])(FontColorEditing);

  Object(createClass["a" /* default */])(FontColorEditing, null, [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'FontColorEditing';
    }
    /**
     * @inheritDoc
     */

  }]);

  function FontColorEditing(editor) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, FontColorEditing);

    _this = _super.call(this, editor);
    editor.config.define(FONT_COLOR, {
      colors: [{
        color: 'hsl(0, 0%, 0%)',
        label: 'Black'
      }, {
        color: 'hsl(0, 0%, 30%)',
        label: 'Dim grey'
      }, {
        color: 'hsl(0, 0%, 60%)',
        label: 'Grey'
      }, {
        color: 'hsl(0, 0%, 90%)',
        label: 'Light grey'
      }, {
        color: 'hsl(0, 0%, 100%)',
        label: 'White',
        hasBorder: true
      }, {
        color: 'hsl(0, 75%, 60%)',
        label: 'Red'
      }, {
        color: 'hsl(30, 75%, 60%)',
        label: 'Orange'
      }, {
        color: 'hsl(60, 75%, 60%)',
        label: 'Yellow'
      }, {
        color: 'hsl(90, 75%, 60%)',
        label: 'Light green'
      }, {
        color: 'hsl(120, 75%, 60%)',
        label: 'Green'
      }, {
        color: 'hsl(150, 75%, 60%)',
        label: 'Aquamarine'
      }, {
        color: 'hsl(180, 75%, 60%)',
        label: 'Turquoise'
      }, {
        color: 'hsl(210, 75%, 60%)',
        label: 'Light blue'
      }, {
        color: 'hsl(240, 75%, 60%)',
        label: 'Blue'
      }, {
        color: 'hsl(270, 75%, 60%)',
        label: 'Purple'
      }],
      columns: 5
    });
    editor.conversion.for('upcast').elementToAttribute({
      view: {
        name: 'span',
        styles: {
          'color': /[\s\S]+/
        }
      },
      model: {
        key: FONT_COLOR,
        value: renderUpcastAttribute('color')
      }
    });
    editor.conversion.for('downcast').attributeToElement({
      model: FONT_COLOR,
      view: renderDowncastElement('color')
    });
    editor.commands.add(FONT_COLOR, new fontcolorcommand_FontColorCommand(editor)); // Allow the font color attribute on text nodes.

    editor.model.schema.extend('$text', {
      allowAttributes: FONT_COLOR
    });
    editor.model.schema.setAttributeProperties(FONT_COLOR, {
      isFormatting: true,
      copyOnEnter: true
    });
    return _this;
  }

  return FontColorEditing;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-ui/src/colorgrid/utils.js



/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module ui/colorgrid/utils
 */

/**
 * Returns color configuration options as defined in `editor.config.(fontColor|fontBackgroundColor).colors` or
 * `editor.config.table.(tableProperties|tableCellProperties).(background|border).colors
 * but processed to account for editor localization in the correct language.
 *
 * Note: The reason behind this method is that there is no way to use {@link module:utils/locale~Locale#t}
 * when the user configuration is defined because the editor does not exist yet.
 *
 * @param {module:utils/locale~Locale} locale The {@link module:core/editor/editor~Editor#locale} instance.
 * @param {Array.<module:ui/colorgrid/colorgrid~ColorDefinition>} options
 * @returns {Array.<module:ui/colorgrid/colorgrid~ColorDefinition>}.
 */
function getLocalizedColorOptions(locale, options) {
  var t = locale.t;
  var localizedColorNames = {
    Black: t('Black'),
    'Dim grey': t('Dim grey'),
    Grey: t('Grey'),
    'Light grey': t('Light grey'),
    White: t('White'),
    Red: t('Red'),
    Orange: t('Orange'),
    Yellow: t('Yellow'),
    'Light green': t('Light green'),
    Green: t('Green'),
    Aquamarine: t('Aquamarine'),
    Turquoise: t('Turquoise'),
    'Light blue': t('Light blue'),
    Blue: t('Blue'),
    Purple: t('Purple')
  };
  return options.map(function (colorOption) {
    var label = localizedColorNames[colorOption.label];

    if (label && label != colorOption.label) {
      colorOption.label = label;
    }

    return colorOption;
  });
}
/**
 * Creates a unified color definition object from color configuration options.
 * The object contains the information necessary to both render the UI and initialize the conversion.
 *
 * @param {module:ui/colorgrid/colorgrid~ColorDefinition} options
 * @returns {Array.<module:ui/colorgrid/colorgrid~ColorDefinition>}
 */

function normalizeColorOptions(options) {
  return options.map(normalizeSingleColorDefinition).filter(function (option) {
    return !!option;
  });
} // Creates a normalized color definition from the user-defined configuration.
// The "normalization" means it will create full
// {@link module:ui/colorgrid/colorgrid~ColorDefinition `ColorDefinition-like`}
// object for string values, and add a `view` property, for each definition.
//
// @param {String|module:ui/colorgrid/colorgrid~ColorDefinition}
// @returns {module:ui/colorgrid/colorgrid~ColorDefinition}

function normalizeSingleColorDefinition(color) {
  if (typeof color === 'string') {
    return {
      model: color,
      label: color,
      hasBorder: false,
      view: {
        name: 'span',
        styles: {
          color: color
        }
      }
    };
  } else {
    return {
      model: color.color,
      label: color.label || color.color,
      hasBorder: color.hasBorder === undefined ? false : color.hasBorder,
      view: {
        name: 'span',
        styles: {
          color: "".concat(color.color)
        }
      }
    };
  }
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-font/src/ui/colorui.js






/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module font/ui/colorui
 */




/**
 * The color UI plugin which isolates the common logic responsible for displaying dropdowns with color grids.
 *
 * It is used to create the `'fontBackgroundColor'` and `'fontColor'` dropdowns, each hosting
 * a {@link module:font/ui/colortableview~ColorTableView}.
 *
 * @extends module:core/plugin~Plugin
 */

var colorui_ColorUI = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(ColorUI, _Plugin);

  var _super = Object(createSuper["a" /* default */])(ColorUI);

  /**
   * Creates a plugin which introduces a dropdown with a pre–configured {@link module:font/ui/colortableview~ColorTableView}.
   *
   * @param {module:core/editor/editor~Editor} editor
   * @param {Object} config The configuration object.
   * @param {String} config.commandName The name of the command which will be executed when a color tile is clicked.
   * @param {String} config.componentName The name of the dropdown in the {@link module:ui/componentfactory~ComponentFactory}
   * and the configuration scope name in `editor.config`.
   * @param {String} config.icon The SVG icon used by the dropdown.
   * @param {String} config.dropdownLabel The label used by the dropdown.
   */
  function ColorUI(editor, _ref) {
    var _this;

    var commandName = _ref.commandName,
        icon = _ref.icon,
        componentName = _ref.componentName,
        dropdownLabel = _ref.dropdownLabel;

    Object(classCallCheck["a" /* default */])(this, ColorUI);

    _this = _super.call(this, editor);
    /**
     * The name of the command which will be executed when a color tile is clicked.
     *
     * @type {String}
     */

    _this.commandName = commandName;
    /**
     * The name of this component in the {@link module:ui/componentfactory~ComponentFactory}.
     * Also the configuration scope name in `editor.config`.
     *
     * @type {String}
     */

    _this.componentName = componentName;
    /**
     * The SVG icon used by the dropdown.
     * @type {String}
     */

    _this.icon = icon;
    /**
     * The label used by the dropdown.
     *
     * @type {String}
     */

    _this.dropdownLabel = dropdownLabel;
    /**
     * The number of columns in the color grid.
     *
     * @type {Number}
     */

    _this.columns = editor.config.get("".concat(_this.componentName, ".columns"));
    /**
     * Keeps a reference to {@link module:font/ui/colortableview~ColorTableView}.
     *
     * @member {module:font/ui/colortableview~ColorTableView}
     */

    _this.colorTableView;
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(ColorUI, [{
    key: "init",
    value: function init() {
      var _this2 = this;

      var editor = this.editor;
      var locale = editor.locale;
      var t = locale.t;
      var command = editor.commands.get(this.commandName);
      var colorsConfig = normalizeColorOptions(editor.config.get(this.componentName).colors);
      var localizedColors = getLocalizedColorOptions(locale, colorsConfig);
      var documentColorsCount = editor.config.get("".concat(this.componentName, ".documentColors")); // Register the UI component.

      editor.ui.componentFactory.add(this.componentName, function (locale) {
        var dropdownView = createDropdown(locale);
        _this2.colorTableView = addColorTableToDropdown({
          dropdownView: dropdownView,
          colors: localizedColors.map(function (option) {
            return {
              label: option.label,
              color: option.model,
              options: {
                hasBorder: option.hasBorder
              }
            };
          }),
          columns: _this2.columns,
          removeButtonLabel: t('Remove color'),
          documentColorsLabel: documentColorsCount !== 0 ? t('Document colors') : undefined,
          documentColorsCount: documentColorsCount === undefined ? _this2.columns : documentColorsCount
        });

        _this2.colorTableView.bind('selectedColor').to(command, 'value');

        dropdownView.buttonView.set({
          label: _this2.dropdownLabel,
          icon: _this2.icon,
          tooltip: true
        });
        dropdownView.extendTemplate({
          attributes: {
            class: 'ck-color-ui-dropdown'
          }
        });
        dropdownView.bind('isEnabled').to(command);
        dropdownView.on('execute', function (evt, data) {
          editor.execute(_this2.commandName, data);
          editor.editing.view.focus();
        });
        dropdownView.on('change:isOpen', function (evt, name, isVisible) {
          // Grids rendering is deferred (#6192).
          dropdownView.colorTableView.appendGrids();

          if (isVisible) {
            if (documentColorsCount !== 0) {
              _this2.colorTableView.updateDocumentColors(editor.model, _this2.componentName);
            }

            _this2.colorTableView.updateSelectedColors();
          }
        });
        return dropdownView;
      });
    }
  }]);

  return ColorUI;
}(plugin_Plugin);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-font/theme/icons/font-color.svg
var font_color = __webpack_require__("7639");
var font_color_default = /*#__PURE__*/__webpack_require__.n(font_color);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-font/src/fontcolor/fontcolorui.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module font/fontcolor/fontcolorui
 */



/**
 * The font color UI plugin. It introduces the `'fontColor'` dropdown.
 *
 * @extends module:core/plugin~Plugin
 */

var fontcolorui_FontColorUI = /*#__PURE__*/function (_ColorUI) {
  Object(inherits["a" /* default */])(FontColorUI, _ColorUI);

  var _super = Object(createSuper["a" /* default */])(FontColorUI);

  /**
   * @inheritDoc
   */
  function FontColorUI(editor) {
    Object(classCallCheck["a" /* default */])(this, FontColorUI);

    var t = editor.locale.t;
    return _super.call(this, editor, {
      commandName: FONT_COLOR,
      componentName: FONT_COLOR,
      icon: font_color_default.a,
      dropdownLabel: t('Font Color')
    });
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(FontColorUI, null, [{
    key: "pluginName",
    get: function get() {
      return 'FontColorUI';
    }
  }]);

  return FontColorUI;
}(colorui_ColorUI);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-font/src/fontcolor.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module font/fontcolor
 */



/**
 * The font color plugin.
 *
 * For a detailed overview, check the {@glink features/font font feature} documentation
 * and the {@glink api/font package page}.
 *
 * This is a "glue" plugin which loads the {@link module:font/fontcolor/fontcolorediting~FontColorEditing} and
 * {@link module:font/fontcolor/fontcolorui~FontColorUI} features in the editor.
 *
 * @extends module:core/plugin~Plugin
 */

var fontcolor_FontColor = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(FontColor, _Plugin);

  var _super = Object(createSuper["a" /* default */])(FontColor);

  function FontColor() {
    Object(classCallCheck["a" /* default */])(this, FontColor);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(FontColor, null, [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [fontcolorediting_FontColorEditing, fontcolorui_FontColorUI];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'FontColor';
    }
  }]);

  return FontColor;
}(plugin_Plugin);
/**
 * The configuration of the font color feature.
 * It is introduced by the {@link module:font/fontcolor/fontcolorediting~FontColorEditing} feature.
 *
 * Read more in {@link module:font/fontcolor~FontColorConfig}.
 *
 * @member {module:font/fontcolor~FontColorConfig} module:core/editor/editorconfig~EditorConfig#fontColor
 */

/**
 * The configuration of the font color feature.
 * This option is used by the {@link module:font/fontcolor/fontcolorediting~FontColorEditing} feature.
 *
 *		ClassicEditor
 *			.create( {
 *				fontColor: ... // Font color feature configuration.
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * See {@link module:core/editor/editorconfig~EditorConfig all editor options}.
 *
 * @interface module:font/fontcolor~FontColorConfig
 */

/**
 * Available font colors defined as an array of strings or objects.
 *
 * The default value registers the following colors:
 *
 *		const fontColorConfig = {
 *			colors: [
 *				{
 *					color: 'hsl(0, 0%, 0%)',
 *					label: 'Black'
 *				},
 *				{
 *					color: 'hsl(0, 0%, 30%)',
 *					label: 'Dim grey'
 *				},
 *				{
 *					color: 'hsl(0, 0%, 60%)',
 *					label: 'Grey'
 *				},
 *				{
 *					color: 'hsl(0, 0%, 90%)',
 *					label: 'Light grey'
 *				},
 *				{
 *					color: 'hsl(0, 0%, 100%)',
 *					label: 'White',
 *					hasBorder: true
 *				},
 *				{
 *					color: 'hsl(0, 75%, 60%)',
 *					label: 'Red'
 *				},
 *				{
 *					color: 'hsl(30, 75%, 60%)',
 *					label: 'Orange'
 *				},
 *				{
 *					color: 'hsl(60, 75%, 60%)',
 *					label: 'Yellow'
 *				},
 *				{
 *					color: 'hsl(90, 75%, 60%)',
 *					label: 'Light green'
 *				},
 *				{
 *					color: 'hsl(120, 75%, 60%)',
 *					label: 'Green'
 *				},
 *				{
 *					color: 'hsl(150, 75%, 60%)',
 *					label: 'Aquamarine'
 *				},
 *				{
 *					color: 'hsl(180, 75%, 60%)',
 *					label: 'Turquoise'
 *				},
 *				{
 *					color: 'hsl(210, 75%, 60%)',
 *					label: 'Light blue'
 *				},
 *				{
 *					color: 'hsl(240, 75%, 60%)',
 *					label: 'Blue'
 *				},
 *				{
 *					color: 'hsl(270, 75%, 60%)',
 *					label: 'Purple'
 *				}
 *			]
 *		};
 *
 * **Note**: The colors are displayed in the `'fontColor'` dropdown.
 *
 * @member {Array.<String|Object>} module:font/fontcolor~FontColorConfig#colors
 */

/**
 * Represents the number of columns in the font color dropdown.
 *
 * The default value is:
 *
 *		const fontColorConfig = {
 *			columns: 5
 *		}
 *
 * @member {Number} module:font/fontcolor~FontColorConfig#columns
 */

/**
 * Determines the maximum number of available document colors.
 * Setting it to `0` will disable the document colors feature.
 *
 * By default it equals to the {@link module:font/fontcolor~FontColorConfig#columns} value.
 *
 * Examples:
 *
 * 	// 1) Neither document colors nor columns are defined in the configuration.
 * 	// Document colors will equal 5,
 * 	// because the value will be inherited from columns,
 * 	// which has a predefined value of 5.
 * 	const fontColorConfig = {}
 *
 * 	// 2) Document colors will equal 8, because the value will be inherited from columns.
 * 	const fontColorConfig = {
 * 		columns: 8
 * 	}
 *
 * 	// 3) Document colors will equal 24, because it has its own value defined.
 * 	const fontColorConfig = {
 * 		columns: 8,
 * 		documentColors: 24
 * 	}
 *
 * 	// 4) The document colors feature will be disabled.
 * 	const fontColorConfig = {
 * 		columns: 8,
 * 		documentColors: 0
 * 	}
 *
 * @member {Number} module:font/fontcolor~FontColorConfig#documentColors
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-font/src/fontsize/fontsizecommand.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module font/fontsize/fontsizecommand
 */


/**
 * The font size command. It is used by {@link module:font/fontsize/fontsizeediting~FontSizeEditing}
 * to apply the font size.
 *
 *		editor.execute( 'fontSize', { value: 'small' } );
 *
 * **Note**: Executing the command without the value removes the attribute from the model.
 *
 * @extends module:font/fontcommand~FontCommand
 */

var fontsizecommand_FontSizeCommand = /*#__PURE__*/function (_FontCommand) {
  Object(inherits["a" /* default */])(FontSizeCommand, _FontCommand);

  var _super = Object(createSuper["a" /* default */])(FontSizeCommand);

  /**
   * @inheritDoc
   */
  function FontSizeCommand(editor) {
    Object(classCallCheck["a" /* default */])(this, FontSizeCommand);

    return _super.call(this, editor, FONT_SIZE);
  }

  return FontSizeCommand;
}(fontcommand_FontCommand);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-font/src/fontsize/utils.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module font/fontsize/utils
 */

/**
 * Normalizes and translates the {@link module:font/fontsize~FontSizeConfig#options configuration options}
 * to the {@link module:font/fontsize~FontSizeOption} format.
 *
 * @param {Array.<String|Number|Object>} configuredOptions An array of options taken from the configuration.
 * @returns {Array.<module:font/fontsize~FontSizeOption>}
 */

function normalizeOptions(configuredOptions) {
  // Convert options to objects.
  return configuredOptions.map(function (item) {
    return getOptionDefinition(item);
  }) // Filter out undefined values that `getOptionDefinition` might return.
  .filter(function (option) {
    return !!option;
  });
} // Default named presets map. Always create a new instance of the preset object in order to avoid modifying references.

var namedPresets = {
  get tiny() {
    return {
      title: 'Tiny',
      model: 'tiny',
      view: {
        name: 'span',
        classes: 'text-tiny',
        priority: 7
      }
    };
  },

  get small() {
    return {
      title: 'Small',
      model: 'small',
      view: {
        name: 'span',
        classes: 'text-small',
        priority: 7
      }
    };
  },

  get big() {
    return {
      title: 'Big',
      model: 'big',
      view: {
        name: 'span',
        classes: 'text-big',
        priority: 7
      }
    };
  },

  get huge() {
    return {
      title: 'Huge',
      model: 'huge',
      view: {
        name: 'span',
        classes: 'text-huge',
        priority: 7
      }
    };
  }

}; // Returns an option definition either from preset or creates one from number shortcut.
// If object is passed then this method will return it without alternating it. Returns undefined for item than cannot be parsed.
//
// @param {String|Number|Object} item
// @returns {undefined|module:font/fontsize~FontSizeOption}

function getOptionDefinition(option) {
  // Check whether passed option is a full item definition provided by user in configuration.
  if (isFullItemDefinition(option)) {
    return attachPriority(option);
  }

  var preset = findPreset(option); // Item is a named preset.

  if (preset) {
    return attachPriority(preset);
  } // 'Default' font size. It will be used to remove the fontSize attribute.


  if (option === 'default') {
    return {
      model: undefined,
      title: 'Default'
    };
  } // At this stage we probably have numerical value to generate a preset so parse it's value.
  // Discard any faulty values.


  if (isNumericalDefinition(option)) {
    return;
  } // Return font size definition from size value.


  return generatePixelPreset(option);
} // Creates a predefined preset for pixel size.
//
// @param {Number} definition Font size in pixels.
// @returns {module:font/fontsize~FontSizeOption}


function generatePixelPreset(definition) {
  // Extend a short (numeric value) definition.
  if (typeof definition === 'number' || typeof definition === 'string') {
    definition = {
      title: String(definition),
      model: "".concat(parseFloat(definition), "px")
    };
  }

  definition.view = {
    name: 'span',
    styles: {
      'font-size': definition.model
    }
  };
  return attachPriority(definition);
} // Adds the priority to the view element definition if missing. It's required due to ckeditor/ckeditor5#2291
//
// @param {Object} definition
// @param {Object} definition.title
// @param {Object} definition.model
// @param {Object} definition.view
// @returns {Object}


function attachPriority(definition) {
  if (!definition.view.priority) {
    definition.view.priority = 7;
  }

  return definition;
} // Returns a prepared preset definition. If passed an object, a name of preset should be defined as `model` value.
//
// @param {String|Object} definition
// @param {String} definition.model A preset name.
// @returns {Object|undefined}


function findPreset(definition) {
  return namedPresets[definition] || namedPresets[definition.model];
} // We treat `definition` as completed if it is an object that contains `title`, `model` and `view` values.
//
// @param {Object} definition
// @param {String} definition.title
// @param {String} definition.model
// @param {Object} definition.view
// @returns {Boolean}


function isFullItemDefinition(definition) {
  return Object(esm_typeof["a" /* default */])(definition) === 'object' && definition.title && definition.model && definition.view;
} // We treat `definition` as numerical if it is a number, number-like (string) or an object with the `title` key.
//
// @param {Object|Number|String} definition
// @param {Object} definition.title
// @returns {Boolean}


function isNumericalDefinition(definition) {
  var numberValue;

  if (Object(esm_typeof["a" /* default */])(definition) === 'object') {
    if (!definition.model) {
      /**
       * Provided value as an option for {@link module:font/fontsize~FontSize} seems to invalid.
       *
       * See valid examples described in the {@link module:font/fontsize~FontSizeConfig#options plugin configuration}.
       *
       * @error font-size-invalid-definition
       */
      throw new ckeditorerror["b" /* default */]('font-size-invalid-definition: Provided font size definition is invalid.', null, definition);
    } else {
      numberValue = parseFloat(definition.model);
    }
  } else {
    numberValue = parseFloat(definition);
  }

  return isNaN(numberValue);
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-font/src/fontsize/fontsizeediting.js











/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module font/fontsize/fontsizeediting
 */





/**
 * The font size editing feature.
 *
 * It introduces the {@link module:font/fontsize/fontsizecommand~FontSizeCommand command} and the `fontSize`
 * attribute in the {@link module:engine/model/model~Model model} which renders in the {@link module:engine/view/view view}
 * as a `<span>` element with either:
 * * a style attribute (`<span style="font-size:12px">...</span>`),
 * * or a class attribute (`<span class="text-small">...</span>`)
 *
 * depending on the {@link module:font/fontsize~FontSizeConfig configuration}.
 *
 * @extends module:core/plugin~Plugin
 */

var fontsizeediting_FontSizeEditing = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(FontSizeEditing, _Plugin);

  var _super = Object(createSuper["a" /* default */])(FontSizeEditing);

  Object(createClass["a" /* default */])(FontSizeEditing, null, [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'FontSizeEditing';
    }
    /**
     * @inheritDoc
     */

  }]);

  function FontSizeEditing(editor) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, FontSizeEditing);

    _this = _super.call(this, editor); // Define default configuration using named presets.

    editor.config.define(FONT_SIZE, {
      options: ['tiny', 'small', 'default', 'big', 'huge'],
      supportAllValues: false
    });
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(FontSizeEditing, [{
    key: "init",
    value: function init() {
      var editor = this.editor; // Allow fontSize attribute on text nodes.

      editor.model.schema.extend('$text', {
        allowAttributes: FONT_SIZE
      });
      editor.model.schema.setAttributeProperties(FONT_SIZE, {
        isFormatting: true,
        copyOnEnter: true
      });
      var supportAllValues = editor.config.get('fontSize.supportAllValues'); // Define view to model conversion.

      var options = normalizeOptions(this.editor.config.get('fontSize.options')).filter(function (item) {
        return item.model;
      });
      var definition = buildDefinition(FONT_SIZE, options); // Set-up the two-way conversion.

      if (supportAllValues) {
        this._prepareAnyValueConverters(definition);
      } else {
        editor.conversion.attributeToElement(definition);
      } // Add FontSize command.


      editor.commands.add(FONT_SIZE, new fontsizecommand_FontSizeCommand(editor));
    }
    /**
     * These converters enable keeping any value found as `style="font-size: *"` as a value of an attribute on a text even
     * if it is not defined in the plugin configuration.
     *
     * @param {Object} definition {@link module:engine/conversion/conversion~ConverterDefinition Converter definition} out of input data.
     * @private
     */

  }, {
    key: "_prepareAnyValueConverters",
    value: function _prepareAnyValueConverters(definition) {
      var editor = this.editor; // If `fontSize.supportAllValues=true`, we do not allow to use named presets in the plugin's configuration.

      var presets = definition.model.values.filter(function (value) {
        return !String(value).match(/[\d.]+[\w%]+/);
      });

      if (presets.length) {
        /**
         * If {@link module:font/fontsize~FontSizeConfig#supportAllValues `config.fontSize.supportAllValues`} is `true`,
         * you need to use numerical values as font size options.
         *
         * See valid examples described in the {@link module:font/fontsize~FontSizeConfig#options plugin configuration}.
         *
         * @error font-size-invalid-use-of-named-presets
         * @param {Array.<String>} presets Invalid values.
         */
        throw new ckeditorerror["b" /* default */]('font-size-invalid-use-of-named-presets: ' + 'If config.fontSize.supportAllValues is set to true, you need to use numerical values as font size options.', null, {
          presets: presets
        });
      }

      editor.conversion.for('downcast').attributeToElement({
        model: FONT_SIZE,
        view: function view(attributeValue, writer) {
          if (!attributeValue) {
            return;
          }

          return writer.createAttributeElement('span', {
            style: 'font-size:' + attributeValue
          }, {
            priority: 7
          });
        }
      });
      editor.conversion.for('upcast').attributeToAttribute({
        model: {
          key: FONT_SIZE,
          value: function value(viewElement) {
            return viewElement.getStyle('font-size');
          }
        },
        view: {
          name: 'span'
        }
      });
    }
  }]);

  return FontSizeEditing;
}(plugin_Plugin);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-font/theme/icons/font-size.svg
var font_size = __webpack_require__("7de4");
var font_size_default = /*#__PURE__*/__webpack_require__.n(font_size);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-font/theme/fontsize.css
var fontsize = __webpack_require__("da88");

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-font/src/fontsize/fontsizeui.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module font/fontsize/fontsizeui
 */








/**
 * The font size UI plugin. It introduces the `'fontSize'` dropdown.
 *
 * @extends module:core/plugin~Plugin
 */

var fontsizeui_FontSizeUI = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(FontSizeUI, _Plugin);

  var _super = Object(createSuper["a" /* default */])(FontSizeUI);

  function FontSizeUI() {
    Object(classCallCheck["a" /* default */])(this, FontSizeUI);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(FontSizeUI, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this = this;

      var editor = this.editor;
      var t = editor.t;

      var options = this._getLocalizedOptions();

      var command = editor.commands.get(FONT_SIZE); // Register UI component.

      editor.ui.componentFactory.add(FONT_SIZE, function (locale) {
        var dropdownView = createDropdown(locale);
        addListToDropdown(dropdownView, _prepareListOptions(options, command)); // Create dropdown model.

        dropdownView.buttonView.set({
          label: t('Font Size'),
          icon: font_size_default.a,
          tooltip: true
        });
        dropdownView.extendTemplate({
          attributes: {
            class: ['ck-font-size-dropdown']
          }
        });
        dropdownView.bind('isEnabled').to(command); // Execute command when an item from the dropdown is selected.

        _this.listenTo(dropdownView, 'execute', function (evt) {
          editor.execute(evt.source.commandName, {
            value: evt.source.commandParam
          });
          editor.editing.view.focus();
        });

        return dropdownView;
      });
    }
    /**
     * Returns options as defined in `config.fontSize.options` but processed to account for
     * editor localization, i.e. to display {@link module:font/fontsize~FontSizeOption}
     * in the correct language.
     *
     * Note: The reason behind this method is that there is no way to use {@link module:utils/locale~Locale#t}
     * when the user configuration is defined because the editor does not exist yet.
     *
     * @private
     * @returns {Array.<module:font/fontsize~FontSizeOption>}.
     */

  }, {
    key: "_getLocalizedOptions",
    value: function _getLocalizedOptions() {
      var editor = this.editor;
      var t = editor.t;
      var localizedTitles = {
        Default: t('Default'),
        Tiny: t('Tiny'),
        Small: t('Small'),
        Big: t('Big'),
        Huge: t('Huge')
      };
      var options = normalizeOptions(editor.config.get(FONT_SIZE).options);
      return options.map(function (option) {
        var title = localizedTitles[option.title];

        if (title && title != option.title) {
          // Clone the option to avoid altering the original `namedPresets` from `./utils.js`.
          option = Object.assign({}, option, {
            title: title
          });
        }

        return option;
      });
    }
  }]);

  return FontSizeUI;
}(plugin_Plugin); // Prepares FontSize dropdown items.
// @private
// @param {Array.<module:font/fontsize~FontSizeOption>} options
// @param {module:font/fontsize/fontsizecommand~FontSizeCommand} command




function _prepareListOptions(options, command) {
  var itemDefinitions = new collection_Collection();

  var _iterator = _createForOfIteratorHelper(options),
      _step;

  try {
    var _loop = function _loop() {
      var option = _step.value;
      var def = {
        type: 'button',
        model: new src_model_Model({
          commandName: FONT_SIZE,
          commandParam: option.model,
          label: option.title,
          class: 'ck-fontsize-option',
          withText: true
        })
      };

      if (option.view && option.view.styles) {
        def.model.set('labelStyle', "font-size:".concat(option.view.styles['font-size']));
      }

      if (option.view && option.view.classes) {
        def.model.set('class', "".concat(def.model.class, " ").concat(option.view.classes));
      }

      def.model.bind('isOn').to(command, 'value', function (value) {
        return value === option.model;
      }); // Add the option to the collection.

      itemDefinitions.add(def);
    };

    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      _loop();
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return itemDefinitions;
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-font/src/fontsize.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module font/fontsize
 */



/**
 * The font size plugin.
 *
 * For a detailed overview, check the {@glink features/font font feature} documentation
 * and the {@glink api/font package page}.
 *
 * This is a "glue" plugin which loads the {@link module:font/fontsize/fontsizeediting~FontSizeEditing} and
 * {@link module:font/fontsize/fontsizeui~FontSizeUI} features in the editor.
 *
 * @extends module:core/plugin~Plugin
 */

var fontsize_FontSize = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(FontSize, _Plugin);

  var _super = Object(createSuper["a" /* default */])(FontSize);

  function FontSize() {
    Object(classCallCheck["a" /* default */])(this, FontSize);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(FontSize, null, [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [fontsizeediting_FontSizeEditing, fontsizeui_FontSizeUI];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'FontSize';
    }
  }]);

  return FontSize;
}(plugin_Plugin);
/**
 * The font size option descriptor.
 *
 * @typedef {Object} module:font/fontsize~FontSizeOption
 *
 * @property {String} title The user-readable title of the option.
 * @property {String} model The attribute's unique value in the model.
 * @property {module:engine/view/elementdefinition~ElementDefinition} view View element configuration.
 * @property {Array.<module:engine/view/elementdefinition~ElementDefinition>} [upcastAlso] An array with all matched elements that
 * the view-to-model conversion should also accept.
 */

/**
 * The configuration of the font size feature.
 * It is introduced by the {@link module:font/fontsize/fontsizeediting~FontSizeEditing} feature.
 *
 * Read more in {@link module:font/fontsize~FontSizeConfig}.
 *
 * @member {module:font/fontsize~FontSizeConfig} module:core/editor/editorconfig~EditorConfig#fontSize
 */

/**
 * The configuration of the font size feature.
 * This option is used by the {@link module:font/fontsize/fontsizeediting~FontSizeEditing} feature.
 *
 * 		ClassicEditor
 * 			.create( {
 * 				fontSize: ... // Font size feature configuration.
 *			} )
 * 			.then( ... )
 * 			.catch( ... );
 *
 * See {@link module:core/editor/editorconfig~EditorConfig all editor options}.
 *
 * @interface module:font/fontsize~FontSizeConfig
 */

/**
 * Available font size options. Expressed as predefined presets, numerical "pixel" values
 * or the {@link module:font/fontsize~FontSizeOption}.
 *
 * The default value is:
 *
 *		const fontSizeConfig = {
 *			options: [
 *				'tiny',
 * 				'small',
 * 				'default',
 * 				'big',
 * 				'huge'
 *			]
 *		};
 *
 * It defines 4 sizes: **tiny**, **small**, **big**, and **huge**. These values will be rendered as `<span>` elements in the view.
 * The **default** defines a text without the `fontSize` attribute.
 *
 * Each `<span>` has the the `class` attribute set to the corresponding size name. For instance, this is what the **small** size looks
 * like in the view:
 *
 * 		<span class="text-small">...</span>
 *
 * As an alternative, the font size might be defined using numerical values (either as a `Number` or as a `String`):
 *
 * 		const fontSizeConfig = {
 * 			options: [ 9, 10, 11, 12, 13, 14, 15 ]
 * 		};
 *
 * Also, you can define a label in the dropdown for numerical values:
 *
 *		const fontSizeConfig = {
 *			options: [
 *				{
 * 				 	title: 'Small',
 * 				 	model: '8px
 * 				},
 * 				'default',
 * 				{
 * 				 	title: 'Big',
 * 				 	model: '14px
 * 				}
 *			]
 *		};
 *
 * Font size can be applied using the command API. To do that, use the `'fontSize'` command and pass the desired font size as a `value`.
 * For example, the following code will apply the `fontSize` attribute with the **tiny** value to the current selection:
 *
 *		editor.execute( 'fontSize', { value: 'tiny' } );
 *
 * Executing the `fontSize` command without value will remove the `fontSize` attribute from the current selection.
 *
 * @member {Array.<String|Number|module:font/fontsize~FontSizeOption>} module:font/fontsize~FontSizeConfig#options
 */

/**
 * By default the plugin removes any `font-size` value that does not match the plugin's configuration. It means that if you paste content
 * with font sizes that the editor does not understand, the `font-size` attribute will be removed and the content will be displayed
 * with the default size.
 *
 * You can preserve pasted font size values by switching the `supportAllValues` option to `true`:
 *
 *		const fontSizeConfig = {
 *			options: [ 9, 10, 11, 12, 'default', 14, 15 ],
 *			supportAllValues: true
 *		};
 *
 * **Note:** This option can only be used with numerical values as font size options.
 *
 * With this configuration font sizes not specified in the editor configuration will not be removed when pasting the content.
 *
 * @member {Boolean} module:font/fontsize~FontSizeConfig#supportAllValues
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-font/src/fontbackgroundcolor/fontbackgroundcolorcommand.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module font/fontbackgroundcolor/fontbackgroundcolorcommand
 */


/**
 * The font background color command. It is used by
 * {@link module:font/fontbackgroundcolor/fontbackgroundcolorediting~FontBackgroundColorEditing}
 * to apply the font background color.
 *
 *		editor.execute( 'fontBackgroundColor', { value: 'rgb(250, 20, 20)' } );
 *
 * **Note**: Executing the command with the `null` value removes the attribute from the model.
 *
 * @extends module:font/fontcommand~FontCommand
 */

var fontbackgroundcolorcommand_FontBackgroundColorCommand = /*#__PURE__*/function (_FontCommand) {
  Object(inherits["a" /* default */])(FontBackgroundColorCommand, _FontCommand);

  var _super = Object(createSuper["a" /* default */])(FontBackgroundColorCommand);

  /**
   * @inheritDoc
   */
  function FontBackgroundColorCommand(editor) {
    Object(classCallCheck["a" /* default */])(this, FontBackgroundColorCommand);

    return _super.call(this, editor, FONT_BACKGROUND_COLOR);
  }

  return FontBackgroundColorCommand;
}(fontcommand_FontCommand);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-font/src/fontbackgroundcolor/fontbackgroundcolorediting.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module font/fontbackgroundcolor/fontbackgroundcolorediting
 */



/**
 * The font background color editing feature.
 *
 * It introduces the {@link module:font/fontbackgroundcolor/fontbackgroundcolorcommand~FontBackgroundColorCommand command} and
 * the `fontBackgroundColor` attribute in the {@link module:engine/model/model~Model model} which renders
 * in the {@link module:engine/view/view view} as a `<span>` element (`<span style="background-color: ...">`),
 * depending on the {@link module:font/fontbackgroundcolor~FontBackgroundColorConfig configuration}.
 *
 * @extends module:core/plugin~Plugin
 */

var fontbackgroundcolorediting_FontBackgroundColorEditing = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(FontBackgroundColorEditing, _Plugin);

  var _super = Object(createSuper["a" /* default */])(FontBackgroundColorEditing);

  Object(createClass["a" /* default */])(FontBackgroundColorEditing, null, [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'FontBackgroundColorEditing';
    }
    /**
     * @inheritDoc
     */

  }]);

  function FontBackgroundColorEditing(editor) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, FontBackgroundColorEditing);

    _this = _super.call(this, editor);
    editor.config.define(FONT_BACKGROUND_COLOR, {
      colors: [{
        color: 'hsl(0, 0%, 0%)',
        label: 'Black'
      }, {
        color: 'hsl(0, 0%, 30%)',
        label: 'Dim grey'
      }, {
        color: 'hsl(0, 0%, 60%)',
        label: 'Grey'
      }, {
        color: 'hsl(0, 0%, 90%)',
        label: 'Light grey'
      }, {
        color: 'hsl(0, 0%, 100%)',
        label: 'White',
        hasBorder: true
      }, {
        color: 'hsl(0, 75%, 60%)',
        label: 'Red'
      }, {
        color: 'hsl(30, 75%, 60%)',
        label: 'Orange'
      }, {
        color: 'hsl(60, 75%, 60%)',
        label: 'Yellow'
      }, {
        color: 'hsl(90, 75%, 60%)',
        label: 'Light green'
      }, {
        color: 'hsl(120, 75%, 60%)',
        label: 'Green'
      }, {
        color: 'hsl(150, 75%, 60%)',
        label: 'Aquamarine'
      }, {
        color: 'hsl(180, 75%, 60%)',
        label: 'Turquoise'
      }, {
        color: 'hsl(210, 75%, 60%)',
        label: 'Light blue'
      }, {
        color: 'hsl(240, 75%, 60%)',
        label: 'Blue'
      }, {
        color: 'hsl(270, 75%, 60%)',
        label: 'Purple'
      }],
      columns: 5
    });
    editor.conversion.for('upcast').elementToAttribute({
      view: {
        name: 'span',
        styles: {
          'background-color': /[\s\S]+/
        }
      },
      model: {
        key: FONT_BACKGROUND_COLOR,
        value: renderUpcastAttribute('background-color')
      }
    });
    editor.conversion.for('downcast').attributeToElement({
      model: FONT_BACKGROUND_COLOR,
      view: renderDowncastElement('background-color')
    });
    editor.commands.add(FONT_BACKGROUND_COLOR, new fontbackgroundcolorcommand_FontBackgroundColorCommand(editor)); // Allow the font backgroundColor attribute on text nodes.

    editor.model.schema.extend('$text', {
      allowAttributes: FONT_BACKGROUND_COLOR
    });
    editor.model.schema.setAttributeProperties(FONT_BACKGROUND_COLOR, {
      isFormatting: true,
      copyOnEnter: true
    });
    return _this;
  }

  return FontBackgroundColorEditing;
}(plugin_Plugin);


// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-font/theme/icons/font-background.svg
var font_background = __webpack_require__("807d");
var font_background_default = /*#__PURE__*/__webpack_require__.n(font_background);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-font/src/fontbackgroundcolor/fontbackgroundcolorui.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module font/fontbackgroundcolor/fontbackgroundcolorui
 */



/**
 * The font background color UI plugin. It introduces the `'fontBackgroundColor'` dropdown.
 *
 * @extends module:core/plugin~Plugin
 */

var fontbackgroundcolorui_FontBackgroundColorUI = /*#__PURE__*/function (_ColorUI) {
  Object(inherits["a" /* default */])(FontBackgroundColorUI, _ColorUI);

  var _super = Object(createSuper["a" /* default */])(FontBackgroundColorUI);

  /**
   * @inheritDoc
   */
  function FontBackgroundColorUI(editor) {
    Object(classCallCheck["a" /* default */])(this, FontBackgroundColorUI);

    var t = editor.locale.t;
    return _super.call(this, editor, {
      commandName: FONT_BACKGROUND_COLOR,
      componentName: FONT_BACKGROUND_COLOR,
      icon: font_background_default.a,
      dropdownLabel: t('Font Background Color')
    });
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(FontBackgroundColorUI, null, [{
    key: "pluginName",
    get: function get() {
      return 'FontBackgroundColorUI';
    }
  }]);

  return FontBackgroundColorUI;
}(colorui_ColorUI);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-font/src/fontbackgroundcolor.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module font/fontbackgroundcolor
 */



/**
 * The font background color plugin.
 *
 * For a detailed overview, check the {@glink features/font font feature} documentation
 * and the {@glink api/font package page}.
 *
 * This is a "glue" plugin which loads
 * the {@link module:font/fontbackgroundcolor/fontbackgroundcolorediting~FontBackgroundColorEditing} and
 * {@link module:font/fontbackgroundcolor/fontbackgroundcolorui~FontBackgroundColorUI} features in the editor.
 *
 * @extends module:core/plugin~Plugin
 */

var fontbackgroundcolor_FontBackgroundColor = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(FontBackgroundColor, _Plugin);

  var _super = Object(createSuper["a" /* default */])(FontBackgroundColor);

  function FontBackgroundColor() {
    Object(classCallCheck["a" /* default */])(this, FontBackgroundColor);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(FontBackgroundColor, null, [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [fontbackgroundcolorediting_FontBackgroundColorEditing, fontbackgroundcolorui_FontBackgroundColorUI];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'FontBackgroundColor';
    }
  }]);

  return FontBackgroundColor;
}(plugin_Plugin);
/**
 * The configuration of the font background color feature.
 * It is introduced by the {@link module:font/fontbackgroundcolor/fontbackgroundcolorediting~FontBackgroundColorEditing} feature.
 *
 * Read more in {@link module:font/fontbackgroundcolor~FontBackgroundColorConfig}.
 *
 * @member {module:font/fontbackgroundcolor~FontBackgroundColorConfig} module:core/editor/editorconfig~EditorConfig#fontBackgroundColor
 */

/**
 * The configuration of the font background color feature.
 * This option is used by the {@link module:font/fontbackgroundcolor/fontbackgroundcolorediting~FontBackgroundColorEditing} feature.
 *
 *		ClassicEditor
 *			.create( {
 *				fontBackgroundColor: ... // Font background color feature configuration.
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * See {@link module:core/editor/editorconfig~EditorConfig all editor options}.
 *
 * @interface module:font/fontbackgroundcolor~FontBackgroundColorConfig
 */

/**
 * Available font background colors defined as an array of strings or objects.
 *
 * The default value registers the following colors:
 *
 *		const fontBackgroundColorConfig = {
 *			colors: [
 *				{
 *					color: 'hsl(0, 0%, 0%)',
 *					label: 'Black'
 *				},
 *				{
 *					color: 'hsl(0, 0%, 30%)',
 *					label: 'Dim grey'
 *				},
 *				{
 *					color: 'hsl(0, 0%, 60%)',
 *					label: 'Grey'
 *				},
 *				{
 *					color: 'hsl(0, 0%, 90%)',
 *					label: 'Light grey'
 *				},
 *				{
 *					color: 'hsl(0, 0%, 100%)',
 *					label: 'White',
 *					hasBorder: true
 *				},
 *				{
 *					color: 'hsl(0, 75%, 60%)',
 *					label: 'Red'
 *				},
 *				{
 *					color: 'hsl(30, 75%, 60%)',
 *					label: 'Orange'
 *				},
 *				{
 *					color: 'hsl(60, 75%, 60%)',
 *					label: 'Yellow'
 *				},
 *				{
 *					color: 'hsl(90, 75%, 60%)',
 *					label: 'Light green'
 *				},
 *				{
 *					color: 'hsl(120, 75%, 60%)',
 *					label: 'Green'
 *				},
 *				{
 *					color: 'hsl(150, 75%, 60%)',
 *					label: 'Aquamarine'
 *				},
 *				{
 *					color: 'hsl(180, 75%, 60%)',
 *					label: 'Turquoise'
 *				},
 *				{
 *					color: 'hsl(210, 75%, 60%)',
 *					label: 'Light blue'
 *				},
 *				{
 *					color: 'hsl(240, 75%, 60%)',
 *					label: 'Blue'
 *				},
 *				{
 *					color: 'hsl(270, 75%, 60%)',
 *					label: 'Purple'
 *				}
 *			]
 *		};
 *
 * **Note**: The colors are displayed in the `'fontBackgroundColor'` dropdown.
 *
 * @member {Array.<String|Object>} module:font/fontbackgroundcolor~FontBackgroundColorConfig#colors
 */

/**
 * Represents the number of columns in the font background color dropdown.
 *
 * The default value is:
 *
 *		const fontBackgroundColorConfig = {
 *			columns: 5
 *		}
 *
 * @member {Number} module:font/fontbackgroundcolor~FontBackgroundColorConfig#columns
 */

/**
 * Determines the maximum number of available document colors.
 * Setting it to `0` will disable the document colors feature.
 *
 * By default it equals to the {@link module:font/fontbackgroundcolor~FontBackgroundColorConfig#columns} value.
 *
 * Examples:
 *
 * 	// 1) Neither document colors nor columns are defined in the configuration.
 * 	// Document colors will equal 5,
 * 	// because the value will be inherited from columns,
 * 	// which has a predefined value of 5.
 * 	const fontBackgroundColorConfig = {}
 *
 * 	// 2) Document colors will equal 8, because the value will be inherited from columns.
 * 	const fontBackgroundColorConfig = {
 * 		columns: 8
 * 	}
 *
 * 	// 3) Document colors will equal 24, because it has its own value defined.
 * 	const fontBackgroundColorConfig = {
 * 		columns: 8,
 * 		documentColors: 24
 * 	}
 *
 * 	// 4) The document colors feature will be disabled.
 * 	const fontBackgroundColorConfig = {
 * 		columns: 8,
 * 		documentColors: 0
 * 	}
 *
 * @member {Number} module:font/fontbackgroundcolor~FontBackgroundColorConfig#documentColors
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-alignment/src/utils.js


/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module alignment/utils
 */

/**
 * The list of supported alignment options:
 *
 * * `'left'`,
 * * `'right'`,
 * * `'center'`,
 * * `'justify'`
 */
var supportedOptions = ['left', 'right', 'center', 'justify'];
/**
 * Checks whether the passed option is supported by {@link module:alignment/alignmentediting~AlignmentEditing}.
 *
 * @param {String} option The option value to check.
 * @returns {Boolean}
 */

function isSupported(option) {
  return supportedOptions.includes(option);
}
/**
 * Checks whether alignment is the default one considering the direction
 * of the editor content.
 *
 * @param {String} alignment The name of the alignment to check.
 * @param {module:utils/locale~Locale} locale The {@link module:core/editor/editor~Editor#locale} instance.
 * @returns {Boolean}
 */

function isDefault(alignment, locale) {
  // Right now only LTR is supported so the 'left' value is always the default one.
  if (locale.contentLanguageDirection == 'rtl') {
    return alignment === 'right';
  } else {
    return alignment === 'left';
  }
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-alignment/src/alignmentcommand.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module alignment/alignmentcommand
 */



var ALIGNMENT = 'alignment';
/**
 * The alignment command plugin.
 *
 * @extends module:core/command~Command
 */

var alignmentcommand_AlignmentCommand = /*#__PURE__*/function (_Command) {
  Object(inherits["a" /* default */])(AlignmentCommand, _Command);

  var _super = Object(createSuper["a" /* default */])(AlignmentCommand);

  function AlignmentCommand() {
    Object(classCallCheck["a" /* default */])(this, AlignmentCommand);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(AlignmentCommand, [{
    key: "refresh",

    /**
     * @inheritDoc
     */
    value: function refresh() {
      var editor = this.editor;
      var locale = editor.locale;
      var firstBlock = first_first(this.editor.model.document.selection.getSelectedBlocks()); // As first check whether to enable or disable the command as the value will always be false if the command cannot be enabled.

      this.isEnabled = !!firstBlock && this._canBeAligned(firstBlock);
      /**
       * A value of the current block's alignment.
       *
       * @observable
       * @readonly
       * @member {String} #value
       */

      if (this.isEnabled && firstBlock.hasAttribute('alignment')) {
        this.value = firstBlock.getAttribute('alignment');
      } else {
        this.value = locale.contentLanguageDirection === 'rtl' ? 'right' : 'left';
      }
    }
    /**
     * Executes the command. Applies the alignment `value` to the selected blocks.
     * If no `value` is passed, the `value` is the default one or it is equal to the currently selected block's alignment attribute,
     * the command will remove the attribute from the selected blocks.
     *
     * @param {Object} [options] Options for the executed command.
     * @param {String} [options.value] The value to apply.
     * @fires execute
     */

  }, {
    key: "execute",
    value: function execute() {
      var _this = this;

      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var editor = this.editor;
      var locale = editor.locale;
      var model = editor.model;
      var doc = model.document;
      var value = options.value;
      model.change(function (writer) {
        // Get only those blocks from selected that can have alignment set
        var blocks = Array.from(doc.selection.getSelectedBlocks()).filter(function (block) {
          return _this._canBeAligned(block);
        });
        var currentAlignment = blocks[0].getAttribute('alignment'); // Remove alignment attribute if current alignment is:
        // - default (should not be stored in model as it will bloat model data)
        // - equal to currently set
        // - or no value is passed - denotes default alignment.

        var removeAlignment = isDefault(value, locale) || currentAlignment === value || !value;

        if (removeAlignment) {
          removeAlignmentFromSelection(blocks, writer);
        } else {
          setAlignmentOnSelection(blocks, writer, value);
        }
      });
    }
    /**
     * Checks whether a block can have alignment set.
     *
     * @private
     * @param {module:engine/model/element~Element} block The block to be checked.
     * @returns {Boolean}
     */

  }, {
    key: "_canBeAligned",
    value: function _canBeAligned(block) {
      return this.editor.model.schema.checkAttribute(block, ALIGNMENT);
    }
  }]);

  return AlignmentCommand;
}(command_Command); // Removes the alignment attribute from blocks.
// @private




function removeAlignmentFromSelection(blocks, writer) {
  var _iterator = _createForOfIteratorHelper(blocks),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var block = _step.value;
      writer.removeAttribute(ALIGNMENT, block);
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
} // Sets the alignment attribute on blocks.
// @private


function setAlignmentOnSelection(blocks, writer, alignment) {
  var _iterator2 = _createForOfIteratorHelper(blocks),
      _step2;

  try {
    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
      var block = _step2.value;
      writer.setAttribute(ALIGNMENT, alignment, block);
    }
  } catch (err) {
    _iterator2.e(err);
  } finally {
    _iterator2.f();
  }
}
// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-alignment/src/alignmentediting.js









/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module alignment/alignmentediting
 */



/**
 * The alignment editing feature. It introduces the {@link module:alignment/alignmentcommand~AlignmentCommand command} and adds
 * the `alignment` attribute for block elements in the {@link module:engine/model/model~Model model}.
 * @extends module:core/plugin~Plugin
 */

var alignmentediting_AlignmentEditing = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(AlignmentEditing, _Plugin);

  var _super = Object(createSuper["a" /* default */])(AlignmentEditing);

  Object(createClass["a" /* default */])(AlignmentEditing, null, [{
    key: "pluginName",

    /**
     * @inheritDoc
     */
    get: function get() {
      return 'AlignmentEditing';
    }
    /**
     * @inheritDoc
     */

  }]);

  function AlignmentEditing(editor) {
    var _this;

    Object(classCallCheck["a" /* default */])(this, AlignmentEditing);

    _this = _super.call(this, editor);
    editor.config.define('alignment', {
      options: _toConsumableArray(supportedOptions)
    });
    return _this;
  }
  /**
   * @inheritDoc
   */


  Object(createClass["a" /* default */])(AlignmentEditing, [{
    key: "init",
    value: function init() {
      var editor = this.editor;
      var locale = editor.locale;
      var schema = editor.model.schema; // Filter out unsupported options.

      var enabledOptions = editor.config.get('alignment.options').filter(isSupported); // Allow alignment attribute on all blocks.

      schema.extend('$block', {
        allowAttributes: 'alignment'
      });
      editor.model.schema.setAttributeProperties('alignment', {
        isFormatting: true
      });

      var definition = _buildDefinition(enabledOptions.filter(function (option) {
        return !isDefault(option, locale);
      }));

      editor.conversion.attributeToAttribute(definition);
      editor.commands.add('alignment', new alignmentcommand_AlignmentCommand(editor));
    }
  }]);

  return AlignmentEditing;
}(plugin_Plugin); // Utility function responsible for building converter definition.
// @private




function _buildDefinition(options) {
  var definition = {
    model: {
      key: 'alignment',
      values: options.slice()
    },
    view: {}
  };

  var _iterator = _createForOfIteratorHelper(options),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var option = _step.value;
      definition.view[option] = {
        key: 'style',
        value: {
          'text-align': option
        }
      };
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return definition;
}
// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-core/theme/icons/align-left.svg
var align_left = __webpack_require__("1efe");
var align_left_default = /*#__PURE__*/__webpack_require__.n(align_left);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-core/theme/icons/align-right.svg
var align_right = __webpack_require__("e046");
var align_right_default = /*#__PURE__*/__webpack_require__.n(align_right);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-core/theme/icons/align-center.svg
var align_center = __webpack_require__("2b8c");
var align_center_default = /*#__PURE__*/__webpack_require__.n(align_center);

// EXTERNAL MODULE: ./node_modules/@ckeditor/ckeditor5-core/theme/icons/align-justify.svg
var align_justify = __webpack_require__("6378");
var align_justify_default = /*#__PURE__*/__webpack_require__.n(align_justify);

// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-alignment/src/alignmentui.js
















/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module alignment/alignmentui
 */








var icons = new Map([['left', align_left_default.a], ['right', align_right_default.a], ['center', align_center_default.a], ['justify', align_justify_default.a]]);
/**
 * The default alignment UI plugin.
 *
 * It introduces the `'alignment:left'`, `'alignment:right'`, `'alignment:center'` and `'alignment:justify'` buttons
 * and the `'alignment'` dropdown.
 *
 * @extends module:core/plugin~Plugin
 */

var alignmentui_AlignmentUI = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(AlignmentUI, _Plugin);

  var _super = Object(createSuper["a" /* default */])(AlignmentUI);

  function AlignmentUI() {
    Object(classCallCheck["a" /* default */])(this, AlignmentUI);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(AlignmentUI, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      var _this = this;

      var editor = this.editor;
      var componentFactory = editor.ui.componentFactory;
      var t = editor.t;
      var options = editor.config.get('alignment.options');
      options.filter(isSupported).forEach(function (option) {
        return _this._addButton(option);
      });
      componentFactory.add('alignment', function (locale) {
        var dropdownView = createDropdown(locale); // Add existing alignment buttons to dropdown's toolbar.

        var buttons = options.map(function (option) {
          return componentFactory.create("alignment:".concat(option));
        });
        addToolbarToDropdown(dropdownView, buttons); // Configure dropdown properties an behavior.

        dropdownView.buttonView.set({
          label: t('Text alignment'),
          tooltip: true
        });
        dropdownView.toolbarView.isVertical = true;
        dropdownView.toolbarView.ariaLabel = t('Text alignment toolbar');
        dropdownView.extendTemplate({
          attributes: {
            class: 'ck-alignment-dropdown'
          }
        }); // The default icon depends on the direction of the content.

        var defaultIcon = locale.contentLanguageDirection === 'rtl' ? align_right_default.a : align_left_default.a; // Change icon to reflect current selection's alignment.

        dropdownView.buttonView.bind('icon').toMany(buttons, 'isOn', function () {
          for (var _len = arguments.length, areActive = new Array(_len), _key = 0; _key < _len; _key++) {
            areActive[_key] = arguments[_key];
          }

          // Get the index of an active button.
          var index = areActive.findIndex(function (value) {
            return value;
          }); // If none of the commands is active, display either defaultIcon or the first button's icon.

          if (index < 0) {
            return defaultIcon;
          } // Return active button's icon.


          return buttons[index].icon;
        }); // Enable button if any of the buttons is enabled.

        dropdownView.bind('isEnabled').toMany(buttons, 'isEnabled', function () {
          for (var _len2 = arguments.length, areEnabled = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            areEnabled[_key2] = arguments[_key2];
          }

          return areEnabled.some(function (isEnabled) {
            return isEnabled;
          });
        });
        return dropdownView;
      });
    }
    /**
     * Helper method for initializing the button and linking it with an appropriate command.
     *
     * @private
     * @param {String} option The name of the alignment option for which the button is added.
     */

  }, {
    key: "_addButton",
    value: function _addButton(option) {
      var _this2 = this;

      var editor = this.editor;
      editor.ui.componentFactory.add("alignment:".concat(option), function (locale) {
        var command = editor.commands.get('alignment');
        var buttonView = new buttonview_ButtonView(locale);
        buttonView.set({
          label: _this2.localizedOptionTitles[option],
          icon: icons.get(option),
          tooltip: true,
          isToggleable: true
        }); // Bind button model to command.

        buttonView.bind('isEnabled').to(command);
        buttonView.bind('isOn').to(command, 'value', function (value) {
          return value === option;
        }); // Execute command.

        _this2.listenTo(buttonView, 'execute', function () {
          editor.execute('alignment', {
            value: option
          });
          editor.editing.view.focus();
        });

        return buttonView;
      });
    }
  }, {
    key: "localizedOptionTitles",

    /**
     * Returns the localized option titles provided by the plugin.
     *
     * The following localized titles corresponding with
     * {@link module:alignment/alignment~AlignmentConfig#options} are available:
     *
     * * `'left'`,
     * * `'right'`,
     * * `'center'`,
     * * `'justify'`.
     *
     * @readonly
     * @type {Object.<String,String>}
     */
    get: function get() {
      var t = this.editor.t;
      return {
        'left': t('Align left'),
        'right': t('Align right'),
        'center': t('Align center'),
        'justify': t('Justify')
      };
    }
    /**
     * @inheritDoc
     */

  }], [{
    key: "pluginName",
    get: function get() {
      return 'AlignmentUI';
    }
  }]);

  return AlignmentUI;
}(plugin_Plugin);


// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-alignment/src/alignment.js





/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module alignment/alignment
 */



/**
 * The text alignment plugin.
 *
 * For a detailed overview, check the {@glink features/text-alignment Text alignment feature documentation}
 * and the {@glink api/alignment package page}.
 *
 * This is a "glue" plugin which loads the {@link module:alignment/alignmentediting~AlignmentEditing} and
 * {@link module:alignment/alignmentui~AlignmentUI} plugins.
 *
 * @extends module:core/plugin~Plugin
 */

var alignment_Alignment = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(Alignment, _Plugin);

  var _super = Object(createSuper["a" /* default */])(Alignment);

  function Alignment() {
    Object(classCallCheck["a" /* default */])(this, Alignment);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Alignment, null, [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [alignmentediting_AlignmentEditing, alignmentui_AlignmentUI];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'Alignment';
    }
  }]);

  return Alignment;
}(plugin_Plugin);
/**
 * The configuration of the {@link module:alignment/alignment~Alignment alignment feature}.
 *
 * Read more in {@link module:alignment/alignment~AlignmentConfig}.
 *
 * @member {module:alignment/alignment~AlignmentConfig} module:core/editor/editorconfig~EditorConfig#alignment
 */

/**
 * The configuration of the {@link module:alignment/alignment~Alignment alignment feature}.
 *
 *		ClassicEditor
 *			.create( editorElement, {
 *				alignment: {
 *					options: [ 'left', 'right' ]
 *				}
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * See {@link module:core/editor/editorconfig~EditorConfig all editor configuration options}.
 *
 * @interface AlignmentConfig
 */

/**
 * Available alignment options.
 *
 * The available options are: `'left'`, `'right'`, `'center'` and `'justify'`. Other values are ignored.
 *
 * **Note:** It is recommended to always use `'left'` or `'right'` as these are default values which the user should
 * normally be able to choose depending on the
 * {@glink features/ui-language#setting-the-language-of-the-content language of the editor content}.
 *
 *		ClassicEditor
 *			.create( editorElement, {
 *				alignment: {
 *					options: [ 'left', 'right' ]
 *				}
 *			} )
 *			.then( ... )
 *			.catch( ... );
 *
 * See the demo of {@glink features/text-alignment#configuring-alignment-options custom alignment options}.
 *
 * @member {Array.<String>} module:alignment/alignment~AlignmentConfig#options
 */



// CONCATENATED MODULE: ./node_modules/@ckeditor/ckeditor5-upload/src/adapters/base64uploadadapter.js







/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */

/**
 * @module upload/adapters/base64uploadadapter
 */

/* globals window */


/**
 * A plugin that converts images inserted into the editor into [Base64 strings](https://en.wikipedia.org/wiki/Base64)
 * in the {@glink builds/guides/integration/saving-data editor output}.
 *
 * This kind of image upload does not require server processing – images are stored with the rest of the text and
 * displayed by the web browser without additional requests.
 *
 * Check out the {@glink features/image-upload/image-upload comprehensive "Image upload overview"} to learn about
 * other ways to upload images into CKEditor 5.
 *
 * @extends module:core/plugin~Plugin
 */

var base64uploadadapter_Base64UploadAdapter = /*#__PURE__*/function (_Plugin) {
  Object(inherits["a" /* default */])(Base64UploadAdapter, _Plugin);

  var _super = Object(createSuper["a" /* default */])(Base64UploadAdapter);

  function Base64UploadAdapter() {
    Object(classCallCheck["a" /* default */])(this, Base64UploadAdapter);

    return _super.apply(this, arguments);
  }

  Object(createClass["a" /* default */])(Base64UploadAdapter, [{
    key: "init",

    /**
     * @inheritDoc
     */
    value: function init() {
      this.editor.plugins.get(filerepository_FileRepository).createUploadAdapter = function (loader) {
        return new base64uploadadapter_Adapter(loader);
      };
    }
  }], [{
    key: "requires",

    /**
     * @inheritDoc
     */
    get: function get() {
      return [filerepository_FileRepository];
    }
    /**
     * @inheritDoc
     */

  }, {
    key: "pluginName",
    get: function get() {
      return 'Base64UploadAdapter';
    }
  }]);

  return Base64UploadAdapter;
}(plugin_Plugin);
/**
 * The upload adapter that converts images inserted into the editor into Base64 strings.
 *
 * @private
 * @implements module:upload/filerepository~UploadAdapter
 */




var base64uploadadapter_Adapter = /*#__PURE__*/function () {
  /**
   * Creates a new adapter instance.
   *
   * @param {module:upload/filerepository~FileLoader} loader
   */
  function Adapter(loader) {
    Object(classCallCheck["a" /* default */])(this, Adapter);

    /**
     * `FileLoader` instance to use during the upload.
     *
     * @member {module:upload/filerepository~FileLoader} #loader
     */
    this.loader = loader;
  }
  /**
   * Starts the upload process.
   *
   * @see module:upload/filerepository~UploadAdapter#upload
   * @returns {Promise}
   */


  Object(createClass["a" /* default */])(Adapter, [{
    key: "upload",
    value: function upload() {
      var _this = this;

      return new Promise(function (resolve, reject) {
        var reader = _this.reader = new window.FileReader();
        reader.addEventListener('load', function () {
          resolve({
            default: reader.result
          });
        });
        reader.addEventListener('error', function (err) {
          reject(err);
        });
        reader.addEventListener('abort', function () {
          reject();
        });

        _this.loader.file.then(function (file) {
          reader.readAsDataURL(file);
        });
      });
    }
    /**
     * Aborts the upload process.
     *
     * @see module:upload/filerepository~UploadAdapter#abort
     * @returns {Promise}
     */

  }, {
    key: "abort",
    value: function abort() {
      this.reader.abort();
    }
  }]);

  return Adapter;
}();
// CONCATENATED MODULE: ./src/components/tmeditor/ckeditor.js




/**
 * @license Copyright (c) 2003-2020, CKSource - Frederico Knabben. All rights reserved.
 * For licensing, see LICENSE.md or https://ckeditor.com/legal/ckeditor-oss-license
 */
// The editor creator to use.





 // import BlockQuote from '@ckeditor/ckeditor5-block-quote/src/blockquote';








 // import Indent from '@ckeditor/ckeditor5-indent/src/indent';


 // import MediaEmbed from '@ckeditor/ckeditor5-media-embed/src/mediaembed';












var ckeditor_ClassicEditor = /*#__PURE__*/function (_ClassicEditorBase) {
  Object(inherits["a" /* default */])(ClassicEditor, _ClassicEditorBase);

  var _super = Object(createSuper["a" /* default */])(ClassicEditor);

  function ClassicEditor() {
    Object(classCallCheck["a" /* default */])(this, ClassicEditor);

    return _super.apply(this, arguments);
  }

  return ClassicEditor;
}(classiceditor_ClassicEditor); // Plugins to include in the build.



ckeditor_ClassicEditor.builtinPlugins = [fontsize_FontSize, fontcolor_FontColor, fontbackgroundcolor_FontBackgroundColor, alignment_Alignment, essentials_Essentials, // UploadAdapter,
base64uploadadapter_Base64UploadAdapter, autoformat_Autoformat, bold_Bold, italic_Italic, // BlockQuote,
ckfinder_CKFinder, easyimage_EasyImage, heading_Heading, image_Image, imagecaption_ImageCaption, imagestyle_ImageStyle, imagetoolbar_ImageToolbar, imageupload_ImageUpload, // Indent,
link_Link, list_List, // MediaEmbed,
paragraph_Paragraph, pastefromoffice_PasteFromOffice, table_Table, tabletoolbar_TableToolbar, texttransformation_TextTransformation]; // Editor configuration.

ckeditor_ClassicEditor.defaultConfig = {
  toolbar: {
    items: ['heading', 'fontSize', '|', 'bold', 'italic', 'link', 'bulletedList', 'numberedList', '|', 'fontColor', 'fontBackgroundColor', '|', // 'indent',
    // 'outdent',
    'alignment:left', 'alignment:center', 'alignment:right', '|', 'imageUpload', // 'blockQuote',
    'insertTable', // 'mediaEmbed',
    'undo', 'redo']
  },
  heading: {
    options: [{
      model: 'paragraph',
      title: 'Paragraph',
      class: 'ck-heading_paragraph'
    }, {
      model: 'heading1',
      view: 'h1',
      title: 'Heading 1',
      class: 'ck-heading_headng1'
    }, {
      model: 'heading2',
      view: 'h2',
      title: 'Heading 2',
      class: 'ck-heading_headng2'
    }, {
      model: 'heading3',
      view: 'h3',
      title: 'Heading 3',
      class: 'ck-heading_headng3'
    }, {
      model: 'heading4',
      view: 'h4',
      title: 'Heading 4',
      class: 'ck-heading_headng4'
    }, {
      model: 'heading5',
      view: 'h5',
      title: 'Heading 5',
      class: 'ck-heading_headng5'
    }, {
      model: 'heading6',
      view: 'h6',
      title: 'Heading 6',
      class: 'ck-heading_headng6'
    }]
  },
  fontSize: {
    options: [9, 11, 13, 'default', 17, 19, 21]
  },
  image: {
    toolbar: ['imageStyle:full', 'imageStyle:side', '|', 'imageTextAlternative'],
    types: ['png', 'jpg', 'jpeg', 'gif']
  },
  table: {
    contentToolbar: ['tableColumn', 'tableRow', 'mergeTableCells']
  },
  // This value must be kept in sync with the language defined in webpack.config.js.
  language: 'en'
};
// CONCATENATED MODULE: ./node_modules/cache-loader/dist/cjs.js??ref--12-0!./node_modules/thread-loader/dist/cjs.js!./node_modules/babel-loader/lib!./node_modules/cache-loader/dist/cjs.js??ref--0-0!./node_modules/vue-loader/lib??vue-loader-options!./src/components/tmeditor/ckeditor.vue?vue&type=script&lang=js&
//
//
//
//

/* harmony default export */ var ckeditorvue_type_script_lang_js_ = ({
  name: 'ckeditor',
  model: {
    'props': 'value',
    'event': 'on-change'
  },
  props: {
    value: String,
    default: function _default() {
      return '';
    }
  },
  data: function data() {
    return {
      editorData: '',
      editor: null,
      editorDocument: null,
      lastData: ''
    };
  },
  created: function created() {
    window.g = this;
  },
  mounted: function mounted() {
    var _this = this;

    ckeditor_ClassicEditor.create(this.$el, {
      customToolbar: 'gtest'
    }).then(function (editor) {
      _this.editor = editor;

      _this.init();
    }).catch(function (err) {
      console.log(err);
    });
  },
  watch: {
    value: function value(newValue, oldValue) {
      if (newValue !== oldValue && newValue !== this.lastData) {
        this.editor.setData(newValue);
      }
    }
  },
  methods: {
    init: function init() {
      var _this2 = this;

      var editor = this.editor;
      var view = editor.editing.view;
      this.$emit('on-ready', editor);
      view.document.on('focus', function (evt) {
        _this2.$emit('on-focus', evt, editor);
      });
      view.document.on('blur', function (evt) {
        _this2.$emit('on-blur', evt, editor);
      });
      editor.model.document.on('change:data', _.debounce(function (evt) {
        var data = editor.getData();
        _this2.lastData = data;

        _this2.$emit('on-change', data, evt, editor);
      }, 300));
    },
    focus: function focus() {
      this.editor.editing.view.focus();
    }
  },
  beforeDestroy: function beforeDestroy() {
    if (this.editor) {
      this.editor.destroy();
      this.editor = null;
    }

    this.$emit('on-destroy', this.editor);
  }
});
// CONCATENATED MODULE: ./src/components/tmeditor/ckeditor.vue?vue&type=script&lang=js&
 /* harmony default export */ var tmeditor_ckeditorvue_type_script_lang_js_ = (ckeditorvue_type_script_lang_js_); 
// CONCATENATED MODULE: ./node_modules/vue-loader/lib/runtime/componentNormalizer.js
/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

function normalizeComponent (
  scriptExports,
  render,
  staticRenderFns,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier, /* server only */
  shadowMode /* vue-cli only */
) {
  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (render) {
    options.render = render
    options.staticRenderFns = staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = 'data-v-' + scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = shadowMode
      ? function () {
        injectStyles.call(
          this,
          (options.functional ? this.parent : this).$root.$options.shadowRoot
        )
      }
      : injectStyles
  }

  if (hook) {
    if (options.functional) {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functional component in vue file
      var originalRender = options.render
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return originalRender(h, context)
      }
    } else {
      // inject component registration as beforeCreate hook
      var existing = options.beforeCreate
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    }
  }

  return {
    exports: scriptExports,
    options: options
  }
}

// CONCATENATED MODULE: ./src/components/tmeditor/ckeditor.vue





/* normalize component */

var component = normalizeComponent(
  tmeditor_ckeditorvue_type_script_lang_js_,
  ckeditorvue_type_template_id_6135df79_render,
  staticRenderFns,
  false,
  null,
  null,
  null
  
)

/* harmony default export */ var ckeditor = (component.exports);
// CONCATENATED MODULE: ./src/components/tmeditor/index.js

/* harmony default export */ var tmeditor = (ckeditor);
// CONCATENATED MODULE: ./node_modules/@vue/cli-service/lib/commands/build/entry-lib.js


/* harmony default export */ var entry_lib = __webpack_exports__["default"] = (tmeditor);



/***/ }),

/***/ "fb6a":
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var $ = __webpack_require__("23e7");
var isObject = __webpack_require__("861d");
var isArray = __webpack_require__("e8b5");
var toAbsoluteIndex = __webpack_require__("23cb");
var toLength = __webpack_require__("50c4");
var toIndexedObject = __webpack_require__("fc6a");
var createProperty = __webpack_require__("8418");
var wellKnownSymbol = __webpack_require__("b622");
var arrayMethodHasSpeciesSupport = __webpack_require__("1dde");
var arrayMethodUsesToLength = __webpack_require__("ae40");

var HAS_SPECIES_SUPPORT = arrayMethodHasSpeciesSupport('slice');
var USES_TO_LENGTH = arrayMethodUsesToLength('slice', { ACCESSORS: true, 0: 0, 1: 2 });

var SPECIES = wellKnownSymbol('species');
var nativeSlice = [].slice;
var max = Math.max;

// `Array.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-array.prototype.slice
// fallback for not array-like ES3 strings and DOM objects
$({ target: 'Array', proto: true, forced: !HAS_SPECIES_SUPPORT || !USES_TO_LENGTH }, {
  slice: function slice(start, end) {
    var O = toIndexedObject(this);
    var length = toLength(O.length);
    var k = toAbsoluteIndex(start, length);
    var fin = toAbsoluteIndex(end === undefined ? length : end, length);
    // inline `ArraySpeciesCreate` for usage native `Array#slice` where it's possible
    var Constructor, result, n;
    if (isArray(O)) {
      Constructor = O.constructor;
      // cross-realm fallback
      if (typeof Constructor == 'function' && (Constructor === Array || isArray(Constructor.prototype))) {
        Constructor = undefined;
      } else if (isObject(Constructor)) {
        Constructor = Constructor[SPECIES];
        if (Constructor === null) Constructor = undefined;
      }
      if (Constructor === Array || Constructor === undefined) {
        return nativeSlice.call(O, k, fin);
      }
    }
    result = new (Constructor === undefined ? Array : Constructor)(max(fin - k, 0));
    for (n = 0; k < fin; k++, n++) if (k in O) createProperty(result, n, O[k]);
    result.length = n;
    return result;
  }
});


/***/ }),

/***/ "fc6a":
/***/ (function(module, exports, __webpack_require__) {

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = __webpack_require__("44ad");
var requireObjectCoercible = __webpack_require__("1d80");

module.exports = function (it) {
  return IndexedObject(requireObjectCoercible(it));
};


/***/ }),

/***/ "fdbc":
/***/ (function(module, exports) {

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
module.exports = {
  CSSRuleList: 0,
  CSSStyleDeclaration: 0,
  CSSValueList: 0,
  ClientRectList: 0,
  DOMRectList: 0,
  DOMStringList: 0,
  DOMTokenList: 1,
  DataTransferItemList: 0,
  FileList: 0,
  HTMLAllCollection: 0,
  HTMLCollection: 0,
  HTMLFormElement: 0,
  HTMLSelectElement: 0,
  MediaList: 0,
  MimeTypeArray: 0,
  NamedNodeMap: 0,
  NodeList: 1,
  PaintRequestList: 0,
  Plugin: 0,
  PluginArray: 0,
  SVGLengthList: 0,
  SVGNumberList: 0,
  SVGPathSegList: 0,
  SVGPointList: 0,
  SVGStringList: 0,
  SVGTransformList: 0,
  SourceBufferList: 0,
  StyleSheetList: 0,
  TextTrackCueList: 0,
  TextTrackList: 0,
  TouchList: 0
};


/***/ }),

/***/ "fdbf":
/***/ (function(module, exports, __webpack_require__) {

var NATIVE_SYMBOL = __webpack_require__("4930");

module.exports = NATIVE_SYMBOL
  // eslint-disable-next-line no-undef
  && !Symbol.sham
  // eslint-disable-next-line no-undef
  && typeof Symbol.iterator == 'symbol';


/***/ }),

/***/ "fea9":
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__("da84");

module.exports = global.Promise;


/***/ }),

/***/ "fecc":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "ff23":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ }),

/***/ "ffa0":
/***/ (function(module, exports, __webpack_require__) {

// extracted by mini-css-extract-plugin

/***/ })

/******/ });
});
//# sourceMappingURL=tmeditor.umd.js.map